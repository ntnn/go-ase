SCRIPT  /home/c5262761/.vimrc
Sourced 1 time
Total time:   0.130216
 Self time:   0.098754

count  total (s)   self (s)
                            " rtp {{{
                            
    1              0.000016 set rtp+=/usr/share/vim/vimfiles,/usr/share/vim/vim74
                            
    1              0.000022 let s:rtp_pre = []
    1              0.000008 let s:rtp = &rtp
    1              0.000003 let s:rtp_after = []
                            
    1              0.000009 fu! s:AddRTP(dir)
                                let dir = glob(a:dir)
                            
                                if !isdirectory(dir)
                                    let dir = glob('~/configit/vim/modules/') . a:dir
                                    if !isdirectory(dir)
                                        echomsg printf('Invalid rtp: %s, %s', a:dir, dir)
                                        return v:false
                                    endif
                                endif
                            
                                if isdirectory(dir)
                                    call add(s:rtp_pre, dir)
                                endif
                                if isdirectory(dir . '/after')
                                    call add(s:rtp_after, dir . '/after')
                                endif
                            
                                return v:true
                            endfu
                            
    1   0.000142   0.000021 call s:AddRTP('~/configit/vim')
                            
    1   0.000097   0.000009 if s:AddRTP('vim-slime')
    1              0.000005     let g:slime_target = "tmux"
    1              0.000008     let g:slime_default_config = {"socket_name": "default", "target_pane": "1"}
    1              0.000004     let g:slime_python_ipython = 1
    1              0.000001 endif
                            
    1              0.000007 if has('signs')
    1   0.000094   0.000009     if s:AddRTP('vim-signify')
    1              0.000006         let g:signify_vcs_list = [ 'git' ]
    1              0.000004         let g:signify_sign_add = '+'
    1              0.000004         let g:signify_sign_delete = '-'
    1              0.000004         let g:signify_sign_delete_first_line = '-'
    1              0.000004         let g:signify_sign_change = '~'
    1              0.000004         let g:signify_sign_changedelete = '~'
    1              0.000005         let g:signify_update_on_bufenter = 0
    1              0.000004         let g:signify_update_on_focusgained = 0
    1              0.000004         let g:signify_cursorhold_normal = 0
    1              0.000004         let g:signify_cursorhold_insert = 0
    1              0.000002     endif
    1              0.000001 endif
                            
    1              0.000006 if has('persistent_undo')
    1   0.000103   0.000018     if s:AddRTP('undotree')
    1              0.000018         nnoremap <silent> <Space>u :UndotreeToggle<CR>
    1              0.000006         let g:undotree_SetFocusWhenToggle = 1
    1              0.000005         set undofile
    1              0.000005         set undodir=~/.undodir/
    1              0.000004         set undolevels=1000
    1              0.000005         set undoreload=10000
    1              0.000002     endif
    1              0.000001 endif
                            
    1              0.000006 if has('syntax')
    1   0.000105   0.000009     call s:AddRTP('tmux.vim')
    1              0.000002 endif
                            
    1   0.000081   0.000008 if s:AddRTP('incsearch.vim')
    1              0.000013     map / <Plug>(incsearch-forward)
    1              0.000010     map ? <Plug>(incsearch-backward)
    1              0.000011     map g/ <Plug>(incsearch-stay)
    1              0.000002 endif
                            
    1   0.000095   0.000009 call s:AddRTP('vim-abolish')
                            
    1   0.000084   0.000008 if s:AddRTP('vim-qf')
    1              0.000007     let g:qf_mapping_ack_style = 1
    1              0.000004     let g:qf_loclist_window_bottom = 0
    1              0.000012     nmap <space>q <Plug>QfCtoggle
    1              0.000009     nmap <space>l <Plug>QfLtoggle
    1              0.000002 endif
                            
    1   0.000091   0.000010 call s:AddRTP('vim-diction')
                            
    1   0.000078   0.000008 if s:AddRTP('vim-gutentags')
    1              0.000018     let g:gutentags_cache_dir = '~/tags/gutentags'
    1              0.000001 endif
                            
    1   0.000100   0.000009 call s:AddRTP('tlib_vim')
    1   0.000082   0.000010 call s:AddRTP('vim-addon-mw-utils')
    1   0.000090   0.000007 if s:AddRTP('vim-snipmate')
    1              0.000013     imap <c-x><c-s> <Plug>snipMateShow
    1              0.000010     let g:snipMate = get(g:, 'snipMate', {})
    1              0.000004     let g:snipMate.snippet_version = 1
    1              0.000004     let g:snipMate.override = 1
    1              0.000005     let g:snipMate.snippet_dirs = ['~/configit/vim']
    1              0.000001 endif
                            
    1   0.000087   0.000008 if s:AddRTP('vim-ledger')
    1              0.000012     let g:ledger_maxwidth = 60
    1              0.000005     let g:ledger_fold_blanks = 1
    1              0.000004     let g:ledger_align_at = 60
    1              0.000004     let g:ledger_commodity_before = 0
    1              0.000004     let g:ledger_default_commodity = 'EUR'
    1              0.000003     let g:ledger_commodity_sep = ' '
    1              0.000002 endif
                            
    1   0.000095   0.000006 if s:AddRTP('vim-go')
    1              0.000006     set keywordprg=:GoDoc
    1              0.000005     let g:go_template_autocreate = 0
    1              0.000004     let g:go_fmt_command = 'goimports'
    1              0.000002 endif
                            
    1   0.000109   0.000009 call s:AddRTP('vim-linux-coding-style')
                            " let g:linuxsty_patterns = [
                            "             \ '/usr/src',
                            "             \ 'prog/linux',
                            "             \ 'prog/eudyptula',
                            "             \ ]
                            
    1   0.000133   0.000009 call s:AddRTP('rust.vim')
    1   0.000104   0.000020 call s:AddRTP('tcomment_vim')
    1   0.000081   0.000008 call s:AddRTP('vim-surround')
    1   0.000081   0.000008 call s:AddRTP('targets.vim')
    1   0.000089   0.000008 call s:AddRTP('vim-fugitive')
    1   0.000076   0.000007 call s:AddRTP('vim-dispatch')
                            " call s:AddRTP('vim-foldexpr')
    1   0.000095   0.000021 call s:AddRTP('vim-ctagser')
    1   0.000095   0.000009 call s:AddRTP('vim-puppet')
    1   0.000083   0.000009 call s:AddRTP('bats.vim')
    1   0.000079   0.000008 call s:AddRTP('YCM-Generator')
                            
    1              0.000019 let &rtp = join(s:rtp_pre, ',')
    1              0.000013 let &rtp .= ',' . s:rtp
    1              0.000024 let &rtp .= ',' . join(s:rtp_after, ',')
                            
                            " }}} end rtp
                            " detect project root {{{
                            
    1              0.000004 fu! GetProjectRoot(...) abort
                                if a:0 == 0
                                    let l:dir_curr = getcwd()
                                else
                                    let l:dir_curr = a:1
                                endif
                            
                                let l:dir_last = ""
                            
                                while l:dir_last != l:dir_curr
                                    for l:vcs_dir in ['.git', '.svn', '.darcs', '.hg']
                                        if isdirectory(l:dir_curr . '/' . l:vcs_dir) || filereadable(l:dir_curr . '/.git')
                                            return l:dir_curr
                                        endif
                                    endfor
                            
                                    let l:dir_last = l:dir_curr
                                    let l:dir_curr = fnamemodify(l:dir_curr, ':h')
                                endwhile
                            
                                " no vcs dir was found, assuming this is not a version controlled
                                " directory
                                return ""
                            endfu
    1   0.000078   0.000008 let g:project_root = GetProjectRoot()
                            
                            " }}} end detect project root
                            " settings {{{
                            " general settings {{{
                            
                            " builtin ft settings {{{
                            
    1              0.000014 let g:tex_flavor = 'latex'
    1              0.000004 let g:yaml_schema = 'pyyaml'
                            
    1              0.000003 let g:is_posix = 1
    1              0.000003 let g:sh_fold_enabled = 7
    1              0.000004 let g:zsh_fold_enable = 1
                            
    1              0.000003 let g:c_no_trail_space_error = 1
    1              0.000003 let g:c_no_tab_space_error = 1
    1              0.000004 let g:c_no_bracket_error = 1
    1              0.000003 let g:c_no_curly_error = 1
    1              0.000003 let g:c_syntax_for_h = 1
                            
    1              0.000004 let g:load_doxygen_syntax = 1
    1              0.000004 let g:doxygen_enhanced_colour = 1
                            
                            " }}}
                            " path ordering {{{
                            " 1. dir of the current file
                            " 2. pwd
                            " 3. project root
                            " 4. language specifics added by ftplugins
    1              0.000006 if !empty(g:project_root)
    1              0.000011     exec 'set path+=' . g:project_root
    1              0.000003 endif
                            " /usr/include is only needed for c/cpp projects
    1              0.000003 set path-=/usr/include
                            " }}} end path ordering
                            
    1              0.000010 set thesaurus+=~/configit/vim/thesaurus.txt
                            " set tsr+=
                            " set dictionary+=
    1              0.000073 for dict in glob("/usr/share/dict/*", 1, 1)
                                                                " |  +- return a list
                                                                " +- apply suffixes and wildignore
                                exec 'set dict+=' . dict
    1              0.000003 endfor
                            
    1              0.000009 if has('wildmenu')
    1              0.000005     set wildmenu
                                " full list but without completing immediately
    1              0.000004     set wildmode=list:longest,full
    1              0.000004     set wildignorecase
    1              0.000015     if has('wildignore')
                                    " vim, because other people are to stupid to set vim up
    1              0.000004         set wildignore+=*.sw?,*.bak
                                    " object files
    1              0.000006         set wildignore+=*.pyc,*.class,*.cache,*.dll,*.pdb,*.min.*,*.a,*.o,*.so,*.class
    1              0.000004         set wildignore+=*.obj,*.exe,*.manifest
                                    " latex
    1              0.000004         set wildignore+=*.aux,*.out,*.toc
                                    " media
    1              0.000005         set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg,*.webm,*.mkv,*.avi,*.mp4
                                    " svn
    1              0.000005         set wildignore+=*/.git/**/*,*/.hg/**/*,*/.svn/**/*
                                    " tags
    1              0.000005         set wildignore+=tags,cscope.*,GTAGS,GRTAGS,GPATH
                                    " gcov
    1              0.000005         set wildignore+=*.gcda,*.gcno,*.gcov
                                    " other
    1              0.000006         set wildignore+=*.pdf,*.zwc
                            
    1              0.000013         set wildoptions=tagfile
    1              0.000002     endif
    1              0.000002 endif
    1              0.000004 set suffixes+=*.tar*,*.zip,*.rar
                            
    1              0.000005 if has('cscope')
    1              0.000003     set nocscopeverbose
                            
    1              0.000004     if has('quickfix')
    1              0.000005         set cscopequickfix=s-,c-,d-,i-,t-,e-
    1              0.000002     endif
                            
                                " if executable('gtags-cscope')
                                "     set cscopeprg=gtags-cscope
                                "     let s:target_tags = '/GTAGS'
                                " else
                                "     let s:target_tags = '/cscope.out'
                                " endif
    1              0.000005     let s:target_tags = '/cscope.out'
                            
                                " project tag file
    1              0.000028     silent! exec 'cscope add ' . g:project_root . s:target_tags
                                " pwd tag file
    1              0.000035     silent! exec 'cscope add ' . getcwd() . s:target_tags
                            
    1              0.000003     set cscopeverbose
    1              0.000001 endif
                            
    1              0.000006 if !empty(g:project_root)
    1              0.000005     if has('path_extra')
    1              0.000011         exec 'set tags+=' . g:project_root . '/**/tags'
                                else
                                    exec 'set tags+=' . g:project_root . '/tags'
    1              0.000002     endif
    1              0.000002 endif
                            
    1              0.000006 if has('nvim')
                                let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
    1              0.000002 endif
                            
    1              0.000004 set grepformat^=%f:%l:%c:%m
    1              0.000079 if executable('ag')
                                set grepprg=ag\ --vimgrep\ --hidden\ --ignore\ \'.git\'
                                command! Todo grep '(TODO\|XXX\|FIXME)'
    1              0.000065 elseif executable('ack')
                                set grepprg=ack\ --column\ --nogroup\ --nocolor
    1              0.000001 endif
                            
                            " cppcheck
    1              0.000008 set errorformat+=\[%f:%l\]:\ %m
                            " puppet-lint
    1              0.000007 set errorformat+=%f\ -\ %m\ line\ %l
                            
    1              0.000007 set sessionoptions=blank,buffers,curdir,help,tabpages
                            
    1              0.000013 let g:markdown_fenced_languages = [
                                        \ 'py=python',
                                        \ 'vim',
                                        \ 'sh',
                                        \ 'zsh',
                                        \ 'conf',
                                        \ 'c',
                                        \ 'cpp',
                                        \ ]
                            
                            
                            
                            " }}} end general
                            " buffer settings {{{
    1              0.000003 set hidden
                            
                            " because neovim
    1              0.000002 set noautowrite
    1              0.000003 set noautoread
                            
    1              0.000003 set modeline
                            
                            " }}} buffer end
                            " ui settings {{{
                            
    1              0.000003 set splitright
    1              0.000003 set showcmd
    1              0.000004 set scrolloff=5
    1              0.000003 set list
    1              0.000003 set noequalalways
    1              0.000003 set hlsearch
    1              0.000007 set listchars=tab:>-,trail:.,extends:>,precedes:<,nbsp:%
                            
    1              0.000003 set cursorline
    1              0.000004 aug my_cursorline
    1              0.000004     au!
    1              0.000017     au WinEnter * setl cursorline
    1              0.000008     au WinLeave * setl nocursorline
    1              0.000002 aug END
                            
    1              0.000004 set number relativenumber
    1              0.000003 aug my_numbers
                                " relative and absolute numbers
    1              0.000003     au!
    1              0.000009     au InsertEnter * if &ft != 'qf' | setl norelativenumber | endif
    1              0.000008     au InsertLeave * if &ft != 'qf' | setl relativenumber | endif
    1              0.000002 aug END
                            
    1              0.000005 set shortmess=a " all abbreviations
    1              0.000006 set shm+=oO " messages from opening files overrides previous messages
    1              0.000011 set shm+=tT " truncate long messages
    1              0.000006 set shm+=A " no ATTENTION message
    1              0.000006 set shm+=I " no intro messages
    1              0.000006 set shm+=c " disable ins-completion-menu messages
                            
    1              0.000003 set linebreak
    1              0.000008 if has('linebreak')
    1              0.000004     set showbreak=+++
    1              0.000002 endif
                            
    1              0.000006 if has('quickfix') || has('windows')
    1              0.000004     set previewheight=10
    1              0.000001 endif
                            
    1              0.000005 if has('statusline')
    1              0.000010     set laststatus=2
    1              0.000006     set statusline=%f\ " filepath relative to pwd
    1              0.000006     set stl+=%m " modified
    1              0.000007     set stl+=%r " ro flag
    1              0.000005     set stl+=%y " filetype
    1              0.000006     set stl+=[%{&fdm}] " foldmethod
    1              0.000006     set stl+=%w " preview flag
    1              0.000005     set stl+=%q " quickfix/location list
    1              0.000006     set stl+=[%n\|%{winnr()}]
    1              0.000006     set stl+=%= " seperate between left and right
    1              0.000007     set stl+=[%{&ff}] " fileformat
    1              0.000007     set stl+=[%v-%l/%L] " col / lnum / maxlnum
    1              0.000008     set stl+=[%p%%] " percent
    1              0.000002 endif
                            
    1              0.000004 fu! Tabline()
                                let l:tabline = ''
                            
                                for i in range(tabpagenr('$'))
                                    let l:buflist = tabpagebuflist(i + 1)
                                    let l:winnr = tabpagewinnr(i + 1)
                                    let l:bufnr = l:buflist[l:winnr - 1]
                                    let l:bufname = fnamemodify(bufname(l:bufnr), ':~:.')
                                                                                "   | +- shorten after pwd
                                                                                "   +- shorten to $HOME
                                    " shwos [+] if buffer is modified, nothing otherwise
                                    let l:bufmod = getbufvar(l:bufnr, '&mod') ? '[+]' : ''
                            
                                    " select the highlighting
                                    if i + 1 == tabpagenr()
                                        let l:tabline .= '%#TabLineSel#'
                                    else
                                        let l:tabline .= '%#TabLine#'
                                    endif
                            
                                    let l:tabline .= printf('| %d %s%s |', i + 1, l:bufname, l:bufmod )
                                                            "   |  | +- buffer modified
                                                            "   |  +- buffer name
                                                            "   +- tab number
                                endfor
                            
                                " avoid hi error when opening new tabs
                                let l:tabline .= '%#TabLine#'
                            
                                " Fill to the end
                                let l:tabline .= '%=%#TabLineFill#%T'
                            
                                return l:tabline
                            endfu
    1              0.000004 set tabline=%!Tabline()
                            
    1              0.000006 if has('folding')
    1              0.000005     set foldmethod=expr
    1              0.000003     set foldexpr=
                            
    1              0.000004     set foldtext=getline(v\:foldstart)
                            
    1              0.000003     set foldcolumn=1
    1              0.000003     set foldlevelstart=999
                            
    1              0.000006     set foldopen=hor,insert,mark,quickfix,search,tag,undo
                            
    1              0.000003     set fillchars="fold:\ "
    1              0.000002 endif
                            
                            " }}} end ui
                            " file settings {{{
                            " swap files are evil and bad
    1              0.000003 set noswapfile
                            
    1              0.000005 set backupdir=~/.vim/backup
    1              0.000003 set backupext=.vbak
    1              0.000006 if !has('persistent_undo')
                                set backup
    1              0.000002 else
    1              0.000003     set nobackup
    1              0.000003     set nowritebackup
    1              0.000002 endif
                            
                            " }}} file end
                            " editing settings {{{
                            
    1   0.000444   0.000357 runtime plugin/manpager.vim
    1   0.001577   0.000508 runtime! ftplugin/man.vim
    1              0.000007 set keywordprg=:Man
                            
    1   0.002577   0.000372 runtime macros/matchit.vim
    1              0.000006 set ignorecase
    1              0.000003 set smartcase
                            
    1              0.000003 set expandtab
    1              0.000002 set exrc
    1              0.000005 set shiftwidth=4
    1              0.000004 set softtabstop=-1
                            
    1              0.000003 set textwidth=72
                            
    1   0.019462   0.001456 filetype plugin indent on
                            
                            " show a $ at the end of the change instead of refreshing
    1              0.000009 set cpoptions+=$
                            
                            " allow backspacing over everything
    1              0.000006 set backspace=indent,eol,start
                            
    1              0.000005 set incsearch
    1              0.000005 set formatoptions=c " recognize numbered lists
    1              0.000008 set fo+=r " insert comment leader after hitting enter
    1              0.000006 set fo+=o " insert comment leader after hitting o or O
    1              0.000007 set fo+=q " allow formatting with gq
    1              0.000008 set fo+=1 " don't break a line after one-letter words
    1              0.000008 set fo+=j " remove comment leaders when joining lines
    1              0.000007 set fo+=n " recognize numbered lists when formatting
                            
    1              0.000009 if has('virtualedit')
    1              0.000011     set virtualedit=block,insert
    1              0.000002 endif
                            
    1              0.000007 if has('spell')
    1              0.016048     set spell
    1              0.075826     set spelllang=en,de
    1              0.000013 endif
                            
    1              0.000006 aug my_delete_whitespace
    1              0.000395     au!
    1              0.000023     au BufWritePre * mark ` | %s/\s\+$//e | normal! ````
    1              0.000002 aug END
                            
                            " }}} end editing
                            " syntax/colourscheme {{{
                            
    1   0.002702   0.000075 syntax enable
                            " restrict the lines to search for matches, for slow machines
    1              0.000004 syntax sync fromstart
                            
    1   0.001121   0.000536 set background=dark
    1   0.004684   0.000055 colorscheme wombat
                            
                            " }}} end syntax/colourscheme
                            " completion settings {{{
    1              0.000006 set complete=. " current buffer
    1              0.000007 set cpt+=w " buffers in other windows
    1              0.000005 set cpt+=b " other loaded buffers
    1              0.000005 set cpt+=u " other unloaded buffers
    1              0.000005 set cpt+=t " tag completion
                            
    1              0.000007 if has('insert_expand')
    1              0.000009     set completeopt=menu,preview
    1              0.000002 endif
                            
    1              0.000005 set omnifunc=syntaxcomplete#Complete
                            
                            " }}} completion end
                            " }}} end settings
                            " netrw {{{
                            
    1              0.000009 let g:netrw_browsex_viewer = 'url_handler'
    1              0.000004 let g:netrw_home = '~/.vim'
                            
                            " }}} end netrw
                            " commands and mappings {{{
                            
    1              0.000002 let mapleader = ' '
    1              0.000002 let maplocalleader = ' '
                            
    1              0.000013 noremap <silent> <Space>y "+y
    1              0.000005 noremap <silent> <Space>p "+p
                            
    1              0.000008 for map in [ ['b', 'b'],
                                        \ ['q', 'c'],
                                        \ ['t', 't'],
    3              0.000005             \ ]
    3              0.000047     exec 'nnoremap <silent> [' . map[0] . ' :' . map[1] . 'previous<cr>'
    3              0.000041     exec 'nnoremap <silent> ]' . map[0] . ' :' . map[1] . 'next<cr>'
    3              0.000045     exec 'nnoremap <silent> [' . toupper(map[0]) . ' :' . map[1] . 'first<cr>'
    3              0.000041     exec 'nnoremap <silent> ]' . toupper(map[0]) . ' :' . map[1] . 'last<cr>'
    4              0.000004 endfor
                            
    1              0.000007 nnoremap <silent> <space>ww :call my#OpenWiki()<cr>
    1              0.000007 nnoremap <silent> <space>wq :call my#OpenWiki('work.md')<cr>
    1              0.000007 nnoremap <silent> <space>ws :call my#OpenScratch()<cr>
    1              0.000006 nnoremap <silent> <space>wp :call my#OpenWebsite()<cr>
    1              0.000014 nnoremap gb :ls<cr>:buffer<space>
    1              0.000005 nnoremap <space>n :nohl<cr>
    1              0.000006 nnoremap <C-W>t :tabnew %<cr>
                            
    1              0.000008 cnoremap :: <c-r>=fnameescape(expand('%:p:h'))<cr>/
                            
                            " stolen from romainl
   13              0.000023 for char in [ '_', '.', ':', ',', ';', '<bar>', '/', '<bslash>', '*', '+', '%', '`' ]
   12              0.000135     execute 'xnoremap i' . char . ' :<C-u>normal! T' . char . 'vt' . char . '<CR>'
   12              0.000110     execute 'onoremap i' . char . ' :normal vi' . char . '<CR>'
   12              0.000131     execute 'xnoremap a' . char . ' :<C-u>normal! F' . char . 'vf' . char . '<CR>'
   12              0.000118     execute 'onoremap a' . char . ' :normal va' . char . '<CR>'
   13              0.000014 endfor
    1              0.000018 xnoremap in :<C-u>call visual#Numbers()<CR>
    1              0.000005 onoremap in :normal vin<CR>
                            
    1              0.000006 nnoremap ]l :lnext<cr>
    1              0.000005 nnoremap [l :lprev<cr>
                            
                            " }}} end commands and mappings
                            " abbrev {{{
                            
    1              0.000006 iabbrev <expr> DATE strftime('%Y-%m-%d')
    1              0.000005 iabbrev <expr> TIME strftime('%H:%M')
                            
                            " }}} end abbrev

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/manpager.vim
Sourced 2 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
                            " Vim plugin for using Vim as manpager.
                            " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
                            " Last Change: 2018 Feb 04
                            
    2              0.000025 command! -nargs=0 MANPAGER call s:ManPager() | delcommand MANPAGER
                            
    2              0.000011 function! s:ManPager()
                              set nocompatible
                              if exists('+viminfofile')
                                set viminfofile=NONE
                              endif
                              set noswapfile 
                            
                              setlocal ft=man
                              runtime ftplugin/man.vim
                              setlocal buftype=nofile bufhidden=hide iskeyword+=: modifiable
                            
                              " Emulate 'col -b'
                              silent keepj keepp %s/\v(.)\b\ze\1?//ge
                            
                              " Remove empty lines above the header
                              call cursor(1, 1)
                              let n = search(".*(.*)", "c")
                              if n > 1
                                exe "1," . n-1 . "d"
                              endif
                              setlocal nomodified readonly
                            
                              syntax on
                            endfunction

SCRIPT  /home/c5262761/configit/vim/ftplugin/man.vim
Sourced 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000013 if &ft != 'man'
    1              0.000004     finish
                            endif
                            
                            " recurse is wanted because man.vim rebinds <c-]>
                            nmap <buffer> <cr> <c-]>
                            
                            " do not show tabs in man pages
                            exec 'setl listchars+=tab:\ \ '

SCRIPT  /home/c5262761/local/share/vim/vim81/ftplugin/man.vim
Sourced 1 time
Total time:   0.000617
 Self time:   0.000617

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	man
                            " Maintainer:	SungHyun Nam <goweol@gmail.com>
                            " Last Change: 	2018 Jul 25
                            
                            " To make the ":Man" command available before editing a manual page, source
                            " this script from your startup vimrc file.
                            
                            " If 'filetype' isn't "man", we must have been called to only define ":Man".
    1              0.000006 if &filetype == "man"
                            
                              " Only do this when not done yet for this buffer
                              if exists("b:did_ftplugin")
                                finish
                              endif
                              let b:did_ftplugin = 1
    1              0.000002 endif
                            
    1              0.000039 let s:cpo_save = &cpo
    1              0.000012 set cpo-=C
                            
    1              0.000004 if &filetype == "man"
                              " allow dot and dash in manual page name.
                              setlocal iskeyword+=\.,-
                              let b:undo_ftplugin = "setlocal iskeyword<"
                            
                              " Add mappings, unless the user didn't want this.
                              if !exists("no_plugin_maps") && !exists("no_man_maps")
                                if !hasmapto('<Plug>ManBS')
                                  nmap <buffer> <LocalLeader>h <Plug>ManBS
                                  let b:undo_ftplugin = b:undo_ftplugin
                            	    \ . '|silent! nunmap <buffer> <LocalLeader>h'
                                endif
                                nnoremap <buffer> <Plug>ManBS :%s/.\b//g<CR>:setl nomod<CR>''
                            
                                nnoremap <buffer> <c-]> :call <SID>PreGetPage(v:count)<CR>
                                nnoremap <buffer> <c-t> :call <SID>PopPage()<CR>
                                nnoremap <buffer> <silent> q :q<CR>
                            
                                " Add undo commands for the maps
                                let b:undo_ftplugin = b:undo_ftplugin
                            	  \ . '|silent! nunmap <buffer> <Plug>ManBS'
                            	  \ . '|silent! nunmap <buffer> <c-]>'
                            	  \ . '|silent! nunmap <buffer> <c-t>'
                            	  \ . '|silent! nunmap <buffer> q'
                              endif
                            
                              if exists('g:ft_man_folding_enable') && (g:ft_man_folding_enable == 1)
                                setlocal foldmethod=indent foldnestmax=1 foldenable
                                let b:undo_ftplugin = b:undo_ftplugin
                            	  \ . '|silent! setl fdm< fdn< fen<'
                              endif
                            
    1              0.000001 endif
                            
    1              0.000024 if exists(":Man") != 2
    1              0.000014   com -nargs=+ -complete=shellcmd Man call s:GetPage(<q-mods>, <f-args>)
    1              0.000017   nmap <Leader>K :call <SID>PreGetPage(0)<CR>
    1              0.000016   nmap <Plug>ManPreGetPage :call <SID>PreGetPage(0)<CR>
    1              0.000002 endif
                            
                            " Define functions only once.
    1              0.000006 if !exists("s:man_tag_depth")
                            
    1              0.000005 let s:man_tag_depth = 0
                            
    1              0.000004 let s:man_sect_arg = ""
    1              0.000003 let s:man_find_arg = "-w"
    1              0.000003 try
    1              0.000059   if !has("win32") && $OSTYPE !~ 'cygwin\|linux' && system('uname -s') =~ "SunOS" && system('uname -r') =~ "^5"
                                let s:man_sect_arg = "-s"
                                let s:man_find_arg = "-l"
    1              0.000001   endif
                            catch /E145:/
                              " Ignore the error in restricted mode
    1              0.000012 endtry
                            
    1              0.000007 func <SID>PreGetPage(cnt)
                              if a:cnt == 0
                                let old_isk = &iskeyword
                                if &ft == 'man'
                                  setl iskeyword+=(,)
                                endif
                                let str = expand("<cword>")
                                let &l:iskeyword = old_isk
                                let page = substitute(str, '(*\(\k\+\).*', '\1', '')
                                let sect = substitute(str, '\(\k\+\)(\([^()]*\)).*', '\2', '')
                                if match(sect, '^[0-9 ]\+$') == -1
                                  let sect = ""
                                endif
                                if sect == page
                                  let sect = ""
                                endif
                              else
                                let sect = a:cnt
                                let page = expand("<cword>")
                              endif
                              call s:GetPage(sect, page)
                            endfunc
                            
    1              0.000005 func <SID>GetCmdArg(sect, page)
                              if a:sect == ''
                                return a:page
                              endif
                              return s:man_sect_arg.' '.a:sect.' '.a:page
                            endfunc
                            
    1              0.000004 func <SID>FindPage(sect, page)
                              let where = system("man ".s:man_find_arg.' '.s:GetCmdArg(a:sect, a:page))
                              if where !~ "^/"
                                if matchstr(where, " [^ ]*$") !~ "^ /"
                                  return 0
                                endif
                              endif
                              return 1
                            endfunc
                            
    1              0.000004 func <SID>GetPage(cmdmods, ...)
                              if a:0 >= 2
                                let sect = a:1
                                let page = a:2
                              elseif a:0 >= 1
                                let sect = ""
                                let page = a:1
                              else
                                return
                              endif
                            
                              " To support:	    nmap K :Man <cword>
                              if page == '<cword>'
                                let page = expand('<cword>')
                              endif
                            
                              if sect != "" && s:FindPage(sect, page) == 0
                                let sect = ""
                              endif
                              if s:FindPage(sect, page) == 0
                                echo "\nCannot find a '".page."'."
                                return
                              endif
                              exec "let s:man_tag_buf_".s:man_tag_depth." = ".bufnr("%")
                              exec "let s:man_tag_lin_".s:man_tag_depth." = ".line(".")
                              exec "let s:man_tag_col_".s:man_tag_depth." = ".col(".")
                              let s:man_tag_depth = s:man_tag_depth + 1
                            
                              " Use an existing "man" window if it exists, otherwise open a new one.
                              if &filetype != "man"
                                let thiswin = winnr()
                                exe "norm! \<C-W>b"
                                if winnr() > 1
                                  exe "norm! " . thiswin . "\<C-W>w"
                                  while 1
                            	if &filetype == "man"
                            	  break
                            	endif
                            	exe "norm! \<C-W>w"
                            	if thiswin == winnr()
                            	  break
                            	endif
                                  endwhile
                                endif
                                if &filetype != "man"
                                  if exists("g:ft_man_open_mode")
                                    if g:ft_man_open_mode == "vert"
                                      vnew
                                    elseif g:ft_man_open_mode == "tab"
                                      tabnew
                                    else
                                      new
                                    endif
                                  else
                            	if a:cmdmods != ''
                            	  exe a:cmdmods . ' new'
                            	else
                            	  new
                            	endif
                                  endif
                                  setl nonu fdc=0
                                endif
                              endif
                              silent exec "edit $HOME/".page.".".sect."~"
                              " Avoid warning for editing the dummy file twice
                              setl buftype=nofile noswapfile
                            
                              setl ma nonu nornu nofen
                              silent exec "norm! 1GdG"
                              let unsetwidth = 0
                              if empty($MANWIDTH)
                                let $MANWIDTH = winwidth(0)
                                let unsetwidth = 1
                              endif
                            
                              " Ensure Vim is not recursively invoked (man-db does this) when doing ctrl-[
                              " on a man page reference by unsetting MANPAGER.
                              " Some versions of env(1) do not support the '-u' option, and in such case
                              " we set MANPAGER=cat.
                              if !exists('s:env_has_u')
                                call system('env -u x true')
                                let s:env_has_u = (v:shell_error == 0)
                              endif
                              let env_cmd = s:env_has_u ? 'env -u MANPAGER' : 'env MANPAGER=cat'
                              let man_cmd = env_cmd . ' man ' . s:GetCmdArg(sect, page) . ' | col -b'
                              silent exec "r !" . man_cmd
                            
                              if unsetwidth
                                let $MANWIDTH = ''
                              endif
                              " Remove blank lines from top and bottom.
                              while getline(1) =~ '^\s*$'
                                silent keepj norm! ggdd
                              endwhile
                              while getline('$') =~ '^\s*$'
                                silent keepj norm! Gdd
                              endwhile
                              1
                              setl ft=man nomod
                              setl bufhidden=hide
                              setl nobuflisted
                              setl noma
                            endfunc
                            
    1              0.000004 func <SID>PopPage()
                              if s:man_tag_depth > 0
                                let s:man_tag_depth = s:man_tag_depth - 1
                                exec "let s:man_tag_buf=s:man_tag_buf_".s:man_tag_depth
                                exec "let s:man_tag_lin=s:man_tag_lin_".s:man_tag_depth
                                exec "let s:man_tag_col=s:man_tag_col_".s:man_tag_depth
                                exec s:man_tag_buf."b"
                                exec s:man_tag_lin
                                exec "norm! ".s:man_tag_col."|"
                                exec "unlet s:man_tag_buf_".s:man_tag_depth
                                exec "unlet s:man_tag_lin_".s:man_tag_depth
                                exec "unlet s:man_tag_col_".s:man_tag_depth
                                unlet s:man_tag_buf s:man_tag_lin s:man_tag_col
                              endif
                            endfunc
                            
    1              0.000012 endif
                            
    1              0.000027 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            
                            " vim: set sw=2 ts=8 noet:

SCRIPT  /usr/share/vim/vim74/ftplugin/man.vim
Sourced 1 time
Total time:   0.000380
 Self time:   0.000380

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	man
                            " Maintainer:	SungHyun Nam <goweol@gmail.com>
                            " Last Change:	2013 Jul 17
                            
                            " To make the ":Man" command available before editing a manual page, source
                            " this script from your startup vimrc file.
                            
                            " If 'filetype' isn't "man", we must have been called to only define ":Man".
    1              0.000007 if &filetype == "man"
                            
                              " Only do this when not done yet for this buffer
                              if exists("b:did_ftplugin")
                                finish
                              endif
                              let b:did_ftplugin = 1
                            
                              " Ensure Vim is not recursively invoked (man-db does this)
                              " when doing ctrl-[ on a man page reference.
                              if exists("$MANPAGER")
                                let $MANPAGER = ""
                              endif
                            
                              " allow dot and dash in manual page name.
                              setlocal iskeyword+=\.,-
                            
                              " Add mappings, unless the user didn't want this.
                              if !exists("no_plugin_maps") && !exists("no_man_maps")
                                if !hasmapto('<Plug>ManBS')
                                  nmap <buffer> <LocalLeader>h <Plug>ManBS
                                endif
                                nnoremap <buffer> <Plug>ManBS :%s/.\b//g<CR>:setl nomod<CR>''
                            
                                nnoremap <buffer> <c-]> :call <SID>PreGetPage(v:count)<CR>
                                nnoremap <buffer> <c-t> :call <SID>PopPage()<CR>
                              endif
                            
                              let b:undo_ftplugin = "setlocal iskeyword<"
                            
    1              0.000009 endif
                            
    1              0.000006 if exists(":Man") != 2
                              com -nargs=+ Man call s:GetPage(<f-args>)
                              nmap <Leader>K :call <SID>PreGetPage(0)<CR>
    1              0.000002 endif
                            
                            " Define functions only once.
    1              0.000005 if !exists("s:man_tag_depth")
                            
    1              0.000004 let s:man_tag_depth = 0
                            
    1              0.000004 let s:man_sect_arg = ""
    1              0.000003 let s:man_find_arg = "-w"
    1              0.000002 try
    1              0.000043   if !has("win32") && $OSTYPE !~ 'cygwin\|linux' && system('uname -s') =~ "SunOS" && system('uname -r') =~ "^5"
                                let s:man_sect_arg = "-s"
                                let s:man_find_arg = "-l"
    1              0.000002   endif
                            catch /E145:/
                              " Ignore the error in restricted mode
    1              0.000002 endtry
                            
    1              0.000006 func <SID>PreGetPage(cnt)
                              if a:cnt == 0
                                let old_isk = &iskeyword
                                setl iskeyword+=(,)
                                let str = expand("<cword>")
                                let &l:iskeyword = old_isk
                                let page = substitute(str, '(*\(\k\+\).*', '\1', '')
                                let sect = substitute(str, '\(\k\+\)(\([^()]*\)).*', '\2', '')
                                if match(sect, '^[0-9 ]\+$') == -1
                                  let sect = ""
                                endif
                                if sect == page
                                  let sect = ""
                                endif
                              else
                                let sect = a:cnt
                                let page = expand("<cword>")
                              endif
                              call s:GetPage(sect, page)
                            endfunc
                            
    1              0.000005 func <SID>GetCmdArg(sect, page)
                              if a:sect == ''
                                return a:page
                              endif
                              return s:man_sect_arg.' '.a:sect.' '.a:page
                            endfunc
                            
    1              0.000004 func <SID>FindPage(sect, page)
                              let where = system("/usr/bin/man ".s:man_find_arg.' '.s:GetCmdArg(a:sect, a:page))
                              if where !~ "^/"
                                if matchstr(where, " [^ ]*$") !~ "^ /"
                                  return 0
                                endif
                              endif
                              return 1
                            endfunc
                            
    1              0.000014 func <SID>GetPage(...)
                              if a:0 >= 2
                                let sect = a:1
                                let page = a:2
                              elseif a:0 >= 1
                                let sect = ""
                                let page = a:1
                              else
                                return
                              endif
                            
                              " To support:	    nmap K :Man <cword>
                              if page == '<cword>'
                                let page = expand('<cword>')
                              endif
                            
                              if sect != "" && s:FindPage(sect, page) == 0
                                let sect = ""
                              endif
                              if s:FindPage(sect, page) == 0
                                echo "\nCannot find a '".page."'."
                                return
                              endif
                              exec "let s:man_tag_buf_".s:man_tag_depth." = ".bufnr("%")
                              exec "let s:man_tag_lin_".s:man_tag_depth." = ".line(".")
                              exec "let s:man_tag_col_".s:man_tag_depth." = ".col(".")
                              let s:man_tag_depth = s:man_tag_depth + 1
                            
                              " Use an existing "man" window if it exists, otherwise open a new one.
                              if &filetype != "man"
                                let thiswin = winnr()
                                exe "norm! \<C-W>b"
                                if winnr() > 1
                                  exe "norm! " . thiswin . "\<C-W>w"
                                  while 1
                            	if &filetype == "man"
                            	  break
                            	endif
                            	exe "norm! \<C-W>w"
                            	if thiswin == winnr()
                            	  break
                            	endif
                                  endwhile
                                endif
                                if &filetype != "man"
                                  new
                                  setl nonu fdc=0
                                endif
                              endif
                              silent exec "edit $HOME/".page.".".sect."~"
                              " Avoid warning for editing the dummy file twice
                              setl buftype=nofile noswapfile
                            
                              setl ma nonu nornu nofen
                              silent exec "norm 1GdG"
                              let $MANWIDTH = winwidth(0)
                              silent exec "r!/usr/bin/man ".s:GetCmdArg(sect, page)." | col -b"
                              " Remove blank lines from top and bottom.
                              while getline(1) =~ '^\s*$'
                                silent norm ggdd
                              endwhile
                              while getline('$') =~ '^\s*$'
                                silent norm Gdd
                              endwhile
                              1
                              setl ft=man nomod
                              setl bufhidden=hide
                              setl nobuflisted
                            endfunc
                            
    1              0.000006 func <SID>PopPage()
                              if s:man_tag_depth > 0
                                let s:man_tag_depth = s:man_tag_depth - 1
                                exec "let s:man_tag_buf=s:man_tag_buf_".s:man_tag_depth
                                exec "let s:man_tag_lin=s:man_tag_lin_".s:man_tag_depth
                                exec "let s:man_tag_col=s:man_tag_col_".s:man_tag_depth
                                exec s:man_tag_buf."b"
                                exec s:man_tag_lin
                                exec "norm ".s:man_tag_col."|"
                                exec "unlet s:man_tag_buf_".s:man_tag_depth
                                exec "unlet s:man_tag_lin_".s:man_tag_depth
                                exec "unlet s:man_tag_col_".s:man_tag_depth
                                unlet s:man_tag_buf s:man_tag_lin s:man_tag_col
                              endif
                            endfunc
                            
    1              0.000001 endif
                            
                            " vim: set sw=2:

SCRIPT  /home/c5262761/local/share/vim/vim81/macros/matchit.vim
Sourced 1 time
Total time:   0.002186
 Self time:   0.000812

count  total (s)   self (s)
                            " Load the matchit package.
                            " For those users who were loading the matchit plugin from here.
    1              0.000005 if 1
    1   0.002160   0.000786     packadd matchit
    1              0.000006 endif

SCRIPT  /home/c5262761/local/share/vim/vim81/pack/dist/opt/matchit/plugin/matchit.vim
Sourced 2 times
Total time:   0.001385
 Self time:   0.001385

count  total (s)   self (s)
                            "  matchit.vim: (global plugin) Extended "%" matching
                            "  Last Change: 2018 Jul 3 by Christian Brabandt
                            "  Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
                            "  Version:     1.13.3, for Vim 6.3+
                            "		Fix from Fernando Torres included.
                            "		Improvement from Ken Takata included.
                            "  URL:		http://www.vim.org/script.php?script_id=39
                            
                            " Documentation:
                            "  The documentation is in a separate file, matchit.txt .
                            
                            " Credits:
                            "  Vim editor by Bram Moolenaar (Thanks, Bram!)
                            "  Original script and design by Raul Segura Acevedo
                            "  Support for comments by Douglas Potts
                            "  Support for back references and other improvements by Benji Fisher
                            "  Support for many languages by Johannes Zellner
                            "  Suggestions for improvement, bug reports, and support for additional
                            "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
                            "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
                            
                            " Debugging:
                            "  If you'd like to try the built-in debugging commands...
                            "   :MatchDebug      to activate debugging for the current buffer
                            "  This saves the values of several key script variables as buffer-local
                            "  variables.  See the MatchDebug() function, below, for details.
                            
                            " TODO:  I should think about multi-line patterns for b:match_words.
                            "   This would require an option:  how many lines to scan (default 1).
                            "   This would be useful for Python, maybe also for *ML.
                            " TODO:  Maybe I should add a menu so that people will actually use some of
                            "   the features that I have implemented.
                            " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
                            "   Match_wrapper() instead.
                            " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                            " TODO:  Make backrefs safer by using '\V' (very no-magic).
                            " TODO:  Add a level of indirection, so that custom % scripts can use my
                            "   work but extend it.
                            
                            " allow user to prevent loading
                            " and prevent duplicate loading
    2              0.000034 if exists("loaded_matchit") || &cp
    1              0.000002   finish
    1              0.000002 endif
    1              0.000005 let loaded_matchit = 1
    1              0.000004 let s:last_mps = ""
    1              0.000005 let s:last_words = ":"
    1              0.000003 let s:patBR = ""
                            
    1              0.000008 let s:save_cpo = &cpo
    1              0.000016 set cpo&vim
                            
    1              0.000027 nnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'n') <CR>
    1              0.000012 nnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'n') <CR>
    1              0.000014 vnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'v') <CR>m'gv``
    1              0.000023 vnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'v') <CR>m'gv``
    1              0.000011 onoremap <silent> %  v:<C-U>call <SID>Match_wrapper('',1,'o') <CR>
    1              0.000011 onoremap <silent> g% v:<C-U>call <SID>Match_wrapper('',0,'o') <CR>
                            
                            " Analogues of [{ and ]} using matching patterns:
    1              0.000012 nnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "n") <CR>
    1              0.000011 nnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "n") <CR>
    1              0.000008 vmap [% <Esc>[%m'gv``
    1              0.000008 vmap ]% <Esc>]%m'gv``
                            " vnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "v") <CR>m'gv``
                            " vnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "v") <CR>m'gv``
    1              0.000011 onoremap <silent> [% v:<C-U>call <SID>MultiMatch("bW", "o") <CR>
    1              0.000019 onoremap <silent> ]% v:<C-U>call <SID>MultiMatch("W",  "o") <CR>
                            
                            " text object:
    1              0.000011 vmap a% <Esc>[%v]%
                            
                            " Auto-complete mappings:  (not yet "ready for prime time")
                            " TODO Read :help write-plugin for the "right" way to let the user
                            " specify a key binding.
                            "   let g:match_auto = '<C-]>'
                            "   let g:match_autoCR = '<C-CR>'
                            " if exists("g:match_auto")
                            "   execute "inoremap " . g:match_auto . ' x<Esc>"=<SID>Autocomplete()<CR>Pls'
                            " endif
                            " if exists("g:match_autoCR")
                            "   execute "inoremap " . g:match_autoCR . ' <CR><C-R>=<SID>Autocomplete()<CR>'
                            " endif
                            " if exists("g:match_gthhoh")
                            "   execute "inoremap " . g:match_gthhoh . ' <C-O>:call <SID>Gthhoh()<CR>'
                            " endif " gthhoh = "Get the heck out of here!"
                            
    1              0.000006 let s:notslash = '\\\@<!\%(\\\\\)*'
                            
    1              0.000006 function! s:Match_wrapper(word, forward, mode) range
                              " In s:CleanUp(), :execute "set" restore_options .
                              let restore_options = ""
                              if exists("b:match_ignorecase") && b:match_ignorecase != &ic
                                let restore_options .= (&ic ? " " : " no") . "ignorecase"
                                let &ignorecase = b:match_ignorecase
                              endif
                              if &ve != ''
                                let restore_options = " ve=" . &ve . restore_options
                                set ve=
                              endif
                              " If this function was called from Visual mode, make sure that the cursor
                              " is at the correct end of the Visual range:
                              if a:mode == "v"
                                execute "normal! gv\<Esc>"
                              endif
                              " In s:CleanUp(), we may need to check whether the cursor moved forward.
                              let startline = line(".")
                              let startcol = col(".")
                              " Use default behavior if called with a count.
                              if v:count
                                exe "normal! " . v:count . "%"
                                return s:CleanUp(restore_options, a:mode, startline, startcol)
                              end
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR	flag for whether there are backrefs
                              "   s:pat	parsed version of b:match_words
                              "   s:all	regexp based on s:pat and the default groups
                              "
                              if !exists("b:match_words") || b:match_words == ""
                                let match_words = ""
                                " Allow b:match_words = "GetVimMatchWords()" .
                              elseif b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                execute "let match_words =" b:match_words
                              endif
                            " Thanks to Preben "Peppe" Guldberg and Bram Moolenaar for this suggestion!
                              if (match_words != s:last_words) || (&mps != s:last_mps)
                                  \ || exists("b:match_debug")
                                let s:last_mps = &mps
                                " The next several lines were here before
                                " BF started messing with this script.
                                " quote the special chars in 'matchpairs', replace [,:] with \| and then
                                " append the builtin pairs (/*, */, #if, #ifdef, #else, #elif, #endif)
                                " let default = substitute(escape(&mps, '[$^.*~\\/?]'), '[,:]\+',
                                "  \ '\\|', 'g').'\|\/\*\|\*\/\|#if\>\|#ifdef\>\|#else\>\|#elif\>\|#endif\>'
                                let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") .
                                  \ '\/\*:\*\/,#\s*if\%(def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                                " s:all = pattern with all the keywords
                                let match_words = match_words . (strlen(match_words) ? "," : "") . default
                                let s:last_words = match_words
                                if match_words !~ s:notslash . '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = substitute(s:pat, s:notslash . '\zs[,:]\+', '\\|', 'g')
                                let s:all = '\%(' . s:all . '\)'
                                " let s:all = '\%(' . substitute(s:all, '\\\ze[,:]', '', 'g') . '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                                " Reconstruct the version with unresolved backrefs.
                                let s:patBR = substitute(match_words.',',
                                  \ s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
                                let s:patBR = substitute(s:patBR, s:notslash.'\zs:\{2,}', ':', 'g')
                              endif
                            
                              " Second step:  set the following local variables:
                              "     matchline = line on which the cursor started
                              "     curcol    = number of characters before match
                              "     prefix    = regexp for start of line to start of match
                              "     suffix    = regexp for end of match to end of line
                              " Require match to end on or after the cursor and prefer it to
                              " start on or before the cursor.
                              let matchline = getline(startline)
                              if a:word != ''
                                " word given
                                if a:word !~ s:all
                                  echohl WarningMsg|echo 'Missing rule for word:"'.a:word.'"'|echohl NONE
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
                                let matchline = a:word
                                let curcol = 0
                                let prefix = '^\%('
                                let suffix = '\)$'
                              " Now the case when "word" is not given
                              else	" Find the match that ends on or after the cursor and set curcol.
                                let regexp = s:Wholematch(matchline, s:all, startcol-1)
                                let curcol = match(matchline, regexp)
                                " If there is no match, give up.
                                if curcol == -1
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
                                let endcol = matchend(matchline, regexp)
                                let suf = strlen(matchline) - endcol
                                let prefix = (curcol ? '^.*\%'  . (curcol + 1) . 'c\%(' : '^\%(')
                                let suffix = (suf ? '\)\%' . (endcol + 1) . 'c.*$'  : '\)$')
                              endif
                              if exists("b:match_debug")
                                let b:match_match = matchstr(matchline, regexp)
                                let b:match_col = curcol+1
                              endif
                            
                              " Third step:  Find the group and single word that match, and the original
                              " (backref) versions of these.  Then, resolve the backrefs.
                              " Set the following local variable:
                              " group = colon-separated list of patterns, one of which matches
                              "       = ini:mid:fin or ini:fin
                              "
                              " Now, set group and groupBR to the matching group: 'if:endif' or
                              " 'while:endwhile' or whatever.  A bit of a kluge:  s:Choose() returns
                              " group . "," . groupBR, and we pick it apart.
                              let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, s:patBR)
                              let i = matchend(group, s:notslash . ",")
                              let groupBR = strpart(group, i)
                              let group = strpart(group, 0, i-1)
                              " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
                              if s:do_BR " Do the hard part:  resolve those backrefs!
                                let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              endif
                              if exists("b:match_debug")
                                let b:match_wholeBR = groupBR
                                let i = matchend(groupBR, s:notslash . ":")
                                let b:match_iniBR = strpart(groupBR, 0, i-1)
                              endif
                            
                              " Fourth step:  Set the arguments for searchpair().
                              let i = matchend(group, s:notslash . ":")
                              let j = matchend(group, '.*' . s:notslash . ":")
                              let ini = strpart(group, 0, i-1)
                              let mid = substitute(strpart(group, i,j-i-1), s:notslash.'\zs:', '\\|', 'g')
                              let fin = strpart(group, j)
                              "Un-escape the remaining , and : characters.
                              let ini = substitute(ini, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              let mid = substitute(mid, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              let fin = substitute(fin, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              " searchpair() requires that these patterns avoid \(\) groups.
                              let ini = substitute(ini, s:notslash . '\zs\\(', '\\%(', 'g')
                              let mid = substitute(mid, s:notslash . '\zs\\(', '\\%(', 'g')
                              let fin = substitute(fin, s:notslash . '\zs\\(', '\\%(', 'g')
                              " Set mid.  This is optimized for readability, not micro-efficiency!
                              if a:forward && matchline =~ prefix . fin . suffix
                                \ || !a:forward && matchline =~ prefix . ini . suffix
                                let mid = ""
                              endif
                              " Set flag.  This is optimized for readability, not micro-efficiency!
                              if a:forward && matchline =~ prefix . fin . suffix
                                \ || !a:forward && matchline !~ prefix . ini . suffix
                                let flag = "bW"
                              else
                                let flag = "W"
                              endif
                              " Set skip.
                              if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" . b:match_comment
                              else
                                let skip = 's:comment\|string'
                              endif
                              let skip = s:ParseSkip(skip)
                              if exists("b:match_debug")
                                let b:match_ini = ini
                                let b:match_tail = (strlen(mid) ? mid.'\|' : '') . fin
                              endif
                            
                              " Fifth step:  actually start moving the cursor and call searchpair().
                              " Later, :execute restore_cursor to get to the original screen.
                              let restore_cursor = virtcol(".") . "|"
                              normal! g0
                              let restore_cursor = line(".") . "G" .  virtcol(".") . "|zs" . restore_cursor
                              normal! H
                              let restore_cursor = "normal!" . line(".") . "Gzt" . restore_cursor
                              execute restore_cursor
                              call cursor(0, curcol + 1)
                              " normal! 0
                              " if curcol
                              "   execute "normal!" . curcol . "l"
                              " endif
                              if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = '0'
                              else
                                execute "if " . skip . "| let skip = '0' | endif"
                              endif
                              let sp_return = searchpair(ini, mid, fin, flag, skip)
                              let final_position = "call cursor(" . line(".") . "," . col(".") . ")"
                              " Restore cursor position and original screen.
                              execute restore_cursor
                              normal! m'
                              if sp_return > 0
                                execute final_position
                              endif
                              return s:CleanUp(restore_options, a:mode, startline, startcol, mid.'\|'.fin)
                            endfun
                            
                            " Restore options and do some special handling for Operator-pending mode.
                            " The optional argument is the tail of the matching group.
    1              0.000007 fun! s:CleanUp(options, mode, startline, startcol, ...)
                              if strlen(a:options)
                                execute "set" a:options
                              endif
                              " Open folds, if appropriate.
                              if a:mode != "o"
                                if &foldopen =~ "percent"
                                  normal! zv
                                endif
                                " In Operator-pending mode, we want to include the whole match
                                " (for example, d%).
                                " This is only a problem if we end up moving in the forward direction.
                              elseif (a:startline < line(".")) ||
                            	\ (a:startline == line(".") && a:startcol < col("."))
                                if a:0
                                  " Check whether the match is a single character.  If not, move to the
                                  " end of the match.
                                  let matchline = getline(".")
                                  let currcol = col(".")
                                  let regexp = s:Wholematch(matchline, a:1, currcol-1)
                                  let endcol = matchend(matchline, regexp)
                                  if endcol > currcol  " This is NOT off by one!
                            	call cursor(0, endcol)
                                  endif
                                endif " a:0
                              endif " a:mode != "o" && etc.
                              return 0
                            endfun
                            
                            " Example (simplified HTML patterns):  if
                            "   a:groupBR	= '<\(\k\+\)>:</\1>'
                            "   a:prefix	= '^.\{3}\('
                            "   a:group	= '<\(\k\+\)>:</\(\k\+\)>'
                            "   a:suffix	= '\).\{2}$'
                            "   a:matchline	=  "123<tag>12" or "123</tag>12"
                            " then extract "tag" from a:matchline and return "<tag>:</tag>" .
    1              0.000006 fun! s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              if a:matchline !~ a:prefix .
                                \ substitute(a:group, s:notslash . '\zs:', '\\|', 'g') . a:suffix
                                return a:group
                              endif
                              let i = matchend(a:groupBR, s:notslash . ':')
                              let ini = strpart(a:groupBR, 0, i-1)
                              let tailBR = strpart(a:groupBR, i)
                              let word = s:Choose(a:group, a:matchline, ":", "", a:prefix, a:suffix,
                                \ a:groupBR)
                              let i = matchend(word, s:notslash . ":")
                              let wordBR = strpart(word, i)
                              let word = strpart(word, 0, i-1)
                              " Now, a:matchline =~ a:prefix . word . a:suffix
                              if wordBR != ini
                                let table = s:Resolve(ini, wordBR, "table")
                              else
                                " let table = "----------"
                                let table = ""
                                let d = 0
                                while d < 10
                                  if tailBR =~ s:notslash . '\\' . d
                            	" let table[d] = d
                            	let table = table . d
                                  else
                            	let table = table . "-"
                                  endif
                                  let d = d + 1
                                endwhile
                              endif
                              let d = 9
                              while d
                                if table[d] != "-"
                                  let backref = substitute(a:matchline, a:prefix.word.a:suffix,
                            	\ '\'.table[d], "")
                            	" Are there any other characters that should be escaped?
                                  let backref = escape(backref, '*,:')
                                  execute s:Ref(ini, d, "start", "len")
                                  let ini = strpart(ini, 0, start) . backref . strpart(ini, start+len)
                                  let tailBR = substitute(tailBR, s:notslash . '\zs\\' . d,
                            	\ escape(backref, '\\&'), 'g')
                                endif
                                let d = d-1
                              endwhile
                              if exists("b:match_debug")
                                if s:do_BR
                                  let b:match_table = table
                                  let b:match_word = word
                                else
                                  let b:match_table = ""
                                  let b:match_word = ""
                                endif
                              endif
                              return ini . ":" . tailBR
                            endfun
                            
                            " Input a comma-separated list of groups with backrefs, such as
                            "   a:groups = '\(foo\):end\1,\(bar\):end\1'
                            " and return a comma-separated list of groups with backrefs replaced:
                            "   return '\(foo\):end\(foo\),\(bar\):end\(bar\)'
    1              0.000005 fun! s:ParseWords(groups)
                              let groups = substitute(a:groups.",", s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
                              let groups = substitute(groups, s:notslash . '\zs:\{2,}', ':', 'g')
                              let parsed = ""
                              while groups =~ '[^,:]'
                                let i = matchend(groups, s:notslash . ':')
                                let j = matchend(groups, s:notslash . ',')
                                let ini = strpart(groups, 0, i-1)
                                let tail = strpart(groups, i, j-i-1) . ":"
                                let groups = strpart(groups, j)
                                let parsed = parsed . ini
                                let i = matchend(tail, s:notslash . ':')
                                while i != -1
                                  " In 'if:else:endif', ini='if' and word='else' and then word='endif'.
                                  let word = strpart(tail, 0, i-1)
                                  let tail = strpart(tail, i)
                                  let i = matchend(tail, s:notslash . ':')
                                  let parsed = parsed . ":" . s:Resolve(ini, word, "word")
                                endwhile " Now, tail has been used up.
                                let parsed = parsed . ","
                              endwhile " groups =~ '[^,:]'
                              let parsed = substitute(parsed, ',$', '', '')
                              return parsed
                            endfun
                            
                            " TODO I think this can be simplified and/or made more efficient.
                            " TODO What should I do if a:start is out of range?
                            " Return a regexp that matches all of a:string, such that
                            " matchstr(a:string, regexp) represents the match for a:pat that starts
                            " as close to a:start as possible, before being preferred to after, and
                            " ends after a:start .
                            " Usage:
                            " let regexp = s:Wholematch(getline("."), 'foo\|bar', col(".")-1)
                            " let i      = match(getline("."), regexp)
                            " let j      = matchend(getline("."), regexp)
                            " let match  = matchstr(getline("."), regexp)
    1              0.000062 fun! s:Wholematch(string, pat, start)
                              let group = '\%(' . a:pat . '\)'
                              let prefix = (a:start ? '\(^.*\%<' . (a:start + 2) . 'c\)\zs' : '^')
                              let len = strlen(a:string)
                              let suffix = (a:start+1 < len ? '\(\%>'.(a:start+1).'c.*$\)\@=' : '$')
                              if a:string !~ prefix . group . suffix
                                let prefix = ''
                              endif
                              return prefix . group . suffix
                            endfun
                            
                            " No extra arguments:  s:Ref(string, d) will
                            " find the d'th occurrence of '\(' and return it, along with everything up
                            " to and including the matching '\)'.
                            " One argument:  s:Ref(string, d, "start") returns the index of the start
                            " of the d'th '\(' and any other argument returns the length of the group.
                            " Two arguments:  s:Ref(string, d, "foo", "bar") returns a string to be
                            " executed, having the effect of
                            "   :let foo = s:Ref(string, d, "start")
                            "   :let bar = s:Ref(string, d, "len")
    1              0.000015 fun! s:Ref(string, d, ...)
                              let len = strlen(a:string)
                              if a:d == 0
                                let start = 0
                              else
                                let cnt = a:d
                                let match = a:string
                                while cnt
                                  let cnt = cnt - 1
                                  let index = matchend(match, s:notslash . '\\(')
                                  if index == -1
                            	return ""
                                  endif
                                  let match = strpart(match, index)
                                endwhile
                                let start = len - strlen(match)
                                if a:0 == 1 && a:1 == "start"
                                  return start - 2
                                endif
                                let cnt = 1
                                while cnt
                                  let index = matchend(match, s:notslash . '\\(\|\\)') - 1
                                  if index == -2
                            	return ""
                                  endif
                                  " Increment if an open, decrement if a ')':
                                  let cnt = cnt + (match[index]=="(" ? 1 : -1)  " ')'
                                  " let cnt = stridx('0(', match[index]) + cnt
                                  let match = strpart(match, index+1)
                                endwhile
                                let start = start - 2
                                let len = len - start - strlen(match)
                              endif
                              if a:0 == 1
                                return len
                              elseif a:0 == 2
                                return "let " . a:1 . "=" . start . "| let " . a:2 . "=" . len
                              else
                                return strpart(a:string, start, len)
                              endif
                            endfun
                            
                            " Count the number of disjoint copies of pattern in string.
                            " If the pattern is a literal string and contains no '0' or '1' characters
                            " then s:Count(string, pattern, '0', '1') should be faster than
                            " s:Count(string, pattern).
    1              0.000005 fun! s:Count(string, pattern, ...)
                              let pat = escape(a:pattern, '\\')
                              if a:0 > 1
                                let foo = substitute(a:string, '[^'.a:pattern.']', "a:1", "g")
                                let foo = substitute(a:string, pat, a:2, "g")
                                let foo = substitute(foo, '[^' . a:2 . ']', "", "g")
                                return strlen(foo)
                              endif
                              let result = 0
                              let foo = a:string
                              let index = matchend(foo, pat)
                              while index != -1
                                let result = result + 1
                                let foo = strpart(foo, index)
                                let index = matchend(foo, pat)
                              endwhile
                              return result
                            endfun
                            
                            " s:Resolve('\(a\)\(b\)', '\(c\)\2\1\1\2') should return table.word, where
                            " word = '\(c\)\(b\)\(a\)\3\2' and table = '-32-------'.  That is, the first
                            " '\1' in target is replaced by '\(a\)' in word, table[1] = 3, and this
                            " indicates that all other instances of '\1' in target are to be replaced
                            " by '\3'.  The hard part is dealing with nesting...
                            " Note that ":" is an illegal character for source and target,
                            " unless it is preceded by "\".
    1              0.000005 fun! s:Resolve(source, target, output)
                              let word = a:target
                              let i = matchend(word, s:notslash . '\\\d') - 1
                              let table = "----------"
                              while i != -2 " There are back references to be replaced.
                                let d = word[i]
                                let backref = s:Ref(a:source, d)
                                " The idea is to replace '\d' with backref.  Before we do this,
                                " replace any \(\) groups in backref with :1, :2, ... if they
                                " correspond to the first, second, ... group already inserted
                                " into backref.  Later, replace :1 with \1 and so on.  The group
                                " number w+b within backref corresponds to the group number
                                " s within a:source.
                                " w = number of '\(' in word before the current one
                                let w = s:Count(
                                \ substitute(strpart(word, 0, i-1), '\\\\', '', 'g'), '\(', '1')
                                let b = 1 " number of the current '\(' in backref
                                let s = d " number of the current '\(' in a:source
                                while b <= s:Count(substitute(backref, '\\\\', '', 'g'), '\(', '1')
                                \ && s < 10
                                  if table[s] == "-"
                            	if w + b < 10
                            	  " let table[s] = w + b
                            	  let table = strpart(table, 0, s) . (w+b) . strpart(table, s+1)
                            	endif
                            	let b = b + 1
                            	let s = s + 1
                                  else
                            	execute s:Ref(backref, b, "start", "len")
                            	let ref = strpart(backref, start, len)
                            	let backref = strpart(backref, 0, start) . ":". table[s]
                            	\ . strpart(backref, start+len)
                            	let s = s + s:Count(substitute(ref, '\\\\', '', 'g'), '\(', '1')
                                  endif
                                endwhile
                                let word = strpart(word, 0, i-1) . backref . strpart(word, i+1)
                                let i = matchend(word, s:notslash . '\\\d') - 1
                              endwhile
                              let word = substitute(word, s:notslash . '\zs:', '\\', 'g')
                              if a:output == "table"
                                return table
                              elseif a:output == "word"
                                return word
                              else
                                return table . word
                              endif
                            endfun
                            
                            " Assume a:comma = ",".  Then the format for a:patterns and a:1 is
                            "   a:patterns = "<pat1>,<pat2>,..."
                            "   a:1 = "<alt1>,<alt2>,..."
                            " If <patn> is the first pattern that matches a:string then return <patn>
                            " if no optional arguments are given; return <patn>,<altn> if a:1 is given.
    1              0.000005 fun! s:Choose(patterns, string, comma, branch, prefix, suffix, ...)
                              let tail = (a:patterns =~ a:comma."$" ? a:patterns : a:patterns . a:comma)
                              let i = matchend(tail, s:notslash . a:comma)
                              if a:0
                                let alttail = (a:1 =~ a:comma."$" ? a:1 : a:1 . a:comma)
                                let j = matchend(alttail, s:notslash . a:comma)
                              endif
                              let current = strpart(tail, 0, i-1)
                              if a:branch == ""
                                let currpat = current
                              else
                                let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
                              endif
                              while a:string !~ a:prefix . currpat . a:suffix
                                let tail = strpart(tail, i)
                                let i = matchend(tail, s:notslash . a:comma)
                                if i == -1
                                  return -1
                                endif
                                let current = strpart(tail, 0, i-1)
                                if a:branch == ""
                                  let currpat = current
                                else
                                  let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
                                endif
                                if a:0
                                  let alttail = strpart(alttail, j)
                                  let j = matchend(alttail, s:notslash . a:comma)
                                endif
                              endwhile
                              if a:0
                                let current = current . a:comma . strpart(alttail, 0, j-1)
                              endif
                              return current
                            endfun
                            
                            " Call this function to turn on debugging information.  Every time the main
                            " script is run, buffer variables will be saved.  These can be used directly
                            " or viewed using the menu items below.
    1              0.000008 if !exists(":MatchDebug")
    1              0.000009   command! -nargs=0 MatchDebug call s:Match_debug()
    1              0.000002 endif
                            
    1              0.000003 fun! s:Match_debug()
                              let b:match_debug = 1	" Save debugging information.
                              " pat = all of b:match_words with backrefs parsed
                              amenu &Matchit.&pat	:echo b:match_pat<CR>
                              " match = bit of text that is recognized as a match
                              amenu &Matchit.&match	:echo b:match_match<CR>
                              " curcol = cursor column of the start of the matching text
                              amenu &Matchit.&curcol	:echo b:match_col<CR>
                              " wholeBR = matching group, original version
                              amenu &Matchit.wh&oleBR	:echo b:match_wholeBR<CR>
                              " iniBR = 'if' piece, original version
                              amenu &Matchit.ini&BR	:echo b:match_iniBR<CR>
                              " ini = 'if' piece, with all backrefs resolved from match
                              amenu &Matchit.&ini	:echo b:match_ini<CR>
                              " tail = 'else\|endif' piece, with all backrefs resolved from match
                              amenu &Matchit.&tail	:echo b:match_tail<CR>
                              " fin = 'endif' piece, with all backrefs resolved from match
                              amenu &Matchit.&word	:echo b:match_word<CR>
                              " '\'.d in ini refers to the same thing as '\'.table[d] in word.
                              amenu &Matchit.t&able	:echo '0:' . b:match_table . ':9'<CR>
                            endfun
                            
                            " Jump to the nearest unmatched "(" or "if" or "<tag>" if a:spflag == "bW"
                            " or the nearest unmatched "</tag>" or "endif" or ")" if a:spflag == "W".
                            " Return a "mark" for the original position, so that
                            "   let m = MultiMatch("bW", "n") ... execute m
                            " will return to the original position.  If there is a problem, do not
                            " move the cursor and return "", unless a count is given, in which case
                            " go up or down as many levels as possible and again return "".
                            " TODO This relies on the same patterns as % matching.  It might be a good
                            " idea to give it its own matching patterns.
    1              0.000004 fun! s:MultiMatch(spflag, mode)
                              if !exists("b:match_words") || b:match_words == ""
                                return ""
                              end
                              let restore_options = ""
                              if exists("b:match_ignorecase") && b:match_ignorecase != &ic
                                let restore_options .= (&ic ? " " : " no") . "ignorecase"
                                let &ignorecase = b:match_ignorecase
                              endif
                              let startline = line(".")
                              let startcol = col(".")
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR	flag for whether there are backrefs
                              "   s:pat	parsed version of b:match_words
                              "   s:all	regexp based on s:pat and the default groups
                              " This part is copied and slightly modified from s:Match_wrapper().
                              let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") .
                                \ '\/\*:\*\/,#\s*if\%(def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                              " Allow b:match_words = "GetVimMatchWords()" .
                              if b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                execute "let match_words =" b:match_words
                              endif
                              if (match_words != s:last_words) || (&mps != s:last_mps) ||
                                \ exists("b:match_debug")
                                let s:last_words = match_words
                                let s:last_mps = &mps
                                let match_words = match_words . (strlen(match_words) ? "," : "") . default
                                if match_words !~ s:notslash . '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = '\%(' . substitute(s:pat . (strlen(s:pat) ? "," : "") . default,
                            	\ '[,:]\+', '\\|', 'g') . '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                              endif
                            
                              " Second step:  figure out the patterns for searchpair()
                              " and save the screen, cursor position, and 'ignorecase'.
                              " - TODO:  A lot of this is copied from s:Match_wrapper().
                              " - maybe even more functionality should be split off
                              " - into separate functions!
                              let cdefault = (s:pat =~ '[^,]$' ? "," : "") . default
                              let open =  substitute(s:pat . cdefault,
                            	\ s:notslash . '\zs:.\{-}' . s:notslash . ',', '\\),\\(', 'g')
                              let open =  '\(' . substitute(open, s:notslash . '\zs:.*$', '\\)', '')
                              let close = substitute(s:pat . cdefault,
                            	\ s:notslash . '\zs,.\{-}' . s:notslash . ':', '\\),\\(', 'g')
                              let close = substitute(close, '^.\{-}' . s:notslash . ':', '\\(', '') . '\)'
                              if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" . b:match_comment
                              else
                                let skip = 's:comment\|string'
                              endif
                              let skip = s:ParseSkip(skip)
                              " save v:count1 variable, might be reset from the restore_cursor command
                              let level = v:count1
                              let restore_cursor = virtcol(".") . "|"
                              normal! g0
                              let restore_cursor = line(".") . "G" .  virtcol(".") . "|zs" . restore_cursor
                              normal! H
                              let restore_cursor = "normal!" . line(".") . "Gzt" . restore_cursor
                              execute restore_cursor
                            
                              " Third step: call searchpair().
                              " Replace '\('--but not '\\('--with '\%(' and ',' with '\|'.
                              let openpat =  substitute(open, '\(\\\@<!\(\\\\\)*\)\@<=\\(', '\\%(', 'g')
                              let openpat = substitute(openpat, ',', '\\|', 'g')
                              let closepat = substitute(close, '\(\\\@<!\(\\\\\)*\)\@<=\\(', '\\%(', 'g')
                              let closepat = substitute(closepat, ',', '\\|', 'g')
                            
                              if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = '0'
                              else
                                try
                                  execute "if " . skip . "| let skip = '0' | endif"
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                              mark '
                              while level
                                if searchpair(openpat, '', closepat, a:spflag, skip) < 1
                                  call s:CleanUp(restore_options, a:mode, startline, startcol)
                                  return ""
                                endif
                                let level = level - 1
                              endwhile
                            
                              " Restore options and return a string to restore the original position.
                              call s:CleanUp(restore_options, a:mode, startline, startcol)
                              return restore_cursor
                            endfun
                            
                            " Search backwards for "if" or "while" or "<tag>" or ...
                            " and return "endif" or "endwhile" or "</tag>" or ... .
                            " For now, this uses b:match_words and the same script variables
                            " as s:Match_wrapper() .  Later, it may get its own patterns,
                            " either from a buffer variable or passed as arguments.
                            " fun! s:Autocomplete()
                            "   echo "autocomplete not yet implemented :-("
                            "   if !exists("b:match_words") || b:match_words == ""
                            "     return ""
                            "   end
                            "   let startpos = s:MultiMatch("bW")
                            "
                            "   if startpos == ""
                            "     return ""
                            "   endif
                            "   " - TODO:  figure out whether 'if' or '<tag>' matched, and construct
                            "   " - the appropriate closing.
                            "   let matchline = getline(".")
                            "   let curcol = col(".") - 1
                            "   " - TODO:  Change the s:all argument if there is a new set of match pats.
                            "   let regexp = s:Wholematch(matchline, s:all, curcol)
                            "   let suf = strlen(matchline) - matchend(matchline, regexp)
                            "   let prefix = (curcol ? '^.\{'  . curcol . '}\%(' : '^\%(')
                            "   let suffix = (suf ? '\).\{' . suf . '}$'  : '\)$')
                            "   " Reconstruct the version with unresolved backrefs.
                            "   let patBR = substitute(b:match_words.',', '[,:]*,[,:]*', ',', 'g')
                            "   let patBR = substitute(patBR, ':\{2,}', ':', "g")
                            "   " Now, set group and groupBR to the matching group: 'if:endif' or
                            "   " 'while:endwhile' or whatever.
                            "   let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, patBR)
                            "   let i = matchend(group, s:notslash . ",")
                            "   let groupBR = strpart(group, i)
                            "   let group = strpart(group, 0, i-1)
                            "   " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
                            "   if s:do_BR
                            "     let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                            "   endif
                            " " let g:group = group
                            "
                            "   " - TODO:  Construct the closing from group.
                            "   let fake = "end" . expand("<cword>")
                            "   execute startpos
                            "   return fake
                            " endfun
                            
                            " Close all open structures.  "Get the heck out of here!"
                            " fun! s:Gthhoh()
                            "   let close = s:Autocomplete()
                            "   while strlen(close)
                            "     put=close
                            "     let close = s:Autocomplete()
                            "   endwhile
                            " endfun
                            
                            " Parse special strings as typical skip arguments for searchpair():
                            "   s:foo becomes (current syntax item) =~ foo
                            "   S:foo becomes (current syntax item) !~ foo
                            "   r:foo becomes (line before cursor) =~ foo
                            "   R:foo becomes (line before cursor) !~ foo
    1              0.000006 fun! s:ParseSkip(str)
                              let skip = a:str
                              if skip[1] == ":"
                                if skip[0] == "s"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') =~? '" .
                            	\ strpart(skip,2) . "'"
                                elseif skip[0] == "S"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') !~? '" .
                            	\ strpart(skip,2) . "'"
                                elseif skip[0] == "r"
                                  let skip = "strpart(getline('.'),0,col('.'))=~'" . strpart(skip,2). "'"
                                elseif skip[0] == "R"
                                  let skip = "strpart(getline('.'),0,col('.'))!~'" . strpart(skip,2). "'"
                                endif
                              endif
                              return skip
                            endfun
                            
    1              0.000014 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:

SCRIPT  /home/c5262761/configit/vim/filetype.vim
Sourced 1 time
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
    1              0.000006 aug my_filetypedetect
    1              0.000005     au!
    1              0.000025     au BufNewFile,BufRead *.md setf markdown
    1              0.000009     au BufNewFile,BufRead *.h setf c
                            
    1              0.000010     au BufNewFile,BufRead *.ldg setf ledger
                            
    1              0.000019     au BufNewFile,BufRead /tmp/pentadactyl*{reddit,github}* setf markdown
    1              0.000026     au BufNewFile,BufRead /tmp/pentadactyl*jira*.txt setf jira
    1              0.000011     au BufNewFile,BufRead *.jira setf jira
                            
    1              0.000012     au BufNewFile,BufRead */ssh/config set ft=sshconfig
    1              0.000011     au BufNewfile,BufRead */git/config setf gitconfig
                            
    1              0.000017     au BufNewFile,BufRead *.pp setf puppet
    1              0.000009     au BufNewFile,BufRead *.epp setf puppet.epp
    1              0.000011     au BufNewFile,BufRead Puppetfile setf ruby
                            
    1              0.000023     au BufNewFile,BufRead *.taskrc setf taskrc
                            
    1              0.000010     au BufNewFile,BufRead *.tsv setf tsv
                            
    1              0.000013     au BufNewFile,BufRead *
                                            \ if getline(1) =~ '/usr/bin/\(env\s\+\)\?gorun' |
                                            \   set filetype=go |
                                            \ endif
    1              0.000005 aug END

SCRIPT  /home/c5262761/local/share/vim/vim81/filetype.vim
Sourced 1 time
Total time:   0.017332
 Self time:   0.016209

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2018 May 04
                            
                            " Listen very carefully, I will say this only once
    1              0.000010 if exists("did_load_filetypes")
                              finish
    1              0.000002 endif
    1              0.000005 let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000010 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000003 augroup filetypedetect
                            
                            " Ignored extensions
    1              0.000007 if exists("*fnameescape")
    1              0.000113 au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
    1              0.000033 au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
    1              0.000017 au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
                            elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
    1              0.000001 endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
    1              0.000025 if !exists("g:ft_ignore_pat")
    1              0.000011   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
    1              0.000007 endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
    1              0.000007 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Vim help file
    1              0.000033 au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt	setf help
                            
                            " Abaqus or Trasys
    1              0.000014 au BufNewFile,BufRead *.inp			call dist#ft#Check_inp()
                            
                            " A-A-P recipe
    1              0.000010 au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
    1              0.000034 au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
    1              0.000009 au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
    1              0.000019 au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
    1              0.000008 au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
    1              0.000016 au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
    1              0.000019 au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
    1              0.000011 if has("vms")
                              au BufNewFile,BufRead *.gpr,*.ada_m,*.adc	setf ada
    1              0.000002 else
    1              0.000010   au BufNewFile,BufRead *.gpr			setf ada
    1              0.000002 endif
                            
                            " AHDL
    1              0.000013 au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AMPL
    1              0.000019 au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
    1              0.000014 au BufNewFile,BufRead build.xml			setf ant
                            
                            " Arduino
    1              0.000021 au BufNewFile,BufRead *.ino,*.pde		setf arduino
                            
                            " Apache style config file
    1              0.000012 au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
                            
                            " Apache config file
    1              0.000024 au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            
                            " XA65 MOS6510 cross assembler
    1              0.000012 au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
    1              0.000008 au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
    1              0.000015 au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
    1              0.000041 au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
    1              0.000015 au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
    1              0.000025 au BufNewFile,BufRead apt.conf		       setf aptconf
    1              0.000013 au BufNewFile,BufRead */.aptitude/config       setf aptconf
    1              0.000040 au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
                            
                            " Arch Inventory file
    1              0.000023 au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
    1              0.000012 au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
    1              0.000019 au BufNewFile,BufRead *.asciidoc,*.adoc		setf asciidoc
                            
                            " ASN.1
    1              0.000012 au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
    1              0.000017 au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
    1              0.000020 au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
    1              0.000033 au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
    1              0.000035 au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call dist#ft#FTasm()
                            
                            " Macro (VAX)
    1              0.000009 au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
    1              0.000016 au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Autoit v3
    1              0.000009 au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
    1              0.000009 au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
    1              0.000023 au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
    1              0.000009 au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
    1              0.000008 au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
    1              0.000019 au BufNewFile,BufRead *.awk			setf awk
                            
                            " B
    1              0.000022 au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
    1              0.000009 au BufNewFile,BufRead *.bas			call dist#ft#FTVB("basic")
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
    1              0.000025 au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
    1              0.000019 au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
    1              0.000021 au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
    1              0.000018 au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
    1              0.000013 au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
    1              0.000009 au BufNewFile,BufRead *.btm			call dist#ft#FTbtm()
                            
                            " BC calculator
    1              0.000008 au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
    1              0.000011 au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " BibTeX bibliography database file
    1              0.000007 au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
    1              0.000008 au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
                            " sudoedit uses namedXXXX.conf
    1              0.000027 au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key	setf named
                            
                            " BIND zone
    1              0.000018 au BufNewFile,BufRead named.root		setf bindzone
    1              0.000009 au BufNewFile,BufRead *.db			call dist#ft#BindzoneCheck('')
                            
                            " Blank
    1              0.000018 au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
    1              0.000027 au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " Bazel (http://bazel.io)
    1              0.000039 autocmd BufRead,BufNewFile *.bzl,WORKSPACE,BUILD.bazel 	setf bzl
    1              0.000008 if has("fname_case")
                              " There is another check for BUILD further below.
    1              0.000010   autocmd BufRead,BufNewFile BUILD			setf bzl
    1              0.000002 endif
                            
                            " C or lpc
    1              0.000013 au BufNewFile,BufRead *.c			call dist#ft#FTlpc()
    1              0.000015 au BufNewFile,BufRead *.lpc,*.ulpc		setf lpc
                            
                            " Calendar
    1              0.000021 au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
    1              0.000013 au BufNewFile,BufRead *.cs			setf cs
                            
                            " CSDL
    1              0.000009 au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
    1              0.000008 au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
    1              0.000007 au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
    1              0.000048 au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
    1              0.000019 au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
    1              0.000009 au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
    1              0.000008 au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
    1              0.000009 au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
    1              0.000023 au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
    1              0.000032 au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
    1              0.000025 au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
    1              0.000011 au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
    1              0.000082 au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
    1              0.000007 if has("fname_case")
    1              0.000021   au BufNewFile,BufRead *.C,*.H setf cpp
    1              0.000002 endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
    1              0.000019 au BufNewFile,BufRead *.h			call dist#ft#FTheader()
                            
                            " Ch (CHscript)
    1              0.000009 au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
    1              0.000010 au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
    1              0.000010 au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
    1              0.000009 au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
    1              0.000048 au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
                            					\	setf debchangelog
                            
    1              0.000017 au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
    1              0.000013 au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
    1              0.000022 au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
    1              0.000008 au BufNewFile,BufRead *.ch			call dist#ft#FTchange()
                            
                            " ChordPro
    1              0.000032 au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
    1              0.000020 au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
    1              0.000008 au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
    1              0.000009 au BufNewFile,BufRead *.ent			call dist#ft#FTent()
                            
                            " Clipper (or FoxPro; could also be eviews)
    1              0.000012 au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Clojure
    1              0.000029 au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc		setf clojure
                            
                            " Cmake
    1              0.000030 au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
    1              0.000038 au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
    1              0.000015 au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
    1              0.000018 au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
    1              0.000016 au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
    1              0.000009 au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
    1              0.000020 au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
    1              0.000029 au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA  Cumpute Unified Device Architecture
    1              0.000016 au BufNewFile,BufRead *.cu,*.cuh		setf cuda
                            
                            " Dockerfile
    1              0.000017 au BufNewFile,BufRead Dockerfile,*.Dockerfile	setf dockerfile
                            
                            " WildPackets EtherPeek Decoder
    1              0.000008 au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
    1              0.000016 au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
    1              0.000013 au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Euphoria 3 or 4
    1              0.000033 au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()
    1              0.000008 if has("fname_case")
    1              0.000090    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
    1              0.000003 endif
                            
                            " Lynx config files
    1              0.000013 au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Quake
    1              0.000072 au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
    1              0.000013 au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
    1              0.000007 au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
    1              0.000018 au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
    1              0.000015 au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
    1              0.000014 au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
    1              0.000008 au BufNewFile,BufRead *.pld			setf cupl
    1              0.000008 au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Debian Control
    1              0.000022 au BufNewFile,BufRead */debian/control		setf debcontrol
    1              0.000012 au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Copyright
    1              0.000074 au BufNewFile,BufRead */debian/copyright	setf debcopyright
    1              0.000014 au BufNewFile,BufRead copyright
                            	\  if getline(1) =~ '^Format:'
                            	\|   setf debcopyright
                            	\| endif
                            
                            " Debian Sources.list
    1              0.000014 au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
    1              0.000021 au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
    1              0.000012 au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
    1              0.000025 au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
    1              0.000030 au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
    1              0.000019 au BufNewFile,BufRead *.d			call dist#ft#DtraceCheck()
                            
                            " Desktop files
    1              0.000035 au BufNewFile,BufRead *.desktop,.directory	setf desktop
                            
                            " Dict config
    1              0.000015 au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
    1              0.000010 au BufNewFile,BufRead dictd.conf		setf dictdconf
                            
                            " Diff files
    1              0.000017 au BufNewFile,BufRead *.diff,*.rej		setf diff
    1              0.000021 au BufNewFile,BufRead *.patch
                            	\ if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |
                            	\   setf gitsendemail |
                            	\ else |
                            	\   setf diff |
                            	\ endif
                            
                            " Dircolors
    1              0.000033 au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
    1              0.000013 au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
    1              0.000010 au BufNewFile,BufRead *.com			call dist#ft#BindzoneCheck('dcl')
                            
                            " DOT
    1              0.000009 au BufNewFile,BufRead *.dot			setf dot
                            
                            " Dylan - lid files
    1              0.000020 au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
    1              0.000019 au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
    1              0.000009 au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
    1              0.000008 au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
    1              0.000024 au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
    1              0.000008 au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl
    1              0.000008 au BufNewFile,BufRead *.dsl			setf dsl
                            
                            " DTD (Document Type Definition for XML)
    1              0.000007 au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
    1              0.000013 au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
    1              0.000012 au BufNewFile,BufRead *.ed\(f\|if\|o\)		setf edif
    1              0.000012 au BufNewFile,BufRead *.edn
                            	\ if getline(1) =~ '^\s*(\s*edif\>' |
                            	\   setf edif |
                            	\ else |
                            	\   setf clojure |
                            	\ endif
                            
                            " EditorConfig (close enough to dosini)
    1              0.000016 au BufNewFile,BufRead .editorconfig		setf dosini
                            
                            " Embedix Component Description
    1              0.000008 au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman or Euphoria
    1              0.000012 au BufNewFile,BufRead *.e,*.E			call dist#ft#FTe()
                            
                            " Elinks configuration
    1              0.000026 au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
                            
                            " ERicsson LANGuage; Yaws is erlang too
    1              0.000022 au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm Filter Rules file
    1              0.000011 au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
    1              0.000010 au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
    1              0.000016 au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
    1              0.000012 au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
    1              0.000008 au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
    1              0.000010 au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
    1              0.000012 au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
    1              0.000010 au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
    1              0.000008 au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
    1              0.000027 au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
    1              0.000009 au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fetchmail RC file
    1              0.000015 au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
    1              0.000017 au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
    1              0.000011 au BufNewFile,BufRead auto.master		setf conf
    1              0.000014 au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
    1              0.000019 au BufNewFile,BufRead *.fs,*.ft,*.fth		setf forth
                            
                            " Reva Forth
    1              0.000009 au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
    1              0.000008 if has("fname_case")
    1              0.000061   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
    1              0.000003 endif
    1              0.000078 au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
    1              0.000013 au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
    1              0.000014 au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " GDB command files
    1              0.000011 au BufNewFile,BufRead .gdbinit			setf gdb
                            
                            " GDMO
    1              0.000014 au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
    1              0.000017 au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Git
    1              0.000035 au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG setf gitcommit
    1              0.000028 au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
    1              0.000019 au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
    1              0.000012 au BufNewFile,BufRead */.config/git/config	setf gitconfig
    1              0.000007 if !empty($XDG_CONFIG_HOME)
    1              0.000036   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config	setf gitconfig
    1              0.000002 endif
    1              0.000013 au BufNewFile,BufRead git-rebase-todo		setf gitrebase
    1              0.000018 au BufRead,BufNewFile .gitsendemail.msg.??????	setf gitsendemail
    1              0.000024 au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
    1              0.000019 au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
    1              0.000018 au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
    1              0.000023 au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
    1              0.000011 au BufNewFile,BufRead */.gnupg/options		setf gpg
    1              0.000011 au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
    1              0.000019 au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
    1              0.000011 if !empty($GNUPGHOME)
                              au BufNewFile,BufRead $GNUPGHOME/options	setf gpg
                              au BufNewFile,BufRead $GNUPGHOME/gpg.conf	setf gpg
    1              0.000002 endif
                            
                            " gnash(1) configuration files
    1              0.000033 au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
    1              0.000029 au BufNewFile,BufRead gitolite.conf		setf gitolite
    1              0.000023 au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
    1              0.000023 au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Gnuplot scripts
    1              0.000012 au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " Go (Google)
    1              0.000031 au BufNewFile,BufRead *.go			setf go
                            
                            " GrADS scripts
    1              0.000009 au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
    1              0.000018 au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
    1              0.000019 au BufNewFile,BufRead *.gradle,*.groovy		setf groovy
                            
                            " GNU Server Pages
    1              0.000009 au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
    1              0.000092 au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
    1              0.000021 au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
    1              0.000009 au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
    1              0.000013 au BufNewFile,BufRead *.hsc,*.hsm		setf hamster
                            
                            " Haskell
    1              0.000017 au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
    1              0.000009 au BufNewFile,BufRead *.lhs			setf lhaskell
    1              0.000019 au BufNewFile,BufRead *.chs			setf chaskell
                            
                            " Haste
    1              0.000011 au BufNewFile,BufRead *.ht			setf haste
    1              0.000008 au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
    1              0.000024 au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
    1              0.000013 au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Tilde (must be before HTML)
    1              0.000012 au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
    1              0.000024 au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
                            
                            " HTML with Ruby - eRuby
    1              0.000024 au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
    1              0.000011 au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " HTML Cheetah template
    1              0.000009 au BufNewFile,BufRead *.tmpl			setf htmlcheetah
                            
                            " Host config
    1              0.000012 au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
    1              0.000033 au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
    1              0.000009 au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
    1              0.000014 au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " Icon
    1              0.000008 au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
    1              0.000009 au BufNewFile,BufRead *.idl			call dist#ft#FTidl()
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
    1              0.000021 au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
    1              0.000010 au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
    1              0.000025 au BufNewFile,BufRead .indent.pro		setf indent
    1              0.000012 au BufNewFile,BufRead indent.pro		call dist#ft#ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
    1              0.000008 au BufNewFile,BufRead *.pro			call dist#ft#ProtoCheck('idlang')
                            
                            " Indent RC
    1              0.000010 au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
    1              0.000022 au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
    1              0.000021 au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
    1              0.000031 au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
    1              0.000049 au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c 	setf upstreamlog
    1              0.000042 au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
    1              0.000034 au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
    1              0.000035 au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog
                            
                            " Ipfilter
    1              0.000026 au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
    1              0.000017 au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
    1              0.000009 au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
    1              0.000014 au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
    1              0.000008 au BufNewFile,BufRead *.iss			setf iss
                            
                            " J
    1              0.000008 au BufNewFile,BufRead *.ijs			setf j
                            
                            " JAL
    1              0.000019 au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
    1              0.000012 au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
    1              0.000040 au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
    1              0.000014 au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript
    1              0.000034 au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript
                            
                            " Java Server Pages
    1              0.000008 au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    1              0.000029 au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
    1              0.000013 au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Jess
    1              0.000009 au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
    1              0.000008 au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
    1              0.000018 au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " JSON
    1              0.000021 au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest	setf json
                            
                            " Kixtart
    1              0.000009 au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
    1              0.000008 au BufNewFile,BufRead *.k			setf kwt
                            
                            " Kivy
    1              0.000009 au BufNewFile,BufRead *.kv			setf kivy
                            
                            " KDE script
    1              0.000008 au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
    1              0.000021 au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
    1              0.000024 au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
    1              0.000013 au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
    1              0.000046 au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
    1              0.000013 au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
    1              0.000008 au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
    1              0.000007 au BufNewFile,BufRead *.ld			setf ld
                            
                            " Less
    1              0.000008 au BufNewFile,BufRead *.less			setf less
                            
                            " Lex
    1              0.000043 au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex
                            
                            " Libao
    1              0.000020 au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
    1              0.000024 au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
    1              0.000027 au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
    1              0.000009 au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
    1              0.000010 au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
    1              0.000007 if has("fname_case")
    1              0.000056   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
                            else
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
    1              0.000001 endif
                            
                            " SBCL implementation of Common Lisp
    1              0.000019 au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
    1              0.000021 au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
    1              0.000016 au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
    1              0.000015 au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
    1              0.000013 au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
    1              0.000015 au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
    1              0.000011 au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
    1              0.000012 au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
    1              0.000015 au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
    1              0.000008 au BufNewFile,BufRead *.lua			setf lua
                            
                            " Luarocks
    1              0.000009 au BufNewFile,BufRead *.rockspec		setf lua
                            
                            " Linden Scripting Language (Second Life)
    1              0.000009 au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
    1              0.000009 au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
    1              0.000011 au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
    1              0.000009 au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
    1              0.000173 au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
    1              0.000020 au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
    1              0.000025 au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
    1              0.000028 au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
    1              0.000023 au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
    1              0.000009 au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
    1              0.000012 au BufNewFile,BufRead *.man			setf man
                            
                            " Man config
    1              0.000017 au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
    1              0.000019 au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
    1              0.000008 au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
    1              0.000043 au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
                            
                            " Mason
    1              0.000025 au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason
                            
                            " Mathematica, Matlab, Murphi or Objective C
    1              0.000008 au BufNewFile,BufRead *.m			call dist#ft#FTm()
                            
                            " Mathematica notebook
    1              0.000008 au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
    1              0.000019 au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
    1              0.000012 au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
    1              0.000013 au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Messages (logs mostly)
    1              0.000066 au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
    1              0.000036 au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
    1              0.000009 au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
    1              0.000008 au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MIX - Knuth assembly
    1              0.000018 au BufNewFile,BufRead *.mix,*.mixal		setf mix
                            
                            " MMIX or VMS makefile
    1              0.000009 au BufNewFile,BufRead *.mms			call dist#ft#FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
    1              0.000010 au BufNewFile,BufRead *.mmp			setf mmp
                            
                            " Modsim III (or LambdaProlog)
    1              0.000013 au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula 2  (.md removed in favor of Markdown)
    1              0.000042 au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2
                            
                            " Modula 3 (.m3, .i3, .mg, .ig)
    1              0.000011 au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
    1              0.000021 au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
    1              0.000009 au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
    1              0.000028 au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " Mplayer config
    1              0.000019 au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Motorola S record
    1              0.000029 au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec	setf srec
                            
                            " Mrxvtrc
    1              0.000016 au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
    1              0.000009 au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
    1              0.000010 au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
    1              0.000013 au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " M$ Resource files
    1              0.000014 au BufNewFile,BufRead *.rc,*.rch		setf rc
                            
                            " MuPAD source
    1              0.000008 au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
    1              0.000008 au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
    1              0.000019 au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " N1QL
    1              0.000018 au BufRead,BufNewfile *.n1ql,*.nql		setf n1ql
                            
                            " Nano
    1              0.000016 au BufNewFile,BufRead */etc/nanorc,*.nanorc  	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
    1              0.000011 au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Noemutt setup file
    1              0.000010 au BufNewFile,BufRead Neomuttrc			setf neomuttrc
                            
                            " Netrc
    1              0.000010 au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Ninja file
    1              0.000022 au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Novell netware batch files
    1              0.000009 au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
    1              0.000012 au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
    1              0.000040 au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
    1              0.000010 au BufNewFile,BufRead *.[1-9]			call dist#ft#FTnroff()
                            
                            " Nroff or Objective C++
    1              0.000008 au BufNewFile,BufRead *.mm			call dist#ft#FTmm()
                            
                            " Not Quite C
    1              0.000012 au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSE - Nmap Script Engine - uses Lua syntax
    1              0.000008 au BufNewFile,BufRead *.nse			setf lua
                            
                            " NSIS
    1              0.000013 au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCAML
    1              0.000033 au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml
                            
                            " Occam
    1              0.000008 au BufNewFile,BufRead *.occ			setf occam
                            
                            " Omnimark
    1              0.000016 au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OpenROAD
    1              0.000010 au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
    1              0.000010 au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
    1              0.000008 au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
    1              0.000010 au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pam conf
    1              0.000011 au BufNewFile,BufRead */etc/pam.conf		setf pamconf
                            
                            " PApp
    1              0.000033 au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
    1              0.000074 au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p)
    1              0.000008 au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Delphi project file
    1              0.000008 au BufNewFile,BufRead *.dpr			setf pascal
                            
                            " PDF
    1              0.000009 au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " PCMK - HAE - crm configure edit 
    1              0.000014 au BufNewFile,BufRead *.pcmk 			setf pcmk
                            
                            " Perl
    1              0.000017 if has("fname_case")
    1              0.000015   au BufNewFile,BufRead *.pl,*.PL		call dist#ft#FTpl()
                            else
                              au BufNewFile,BufRead *.pl			call dist#ft#FTpl()
    1              0.000001 endif
    1              0.000018 au BufNewFile,BufRead *.plx,*.al,*.psgi		setf perl
    1              0.000016 au BufNewFile,BufRead *.p6,*.pm6,*.pl6		setf perl6
                            
                            " Perl, XPM or XPM2
    1              0.000021 au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
    1              0.000013 au BufNewFile,BufRead *.pod			setf pod
    1              0.000010 au BufNewFile,BufRead *.pod6			setf pod6
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
    1              0.000040 au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " Pike and Cmod
    1              0.000013 au BufNewFile,BufRead *.pike,*.pmod		setf pike
    1              0.000017 au BufNewFile,BufRead *.cmod			setf cmod
                            
                            " Pinfo config
    1              0.000017 au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
    1              0.000009 au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
    1              0.000031 au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " PL/1, PL/I
    1              0.000017 au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
    1              0.000017 au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
    1              0.000016 au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
    1              0.000007 au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
    1              0.000015 au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
    1              0.000010 au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
    1              0.000051 au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
    1              0.000069 au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
    1              0.000009 au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
    1              0.000010 au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, PHP or assembly
    1              0.000008 au BufNewFile,BufRead *.inc			call dist#ft#FTinc()
                            
                            " Printcap and Termcap
    1              0.000013 au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
    1              0.000012 au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTRL
                            "au BufNewFile,BufRead *.g			setf antrl
    1              0.000008 au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
    1              0.000013 au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
    1              0.000049 au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
    1              0.000011 au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
    1              0.000010 au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
    1              0.000016 au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
    1              0.000009 au BufNewFile,BufRead *.w			call dist#ft#FTprogress_cweb()
                            
                            " Progress or assembly
    1              0.000012 au BufNewFile,BufRead *.i			call dist#ft#FTprogress_asm()
                            
                            " Progress or Pascal
    1              0.000009 au BufNewFile,BufRead *.p			call dist#ft#FTprogress_pascal()
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
    1              0.000009 au BufNewFile,BufRead *.psf			setf psf
    1              0.000020 au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
    1              0.000009 au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
    1              0.000009 au BufNewFile,BufRead *.pml			setf promela
                            
                            " Google protocol buffers
    1              0.000009 au BufNewFile,BufRead *.proto			setf proto
                            
                            " Protocols
    1              0.000012 au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyrex
    1              0.000013 au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python, Python Shell Startup Files
                            " Quixote (Python-based web framework)
    1              0.000038 au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl  setf python
                            
                            " Radiance
    1              0.000014 au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Ratpoison config/command files
    1              0.000016 au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
    1              0.000008 au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
    1              0.000016 au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
    1              0.000016 au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
    1              0.000009 au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rexx
    1              0.000066 au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R (Splus)
    1              0.000008 if has("fname_case")
    1              0.000018   au BufNewFile,BufRead *.s,*.S			setf r
                            else
                              au BufNewFile,BufRead *.s			setf r
    1              0.000002 endif
                            
                            " R Help file
    1              0.000008 if has("fname_case")
    1              0.000029   au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
                            else
                              au BufNewFile,BufRead *.rd			setf rhelp
    1              0.000002 endif
                            
                            " R noweb file
    1              0.000004 if has("fname_case")
    1              0.000023   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
                            else
                              au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
    1              0.000002 endif
                            
                            " R Markdown file
    1              0.000004 if has("fname_case")
    1              0.000025   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
                            else
                              au BufNewFile,BufRead *.rmd,*.smd			setf rmd
    1              0.000001 endif
                            
                            " R reStructuredText file
    1              0.000004 if has("fname_case")
    1              0.000023   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
                            else
                              au BufNewFile,BufRead *.rrst,*.srst			setf rrst
    1              0.000001 endif
                            
                            " Rexx, Rebol or R
    1              0.000012 au BufNewFile,BufRead *.r,*.R				call dist#ft#FTr()
                            
                            " Remind
    1              0.000021 au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
    1              0.000011 au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
    1              0.000010 au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
    1              0.000008 au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
    1              0.000008 au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
    1              0.000011 au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
    1              0.000008 au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " reStructuredText Documentation Format
    1              0.000008 au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
    1              0.000008 au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
    1              0.000015 au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
    1              0.000014 au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
    1              0.000010 au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " Rust
    1              0.000033 au BufNewFile,BufRead *.rs			setf rust
                            
                            " Rackup
    1              0.000010 au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
    1              0.000028 au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
    1              0.000019 au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
    1              0.000037 au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " S-lang (or shader language, or SmallLisp)
    1              0.000009 au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
    1              0.000013 au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
    1              0.000008 au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
    1              0.000026 au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
    1              0.000008 au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scala
    1              0.000014 au BufNewFile,BufRead *.scala			setf scala
                            
                            " SBT - Scala Build Tool
    1              0.000012 au BufNewFile,BufRead *.sbt			setf sbt
                            
                            " Scilab
    1              0.000014 au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " SCSS
    1              0.000009 au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
    1              0.000019 au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
    1              0.000012 au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
    1              0.000009 au BufNewFile,BufRead *.sed			setf sed
                            
                            " Sieve (RFC 3028)
    1              0.000008 au BufNewFile,BufRead *.siv			setf sieve
                            
                            " Sendmail
    1              0.000011 au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
    1              0.000009 au BufNewFile,BufRead *.mc			call dist#ft#McSetf()
                            
                            " Services
    1              0.000012 au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
    1              0.000010 au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
    1              0.000012 au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
    1              0.000011 au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
    1              0.000012 au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
    1              0.000035 au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
    1              0.000022 au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
    1              0.000010 au BufNewFile,BufRead catalog			setf catalog
    1              0.000012 au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
    1              0.000111 au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD* call dist#ft#SetFileTypeSH("bash")
    1              0.000029 au BufNewFile,BufRead .kshrc*,*.ksh call dist#ft#SetFileTypeSH("ksh")
    1              0.000032 au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
                            
                            " Shell script (Arch Linux) or PHP file (Drupal)
    1              0.000015 au BufNewFile,BufRead *.install
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   call dist#ft#SetFileTypeSH("bash") |
                            	\ endif
                            
                            " tcsh scripts
    1              0.000033 au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call dist#ft#SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
    1              0.000052 au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
                            
                            " Z-Shell script
    1              0.000037 au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
    1              0.000023 au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
    1              0.000009 au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
    1              0.000021 au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme
                            
                            " Screen RC
    1              0.000020 au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Simula
    1              0.000008 au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
    1              0.000018 au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
    1              0.000030 au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
    1              0.000023 au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
    1              0.000018 au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
    1              0.000011 au BufNewFile,BufRead .slrnrc			setf slrnrc
    1              0.000009 au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
    1              0.000019 au BufNewFile,BufRead *.st			setf st
    1              0.000014 au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
    1              0.000008 au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
    1              0.000013 au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
    1              0.000013 au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
    1              0.000015 au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
    1              0.000012 au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
    1              0.000012 au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
    1              0.000023 au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
    1              0.000011 au BufNewFile,BufRead *.rules			call dist#ft#FTRules()
                            
                            " Spec (Linux RPM)
    1              0.000009 au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
    1              0.000020 au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
    1              0.000009 au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
    1              0.000013 au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
    1              0.000013 au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
    1              0.000011 au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
    1              0.000027 au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
    1              0.000020 au BufNewFile,BufRead *.sql			call dist#ft#SQL()
                            
                            " SQLJ
    1              0.000010 au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
    1              0.000012 au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
    1              0.000032 au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig
                            
                            " OpenSSH server configuration
    1              0.000011 au BufNewFile,BufRead sshd_config		setf sshdconfig
                            
                            " Stata
    1              0.000025 au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata	setf stata
                            " Also *.class, but not when it's a Java bytecode file
    1              0.000015 au BufNewFile,BufRead *.class
                            	\ if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
                            
                            " SMCL
    1              0.000023 au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
    1              0.000012 au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
    1              0.000008 au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
    1              0.000011 au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Sysctl
    1              0.000025 au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Systemd unit files
    1              0.000026 au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}	setf systemd
                            
                            " Synopsys Design Constraints
    1              0.000009 au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
    1              0.000019 au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
    1              0.000019 au BufNewFile,BufRead *.svg			setf svg
                            
                            " Tads (or Nroff or Perl test file)
    1              0.000011 au BufNewFile,BufRead *.t
                            	\ if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
                            
                            " Tags
    1              0.000010 au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
    1              0.000010 au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
    1              0.000018 au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
    1              0.000011 au BufRead,BufNewFile *.task			setf taskedit
                            
                            " Tcl (JACL too)
    1              0.000029 au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
                            
                            " TealInfo
    1              0.000008 au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
    1              0.000009 au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Tera Term Language
    1              0.000009 au BufRead,BufNewFile *.ttl			setf teraterm
                            
                            " Terminfo
    1              0.000008 au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
    1              0.000027 au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
    1              0.000009 au BufNewFile,BufRead *.tex			call dist#ft#FTtex()
                            
                            " ConTeXt
    1              0.000019 au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
                            
                            " Texinfo
    1              0.000020 au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
    1              0.000021 au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
    1              0.000019 au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy
                            
                            " TF mud client
    1              0.000018 au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " tmux configuration
    1              0.000014 au BufNewFile,BufRead {.,}tmux*.conf		setf tmux
                            
                            " TPP - Text Presentation Program
    1              0.000018 au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
    1              0.000014 au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
    1              0.000010 au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
    1              0.000009 au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
    1              0.000013 au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
    1              0.000012 au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " TWIG files
    1              0.000009 au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " Motif UIT/UIL files
    1              0.000014 au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
    1              0.000018 au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
    1              0.000031 au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
    1              0.000015 au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
    1              0.000008 au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
    1              0.000013 au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
    1              0.000015 au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
    1              0.000016 au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
    1              0.000031 au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
    1              0.000021 au BufNewFile,BufRead */.init/*.conf,*/.init/*.override	       setf upstart
    1              0.000014 au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
    1              0.000015 au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
                            
                            " Vera
    1              0.000019 au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
    1              0.000009 au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
    1              0.000016 au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " SystemVerilog
    1              0.000012 au BufNewFile,BufRead *.sv,*.svh		setf systemverilog
                            
                            " VHDL
    1              0.000039 au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
    1              0.000015 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
    1              0.000033 au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
    1              0.000021 au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
    1              0.000028 au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
    1              0.000010 au BufNewFile,BufRead *.frm			call dist#ft#FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
    1              0.000009 au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
    1              0.000010 au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
    1              0.000009 au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Vroom (vim testing and executable documentation)
    1              0.000009 au BufNewFile,BufRead *.vroom			setf vroom
                            
                            " Webmacro
    1              0.000022 au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " WebAssembly
    1              0.000017 au BufNewFile,BufRead *.wast,*.wat		setf wast
                            
                            " Wget config
    1              0.000014 au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
    1              0.000008 au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
    1              0.000037 au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
    1              0.000009 au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WPL
    1              0.000007 au BufNewFile,BufRead *.wpl			setf xml
                            
                            " WvDial
    1              0.000021 au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
    1              0.000025 au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
    1              0.000012 au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
    1              0.000021 au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
    1              0.000010 au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
    1              0.000015 au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
    1              0.000010 au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
    1              0.000007 au BufEnter *.xpm2				setf xpm2
                            
                            " XFree86 config
    1              0.000025 au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
    1              0.000019 au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
    1              0.000021 au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
    1              0.000022 au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
    1              0.000007 au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
    1              0.000036 au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
    1              0.000023 au BufNewFile,BufRead *.msc,*.msf		setf xmath
    1              0.000010 au BufNewFile,BufRead *.ms
                            	\ if !dist#ft#FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
    1              0.000009 au BufNewFile,BufRead *.xml			call dist#ft#FTxml()
                            
                            " XMI (holding UML models) is also XML
    1              0.000009 au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based project config files
    1              0.000025 au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
    1              0.000012 au BufNewFile,BufRead *.ts,*.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
    1              0.000008 au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
    1              0.000014 au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
    1              0.000010 au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " Web Services Description Language (WSDL)
    1              0.000009 au BufNewFile,BufRead *.wsdl			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
    1              0.000008 au BufNewFile,BufRead *.xlf			setf xml
    1              0.000020 au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
    1              0.000009 au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
    1              0.000010 au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
    1              0.000028 au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
    1              0.000009 au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
    1              0.000013 au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
    1              0.000017 au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc
                            
                            " Yacc or racc
    1              0.000008 au BufNewFile,BufRead *.y			call dist#ft#FTy()
                            
                            " Yaml or Raml
    1              0.000036 au BufNewFile,BufRead *.yaml,*.yml,*.raml	setf yaml
                            
                            " yum conf (close enough to dosini)
    1              0.000015 au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " Zimbu
    1              0.000008 au BufNewFile,BufRead *.zu			setf zimbu
                            " Zimbu Templates
    1              0.000009 au BufNewFile,BufRead *.zut			setf zimbutempl
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
    1              0.000019 au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call dist#ft#FThtml()
                            "   zsql (zope sql method)
    1              0.000009 au BufNewFile,BufRead *.zsql			call dist#ft#SQL()
                            
                            " Z80 assembler asz80
    1              0.000009 au BufNewFile,BufRead *.z8a			setf z8a
                            
    1              0.000003 augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
    1              0.000027 if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
    1              0.000002 endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
    1              0.000003 augroup filetypedetect
    1              0.000012 au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
    1              0.000009 au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache style config files
    1              0.000022 au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*	call s:StarSetf('apachestyle')
                            
                            " More Apache config files
    1              0.000049 au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
    1              0.000051 au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
    1              0.000012 au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
    1              0.000020 au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
    1              0.000010 au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " Bazel build file
    1              0.000006 if !has("fname_case")
                              au BufNewFile,BufRead BUILD			setf bzl
    1              0.000002 endif
                            
                            " BIND zone
    1              0.000018 au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
    1              0.000035 au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
    1              0.000028 au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
    1              0.000025 au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
    1              0.000012 au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
    1              0.000010 au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
    1              0.000010 au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
    1              0.000035 au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
    1              0.000016 au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
    1              0.000014 au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " GTK RC
    1              0.000013 au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
    1              0.000019 au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
    1              0.000118 au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Kconfig
    1              0.000012 au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
    1              0.000011 au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
    1              0.000021 au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
    1              0.000015 au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
    1              0.000021 au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
    1              0.000033 au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
    1              0.000012 au BufNewFile,BufRead reportbug-*		call s:StarSetf('mail')
                            
                            " Modconf
    1              0.000022 au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
    1              0.000015 au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
    1              0.000024 au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
    1              0.000021 au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Neomutt setup file
    1              0.000018 au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*	call s:StarSetf('neomuttrc')
    1              0.000021 au BufNewFile,BufRead neomuttrc*,Neomuttrc*		call s:StarSetf('neomuttrc')
                            
                            " Nroff macros
    1              0.000010 au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " OpenBSD hostname.if
    1              0.000013 au BufNewFile,BufRead /etc/hostname.*		call s:StarSetf('config')
                            
                            " Pam conf
    1              0.000019 au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
    1              0.000018 au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
    1              0.000013 au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
    1              0.000010 au BufRead,BufNewFile *.rdf			call dist#ft#Redif()
                            
                            " Remind
    1              0.000029 au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " Vim script
    1              0.000010 au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
    1              0.000013 au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
    1              0.000030 au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
    1              0.000015 au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
    1              0.000018 au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
    1              0.000010 au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
    1              0.000011 au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
    1              0.000017 au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script
    1              0.000027 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
    1              0.000014 au BufNewFile,BufRead *.text,README		setf text
                            
                            " Help files match *.txt but should have a last line that is a modeline.
    1              0.000012 au BufNewFile,BufRead *.txt	
                            	\  if getline('$') !~ 'vim:.*ft=help'
                            	\|   setf text
                            	\| endif
                            
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
    1   0.002485   0.001362 runtime! ftdetect/*.vim
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
    1              0.000004 augroup END
                            
                            " Generic configuration file. Use FALLBACK, it's just guessing!
    1              0.000021 au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf FALLBACK conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
    1              0.000027 if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
    1              0.000002 endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
    1              0.000005 func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
    1              0.000014 let &cpo = s:cpo_save
    1              0.000007 unlet s:cpo_save

SCRIPT  /home/c5262761/configit/vim/ftdetect/pentadactyl.vim
Sourced 1 time
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
                            " Vim filetype detection file
                            " Language:    Pentadactyl configuration file
                            " Maintainer:  Doug Kearns <dougkearns@gmail.com>
                            " Version:     1.0.5-pm
                            
    1              0.000024 au BufNewFile,BufRead *pentadactylrc*,*.penta set filetype=pentadactyl

SCRIPT  /home/c5262761/configit/vim/modules/tmux.vim/ftdetect/tmux.vim
Sourced 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000020 autocmd BufNewFile,BufRead {.,}tmux*.conf* setfiletype tmux

SCRIPT  /home/c5262761/configit/vim/modules/vim-ledger/ftdetect/ledger.vim
Sourced 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000030 autocmd BufNewFile,BufRead *.ldg,*.ledger,*.journal setlocal filetype=ledger

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/ftdetect/gofiletype.vim
Sourced 1 time
Total time:   0.000442
 Self time:   0.000442

count  total (s)   self (s)
                            " vint: -ProhibitAutocmdWithNoGroup
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000023 let s:cpo_save = &cpo
    1              0.000013 set cpo&vim
                            
                            " Note: should not use augroup in ftdetect (see :help ftdetect)
    1              0.000013 au BufRead,BufNewFile *.go setfiletype go
    1              0.000010 au BufRead,BufNewFile *.s setfiletype asm
    1              0.000011 au BufRead,BufNewFile *.tmpl setfiletype gohtmltmpl
                            
                            " remove the autocommands for modsim3, and lprolog files so that their
                            " highlight groups, syntax, etc. will not be loaded. *.MOD is included, so
                            " that on case insensitive file systems the module2 autocmds will not be
                            " executed.
    1              0.000250 au! BufRead,BufNewFile *.mod,*.MOD
                            " Set the filetype if the first non-comment and non-blank line starts with
                            " 'module <path>'.
    1              0.000016 au BufRead,BufNewFile go.mod call s:gomod()
                            
    1              0.000008 fun! s:gomod()
                              for l:i in range(1, line('$'))
                                let l:l = getline(l:i)
                                if l:l ==# '' || l:l[:1] ==# '//'
                                  continue
                                endif
                            
                                if l:l =~# '^module .\+'
                                  setfiletype gomod
                                endif
                            
                                break
                              endfor
                            endfun
                            
                            " restore Vi compatibility settings
    1              0.000015 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/rust.vim/ftdetect/rust.vim
Sourced 1 time
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
                            " vint: -ProhibitAutocmdWithNoGroup
                            
    1              0.000014 autocmd BufRead,BufNewFile *.rs call s:set_rust_filetype()
                            
    1              0.000012 if has('patch-8.0.613')
    1              0.000014     autocmd BufRead,BufNewFile Cargo.toml setf FALLBACK cfg
    1              0.000002 endif
                            
    1              0.000006 function! s:set_rust_filetype() abort
                                if &filetype !=# 'rust'
                                    set filetype=rust
                                endif
                            endfunction
                            
                            " vim: set et sw=4 sts=4 ts=8:

SCRIPT  /home/c5262761/configit/vim/modules/vim-fugitive/ftdetect/fugitive.vim
Sourced 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000015 autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame

SCRIPT  /home/c5262761/configit/vim/modules/vim-puppet/ftdetect/puppet.vim
Sourced 1 time
Total time:   0.000258
 Self time:   0.000258

count  total (s)   self (s)
    1              0.000100 au! BufRead,BufNewFile *.pp setfiletype puppet
    1              0.000080 au! BufRead,BufNewFile Puppetfile setfiletype ruby

SCRIPT  /home/c5262761/configit/vim/modules/bats.vim/ftdetect/bats.vim
Sourced 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000027 au BufRead,BufNewFile *.bats        set filetype=sh

SCRIPT  /usr/share/vim/vim74/filetype.vim
Sourced 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2013 Aug 03
                            
                            " Listen very carefully, I will say this only once
    1              0.000010 if exists("did_load_filetypes")
    1              0.000004   finish
                            endif
                            let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            augroup filetypedetect
                            
                            " Ignored extensions
                            if exists("*fnameescape")
                            au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.mine,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
                            au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
                            au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
                            elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
                            endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
                            if !exists("g:ft_ignore_pat")
                              let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
                            endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
                            func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Abaqus or Trasys
                            au BufNewFile,BufRead *.inp			call s:Check_inp()
                            
                            func! s:Check_inp()
                              if getline(1) =~ '^\*'
                                setf abaqus
                              else
                                let n = 1
                                if line("$") > 500
                                  let nmax = 500
                                else
                                  let nmax = line("$")
                                endif
                                while n <= nmax
                                  if getline(n) =~? "^header surface data"
                            	setf trasys
                            	break
                                  endif
                                  let n = n + 1
                                endwhile
                              endif
                            endfunc
                            
                            " A-A-P recipe
                            au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
                            au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
                            au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
                            au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
                            au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
                            au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
                            au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
                            if has("vms")
                              au BufNewFile,BufRead *.gpr,*.ada_m,*.adc	setf ada
                            else
                              au BufNewFile,BufRead *.gpr			setf ada
                            endif
                            
                            " AHDL
                            au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AMPL
                            au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
                            au BufNewFile,BufRead build.xml			setf ant
                            
                            " Apache style config file
                            au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
                            
                            " Apache config file
                            au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            
                            " AppArmor
                            au BufNewFile,BufRead */etc/apparmor.d/*       setf apparmor
                            au BufNewFile,BufRead */etc/apparmor/profiles/*        setf apparmor
                            
                            " XA65 MOS6510 cross assembler
                            au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
                            au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
                            au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
                            au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
                            au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
                            au BufNewFile,BufRead apt.conf                 setf aptconf
                            au BufNewFile,BufRead */.aptitude/config       setf aptconf
                            au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
                            
                            " Arch Inventory file
                            au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
                            au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
                            au BufNewFile,BufRead *.asciidoc		setf asciidoc
                            
                            " ASN.1
                            au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
                            au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
                            au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
                            au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
                            au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call s:FTasm()
                            
                            " This function checks for the kind of assembly that is wanted by the user, or
                            " can be detected from the first five lines of the file.
                            func! s:FTasm()
                              " make sure b:asmsyntax exists
                              if !exists("b:asmsyntax")
                                let b:asmsyntax = ""
                              endif
                            
                              if b:asmsyntax == ""
                                call s:FTasmsyntax()
                              endif
                            
                              " if b:asmsyntax still isn't set, default to asmsyntax or GNU
                              if b:asmsyntax == ""
                                if exists("g:asmsyntax")
                                  let b:asmsyntax = g:asmsyntax
                                else
                                  let b:asmsyntax = "asm"
                                endif
                              endif
                            
                              exe "setf " . fnameescape(b:asmsyntax)
                            endfunc
                            
                            func! s:FTasmsyntax()
                              " see if file contains any asmsyntax=foo overrides. If so, change
                              " b:asmsyntax appropriately
                              let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
                            	\" ".getline(5)." "
                              let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
                              if match != ''
                                let b:asmsyntax = match
                              elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
                                let b:asmsyntax = "vmasm"
                              endif
                            endfunc
                            
                            " Macro (VAX)
                            au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
                            au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Autoit v3
                            au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
                            au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
                            au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
                            au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
                            au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
                            au BufNewFile,BufRead *.awk			setf awk
                            
                            " B
                            au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
                            au BufNewFile,BufRead *.bas			call s:FTVB("basic")
                            
                            " Check if one of the first five lines contains "VB_Name".  In that case it is
                            " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
                            func! s:FTVB(alt)
                              if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
                                setf vb
                              else
                                exe "setf " . a:alt
                              endif
                            endfunc
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
                            au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
                            au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
                            au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
                            au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
                            au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
                            au BufNewFile,BufRead *.btm			call s:FTbtm()
                            func! s:FTbtm()
                              if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
                                setf dosbatch
                              else
                                setf btm
                              endif
                            endfunc
                            
                            " BC calculator
                            au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
                            au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " BibTeX bibliography database file
                            au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
                            au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
                            au BufNewFile,BufRead named.conf,rndc.conf	setf named
                            
                            " BIND zone
                            au BufNewFile,BufRead named.root		setf bindzone
                            au BufNewFile,BufRead *.db			call s:BindzoneCheck('')
                            
                            func! s:BindzoneCheck(default)
                              if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setf bindzone
                              elseif a:default != ''
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            " Blank
                            au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
                            au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " C or lpc
                            au BufNewFile,BufRead *.c			call s:FTlpc()
                            
                            func! s:FTlpc()
                              if exists("g:lpc_syntax_for_c")
                                let lnum = 1
                                while lnum <= 12
                                  if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
                            	setf lpc
                            	return
                                  endif
                                  let lnum = lnum + 1
                                endwhile
                              endif
                              setf c
                            endfunc
                            
                            " Calendar
                            au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
                            au BufNewFile,BufRead *.cs			setf cs
                            
                            " CSDL
                            au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
                            au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
                            au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
                            au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
                            au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
                            au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
                            au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
                            au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
                            au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
                            au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
                            au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
                            au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
                            au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
                            if has("fname_case")
                              au BufNewFile,BufRead *.C,*.H setf cpp
                            endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
                            au BufNewFile,BufRead *.h			call s:FTheader()
                            
                            func! s:FTheader()
                              if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
                                if exists("g:c_syntax_for_h")
                                  setf objc
                                else
                                  setf objcpp
                                endif
                              elseif exists("g:c_syntax_for_h")
                                setf c
                              elseif exists("g:ch_syntax_for_h")
                                setf ch
                              else
                                setf cpp
                              endif
                            endfunc
                            
                            " Ch (CHscript)
                            au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
                            au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
                            au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
                            au BufNewFile,BufRead *.con			setf cterm
                            
                            " SuSE .changes file
                            au BufNewFile,BufRead *.changes			setf changes
                            
                            " Changelog
                            au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
                            					\	setf debchangelog
                            
                            au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
                            au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
                            au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
                            au BufNewFile,BufRead *.ch			call s:FTchange()
                            
                            " This function checks if one of the first ten lines start with a '@'.  In
                            " that case it is probably a change file.
                            " If the first line starts with # or ! it's probably a ch file.
                            " If a line has "main", "include", "//" ir "/*" it's probably ch.
                            " Otherwise CHILL is assumed.
                            func! s:FTchange()
                              let lnum = 1
                              while lnum <= 10
                                if getline(lnum)[0] == '@'
                                  setf change
                                  return
                                endif
                                if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
                                  setf ch
                                  return
                                endif
                                if getline(lnum) =~ "MODULE"
                                  setf chill
                                  return
                                endif
                                if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
                                  setf ch
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                              setf chill
                            endfunc
                            
                            " ChordPro
                            au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
                            au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
                            au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
                            au BufNewFile,BufRead *.ent			call s:FTent()
                            
                            func! s:FTent()
                              " This function checks for valid cl syntax in the first five lines.
                              " Look for either an opening comment, '#', or a block start, '{".
                              " If not found, assume SGML.
                              let lnum = 1
                              while lnum < 6
                                let line = getline(lnum)
                                if line =~ '^\s*[#{]'
                                  setf cl
                                  return
                                elseif line !~ '^\s*$'
                                  " Not a blank line, not a comment, and not a block start,
                                  " so doesn't look like valid cl code.
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf dtd
                            endfunc
                            
                            " Clipper (or FoxPro; could also be eviews)
                            au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Clojure
                            au BufNewFile,BufRead *.clj,*.cljs		setf clojure
                            
                            " Cmake
                            au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
                            au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
                            au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
                            au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
                            au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
                            au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
                            au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
                            au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA  Cumpute Unified Device Architecture
                            au BufNewFile,BufRead *.cu			setf cuda
                            
                            " WildPackets EtherPeek Decoder
                            au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
                            au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
                            au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Lynx config files
                            au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Quake
                            au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
                            au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
                            au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
                            au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
                            au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
                            au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
                            au BufNewFile,BufRead *.pld			setf cupl
                            au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Debian Control
                            au BufNewFile,BufRead */debian/control		setf debcontrol
                            au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Sources.list
                            au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
                            au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
                            au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
                            au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
                            au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
                            au BufNewFile,BufRead *.d			call s:DtraceCheck()
                            
                            func! s:DtraceCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if match(lines, '^module\>\|^import\>') > -1
                                " D files often start with a module and/or import statement.
                                setf d
                              elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
                                setf dtrace
                              else
                                setf d
                              endif
                            endfunc
                            
                            " Desktop files
                            au BufNewFile,BufRead *.desktop,.directory	setf desktop
                            
                            " Dict config
                            au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
                            au BufNewFile,BufRead dictd.conf		setf dictdconf
                            
                            " Diff files
                            au BufNewFile,BufRead *.diff,*.rej,*.patch	setf diff
                            
                            " Dircolors
                            au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
                            au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
                            au BufNewFile,BufRead *.com			call s:BindzoneCheck('dcl')
                            
                            " DOT
                            au BufNewFile,BufRead *.dot			setf dot
                            
                            " Dylan - lid files
                            au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
                            au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
                            au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
                            au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
                            au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
                            au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl
                            au BufNewFile,BufRead *.dsl			setf dsl
                            
                            " DTD (Document Type Definition for XML)
                            au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
                            au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo)
                            au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)	setf edif
                            
                            " Embedix Component Description
                            au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman
                            au BufNewFile,BufRead *.e,*.E			call s:FTe()
                            
                            " Elinks configuration
                            au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
                            
                            func! s:FTe()
                              let n = 1
                              while n < 100 && n < line("$")
                                if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
                                  setf specman
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf eiffel
                            endfunc
                            
                            " ERicsson LANGuage; Yaws is erlang too
                            au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm Filter Rules file
                            au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
                            au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
                            au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
                            au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
                            au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
                            au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
                            au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
                            au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
                            au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
                            au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
                            au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fetchmail RC file
                            au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
                            au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
                            au BufNewFile,BufRead auto.master		setf conf
                            au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
                            au BufNewFile,BufRead *.fs,*.ft			setf forth
                            
                            " Reva Forth
                            au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
                            if has("fname_case")
                              au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
                            endif
                            au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
                            au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
                            au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " GDB command files
                            au BufNewFile,BufRead .gdbinit			setf gdb
                            
                            " GDMO
                            au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
                            au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Git
                            au BufNewFile,BufRead *.git/COMMIT_EDITMSG	setf gitcommit
                            au BufNewFile,BufRead *.git/MERGE_MSG		setf gitcommit
                            au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
                            au BufNewFile,BufRead *.git/modules/*/COMMIT_EDITMSG setf gitcommit
                            au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
                            au BufNewFile,BufRead */.config/git/config	setf gitconfig
                            au BufNewFile,BufRead git-rebase-todo		setf gitrebase
                            au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
                            au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
                            au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
                            au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
                            au BufNewFile,BufRead */.gnupg/options		setf gpg
                            au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
                            au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
                            
                            " gnash(1) configuration files
                            au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
                            au BufNewFile,BufRead gitolite.conf		setf gitolite
                            au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
                            au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Gnuplot scripts
                            au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " GrADS scripts
                            au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
                            au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
                            au BufNewFile,BufRead *.groovy			setf groovy
                            
                            " GNU Server Pages
                            au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
                            au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
                            au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
                            au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
                            au BufNewFile,BufRead *.hsc,*.hsm		setf hamster
                            
                            " Haskell
                            au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
                            au BufNewFile,BufRead *.lhs			setf lhaskell
                            au BufNewFile,BufRead *.chs			setf chaskell
                            
                            " Haste
                            au BufNewFile,BufRead *.ht			setf haste
                            au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
                            au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
                            au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Tilde (must be before HTML)
                            au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
                            au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
                            
                            " Distinguish between HTML, XHTML and Django
                            func! s:FThtml()
                              let n = 1
                              while n < 10 && n < line("$")
                                if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
                                if getline(n) =~ '{%\s*\(extends\|block\)\>'
                                  setf htmldjango
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf html
                            endfunc
                            
                            " HTML with Ruby - eRuby
                            au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
                            au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " HTML Cheetah template
                            au BufNewFile,BufRead *.tmpl			setf htmlcheetah
                            
                            " Host config
                            au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
                            au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
                            au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
                            au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " Icon
                            au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
                            au BufNewFile,BufRead *.idl			call s:FTidl()
                            
                            " Distinguish between standard IDL and MS-IDL
                            func! s:FTidl()
                              let n = 1
                              while n < 50 && n < line("$")
                                if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
                                  setf msidl
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf idl
                            endfunc
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
                            au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
                            au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
                            au BufNewFile,BufRead .indent.pro		setf indent
                            au BufNewFile,BufRead indent.pro		call s:ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
                            au BufNewFile,BufRead *.pro			call s:ProtoCheck('idlang')
                            
                            " Distinguish between "default" and Cproto prototype file. */
                            func! s:ProtoCheck(default)
                              " Cproto files have a comment in the first line and a function prototype in
                              " the second line, it always ends in ";".  Indent files may also have
                              " comments, thus we can't match comments to see the difference.
                              " IDL files can have a single ';' in the second line, require at least one
                              " chacter before the ';'.
                              if getline(2) =~ '.;$'
                                setf cpp
                              else
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            
                            " Indent RC
                            au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
                            au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
                            au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
                            au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
                            au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c 	setf upstreamlog
                            au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
                            au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
                            au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog
                            
                            " Ipfilter
                            au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
                            au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
                            au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
                            au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
                            au BufNewFile,BufRead *.iss			setf iss
                            
                            " JAL
                            au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
                            au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
                            au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
                            au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript
                            au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.json   setf javascript
                            
                            " Java Server Pages
                            au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
                            au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
                            au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Jess
                            au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
                            au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
                            au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " Kixtart
                            au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
                            au BufNewFile,BufRead *.k			setf kwt
                            
                            " KDE script
                            au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
                            au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
                            au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
                            au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
                            au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
                            au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
                            au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
                            au BufNewFile,BufRead *.ld			setf ld
                            
                            " Lex
                            au BufNewFile,BufRead *.lex,*.l			setf lex
                            
                            " Libao
                            au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
                            au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
                            au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
                            au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
                            au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
                            if has("fname_case")
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
                            else
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
                            endif
                            
                            " SBCL implementation of Common Lisp
                            au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
                            au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
                            au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
                            au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
                            au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
                            au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
                            au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
                            au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
                            au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
                            au BufNewFile,BufRead *.lua			setf lua
                            
                            " Linden Scripting Language (Second Life)
                            au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
                            au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
                            au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
                            au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn)
                            au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
                            au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
                            au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
                            au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
                            au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
                            au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
                            au BufNewFile,BufRead *.man			setf man
                            
                            " Man config
                            au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
                            au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
                            au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
                            au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,README.md  setf markdown
                            
                            " Mason
                            au BufNewFile,BufRead *.mason,*.mhtml		setf mason
                            
                            " Matlab or Objective C
                            au BufNewFile,BufRead *.m			call s:FTm()
                            
                            func! s:FTm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\|//\)'
                                  setf objc
                                  return
                                endif
                                if line =~ '^\s*%'
                                  setf matlab
                                  return
                                endif
                                if line =~ '^\s*(\*'
                                  setf mma
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              if exists("g:filetype_m")
                                exe "setf " . g:filetype_m
                              else
                                setf matlab
                              endif
                            endfunc
                            
                            " Mathematica notebook
                            au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
                            au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
                            au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
                            au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Messages (logs mostly)
                            au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
                            au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
                            au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
                            au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MMIX or VMS makefile
                            au BufNewFile,BufRead *.mms			call s:FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
                            au BufNewFile,BufRead *.mmp			setf mmp
                            
                            func! s:FTmms()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
                                  setf mmix
                                  return
                                endif
                                if line =~ '^\s*#'
                                  setf make
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf mmix
                            endfunc
                            
                            
                            " Modsim III (or LambdaProlog)
                            au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula 2
                            au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.md,*.mi setf modula2
                            
                            " Modula 3 (.m3, .i3, .mg, .ig)
                            au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
                            au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
                            au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
                            au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " Mplayer config
                            au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Moterola S record
                            au BufNewFile,BufRead *.s19,*.s28,*.s37		setf srec
                            
                            " Mrxvtrc
                            au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
                            au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
                            au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
                            au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " M$ Resource files
                            au BufNewFile,BufRead *.rc,*.rch		setf rc
                            
                            " MuPAD source
                            au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
                            au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
                            au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " Nano
                            au BufNewFile,BufRead */etc/nanorc,.nanorc	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
                            au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Netrc
                            au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Ninja file
                            au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Novell netware batch files
                            au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
                            au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
                            au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
                            au BufNewFile,BufRead *.[1-9]			call s:FTnroff()
                            
                            " This function checks if one of the first five lines start with a dot.  In
                            " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
                            func! s:FTnroff()
                              if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
                                setf nroff
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Nroff or Objective C++
                            au BufNewFile,BufRead *.mm			call s:FTmm()
                            
                            func! s:FTmm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\)'
                                  setf objcpp
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf nroff
                            endfunc
                            
                            " Not Quite C
                            au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSIS
                            au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCAML
                            au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml
                            
                            " Occam
                            au BufNewFile,BufRead *.occ			setf occam
                            
                            " Omnimark
                            au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OpenROAD
                            au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
                            au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
                            au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
                            au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pam conf
                            au BufNewFile,BufRead */etc/pam.conf		setf pamconf
                            
                            " PApp
                            au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
                            au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p)
                            au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Delphi project file
                            au BufNewFile,BufRead *.dpr			setf pascal
                            
                            " PDF
                            au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " Perl
                            if has("fname_case")
                              au BufNewFile,BufRead *.pl,*.PL		call s:FTpl()
                            else
                              au BufNewFile,BufRead *.pl			call s:FTpl()
                            endif
                            au BufNewFile,BufRead *.plx,*.al		setf perl
                            au BufNewFile,BufRead *.p6,*.pm6		setf perl6
                            
                            func! s:FTpl()
                              if exists("g:filetype_pl")
                                exe "setf " . g:filetype_pl
                              else
                                " recognize Prolog by specific text in the first non-empty line
                                " require a blank after the '%' because Perl uses "%list" and "%translate"
                                let l = getline(nextnonblank(1))
                                if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
                                  setf prolog
                                else
                                  setf perl
                                endif
                              endif
                            endfunc
                            
                            " Perl, XPM or XPM2
                            au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
                            au BufNewFile,BufRead *.pod			setf pod
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
                            au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " Pike
                            au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
                            
                            " Pinfo config
                            au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
                            au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
                            au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " PL/1, PL/I
                            au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
                            au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
                            au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
                            au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
                            au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
                            au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
                            au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
                            au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
                            au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
                            au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, PHP or assembly
                            au BufNewFile,BufRead *.inc			call s:FTinc()
                            
                            func! s:FTinc()
                              if exists("g:filetype_inc")
                                exe "setf " . g:filetype_inc
                              else
                                let lines = getline(1).getline(2).getline(3)
                                if lines =~? "perlscript"
                                  setf aspperl
                                elseif lines =~ "<%"
                                  setf aspvbs
                                elseif lines =~ "<?"
                                  setf php
                                else
                                  call s:FTasmsyntax()
                                  if exists("b:asmsyntax")
                            	exe "setf " . fnameescape(b:asmsyntax)
                                  else
                            	setf pov
                                  endif
                                endif
                              endif
                            endfunc
                            
                            " Printcap and Termcap
                            au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
                            au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTRL
                            "au BufNewFile,BufRead *.g			setf antrl
                            au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
                            au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
                            au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
                            au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
                            au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
                            au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
                            au BufNewFile,BufRead *.w			call s:FTprogress_cweb()
                            
                            func! s:FTprogress_cweb()
                              if exists("g:filetype_w")
                                exe "setf " . g:filetype_w
                                return
                              endif
                              if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
                                setf progress
                              else
                                setf cweb
                              endif
                            endfunc
                            
                            " Progress or assembly
                            au BufNewFile,BufRead *.i			call s:FTprogress_asm()
                            
                            func! s:FTprogress_asm()
                              if exists("g:filetype_i")
                                exe "setf " . g:filetype_i
                                return
                              endif
                              " This function checks for an assembly comment the first ten lines.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*;' || line =~ '^\*'
                                  call s:FTasm()
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid assembly code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            " Progress or Pascal
                            au BufNewFile,BufRead *.p			call s:FTprogress_pascal()
                            
                            func! s:FTprogress_pascal()
                              if exists("g:filetype_p")
                                exe "setf " . g:filetype_p
                                return
                              endif
                              " This function checks for valid Pascal syntax in the first ten lines.
                              " Look for either an opening comment or a program start.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*\(program\|unit\|procedure\|function\|const\|type\|var\)\>'
                            	\ || line =~ '^\s*{' || line =~ '^\s*(\*'
                                  setf pascal
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid Pascal code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
                            au BufNewFile,BufRead *.psf			setf psf
                            au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
                            au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
                            au BufNewFile,BufRead *.pml			setf promela
                            
                            " Google protocol buffers
                            au BufNewFile,BufRead *.proto			setf proto
                            
                            " Protocols
                            au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyrex
                            au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python
                            au BufNewFile,BufRead *.py,*.pyw		setf python
                            
                            " Quixote (Python-based web framework)
                            au BufNewFile,BufRead *.ptl			setf python
                            
                            " Radiance
                            au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Ratpoison config/command files
                            au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
                            au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
                            au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
                            au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
                            au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rexx
                            au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R (Splus)
                            if has("fname_case")
                              au BufNewFile,BufRead *.s,*.S			setf r
                            else
                              au BufNewFile,BufRead *.s			setf r
                            endif
                            
                            " R Help file
                            if has("fname_case")
                              au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
                            else
                              au BufNewFile,BufRead *.rd			setf rhelp
                            endif
                            
                            " R noweb file
                            if has("fname_case")
                              au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
                            else
                              au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
                            endif
                            
                            " Rexx, Rebol or R
                            au BufNewFile,BufRead *.r,*.R			call s:FTr()
                            
                            func! s:FTr()
                              let max = line("$") > 50 ? 50 : line("$")
                            
                              for n in range(1, max)
                                " Rebol is easy to recognize, check for that first
                                if getline(n) =~? '\<REBOL\>'
                                  setf rebol
                                  return
                                endif
                              endfor
                            
                              for n in range(1, max)
                                " R has # comments
                                if getline(n) =~ '^\s*#'
                                  setf r
                                  return
                                endif
                                " Rexx has /* comments */
                                if getline(n) =~ '^\s*/\*'
                                  setf rexx
                                  return
                                endif
                              endfor
                            
                              " Nothing recognized, use user default or assume Rexx
                              if exists("g:filetype_r")
                                exe "setf " . g:filetype_r
                              else
                                " Rexx used to be the default, but R appears to be much more popular.
                                setf r
                              endif
                            endfunc
                            
                            " Remind
                            au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
                            au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
                            au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
                            au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
                            au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
                            au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
                            au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " reStructuredText Documentation Format
                            au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
                            au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
                            au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
                            au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
                            au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " Rackup
                            au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
                            au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
                            au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
                            au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " S-lang (or shader language, or SmallLisp)
                            au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
                            au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
                            au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
                            au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
                            au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scilab
                            au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " SCSS
                            au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
                            au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
                            au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
                            au BufNewFile,BufRead *.sed			setf sed
                            
                            " Sieve (RFC 3028)
                            au BufNewFile,BufRead *.siv			setf sieve
                            
                            " Sendmail
                            au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
                            au BufNewFile,BufRead *.mc			call s:McSetf()
                            
                            func! s:McSetf()
                              " Rely on the file to start with a comment.
                              " MS message text files use ';', Sendmail files use '#' or 'dnl'
                              for lnum in range(1, min([line("$"), 20]))
                                let line = getline(lnum)
                                if line =~ '^\s*\(#\|dnl\)'
                                  setf m4  " Sendmail .mc file
                                  return
                                elseif line =~ '^\s*;'
                                  setf msmessages  " MS Message text file
                                  return
                                endif
                              endfor
                              setf m4  " Default: Sendmail .mc file
                            endfunc
                            
                            " Services
                            au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
                            au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
                            au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
                            au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
                            au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
                            au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
                            au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
                            au BufNewFile,BufRead catalog			setf catalog
                            au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds are actually bash scripts
                            au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")
                            au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
                            au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
                            
                            " Also called from scripts.vim.
                            func! SetFileTypeSH(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              if a:name =~ '\<csh\>'
                                " Some .sh scripts contain #!/bin/csh.
                                call SetFileTypeShell("csh")
                                return
                              elseif a:name =~ '\<tcsh\>'
                                " Some .sh scripts contain #!/bin/tcsh.
                                call SetFileTypeShell("tcsh")
                                return
                              elseif a:name =~ '\<zsh\>'
                                " Some .sh scripts contain #!/bin/zsh.
                                call SetFileTypeShell("zsh")
                                return
                              elseif a:name =~ '\<ksh\>'
                                let b:is_kornshell = 1
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
                                let b:is_bash = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif a:name =~ '\<sh\>'
                                let b:is_sh = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                              endif
                              call SetFileTypeShell("sh")
                            endfunc
                            
                            " For shell-like file types, check for an "exec" command hidden in a comment,
                            " as used for Tcl.
                            " Also called from scripts.vim, thus can't be local to this script.
                            func! SetFileTypeShell(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              let l = 2
                              while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
                                " Skip empty and comment lines.
                                let l = l + 1
                              endwhile
                              if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
                                " Found an "exec" line after a comment with continuation
                                let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
                                if n =~ '\<tclsh\|\<wish'
                                  setf tcl
                                  return
                                endif
                              endif
                              exe "setf " . a:name
                            endfunc
                            
                            " tcsh scripts
                            au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
                            au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
                            
                            func! s:CSH()
                              if exists("g:filetype_csh")
                                call SetFileTypeShell(g:filetype_csh)
                              elseif &shell =~ "tcsh"
                                call SetFileTypeShell("tcsh")
                              else
                                call SetFileTypeShell("csh")
                              endif
                            endfunc
                            
                            " Z-Shell script
                            au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
                            au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
                            au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
                            au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme
                            
                            " Screen RC
                            au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Simula
                            au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
                            au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
                            au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
                            au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
                            au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
                            au BufNewFile,BufRead .slrnrc			setf slrnrc
                            au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
                            au BufNewFile,BufRead *.st			setf st
                            au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
                            au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
                            au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
                            au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
                            au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
                            au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
                            au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
                            au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
                            au BufNewFile,BufRead *.rules			call s:FTRules()
                            
                            let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
                            func! s:FTRules()
                              let path = expand('<amatch>:p')
                              if path =~ '^/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
                                setf udevrules
                                return
                              endif
                              if path =~ '^/etc/ufw/'
                                setf conf  " Better than hog
                                return
                              endif
                              try
                                let config_lines = readfile('/etc/udev/udev.conf')
                              catch /^Vim\%((\a\+)\)\=:E484/
                                setf hog
                                return
                              endtry
                              let dir = expand('<amatch>:p:h')
                              for line in config_lines
                                if line =~ s:ft_rules_udev_rules_pattern
                                  let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
                                  if dir == udev_rules
                                    setf udevrules
                                  endif
                                  break
                                endif
                              endfor
                              setf hog
                            endfunc
                            
                            
                            " Spec (Linux RPM)
                            au BufNewFile,BufRead *.spec,*.spec.in		setf spec
                            
                            " Speedup (AspenTech plant simulator)
                            au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
                            au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
                            au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
                            au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
                            au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
                            au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
                            au BufNewFile,BufRead *.sql			call s:SQL()
                            
                            func! s:SQL()
                              if exists("g:filetype_sql")
                                exe "setf " . g:filetype_sql
                              else
                                setf sql
                              endif
                            endfunc
                            
                            " SQLJ
                            au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
                            au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
                            au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig
                            
                            " OpenSSH server configuration
                            au BufNewFile,BufRead sshd_config		setf sshdconfig
                            
                            " Stata
                            au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
                            
                            " SMCL
                            au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
                            au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
                            au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
                            au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Sysctl
                            au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Synopsys Design Constraints
                            au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
                            au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
                            au BufNewFile,BufRead *.svg			setf svg
                            
                            " If the file has an extension of 't' and is in a directory 't' then it is
                            " almost certainly a Perl test file.
                            " If the first line starts with '#' and contains 'perl' it's probably a Perl
                            " file.
                            " (Slow test) If a file contains a 'use' statement then it is almost certainly
                            " a Perl file.
                            func! s:FTperl()
                              if expand("%:e") == 't' && expand("%:p:h:t") == 't'
                                setf perl
                                return 1
                              endif
                              if getline(1)[0] == '#' && getline(1) =~ 'perl'
                                setf perl
                                return 1
                              endif
                              if search('^use\s\s*\k', 'nc', 30)
                                setf perl
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Tads (or Nroff or Perl test file)
                            au BufNewFile,BufRead *.t
                            	\ if !s:FTnroff() && !s:FTperl() | setf tads | endif
                            
                            " Tags
                            au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
                            au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
                            au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
                            au BufRead,BufNewFile *.task                    setf taskedit
                            
                            " Tcl (JACL too)
                            au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
                            
                            " TealInfo
                            au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
                            au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Terminfo
                            au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
                            au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
                            au BufNewFile,BufRead *.tex			call s:FTtex()
                            
                            " Choose context, plaintex, or tex (LaTeX) based on these rules:
                            " 1. Check the first line of the file for "%&<format>".
                            " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
                            " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
                            func! s:FTtex()
                              let firstline = getline(1)
                              if firstline =~ '^%&\s*\a\+'
                                let format = tolower(matchstr(firstline, '\a\+'))
                                let format = substitute(format, 'pdf', '', '')
                                if format == 'tex'
                                  let format = 'plain'
                                endif
                              else
                                " Default value, may be changed later:
                                let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
                                " Save position, go to the top of the file, find first non-comment line.
                                let save_cursor = getpos('.')
                                call cursor(1,1)
                                let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
                                if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
                                  let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>'
                                  let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
                                  let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
                            			      \ 'cnp', firstNC + 1000)
                                  if kwline == 1	" lpat matched
                            	let format = 'latex'
                                  elseif kwline == 2	" cpat matched
                            	let format = 'context'
                                  endif		" If neither matched, keep default set above.
                                  " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
                                  " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
                                  " if cline > 0
                                  "   let format = 'context'
                                  " endif
                                  " if lline > 0 && (cline == 0 || cline > lline)
                                  "   let format = 'tex'
                                  " endif
                                endif " firstNC
                                call setpos('.', save_cursor)
                              endif " firstline =~ '^%&\s*\a\+'
                            
                              " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
                              if format == 'plain'
                                setf plaintex
                              elseif format == 'context'
                                setf context
                              else " probably LaTeX
                                setf tex
                              endif
                              return
                            endfunc
                            
                            " ConTeXt
                            au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
                            
                            " Texinfo
                            au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
                            au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
                            au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy
                            
                            " TF mud client
                            au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " TPP - Text Presentation Program
                            au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
                            au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
                            au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
                            au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
                            au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
                            au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " TWIG files
                            au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " Motif UIT/UIL files
                            au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
                            au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
                            au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
                            au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
                            au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
                            au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
                            au BufNewFile,BufRead */usr/share/upstart/*.conf               setf upstart
                            au BufNewFile,BufRead */usr/share/upstart/*.override           setf upstart
                            au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
                            au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
                            au BufNewFile,BufRead */.config/upstart/*.conf                 setf upstart
                            au BufNewFile,BufRead */.config/upstart/*.override             setf upstart
                            
                            " Vera
                            au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
                            au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
                            au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " VHDL
                            au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
                            au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
                            au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
                            au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
                            au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
                            au BufNewFile,BufRead *.frm			call s:FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
                            au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
                            au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
                            au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Webmacro
                            au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
                            au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
                            au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
                            au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
                            au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WvDial
                            au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
                            au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
                            au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
                            au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
                            au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
                            au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
                            au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
                            au BufEnter *.xpm2				setf xpm2
                            
                            " XFree86 config
                            au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
                            au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
                            au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
                            au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
                            au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
                            au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
                            au BufNewFile,BufRead *.msc,*.msf		setf xmath
                            au BufNewFile,BufRead *.ms
                            	\ if !s:FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
                            au BufNewFile,BufRead *.xml			call s:FTxml()
                            
                            func! s:FTxml()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                " DocBook 4 or DocBook 5.
                                let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
                                let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
                                if is_docbook4 || is_docbook5
                                  let b:docbk_type = "xml"
                                  if is_docbook5
                            	let b:docbk_ver = 5
                                  else
                            	let b:docbk_ver = 4
                                  endif
                                  setf docbk
                                  return
                                endif
                                if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
                                  setf xbl
                                  return
                                endif
                                let n += 1
                              endwhile
                              setf xml
                            endfunc
                            
                            " XMI (holding UML models) is also XML
                            au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based project config files
                            au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
                            au BufNewFile,BufRead *.ts,*.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
                            au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
                            au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
                            au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
                            au BufNewFile,BufRead *.xlf			setf xml
                            au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
                            au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
                            au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
                            au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
                            au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
                            au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
                            au BufNewFile,BufRead *.yy			setf yacc
                            
                            " Yacc or racc
                            au BufNewFile,BufRead *.y			call s:FTy()
                            
                            func! s:FTy()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                if line =~ '^\s*%'
                                  setf yacc
                                  return
                                endif
                                if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
                                  setf racc
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf yacc
                            endfunc
                            
                            
                            " Yaml
                            au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " yum conf (close enough to dosini)
                            au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " Zimbu
                            au BufNewFile,BufRead *.zu			setf zimbu
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
                            au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call s:FThtml()
                            "   zsql (zope sql method)
                            au BufNewFile,BufRead *.zsql			call s:SQL()
                            
                            " Z80 assembler asz80
                            au BufNewFile,BufRead *.z8a			setf z8a
                            
                            augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
                            if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
                            endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
                            augroup filetypedetect
                            au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
                            au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache config files
                            au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
                            au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
                            au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
                            au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
                            au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " BIND zone
                            au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
                            au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
                            au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
                            au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
                            au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
                            au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
                            au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
                            au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
                            au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
                            au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " GTK RC
                            au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
                            au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
                            au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Kconfig
                            au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
                            au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
                            au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
                            au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
                            au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
                            au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
                            " Modconf
                            au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
                            au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
                            au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
                            au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Nroff macros
                            au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " Pam conf
                            au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
                            au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
                            au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
                            au BufRead,BufNewFile *.rdf			call s:Redif()
                            func! s:Redif()
                              let lnum = 1
                              while lnum <= 5 && lnum < line('$')
                                if getline(lnum) =~ "^\ctemplate-type:"
                                  setf redif
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                            endfunc
                            
                            " Remind
                            au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " Vim script
                            au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
                            au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
                            au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
                            au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
                            au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
                            au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
                            au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
                            au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script
                            au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
                            au BufNewFile,BufRead *.txt,*.text		setf text
                            
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
                            runtime! ftdetect/*.vim
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
                            augroup END
                            
                            " Generic configuration file (check this last, it's just guessing!)
                            au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
                            if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
                            endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
                            func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " FreeMarker templates
                            au BufNewFile,BufRead *.ftl     setf ftl
                            

SCRIPT  /home/c5262761/local/share/vim/vim81/ftplugin.vim
Sourced 1 time
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    1              0.000009 if exists("did_load_ftplugin")
                              finish
    1              0.000002 endif
    1              0.000007 let did_load_ftplugin = 1
                            
    1              0.000004 augroup filetypeplugin
    1              0.000010   au FileType * call s:LoadFTPlugin()
                            
    1              0.000016   func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                            	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000005 augroup END

SCRIPT  /usr/share/vim/vim74/ftplugin.vim
Sourced 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    1              0.000009 if exists("did_load_ftplugin")
    1              0.000003   finish
                            endif
                            let did_load_ftplugin = 1
                            
                            augroup filetypeplugin
                              au FileType * call s:LoadFTPlugin()
                            
                              func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                            	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                  endfor
                                endif
                              endfunc
                            augroup END

SCRIPT  /home/c5262761/local/share/vim/vim81/indent.vim
Sourced 1 time
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    1              0.000009 if exists("did_indent_on")
                              finish
    1              0.000001 endif
    1              0.000006 let did_indent_on = 1
                            
    1              0.000002 augroup filetypeindent
    1              0.000021   au FileType * call s:LoadIndent()
    1              0.000006   func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                            	exe 'runtime! indent/' . name . '.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000005 augroup END

SCRIPT  /usr/share/vim/vim74/indent.vim
Sourced 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    1              0.000009 if exists("did_indent_on")
    1              0.000003   finish
                            endif
                            let did_indent_on = 1
                            
                            augroup filetypeindent
                              au FileType * call s:LoadIndent()
                              func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                            	exe 'runtime! indent/' . name . '.vim'
                                  endfor
                                endif
                              endfunc
                            augroup END

SCRIPT  /home/c5262761/local/share/vim/vim81/syntax/syntax.vim
Sourced 1 time
Total time:   0.002602
 Self time:   0.000430

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 04
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000027 if !has("syntax")
                              finish
    1              0.000003 endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000010 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
    1              0.000001 endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1   0.002469   0.000297 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000006 if exists("did_load_filetypes")
    1              0.000004   let s:did_ft = 1
                            else
                              filetype on
                              let s:did_ft = 0
    1              0.000001 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected.
    1              0.000002 augroup syntaxset
    1              0.000008   au! FileType *	exe "set syntax=" . expand("<amatch>")
    1              0.000002 augroup END
                            
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1              0.000003 doautoall syntaxset FileType
    1              0.000002 if !s:did_ft
                              doautoall filetypedetect BufRead
    1              0.000003 endif

SCRIPT  /home/c5262761/local/share/vim/vim81/syntax/synload.vim
Sourced 1 time
Total time:   0.002158
 Self time:   0.000646

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Nov 04
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000008 if !has("syntax")
                              finish
    1              0.000002 endif
                            
                            " let others know that syntax has been switched on
    1              0.000007 let syntax_on = 1
                            
                            " Set the default highlighting colors.  Use a color scheme if specified.
    1              0.000004 if exists("colors_name")
                              exe "colors " . colors_name
    1              0.000002 else
    1   0.001934   0.000422   runtime! syntax/syncolor.vim
    1              0.000003 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000017 let s:cpo_save = &cpo
    1              0.000011 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000004 au! Syntax
                            
    1              0.000012 au Syntax *		call s:SynSet()
                            
    1              0.000014 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
                                for name in split(s, '\.')
                                  exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    1              0.000028 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000006 if exists("mysyntaxfile")
                              let s:fname = expand(mysyntaxfile)
                              if filereadable(s:fname)
                                execute "source " . fnameescape(s:fname)
                              endif
    1              0.000001 endif
                            
                            " Restore 'cpoptions'
    1              0.000010 let &cpo = s:cpo_save
    1              0.000007 unlet s:cpo_save

SCRIPT  /home/c5262761/local/share/vim/vim81/syntax/syncolor.vim
Sourced 3 times
Total time:   0.001798
 Self time:   0.001798

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
    3              0.000026 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    2              0.000016   command -nargs=* SynColor hi <args>
    2              0.000012   command -nargs=* SynLink hi link <args>
    1              0.000001 else
    1              0.000002   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
    1              0.000014     command -nargs=* SynColor hi def <args>
    1              0.000007     command -nargs=* SynLink hi def link <args>
                              elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
                                command -nargs=* SynColor hi <args>
                                command -nargs=* SynLink hi! link <args>
                              else
                                " User defined syncolor file has already set the colors.
                                finish
    1              0.000001   endif
    3              0.000003 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
    3              0.000022 if &background == "dark"
    2              0.000023   SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
    2              0.000028   SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
    2              0.000021   SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
    2              0.000023   SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
    2              0.000021   SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
    2              0.000021   SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
    2              0.000020   SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
    2              0.000015   SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
    2              0.000015   SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    1              0.000001 else
    1              0.000022   SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
    1              0.000011   SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
    1              0.000884   SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
    1              0.000016   SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
    1              0.000009   SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
    1              0.000010   SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
    1              0.000009   SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
    1              0.000009   SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
    1              0.000008   SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    3              0.000004 endif
    3              0.000025 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
    3              0.000025 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
    3              0.000013 SynLink String		Constant
    3              0.000012 SynLink Character	Constant
    3              0.000010 SynLink Number		Constant
    3              0.000012 SynLink Boolean		Constant
    3              0.000010 SynLink Float		Number
    3              0.000012 SynLink Function	Identifier
    3              0.000011 SynLink Conditional	Statement
    3              0.000010 SynLink Repeat		Statement
    3              0.000010 SynLink Label		Statement
    3              0.000013 SynLink Operator	Statement
    3              0.000009 SynLink Keyword		Statement
    3              0.000012 SynLink Exception	Statement
    3              0.000010 SynLink Include		PreProc
    3              0.000010 SynLink Define		PreProc
    3              0.000011 SynLink Macro		PreProc
    3              0.000011 SynLink PreCondit	PreProc
    3              0.000010 SynLink StorageClass	Type
    3              0.000018 SynLink Structure	Type
    3              0.000012 SynLink Typedef		Type
    3              0.000014 SynLink Tag		Special
    3              0.000015 SynLink SpecialChar	Special
    3              0.000014 SynLink Delimiter	Special
    3              0.000015 SynLink SpecialComment	Special
    3              0.000013 SynLink Debug		Special
                            
    3              0.000007 delcommand SynColor
    3              0.000013 delcommand SynLink

SCRIPT  /usr/share/vim/vim74/syntax/syncolor.vim
Sourced 3 times
Total time:   0.000869
 Self time:   0.000869

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
    3              0.000037 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    2              0.000014   command -nargs=* SynColor hi <args>
    2              0.000013   command -nargs=* SynLink hi link <args>
    1              0.000001 else
    1              0.000003   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
    1              0.000008     command -nargs=* SynColor hi def <args>
    1              0.000006     command -nargs=* SynLink hi def link <args>
                              elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
                                command -nargs=* SynColor hi <args>
                                command -nargs=* SynLink hi! link <args>
                              else
                                " User defined syncolor file has already set the colors.
                                finish
    1              0.000001   endif
    3              0.000003 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
    3              0.000009 if &background == "dark"
    2              0.000022   SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
    2              0.000016   SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
    2              0.000029   SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
    2              0.000015   SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
    2              0.000015   SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
    2              0.000016   SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
    2              0.000022   SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
    2              0.000020   SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
    2              0.000019   SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    1              0.000001 else
    1              0.000007   SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
    1              0.000004   SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
    1              0.000005   SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
    1              0.000004   SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
    1              0.000004   SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
    1              0.000004   SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
    1              0.000004   SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
    1              0.000004   SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
    1              0.000003   SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    3              0.000004 endif
    3              0.000042 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
    3              0.000026 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
    3              0.000014 SynLink String		Constant
    3              0.000014 SynLink Character	Constant
    3              0.000012 SynLink Number		Constant
    3              0.000014 SynLink Boolean		Constant
    3              0.000017 SynLink Float		Number
    3              0.000029 SynLink Function	Identifier
    3              0.000013 SynLink Conditional	Statement
    3              0.000012 SynLink Repeat		Statement
    3              0.000011 SynLink Label		Statement
    3              0.000013 SynLink Operator	Statement
    3              0.000013 SynLink Keyword		Statement
    3              0.000012 SynLink Exception	Statement
    3              0.000011 SynLink Include		PreProc
    3              0.000011 SynLink Define		PreProc
    3              0.000009 SynLink Macro		PreProc
    3              0.000010 SynLink PreCondit	PreProc
    3              0.000011 SynLink StorageClass	Type
    3              0.000010 SynLink Structure	Type
    3              0.000012 SynLink Typedef		Type
    3              0.000015 SynLink Tag		Special
    3              0.000013 SynLink SpecialChar	Special
    3              0.000012 SynLink Delimiter	Special
    3              0.000014 SynLink SpecialComment	Special
    3              0.000012 SynLink Debug		Special
                            
    3              0.000005 delcommand SynColor
    3              0.000014 delcommand SynLink

SCRIPT  /home/c5262761/configit/vim/colors/wombat.vim
Sourced 1 time
Total time:   0.004612
 Self time:   0.003978

count  total (s)   self (s)
    1   0.001223   0.000589 hi clear
                            
    1              0.000005 if &t_Co > 16
    1              0.000004     let s:orange = 214
    1              0.000002     let s:green_mud = 70
    1              0.000002     let s:grey_darker = 236
    1              0.000003     let s:cursorline = s:grey_darker
    1              0.000002     let s:grey_dark = 238
    1              0.000002     let s:grey_light = 242
    1              0.000002     let s:grey_lighter = 245
    1              0.000002     let s:yellow_dirty = 185
                            else
                                let s:orange = 'yellow'
                                let s:green_mud = 'green'
                                let s:grey_darker = 'grey'
                                let s:cursorline = 'NONE'
                                let s:grey_dark = 'grey'
                                let s:grey_light = 'grey'
                                let s:grey_lighter = 'grey'
                                let s:yellow_dirty = 'yellow'
    1              0.000001 endif
                            
                            " [ group, fg, bg, style]
    1              0.000133 let s:groups = [
                                        \ ["Normal",        "NONE",         "NONE",         "NONE"],
                                        \ ["Comment",       s:grey_light,   "NONE",         "NONE"],
                                        \ ["Constant",      "blue",         "NONE",         "NONE"],
                                        \ ["Identifier",    "cyan",         "NONE",         "NONE"],
                                        \ ["zshVariable",   "Identifier"],
                                        \ ["Function",      "NONE",         "NONE",         "NONE"],
                                        \ ["Statement",     s:orange,       "NONE",         "NONE"],
                                        \ ["PreProc",       "NONE",         "NONE",         "NONE"],
                                        \ ["Type",          s:green_mud,    "NONE",         "NONE"],
                                        \ ["Special",       "red",          "NONE",         "NONE"],
                                        \ ["SpecialKey",    s:grey_light,   "NONE",         "NONE"],
                                        \ ["Delimiter",      "red",          "NONE",         "NONE"],
                                        \ ["Underlined",    "NONE",         "NONE",         "underline"],
                                        \ ["Ignore",        "NONE",         "NONE",         "NONE"],
                                        \ ["Error",         "black",        "red",          "NONE"],
                                        \ ["WarningMsg",    "Error"],
                                        \ ["Todo",          "red",          "NONE",         "NONE"],
                                        \ ["CursorColumn",  "NONE",         s:cursorline,   "NONE"],
                                        \ ["CursorLine",    "CursorColumn"],
                                        \ ["DiffAdd",       "green",        "NONE",         "NONE"],
                                        \ ["DiffChange",    "NONE",         "NONE",         "NONE"],
                                        \ ["DiffDelete",    "red",          "NONE",         "NONE"],
                                        \ ["DiffText",      s:orange,       "NONE",         "NONE"],
                                        \ ["ErrorMsg",      "red",          "NONE",         "NONE"],
                                        \ ["VertSplit",     "NONE",         s:grey_dark,    "NONE"],
                                        \ ["Folded",        "",             "NONE",         "NONE"],
                                        \ ["FoldColumn",    "NONE",         "NONE",         "NONE"],
                                        \ ["LineNr",        "NONE",         "NONE",         "NONE"],
                                        \ ["CursorLineNr",  s:orange,       "NONE",         "NONE"],
                                        \ ["MatchParen",    "green",        "NONE",         "NONE"],
                                        \ ["ModeMsg",       "blue",         "NONE",         "NONE"],
                                        \ ["MoreMsg",       "blue",         "NONE",         "NONE"],
                                        \ ["NonText",       "NONE",         "NONE",         "NONE"],
                                        \ ["Pmenu",         "black",        s:grey_lighter, "NONE"],
                                        \ ["PmenuSel",      s:grey_lighter, "black",        "NONE"],
                                        \ ["PmenuSbar",     "NONE",         "NONE",         "NONE"],
                                        \ ["PmenuThumb",    s:grey_lighter, "NONE",         "NONE"],
                                        \ ["Question",      "NONE",         "NONE",         "NONE"],
                                        \ ["IncSearch",     "black",         s:yellow_dirty, "NONE"],
                                        \ ["Search",        "IncSearch"],
                                        \ ["SpellBad",      "NONE",         "NONE",         "underline"],
                                        \ ["SpellCap",      "SpellBad"],
                                        \ ["SpellLocal",    "SpellBad"],
                                        \ ["SpellRare",     "SpellBad"],
                                        \ ["StatusLine",    "black",        s:grey_lighter, "NONE"],
                                        \ ["StatusLineNC",  "NONE",         s:grey_dark,    "NONE"],
                                        \ ["TabLine",       "NONE",         "NONE",         "underline"],
                                        \ ["TabLineSel",    "black",        s:grey_lighter, "underline"],
                                        \ ["TabLineFill",   "NONE",         "NONE",         "underline"],
                                        \ ["Title",         "NONE",         "NONE",         "bold"],
                                        \ ["Visual",        "NONE",         s:grey_dark,    "NONE"],
                                        \ ["WildMenu",      "NONE",         "NONE",         "NONE"],
                                        \ ["Header1",       s:orange,       "NONE",         "NONE"],
                                        \ ["helpSectionDelim",  "Header1"],
                                        \ ["Header2",       "red",          "NONE",         "NONE"],
                                        \ ["helpHeader",    "Header2"],
                                        \ ["Header3",       "green",        "NONE",         "NONE"],
                                        \ ["Header4",       "lightblue",    "NONE",         "NONE"],
                                        \ ["Header5",       "cyan",         "NONE",         "NONE"],
                                        \ ["Header6",       "yellow",       "NONE",         "NONE"],
                                        \ ["Tag",           "NONE",         "NONE",         "italic"],
                                        \ ["SignColumn",    "NONE",         "NONE",         "NONE"],
                                        \ ["doxygenBrief",  "cyan",         "NONE",         "bold"],
                                        \ ]
                            
                            " netrw
    1              0.000016 let s:groups += [
                                        \ ["Directory",     "blue",         "NONE",         "NONE"],
                                        \ ["netrwClassify", "NONE",         "NONE",         "NONE"],
                                        \ ["netrwExe",      "green",        "NONE",         "NONE"],
                                        \ ["netrwSymLink",  "cyan",         "NONE",         "NONE"],
                                        \ ]
                            
                            " quickfix
    1              0.000007 let s:groups += [
                                        \ ["qfFileName",    "blue",         "NONE",         "NONE"],
                                        \ ["qfLineNr",      "blue",         "NONE",         "NONE"],
                                        \ ]
                            
                            " header mess
    1              0.000004 let s:header_strings = ["htmlH%d", "markdownH%d"]
    1              0.000003 let s:header_nums = 5
                            
    6              0.000018 for i in range(1, s:header_nums)
   15              0.000025     for header in s:header_strings
                                    " exec 'let s:groups += ["' .  ']'
    1              0.000026         exec printf('let s:groups += [["%s", "%s"]]',
                                                \ printf(header, i),
                                                \ printf("Header%d", i)
    9              0.000100                     \ )
   15              0.000014     endfor
    6              0.000005 endfor
                            
   80              0.000129 for group in s:groups
   79              0.000193     if len(group) == 2
   19              0.000145         execute 'hi! link ' . group[0] . ' ' . group[1]
   60              0.000056     else
   60              0.000209         let cmd = 'hi!' . group[0]
   60              0.000136         if group[1] != ''
   59              0.000208             let cmd .= ' ctermfg=' . group[1]
   60              0.000057         endif
   60              0.000131         if group[2] != ''
   60              0.000198             let cmd .= ' ctermbg=' . group[2]
   60              0.000068         endif
   60              0.000133         if group[3] != ''
   60              0.000191             let cmd .= ' cterm=' . group[3]
   60              0.000050         endif
   60              0.000388         execute cmd
   79              0.000069     endif
   80              0.000075 endfor

SCRIPT  /home/c5262761/configit/vim/plugin/dragvisuals.vim
Sourced 1 time
Total time:   0.000490
 Self time:   0.000490

count  total (s)   self (s)
                            " Vim global plugin for dragging virtual blocks
                            " Last change: Tue Jul 24 07:19:35 EST 2012
                            " Maintainer:	Damian Conway
                            " License:	This file is placed in the public domain.
                            
                            "#########################################################################
                            "##                                                                     ##
                            "##  Add the following (uncommented) to your .vimrc...                  ##
                            "##                                                                     ##
                            "##     runtime plugin/dragvisuals.vim                                  ##
                            "##                                                                     ##
                            "##     vmap  <expr>  <LEFT>   DVB_Drag('left')                         ##
                            "##     vmap  <expr>  <RIGHT>  DVB_Drag('right')                        ##
                            "##     vmap  <expr>  <DOWN>   DVB_Drag('down')                         ##
                            "##     vmap  <expr>  <UP>     DVB_Drag('up')                           ##
                            "##     vmap  <expr>  D        DVB_Duplicate()                          ##
                            "##                                                                     ##
                            "##     " Remove any introduced trailing whitespace after moving...     ##
                            "##     let g:DVB_TrimWS = 1                                            ##
                            "##                                                                     ##
                            "##  Or, if you use the arrow keys for normal motions, choose           ##
                            "##  four other keys for block dragging. For example:                   ##
                            "##                                                                     ##
                            "##     vmap  <expr>  h        DVB_Drag('left')                         ##
                            "##     vmap  <expr>  l        DVB_Drag('right')                        ##
                            "##     vmap  <expr>  j        DVB_Drag('down')                         ##
                            "##     vmap  <expr>  k        DVB_Drag('up')                           ##
                            "##                                                                     ##
                            "##  Or:                                                                ##
                            "##                                                                     ##
                            "##     vmap  <expr>  <S-LEFT>   DVB_Drag('left')                       ##
                            "##     vmap  <expr>  <S-RIGHT>  DVB_Drag('right')                      ##
                            "##     vmap  <expr>  <S-DOWN>   DVB_Drag('down')                       ##
                            "##     vmap  <expr>  <S-UP>     DVB_Drag('up')                         ##
                            "##                                                                     ##
                            "##  Or even:                                                           ##
                            "##                                                                     ##
                            "##     vmap  <expr>   <LEFT><LEFT>   DVB_Drag('left')                  ##
                            "##     vmap  <expr>  <RIGHT><RIGHT>  DVB_Drag('right')                 ##
                            "##     vmap  <expr>   <DOWN><DOWN>   DVB_Drag('down')                  ##
                            "##     vmap  <expr>     <UP><UP>     DVB_Drag('up')                    ##
                            "##                                                                     ##
                            "#########################################################################
                            
                            
                            " If already loaded, we're done...
    1              0.000009 if exists("loaded_dragvirtualblocks")
                                finish
    1              0.000002 endif
    1              0.000003 let loaded_dragvirtualblocks = 1
                            
                            " Preserve external compatibility options, then enable full vim compatibility...
    1              0.000008 let s:save_cpo = &cpo
    1              0.000018 set cpo&vim
                            
                            "====[ Implementation ]====================================
                            
                            " Toggle this to stop trimming on drags...
    1              0.000004 if !exists('g:DVB_TrimWS')
    1              0.000002     let g:DVB_TrimWS = 1
    1              0.000001 endif
                            
    1              0.000003 function! DVB_Drag (dir)
                                " No-op in Visual mode...
                                if mode() ==# 'v'
                                    return "\<ESC>gv"
                            
                                " Do Visual Line drag indirectly via temporary nmap
                                " (to ensure we have access to block position data)...
                                elseif mode() ==# 'V'
                                    " Set up a temporary convenience...
                                    exec "nnoremap <silent><expr><buffer>  M  \<SID>Drag_Lines('".a:dir."')"
                            
                                    " Return instructions to implement the move and reset selection...
                                    return '"vyM'
                            
                                " Otherwise do Visual Block drag indirectly via temporary nmap
                                " (to ensure we have access to block position data)...
                                else
                                    " Set up a temporary convenience...
                                    exec "nnoremap <silent><expr><buffer>  M  \<SID>Drag_Block('".a:dir."')"
                            
                                    " Return instructions to implement the move and reset selection...
                                    return '"vyM'
                                endif
                            endfunction
                            
    1              0.000002 function! DVB_Float (dir)
                                " No-op in Visual mode...
                                if mode() ==# 'v'
                                    return "\<ESC>gv"
                            
                                " Do Visual Line drag indirectly via temporary nmap
                                " (to ensure we have access to block position data)...
                                elseif mode() ==# 'V'
                                    " Set up a temporary convenience...
                                    exec "nnoremap <silent><expr><buffer>  M  \<SID>Float_Lines('".a:dir."')"
                            
                                    " Return instructions to implement the move and reset selection...
                                    return '"vyM'
                            
                                " Otherwise do Visual Block drag indirectly via temporary nmap
                                " (to ensure we have access to block position data)...
                                else
                                    " Set up a temporary convenience...
                                    exec "nnoremap <silent><expr><buffer>  M  \<SID>Float_Block('".a:dir."')"
                            
                                    " Return instructions to implement the move and reset selection...
                                    return '"vyM'
                                endif
                            endfunction
                            
                            " Duplicate selected block and place to the right...
    1              0.000002 function! DVB_Duplicate ()
                                exec "nnoremap <silent><expr><buffer>  M  \<SID>DuplicateBlock()"
                                return '"vyM'
                            endfunction
                            
    1              0.000006 function! s:DuplicateBlock ()
                                nunmap <buffer>  M
                                " Locate block boundaries...
                                let [buf_left,  line_left,  col_left,  offset_left ] = getpos("'<")
                                let [buf_right, line_right, col_right, offset_right] = getpos("'>")
                            
                                " Identify special '$' blocks...
                                let dollar_block = 0
                                let start_col    = min([col_left+offset_left, col_right+offset_right])
                                let end_col      = max([col_left+offset_left, col_right+offset_right])
                                let visual_width = end_col - start_col + 1
                                for visual_line in split(getreg("v"),"\n")
                                    if strlen(visual_line) > visual_width
                                        let dollar_block = 1
                                        let visual_width = strlen(visual_line)
                                    endif
                                endfor
                                let square_up = (dollar_block ? (start_col+visual_width-2).'|' : '')
                            
                                set virtualedit=all
                                return 'gv'.square_up.'yPgv'
                                    \. (visual_width-dollar_block) . 'lo' . (visual_width-dollar_block) . 'l'
                                    \. "y:set virtualedit=block\<CR>gv"
                                    \. (dollar_block ? 'o$' : '')
                            endfunction
                            
                            
                            " Kludge to hide change reporting inside implementation...
    1              0.000011 let s:NO_REPORT   = ":let b:DVB_report=&report\<CR>:let &report=1000000000\<CR>"
    1              0.000005 let s:PREV_REPORT = ":let &report = b:DVB_report\<CR>"
                            
                            
                            " Drag in specified direction in Visual Line mode...
    1              0.000004 function! s:Drag_Lines (dir)
                                " Clean up the temporary convenience...
                                nunmap <buffer>  M
                            
                                " Locate block being shifted...
                                let [buf_left,  line_left,  col_left,  offset_left ] = getpos("'<")
                                let [buf_right, line_right, col_right, offset_right] = getpos("'>")
                            
                                " Drag entire lines left if possible...
                                if a:dir == 'left'
                                    " Are all lines indented at least one space???
                                    let lines        = getline(line_left, line_right)
                                    let all_indented = match(lines, '^[^ ]') == -1
                            
                                    " If can't trim one space from start of each line, be a no-op...
                                    if !all_indented
                                        return 'gv'
                            
                                    " Otherwise drag left by removing one space from start of each line...
                                    else
                                        return    s:NO_REPORT
                                              \ . "gv:s/^ //\<CR>:nohlsearch\<CR>"
                                              \ . s:PREV_REPORT
                                              \ . "gv"
                                    endif
                            
                                " To drag entire lines right, add a space in column 1...
                                elseif a:dir == 'right'
                                    return   s:NO_REPORT
                                         \ . "gv:s/^/ /\<CR>:nohlsearch\<CR>"
                                         \ . s:PREV_REPORT
                                         \ . "gv"
                            
                                " To drag entire lines upwards...
                                elseif a:dir == 'up'
                                    let EOF = line('$')
                            
                                    " Can't drag up if at first line...
                                    if line_left == 1 || line_right == 1
                                        return 'gv'
                            
                                    " Needs special handling at EOF (because cursor moves up on delete)...
                                    elseif line_left == EOF || line_right == EOF
                                        let height = line_right - line_left
                                        let select_extra = height ? height . 'j' : ""
                                        return   s:NO_REPORT
                                             \ . 'gvxP'
                                             \ . s:PREV_REPORT
                                             \ . 'V' . select_extra
                            
                                    " Otherwise just cut-move-paste-reselect...
                                    else
                                        let height = line_right - line_left
                                        let select_extra = height ? height . 'j' : ""
                                        return   s:NO_REPORT
                                             \ . 'gvxkP'
                                             \ . s:PREV_REPORT
                                             \ . 'V' . select_extra
                                    endif
                            
                                " To drag entire lines downwards...
                                elseif a:dir == 'down'
                                    let EOF = line('$')
                            
                                    " This is how much extra we're going to have to reselect...
                                    let height = line_right - line_left
                                    let select_extra = height ? height . 'j' : ""
                            
                                    " Needs special handling at EOF (to push selection down into new space)...
                                    if line_left == EOF || line_right == EOF
                                        return   "O\<ESC>gv"
                            
                                    " Otherwise, just cut-move-paste-reselect...
                                    else
                                        return   s:NO_REPORT
                                             \ . 'gvxp'
                                             \ . s:PREV_REPORT
                                             \ . 'V' . select_extra
                                    endif
                            
                                endif
                            endfunction
                            
                            " Drag in specified direction in Visual Block mode...
    1              0.000003 function! s:Drag_Block (dir)
                                " Clean up the temporary convenience...
                                nunmap <buffer>  M
                            
                                " Locate block being shifted...
                                let [buf_left,  line_left,  col_left,  offset_left ] = getpos("'<")
                                let [buf_right, line_right, col_right, offset_right] = getpos("'>")
                            
                                " Identify special '$' blocks...
                                let dollar_block = 0
                                let start_col    = min([col_left+offset_left, col_right+offset_right])
                                let end_col      = max([col_left+offset_left, col_right+offset_right])
                                let visual_width = end_col - start_col + 1
                                for visual_line in split(getreg("v"),"\n")
                                    if strlen(visual_line) > visual_width
                                        let dollar_block = 1
                                        let visual_width = strlen(visual_line)
                                    endif
                                endfor
                                let square_up = (dollar_block ? (start_col+visual_width-2).'|' : '')
                            
                                " Drag left...
                                if a:dir == 'left'
                                    "Can't drag left at left margin...
                                    if col_left == 1 || col_right == 1
                                        return 'gv'
                            
                                    " Otherwise reposition one column left (and optionally trim any whitespace)...
                                    elseif g:DVB_TrimWS
                                        " May need to be able to temporarily step past EOL...
                                        let prev_ve = &virtualedit
                                        set virtualedit=all
                            
                                        " Are we moving past other text???
                                        let square_up_final = ""
                                        if dollar_block
                                            let lines = getline(line_left, line_right)
                                            if match(lines, '^.\{'.(start_col-2).'}\S') >= 0
                                                let dollar_block = 0
                                                let square_up_final = (start_col+visual_width-3).'|'
                                            endif
                                        endif
                            
                                        let vcol = start_col - 2
                                        return   'gv'.square_up.'xhP'
                                             \ . s:NO_REPORT
                                             \ . "gvhoho:s/\\s\\+$//e\<CR>gv\<ESC>"
                                             \ . ':set virtualedit=' . prev_ve . "\<CR>"
                                             \ . s:PREV_REPORT
                                             \ . ":nohlsearch\<CR>gv"
                                             \ . (dollar_block ? '$' : square_up_final )
                                    else
                                        return 'gv'.square_up.'xhPgvhoho'
                                    endif
                            
                                " Drag right...
                                elseif a:dir == 'right'
                                    " May need to be able to temporarily step past EOL...
                                    let prev_ve = &virtualedit
                                    set virtualedit=all
                            
                                    " Reposition block one column to the right...
                                    if g:DVB_TrimWS
                                        let vcol = start_col
                                        return   'gv'.square_up.'xp'
                                             \ . s:NO_REPORT
                                             \ . "gvlolo"
                                             \ . ":s/\\s\\+$//e\<CR>gv\<ESC>"
                                             \ . ":nohlsearch\<CR>:set virtualedit=" . prev_ve . "\<CR>"
                                             \ . s:PREV_REPORT
                                             \ . (dollar_block ? 'gv$' : 'gv')
                                    else
                                        return 'gv'.square_up.'xp:set virtualedit=' . prev_ve . "\<CR>gvlolo"
                                    endif
                            
                                " Drag upwards...
                                elseif a:dir == 'up'
                                    " Can't drag upwards at top margin...
                                    if line_left == 1 || line_right == 1
                                        return 'gv'
                                    endif
                            
                                    " May need to be able to temporarily step past EOL...
                                    let prev_ve = &virtualedit
                                    set virtualedit=all
                            
                                    " If trimming whitespace, jump to just below block to do it...
                                    if g:DVB_TrimWS
                                        let height = line_right - line_left + 1
                                        return  'gv'.square_up.'xkPgvkoko"vy'
                                                \ . height
                                                \ . 'j:s/\s\+$//e'
                                                \ . "\<CR>:nohlsearch\<CR>:set virtualedit="
                                                \ . prev_ve
                                                \ . "\<CR>gv"
                                                \ . (dollar_block ? '$' : '')
                            
                                    " Otherwise just move and reselect...
                                    else
                                        return   'gv'.square_up.'xkPgvkoko"vy:set virtualedit='
                                                \ . prev_ve
                                                \ . "\<CR>gv"
                                                \ . (dollar_block ? '$' : '')
                                    endif
                            
                                " Drag downwards...
                                elseif a:dir == 'down'
                                    " May need to be able to temporarily step past EOL...
                                    let prev_ve = &virtualedit
                                    set virtualedit=all
                            
                                    " If trimming whitespace, move to just above block to do it...
                                    if g:DVB_TrimWS
                                        return   'gv'.square_up.'xjPgvjojo"vyk:s/\s\+$//e'
                                                \ . "\<CR>:nohlsearch\<CR>:set virtualedit="
                                                \ . prev_ve
                                                \ . "\<CR>gv"
                                                \ . (dollar_block ? '$' : '')
                            
                                    " Otherwise just move and reselect...
                                    else
                                        return   'gv'.square_up.'xjPgvjojo"vy'
                                                \ . "\<CR>:set virtualedit="
                                                \ . prev_ve
                                                \ . "\<CR>gv"
                                                \ . (dollar_block ? '$' : '')
                                    endif
                                endif
                            endfunction
                            
                            
                            " Restore previous external compatibility options
    1              0.000012 let &cpo = s:save_cpo
                            
    1              0.000012 vmap  <expr>  <LEFT>   DVB_Drag('left')
    1              0.000007 vmap  <expr>  <RIGHT>  DVB_Drag('right')
    1              0.000007 vmap  <expr>  <DOWN>   DVB_Drag('down')
    1              0.000006 vmap  <expr>  <UP>     DVB_Drag('up')
    1              0.000015 vmap  <expr>  D        DVB_Duplicate()

SCRIPT  /home/c5262761/configit/vim/plugin/my.vim
Sourced 1 time
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    1              0.000009 com! Profile call my#Profiling()
    1              0.000004 com! TabToggle call my#TabToggle()
    1              0.000004 com! Modernize call my#Modernize()
    1              0.000003 com! SynStack call my#SynStack()
    1              0.000006 com! DiffExternalChange call my#DiffExternalChange()
    1              0.000004 com! Helptags call my#Helptags()
                            
    1              0.000005 com! -nargs=? ListRTP call my#ListRTP(<q-args>)
    1              0.000007 com! -nargs=? ListScriptnames call my#ListScriptnames(<q-args>)
                            
    1              0.000010 com! -nargs=1 Bgrep call setqflist([]) | silent bufdo grepadd <args> %
    1              0.000011 com! -nargs=1 Blgrep call setloclist(winnr(), []) | silent bufdo lgrepadd <args> %
    1              0.000006 com! -nargs=1 Replace call my#FindAndReplace(<q-args>)
                            
    1              0.000004 com! WindowFit call my#FitWindowToBuffer()
    1              0.000019 nnoremap <silent> <c-w>f :WindowFit<cr>
                            

SCRIPT  /home/c5262761/configit/vim/modules/vim-slime/plugin/slime.vim
Sourced 1 time
Total time:   0.000284
 Self time:   0.000284

count  total (s)   self (s)
    1              0.000016 if exists('g:loaded_slime') || &cp || v:version < 700
                              finish
    1              0.000001 endif
    1              0.000004 let g:loaded_slime = 1
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Setup key bindings
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000006 command -bar -nargs=0 SlimeConfig call slime#config()
    1              0.000012 command -range -bar -nargs=0 SlimeSend call slime#send_range(<line1>, <line2>)
    1              0.000006 command -nargs=+ SlimeSend1 call slime#send(<q-args> . "\r")
    1              0.000011 command -nargs=+ SlimeSend0 call slime#send(<args>)
    1              0.000011 command! SlimeSendCurrentLine call slime#send(getline(".") . "\r")
                            
    1              0.000033 noremap <SID>Operator :<c-u>call slime#store_curpos()<cr>:set opfunc=slime#send_op<cr>g@
                            
    1              0.000021 noremap <unique> <script> <silent> <Plug>SlimeRegionSend :<c-u>call slime#send_op(visualmode(), 1)<cr>
    1              0.000014 noremap <unique> <script> <silent> <Plug>SlimeLineSend :<c-u>call slime#send_lines(v:count1)<cr>
    1              0.000011 noremap <unique> <script> <silent> <Plug>SlimeMotionSend <SID>Operator
    1              0.000020 noremap <unique> <script> <silent> <Plug>SlimeParagraphSend <SID>Operatorip
    1              0.000010 noremap <unique> <script> <silent> <Plug>SlimeConfig :<c-u>SlimeConfig<cr>
                            
    1              0.000007 if !exists("g:slime_no_mappings") || !g:slime_no_mappings
    1              0.000013   if !hasmapto('<Plug>SlimeRegionSend', 'x')
    1              0.000010     xmap <c-c><c-c> <Plug>SlimeRegionSend
    1              0.000001   endif
                            
    1              0.000011   if !hasmapto('<Plug>SlimeParagraphSend', 'n')
    1              0.000009     nmap <c-c><c-c> <Plug>SlimeParagraphSend
    1              0.000001   endif
                            
    1              0.000010   if !hasmapto('<Plug>SlimeConfig', 'n')
    1              0.000009     nmap <c-c>v <Plug>SlimeConfig
    1              0.000001   endif
    1              0.000001 endif
                            

SCRIPT  /home/c5262761/configit/vim/modules/vim-signify/plugin/signify.vim
Sourced 1 time
Total time:   0.000634
 Self time:   0.000634

count  total (s)   self (s)
                            " vim: et sw=2 sts=2
                            
    1              0.000005 scriptencoding utf-8
                            
    1              0.000011 if exists('g:loaded_signify') || !has('signs') || &compatible
                              finish
    1              0.000001 endif
                            
                            " Init: values {{{1
    1              0.000003 let g:loaded_signify = 1
    1              0.000002 let g:signify_locked = 0
                            
                            " Init: autocmds {{{1
    1              0.000002 augroup signify
    1              0.000086   autocmd!
                            
    1              0.000010   autocmd QuickFixCmdPre  *vimgrep* let g:signify_locked = 1
    1              0.000007   autocmd QuickFixCmdPost *vimgrep* let g:signify_locked = 0
                            
    1              0.000005   autocmd CmdwinEnter * let g:signify_cmdwin_active = 1
    1              0.000011   autocmd CmdwinLeave * let g:signify_cmdwin_active = 0
                            
    1              0.000005   autocmd BufWritePost * call sy#start()
                            
    1              0.000007   if get(g:, 'signify_realtime') && has('patch-7.4.1967')
                                autocmd WinEnter * call sy#start()
                                if get(g:, 'signify_update_on_bufenter')
                                  autocmd BufEnter * nested call s:save()
                                else
                                  autocmd BufEnter * call sy#start()
                                endif
                                if get(g:, 'signify_cursorhold_normal', 1)
                                  autocmd CursorHold * nested call s:save()
                                endif
                                if get(g:, 'signify_cursorhold_insert', 1)
                                  autocmd CursorHoldI * nested call s:save()
                                endif
                                if get(g:, 'signify_update_on_focusgained', 1)
                                  autocmd FocusGained * SignifyRefresh
                                endif
    1              0.000001   else
    1              0.000009     autocmd BufRead * call sy#start()
    1              0.000007     if get(g:, 'signify_update_on_bufenter')
                                  autocmd BufEnter * nested call s:save()
    1              0.000002     endif
    1              0.000006     if get(g:, 'signify_cursorhold_normal')
                                  autocmd CursorHold * nested call s:save()
    1              0.000002     endif
    1              0.000015     if get(g:, 'signify_cursorhold_insert')
                                  autocmd CursorHoldI * nested call s:save()
    1              0.000001     endif
    1              0.000003     if get(g:, 'signify_update_on_focusgained')
                                  autocmd FocusGained * SignifyRefresh
    1              0.000001     endif
    1              0.000001   endif
                            
    1              0.000006   if has('gui_running') && has('win32') && argc()
                                " Fix 'no signs at start' race.
                                autocmd GUIEnter * redraw
    1              0.000001   endif
    1              0.000001 augroup END
                            
                            " Init: commands {{{1
                            
    1              0.000010 command! -nargs=0 -bar       SignifyList            call sy#debug#list_active_buffers()
    1              0.000006 command! -nargs=0 -bar       SignifyDebug           call sy#repo#debug_detection()
    1              0.000008 command! -nargs=0 -bar -bang SignifyFold            call sy#fold#dispatch(<bang>1)
    1              0.000007 command! -nargs=0 -bar -bang SignifyDiff            call sy#repo#diffmode(<bang>1)
    1              0.000005 command! -nargs=0 -bar       SignifyDiffPreview     call sy#repo#preview_hunk()
    1              0.000005 command! -nargs=0 -bar       SignifyRefresh         call sy#util#refresh_windows()
    1              0.000005 command! -nargs=0 -bar       SignifyEnable          call sy#enable()
    1              0.000004 command! -nargs=0 -bar       SignifyDisable         call sy#disable()
    1              0.000004 command! -nargs=0 -bar       SignifyToggle          call sy#toggle()
    1              0.000024 command! -nargs=0 -bar       SignifyToggleHighlight call sy#highlight#line_toggle()
                            
                            " Init: mappings {{{1
    1              0.000014 let s:cpoptions = &cpoptions
    1              0.000006 set cpoptions+=B
                            
                            " hunk jumping
    1              0.000020 nnoremap <silent> <expr> <plug>(signify-next-hunk) &diff
                                  \ ? ']c'
                                  \ : ":\<c-u>call sy#jump#next_hunk(v:count1)\<cr>"
    1              0.000016 nnoremap <silent> <expr> <plug>(signify-prev-hunk) &diff
                                  \ ? '[c'
                                  \ : ":\<c-u>call sy#jump#prev_hunk(v:count1)\<cr>"
                            
    1              0.000022 if empty(maparg(']c', 'n')) && !hasmapto('<plug>(signify-next-hunk)', 'n')
    1              0.000009   nmap ]c <plug>(signify-next-hunk)
    1              0.000013   if empty(maparg(']C', 'n')) && !hasmapto('9999]c', 'n')
    1              0.000005     nmap ]C 9999]c
    1              0.000001   endif
    1              0.000001 endif
    1              0.000016 if empty(maparg('[c', 'n')) && !hasmapto('<plug>(signify-prev-hunk)', 'n')
    1              0.000008   nmap [c <plug>(signify-prev-hunk)
    1              0.000013   if empty(maparg('[C', 'n')) && !hasmapto('9999[c', 'n')
    1              0.000005     nmap [C 9999[c
    1              0.000001   end
    1              0.000001 endif
                            
                            " hunk text object
    1              0.000030 onoremap <silent> <plug>(signify-motion-inner-pending) :<c-u>call sy#util#hunk_text_object(0)<cr>
    1              0.000013 xnoremap <silent> <plug>(signify-motion-inner-visual)  :<c-u>call sy#util#hunk_text_object(0)<cr>
    1              0.000013 onoremap <silent> <plug>(signify-motion-outer-pending) :<c-u>call sy#util#hunk_text_object(1)<cr>
    1              0.000013 xnoremap <silent> <plug>(signify-motion-outer-visual)  :<c-u>call sy#util#hunk_text_object(1)<cr>
                            
    1              0.000006 let &cpoptions = s:cpoptions
    1              0.000003 unlet s:cpoptions
                            
                            " Function: save {{{1
                            
    1              0.000015 function! s:save()
                              if exists('b:sy') && b:sy.active && &modified && &modifiable && ! &readonly
                                write
                              endif
                            endfunction
                            
    1              0.000005 if exists('#User#SignifySetup')
                              doautocmd <nomodeline> User SignifySetup
    1              0.000004 endif

SCRIPT  /home/c5262761/configit/vim/modules/undotree/plugin/undotree.vim
Sourced 1 time
Total time:   0.000243
 Self time:   0.000243

count  total (s)   self (s)
                            "=================================================
                            " File: plugin/undotree.vim
                            " Description: Manage your undo history in a graph.
                            " Author: Ming Bai <mbbill@gmail.com>
                            " License: BSD
                            
                            " Avoid installing twice.
    1              0.000008 if exists('g:loaded_undotree')
                                finish
    1              0.000001 endif
    1              0.000003 let g:loaded_undotree = 0
                            
                            " At least version 7.3 with 005 patch is needed for undo branches.
                            " Refer to https://github.com/mbbill/undotree/issues/4 for details.
                            " Thanks kien
    1              0.000003 if v:version < 703
                                command! -n=0 -bar UndotreeToggle :echoerr "undotree.vim needs Vim version >= 7.3"
                                finish
    1              0.000001 endif
    1              0.000003 if (v:version == 703 && !has("patch005"))
                                command! -n=0 -bar UndotreeToggle :echoerr "undotree.vim needs vim7.3 with patch005 applied."
                                finish
    1              0.000001 endif
    1              0.000002 let g:loaded_undotree = 1   " Signal plugin availability with a value of 1.
                            
                            "=================================================
                            "Options:
                            
                            " Window layout
                            " style 1
                            " +----------+------------------------+
                            " |          |                        |
                            " |          |                        |
                            " | undotree |                        |
                            " |          |                        |
                            " |          |                        |
                            " +----------+                        |
                            " |          |                        |
                            " |   diff   |                        |
                            " |          |                        |
                            " +----------+------------------------+
                            " Style 2
                            " +----------+------------------------+
                            " |          |                        |
                            " |          |                        |
                            " | undotree |                        |
                            " |          |                        |
                            " |          |                        |
                            " +----------+------------------------+
                            " |                                   |
                            " |   diff                            |
                            " |                                   |
                            " +-----------------------------------+
                            " Style 3
                            " +------------------------+----------+
                            " |                        |          |
                            " |                        |          |
                            " |                        | undotree |
                            " |                        |          |
                            " |                        |          |
                            " |                        +----------+
                            " |                        |          |
                            " |                        |   diff   |
                            " |                        |          |
                            " +------------------------+----------+
                            " Style 4
                            " +-----------------------++----------+
                            " |                        |          |
                            " |                        |          |
                            " |                        | undotree |
                            " |                        |          |
                            " |                        |          |
                            " +------------------------+----------+
                            " |                                   |
                            " |                            diff   |
                            " |                                   |
                            " +-----------------------------------+
    1              0.000003 if !exists('g:undotree_WindowLayout')
    1              0.000003     let g:undotree_WindowLayout = 1
    1              0.000001 endif
                            
                            " e.g. using 'd' instead of 'days' to save some space.
    1              0.000003 if !exists('g:undotree_ShortIndicators')
    1              0.000002     let g:undotree_ShortIndicators = 0
    1              0.000001 endif
                            
                            " undotree window width
    1              0.000003 if !exists('g:undotree_SplitWidth')
    1              0.000002     if g:undotree_ShortIndicators == 1
                                    let g:undotree_SplitWidth = 24
    1              0.000001     else
    1              0.000003         let g:undotree_SplitWidth = 30
    1              0.000001     endif
    1              0.000001 endif
                            
                            " diff window height
    1              0.000003 if !exists('g:undotree_DiffpanelHeight')
    1              0.000010     let g:undotree_DiffpanelHeight = 10
    1              0.000001 endif
                            
                            " auto open diff window
    1              0.000003 if !exists('g:undotree_DiffAutoOpen')
    1              0.000002     let g:undotree_DiffAutoOpen = 1
    1              0.000001 endif
                            
                            " if set, let undotree window get focus after being opened, otherwise
                            " focus will stay in current window.
    1              0.000004 if !exists('g:undotree_SetFocusWhenToggle')
                                let g:undotree_SetFocusWhenToggle = 0
    1              0.000001 endif
                            
                            " tree node shape.
    1              0.000003 if !exists('g:undotree_TreeNodeShape')
    1              0.000002     let g:undotree_TreeNodeShape = '*'
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:undotree_DiffCommand')
    1              0.000002     let g:undotree_DiffCommand = "diff"
    1              0.000001 endif
                            
                            " relative timestamp
    1              0.000003 if !exists('g:undotree_RelativeTimestamp')
    1              0.000003     let g:undotree_RelativeTimestamp = 1
    1              0.000001 endif
                            
                            " Highlight changed text
    1              0.000003 if !exists('g:undotree_HighlightChangedText')
    1              0.000002     let g:undotree_HighlightChangedText = 1
    1              0.000000 endif
                            
                            " Highlight changed text using signs in the gutter
    1              0.000004 if !exists('g:undotree_HighlightChangedWithSign')
    1              0.000002     let g:undotree_HighlightChangedWithSign = 1
    1              0.000001 endif
                            
                            " Highlight linked syntax type.
                            " You may chose your favorite through ":hi" command
    1              0.000003 if !exists('g:undotree_HighlightSyntaxAdd')
    1              0.000003     let g:undotree_HighlightSyntaxAdd = "DiffAdd"
    1              0.000001 endif
    1              0.000003 if !exists('g:undotree_HighlightSyntaxChange')
    1              0.000003     let g:undotree_HighlightSyntaxChange = "DiffChange"
    1              0.000001 endif
    1              0.000003 if !exists('g:undotree_HighlightSyntaxDel')
    1              0.000003     let g:undotree_HighlightSyntaxDel = "DiffDelete"
    1              0.000001 endif
                            
                            " Deprecates the old style configuration.
    1              0.000003 if exists('g:undotree_SplitLocation')
                                echo "g:undotree_SplitLocation is deprecated,
                                            \ please use g:undotree_WindowLayout instead."
    1              0.000001 endif
                            
                            " Show help line
    1              0.000003 if !exists('g:undotree_HelpLine')
    1              0.000002     let g:undotree_HelpLine = 1
    1              0.000001 endif
                            
                            "=================================================
                            " User commands.
    1              0.000008 command! -n=0 -bar UndotreeToggle   :call undotree#UndotreeToggle()
    1              0.000006 command! -n=0 -bar UndotreeHide     :call undotree#UndotreeHide()
    1              0.000012 command! -n=0 -bar UndotreeShow     :call undotree#UndotreeShow()
    1              0.000005 command! -n=0 -bar UndotreeFocus    :call undotree#UndotreeFocus()
                            
                            " vim: set et fdm=marker sts=4 sw=4:

SCRIPT  /home/c5262761/configit/vim/modules/incsearch.vim/plugin/incsearch.vim
Sourced 1 time
Total time:   0.000433
 Self time:   0.000433

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: plugin/incsearch.vim
                            " AUTHOR: haya14busa
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000004 scriptencoding utf-8
                            " Load Once {{{
    1              0.000039 if expand('%:p') ==# expand('<sfile>:p')
                              unlet! g:loaded_incsearch
    1              0.000001 endif
    1              0.000004 if exists('g:loaded_incsearch')
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_incsearch = 1
                            " }}}
                            
                            " Saving 'cpoptions' {{{
    1              0.000007 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            " }}}
                            
                            " <silent>: do not show command in command line
    1              0.000017 noremap <silent><expr> <Plug>(incsearch-forward)  incsearch#go({'command': '/'})
    1              0.000012 noremap <silent><expr> <Plug>(incsearch-backward) incsearch#go({'command': '?'})
    1              0.000012 noremap <silent><expr> <Plug>(incsearch-stay)     incsearch#go({'command': '/', 'is_stay': 1})
                            
                            " Apply automatic :h :nohlsearch with :h :autocmd
                            " NOTE:
                            "   - This mappings doesn't move the cursor, please use this with other
                            "     mappings at the same time.
                            "   - Make sure calling this mapping __before__ moving commands
                            "     e.g. `<Plug>(incsearch-nohl)n` works but `n<Plug>(incsearch-nohl)` doesn't
                            "     work
    1              0.000012 noremap <expr> <Plug>(incsearch-nohl)  incsearch#autocmd#auto_nohlsearch(1)
    1              0.000012 noremap <expr> <Plug>(incsearch-nohl0) incsearch#autocmd#auto_nohlsearch(0)
    1              0.000011 noremap <expr> <Plug>(incsearch-nohl2) incsearch#autocmd#auto_nohlsearch(2)
                            
                            
    1              0.000015 map <Plug>(incsearch-nohl-n)  <Plug>(incsearch-nohl)<Plug>(_incsearch-n)
    1              0.000015 map <Plug>(incsearch-nohl-N)  <Plug>(incsearch-nohl)<Plug>(_incsearch-N)
    1              0.000014 map <Plug>(incsearch-nohl-*)  <Plug>(incsearch-nohl)<Plug>(_incsearch-*)
    1              0.000015 map <Plug>(incsearch-nohl-#)  <Plug>(incsearch-nohl)<Plug>(_incsearch-#)
    1              0.000015 map <Plug>(incsearch-nohl-g*) <Plug>(incsearch-nohl)<Plug>(_incsearch-g*)
    1              0.000015 map <Plug>(incsearch-nohl-g#) <Plug>(incsearch-nohl)<Plug>(_incsearch-g#)
                            
                            " These mappings are just alias to default mappings except they won't be
                            " remapped any more
    1              0.000015 noremap <expr> <Plug>(_incsearch-n)  g:incsearch#consistent_n_direction && !v:searchforward ? 'N' : 'n'
    1              0.000014 noremap <expr> <Plug>(_incsearch-N)  g:incsearch#consistent_n_direction && !v:searchforward ? 'n' : 'N'
    1              0.000009 noremap        <Plug>(_incsearch-*)  *
    1              0.000008 noremap        <Plug>(_incsearch-#)  #
    1              0.000008 noremap        <Plug>(_incsearch-g*) g*
    1              0.000008 noremap        <Plug>(_incsearch-g#) g#
                            
                            " CommandLine Mapping {{{
    1              0.000008 let g:incsearch_cli_key_mappings = get(g:, 'incsearch_cli_key_mappings', {})
                            
    1              0.000006 function! s:key_mapping(lhs, rhs, noremap) abort
                              let g:incsearch_cli_key_mappings[a:lhs] = {
                              \       'key' : a:rhs,
                              \       'noremap' : a:noremap,
                              \   }
                            endfunction
                            
    1              0.000003 function! s:as_keymapping(key) abort
                              return eval('"' . substitute(escape(a:key, '\"'), '\(<.\{-}>\)', '\\\1', 'g') . '"')
                            endfunction
                            
    1              0.000018 command! -nargs=* IncSearchNoreMap
                            \   call call('s:key_mapping', map([<f-args>], 's:as_keymapping(v:val)') + [1])
                            
    1              0.000017 command! -nargs=* IncSearchMap
                            \   call call('s:key_mapping', map([<f-args>], 's:as_keymapping(v:val)') + [0])
                            
                            "}}}
                            
                            " Restore 'cpoptions' {{{
    1              0.000016 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo
                            " }}}
                            " __END__  {{{
                            " vim: expandtab softtabstop=2 shiftwidth=2
                            " vim: foldmethod=marker
                            " }}}

SCRIPT  /home/c5262761/configit/vim/modules/vim-abolish/plugin/abolish.vim
Sourced 1 time
Total time:   0.001500
 Self time:   0.001239

count  total (s)   self (s)
                            " abolish.vim - Language friendly searches, substitutions, and abbreviations
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      1.1
                            " GetLatestVimScripts: 1545 1 :AutoInstall: abolish.vim
                            
                            " Initialization {{{1
                            
    1              0.000014 if exists("g:loaded_abolish") || &cp || v:version < 700
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_abolish = 1
                            
    1              0.000004 if !exists("g:abolish_save_file")
    1              0.000120   if isdirectory(expand("~/.vim"))
    1              0.000090     let g:abolish_save_file = expand("~/.vim/after/plugin/abolish.vim")
                              elseif isdirectory(expand("~/vimfiles")) || has("win32")
                                let g:abolish_save_file = expand("~/vimfiles/after/plugin/abolish.vim")
                              else
                                let g:abolish_save_file = expand("~/.vim/after/plugin/abolish.vim")
    1              0.000001   endif
    1              0.000001 endif
                            
                            " }}}1
                            " Utility functions {{{1
                            
    1              0.000004 function! s:function(name)
                              return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
                            endfunction
                            
    1              0.000003 function! s:send(self,func,...)
                              if type(a:func) == type('') || type(a:func) == type(0)
                                let l:Func = get(a:self,a:func,'')
                              else
                                let l:Func = a:func
                              endif
                              let s = type(a:self) == type({}) ? a:self : {}
                              if type(Func) == type(function('tr'))
                                return call(Func,a:000,s)
                              elseif type(Func) == type({}) && has_key(Func,'apply')
                                return call(Func.apply,a:000,Func)
                              elseif type(Func) == type({}) && has_key(Func,'call')
                                return call(Func.call,a:000,s)
                              elseif type(Func) == type('') && Func == '' && has_key(s,'function missing')
                                return call('s:send',[s,'function missing',a:func] + a:000)
                              else
                                return Func
                              endif
                            endfunction
                            
    1              0.000003 let s:object = {}
    1              0.000003 function! s:object.clone(...)
                              let sub = deepcopy(self)
                              return a:0 ? extend(sub,a:1) : sub
                            endfunction
                            
    1              0.000003 if !exists("g:Abolish")
    1              0.000003   let Abolish = {}
    1              0.000001 endif
    1              0.000007 call extend(Abolish, s:object, 'force')
    1              0.000005 call extend(Abolish, {'Coercions': {}}, 'keep')
                            
    1              0.000002 function! s:throw(msg)
                              let v:errmsg = a:msg
                              throw "Abolish: ".a:msg
                            endfunction
                            
    1              0.000002 function! s:words()
                              let words = []
                              let lnum = line('w0')
                              while lnum <= line('w$')
                                let line = getline(lnum)
                                let col = 0
                                while match(line,'\<\k\k\+\>',col) != -1
                                  let words += [matchstr(line,'\<\k\k\+\>',col)]
                                  let col = matchend(line,'\<\k\k\+\>',col)
                                endwhile
                                let lnum += 1
                              endwhile
                              return words
                            endfunction
                            
    1              0.000003 function! s:extractopts(list,opts)
                              let i = 0
                              while i < len(a:list)
                                if a:list[i] =~ '^-[^=]' && has_key(a:opts,matchstr(a:list[i],'-\zs[^=]*'))
                                  let key   = matchstr(a:list[i],'-\zs[^=]*')
                                  let value = matchstr(a:list[i],'=\zs.*')
                                  if type(get(a:opts,key)) == type([])
                                    let a:opts[key] += [value]
                                  elseif type(get(a:opts,key)) == type(0)
                                    let a:opts[key] = 1
                                  else
                                    let a:opts[key] = value
                                  endif
                                else
                                  let i += 1
                                  continue
                                endif
                                call remove(a:list,i)
                              endwhile
                              return a:opts
                            endfunction
                            
                            " }}}1
                            " Dictionary creation {{{1
                            
    1              0.000003 function! s:mixedcase(word)
                              return substitute(s:camelcase(a:word),'^.','\u&','')
                            endfunction
                            
    1              0.000002 function! s:camelcase(word)
                              let word = substitute(a:word, '-', '_', 'g')
                              if word !~# '_' && word =~# '\l'
                                return substitute(word,'^.','\l&','')
                              else
                                return substitute(word,'\C\(_\)\=\(.\)','\=submatch(1)==""?tolower(submatch(2)) : toupper(submatch(2))','g')
                              endif
                            endfunction
                            
    1              0.000002 function! s:snakecase(word)
                              let word = substitute(a:word,'::','/','g')
                              let word = substitute(word,'\(\u\+\)\(\u\l\)','\1_\2','g')
                              let word = substitute(word,'\(\l\|\d\)\(\u\)','\1_\2','g')
                              let word = substitute(word,'[.-]','_','g')
                              let word = tolower(word)
                              return word
                            endfunction
                            
    1              0.000002 function! s:uppercase(word)
                              return toupper(s:snakecase(a:word))
                            endfunction
                            
    1              0.000002 function! s:dashcase(word)
                              return substitute(s:snakecase(a:word),'_','-','g')
                            endfunction
                            
    1              0.000002 function! s:spacecase(word)
                              return substitute(s:snakecase(a:word),'_',' ','g')
                            endfunction
                            
    1              0.000002 function! s:dotcase(word)
                              return substitute(s:snakecase(a:word),'_','.','g')
                            endfunction
                            
    1              0.000002 function! s:titlecase(word)
                              return substitute(s:spacecase(a:word), '\(\<\w\)','\=toupper(submatch(1))','g')
                            endfunction
                            
    1   0.000250   0.000074 call extend(Abolish, {
                                  \ 'camelcase':  s:function('s:camelcase'),
                                  \ 'mixedcase':  s:function('s:mixedcase'),
                                  \ 'snakecase':  s:function('s:snakecase'),
                                  \ 'uppercase':  s:function('s:uppercase'),
                                  \ 'dashcase':   s:function('s:dashcase'),
                                  \ 'dotcase':    s:function('s:dotcase'),
                                  \ 'spacecase':  s:function('s:spacecase'),
                                  \ 'titlecase':  s:function('s:titlecase')
                                  \ }, 'keep')
                            
    1              0.000004 function! s:create_dictionary(lhs,rhs,opts)
                              let dictionary = {}
                              let i = 0
                              let expanded = s:expand_braces({a:lhs : a:rhs})
                              for [lhs,rhs] in items(expanded)
                                if get(a:opts,'case',1)
                                  let dictionary[s:mixedcase(lhs)] = s:mixedcase(rhs)
                                  let dictionary[tolower(lhs)] = tolower(rhs)
                                  let dictionary[toupper(lhs)] = toupper(rhs)
                                endif
                                let dictionary[lhs] = rhs
                              endfor
                              let i += 1
                              return dictionary
                            endfunction
                            
    1              0.000003 function! s:expand_braces(dict)
                              let new_dict = {}
                              for [key,val] in items(a:dict)
                                if key =~ '{.*}'
                                  let redo = 1
                                  let [all,kbefore,kmiddle,kafter;crap] = matchlist(key,'\(.\{-\}\){\(.\{-\}\)}\(.*\)')
                                  let [all,vbefore,vmiddle,vafter;crap] = matchlist(val,'\(.\{-\}\){\(.\{-\}\)}\(.*\)') + ["","","",""]
                                  if all == ""
                                    let [vbefore,vmiddle,vafter] = [val, ",", ""]
                                  endif
                                  let targets      = split(kmiddle,',',1)
                                  let replacements = split(vmiddle,',',1)
                                  if replacements == [""]
                                    let replacements = targets
                                  endif
                                  for i in range(0,len(targets)-1)
                                    let new_dict[kbefore.targets[i].kafter] = vbefore.replacements[i%len(replacements)].vafter
                                  endfor
                                else
                                  let new_dict[key] = val
                                endif
                              endfor
                              if exists("redo")
                                return s:expand_braces(new_dict)
                              else
                                return new_dict
                              endif
                            endfunction
                            
                            " }}}1
                            " Abolish Dispatcher {{{1
                            
    1              0.000003 function! s:SubComplete(A,L,P)
                              if a:A =~ '^[/?]\k\+$'
                                let char = strpart(a:A,0,1)
                                return join(map(s:words(),'char . v:val'),"\n")
                              elseif a:A =~# '^\k\+$'
                                return join(s:words(),"\n")
                              endif
                            endfunction
                            
    1              0.000002 function! s:Complete(A,L,P)
                              let g:L = a:L
                              " Vim bug: :Abolish -<Tab> calls this function with a:A equal to 0
                              if a:A =~# '^[^/?-]' && type(a:A) != type(0)
                                return join(s:words(),"\n")
                              elseif a:L =~# '^\w\+\s\+\%(-\w*\)\=$'
                                return "-search\n-substitute\n-delete\n-buffer\n-cmdline\n"
                              elseif a:L =~# ' -\%(search\|substitute\)\>'
                                return "-flags="
                              else
                                return "-buffer\n-cmdline"
                              endif
                            endfunction
                            
    1              0.000003 let s:commands = {}
    1   0.000016   0.000007 let s:commands.abstract = s:object.clone()
                            
    1              0.000003 function! s:commands.abstract.dispatch(bang,line1,line2,count,args)
                              return self.clone().go(a:bang,a:line1,a:line2,a:count,a:args)
                            endfunction
                            
    1              0.000003 function! s:commands.abstract.go(bang,line1,line2,count,args)
                              let self.bang = a:bang
                              let self.line1 = a:line1
                              let self.line2 = a:line2
                              let self.count = a:count
                              return self.process(a:bang,a:line1,a:line2,a:count,a:args)
                            endfunction
                            
    1              0.000003 function! s:dispatcher(bang,line1,line2,count,args)
                              let i = 0
                              let args = copy(a:args)
                              let command = s:commands.abbrev
                              while i < len(args)
                                if args[i] =~# '^-\w\+$' && has_key(s:commands,matchstr(args[i],'-\zs.*'))
                                  let command = s:commands[matchstr(args[i],'-\zs.*')]
                                  call remove(args,i)
                                  break
                                endif
                                let i += 1
                              endwhile
                              try
                                return command.dispatch(a:bang,a:line1,a:line2,a:count,args)
                              catch /^Abolish: /
                                echohl ErrorMsg
                                echo   v:errmsg
                                echohl NONE
                                return ""
                              endtry
                            endfunction
                            
                            " }}}1
                            " Subvert Dispatcher {{{1
                            
    1              0.000004 function! s:subvert_dispatcher(bang,line1,line2,count,args)
                              try
                                return s:parse_subvert(a:bang,a:line1,a:line2,a:count,a:args)
                              catch /^Subvert: /
                                echohl ErrorMsg
                                echo   v:errmsg
                                echohl NONE
                                return ""
                              endtry
                            endfunction
                            
    1              0.000003 function! s:parse_subvert(bang,line1,line2,count,args)
                              if a:args =~ '^\%(\w\|$\)'
                                let args = (a:bang ? "!" : "").a:args
                              else
                                let args = a:args
                              endif
                              let separator = matchstr(args,'^.')
                              let split = split(args,separator,1)[1:]
                              if a:count || split == [""]
                                return s:parse_substitute(a:bang,a:line1,a:line2,a:count,split)
                              elseif len(split) == 1
                                return s:find_command(separator,"",split[0])
                              elseif len(split) == 2 && split[1] =~# '^[A-Za-z]*n[A-Za-z]*$'
                                return s:parse_substitute(a:bang,a:line1,a:line2,a:count,[split[0],"",split[1]])
                              elseif len(split) == 2 && split[1] =~# '^[A-Za-z]*\%([+-]\d\+\)\=$'
                                return s:find_command(separator,split[1],split[0])
                              elseif len(split) >= 2 && split[1] =~# '^[A-Za-z]* '
                                let flags = matchstr(split[1],'^[A-Za-z]*')
                                let rest = matchstr(join(split[1:],separator),' \zs.*')
                                return s:grep_command(rest,a:bang,flags,split[0])
                              elseif len(split) >= 2 && separator == ' '
                                return s:grep_command(join(split[1:],' '),a:bang,"",split[0])
                              else
                                return s:parse_substitute(a:bang,a:line1,a:line2,a:count,split)
                              endif
                            endfunction
                            
    1              0.000003 function! s:normalize_options(flags)
                              if type(a:flags) == type({})
                                let opts = a:flags
                                let flags = get(a:flags,"flags","")
                              else
                                let opts = {}
                                let flags = a:flags
                              endif
                              let g:op1 = copy(opts)
                              if flags =~# 'w'
                                let opts.boundaries = 2
                              elseif flags =~# 'v'
                                let opts.boundaries = 1
                              elseif !has_key(opts,'boundaries')
                                let opts.boundaries = 0
                              endif
                              let opts.case = (flags !~# 'I' ? get(opts,'case',1) : 0)
                              let opts.flags = substitute(flags,'\C[avIiw]','','g')
                              let g:op2 = copy(opts)
                              return opts
                            endfunction
                            
                            " }}}1
                            " Searching {{{1
                            
    1              0.000002 function! s:subesc(pattern)
                              return substitute(a:pattern,'[][\\/.*+?~%()&]','\\&','g')
                            endfunction
                            
    1              0.000002 function! s:sort(a,b)
                              if a:a ==? a:b
                                return a:a == a:b ? 0 : a:a > a:b ? 1 : -1
                              elseif strlen(a:a) == strlen(a:b)
                                return a:a >? a:b ? 1 : -1
                              else
                                return strlen(a:a) < strlen(a:b) ? 1 : -1
                              endif
                            endfunction
                            
    1              0.000002 function! s:pattern(dict,boundaries)
                              if a:boundaries == 2
                                let a = '<'
                                let b = '>'
                              elseif a:boundaries
                                let a = '%(<|_@<=|[[:lower:]]@<=[[:upper:]]@=)'
                                let b =  '%(>|_@=|[[:lower:]]@<=[[:upper:]]@=)'
                              else
                                let a = ''
                                let b = ''
                              endif
                              return '\v\C'.a.'%('.join(map(sort(keys(a:dict),function('s:sort')),'s:subesc(v:val)'),'|').')'.b
                            endfunction
                            
    1              0.000002 function! s:egrep_pattern(dict,boundaries)
                              if a:boundaries == 2
                                let a = '\<'
                                let b = '\>'
                              elseif a:boundaries
                                let a = '(\<\|_)'
                                let b = '(\>\|_\|[[:upper:]][[:lower:]])'
                              else
                                let a = ''
                                let b = ''
                              endif
                              return a.'('.join(map(sort(keys(a:dict),function('s:sort')),'s:subesc(v:val)'),'\|').')'.b
                            endfunction
                            
    1              0.000005 function! s:c()
                              call histdel('search',-1)
                              return ""
                            endfunction
                            
    1              0.000005 function! s:find_command(cmd,flags,word)
                              let opts = s:normalize_options(a:flags)
                              let dict = s:create_dictionary(a:word,"",opts)
                              " This is tricky.  If we use :/pattern, the search drops us at the
                              " beginning of the line, and we can't use position flags (e.g., /foo/e).
                              " If we use :norm /pattern, we leave ourselves vulnerable to "press enter"
                              " prompts (even with :silent).
                              let cmd = (a:cmd =~ '[?!]' ? '?' : '/')
                              let @/ = s:pattern(dict,opts.boundaries)
                              if opts.flags == "" || !search(@/,'n')
                                return "norm! ".cmd."\<CR>"
                              elseif opts.flags =~ ';[/?]\@!'
                                call s:throw("E386: Expected '?' or '/' after ';'")
                              else
                                return "exe 'norm! ".cmd.cmd.opts.flags."\<CR>'|call histdel('search',-1)"
                                return ""
                              endif
                            endfunction
                            
    1              0.000007 function! s:grep_command(args,bang,flags,word)
                              let opts = s:normalize_options(a:flags)
                              let dict = s:create_dictionary(a:word,"",opts)
                              if &grepprg == "internal"
                                let lhs = "'".s:pattern(dict,opts.boundaries)."'"
                              else
                                let lhs = "-E '".s:egrep_pattern(dict,opts.boundaries)."'"
                              endif
                              return "grep".(a:bang ? "!" : "")." ".lhs." ".a:args
                            endfunction
                            
    1   0.000023   0.000012 let s:commands.search = s:commands.abstract.clone()
    1              0.000009 let s:commands.search.options = {"word": 0, "variable": 0, "flags": ""}
                            
    1              0.000007 function! s:commands.search.process(bang,line1,line2,count,args)
                              call s:extractopts(a:args,self.options)
                              if self.options.word
                                let self.options.flags .= "w"
                              elseif self.options.variable
                                let self.options.flags .= "v"
                              endif
                              let opts = s:normalize_options(self.options)
                              if len(a:args) > 1
                                return s:grep_command(join(a:args[1:]," "),a:bang,opts,a:args[0])
                              elseif len(a:args) == 1
                                return s:find_command(a:bang ? "!" : " ",opts,a:args[0])
                              else
                                call s:throw("E471: Argument required")
                              endif
                            endfunction
                            
                            " }}}1
                            " Substitution {{{1
                            
    1              0.000005 function! Abolished()
                              return get(g:abolish_last_dict,submatch(0),submatch(0))
                            endfunction
                            
    1              0.000004 function! s:substitute_command(cmd,bad,good,flags)
                              let opts = s:normalize_options(a:flags)
                              let dict = s:create_dictionary(a:bad,a:good,opts)
                              let lhs = s:pattern(dict,opts.boundaries)
                              let g:abolish_last_dict = dict
                              return a:cmd.'/'.lhs.'/\=Abolished()'."/".opts.flags
                            endfunction
                            
    1              0.000004 function! s:parse_substitute(bang,line1,line2,count,args)
                              if get(a:args,0,'') =~ '^[/?'']'
                                let separator = matchstr(a:args[0],'^.')
                                let args = split(join(a:args,' '),separator,1)
                                call remove(args,0)
                              else
                                let args = a:args
                              endif
                              if len(args) < 2
                                call s:throw("E471: Argument required")
                              elseif len(args) > 3
                                call s:throw("E488: Trailing characters")
                              endif
                              let [bad,good,flags] = (args + [""])[0:2]
                              if a:count == 0
                                let cmd = "substitute"
                              else
                                let cmd = a:line1.",".a:line2."substitute"
                              endif
                              return s:substitute_command(cmd,bad,good,flags)
                            endfunction
                            
    1   0.000020   0.000008 let s:commands.substitute = s:commands.abstract.clone()
    1              0.000006 let s:commands.substitute.options = {"word": 0, "variable": 0, "flags": "g"}
                            
    1              0.000003 function! s:commands.substitute.process(bang,line1,line2,count,args)
                              call s:extractopts(a:args,self.options)
                              if self.options.word
                                let self.options.flags .= "w"
                              elseif self.options.variable
                                let self.options.flags .= "v"
                              endif
                              let opts = s:normalize_options(self.options)
                              if len(a:args) <= 1
                                call s:throw("E471: Argument required")
                              else
                                let good = join(a:args[1:],"")
                                let cmd = a:bang ? "." : "%"
                                return s:substitute_command(cmd,a:args[0],good,self.options)
                              endif
                            endfunction
                            
                            " }}}1
                            " Abbreviations {{{1
                            
    1              0.000002 function! s:badgood(args)
                              let words = filter(copy(a:args),'v:val !~ "^-"')
                              call filter(a:args,'v:val =~ "^-"')
                              if empty(words)
                                call s:throw("E471: Argument required")
                              elseif !empty(a:args)
                                call s:throw("Unknown argument: ".a:args[0])
                              endif
                              let [bad; words] = words
                              return [bad, join(words," ")]
                            endfunction
                            
    1              0.000003 function! s:abbreviate_from_dict(cmd,dict)
                              for [lhs,rhs] in items(a:dict)
                                exe a:cmd lhs rhs
                              endfor
                            endfunction
                            
    1   0.000015   0.000006 let s:commands.abbrev     = s:commands.abstract.clone()
    1              0.000005 let s:commands.abbrev.options = {"buffer":0,"cmdline":0,"delete":0}
    1              0.000003 function! s:commands.abbrev.process(bang,line1,line2,count,args)
                              let args = copy(a:args)
                              call s:extractopts(a:args,self.options)
                              if self.options.delete
                                let cmd = "unabbrev"
                                let good = ""
                              else
                                let cmd = "noreabbrev"
                              endif
                              if !self.options.cmdline
                                let cmd = "i" . cmd
                              endif
                              if self.options.delete
                                let cmd = "silent! ".cmd
                              endif
                              if self.options.buffer
                                let cmd = cmd . " <buffer>"
                              endif
                              let [bad, good] = s:badgood(a:args)
                              if substitute(bad, '[{},]', '', 'g') !~# '^\k*$'
                                call s:throw("E474: Invalid argument (not a keyword: ".string(bad).")")
                              endif
                              if !self.options.delete && good == ""
                                call s:throw("E471: Argument required".a:args[0])
                              endif
                              let dict = s:create_dictionary(bad,good,self.options)
                              call s:abbreviate_from_dict(cmd,dict)
                              if a:bang
                                let i = 0
                                let str = "Abolish ".join(args," ")
                                let file = g:abolish_save_file
                                if !isdirectory(fnamemodify(file,':h'))
                                  call mkdir(fnamemodify(file,':h'),'p')
                                endif
                            
                                if filereadable(file)
                                  let old = readfile(file)
                                else
                                  let old = ["\" Exit if :Abolish isn't available.","if !exists(':Abolish')","    finish","endif",""]
                                endif
                                call writefile(old + [str],file)
                              endif
                              return ""
                            endfunction
                            
    1   0.000013   0.000004 let s:commands.delete   = s:commands.abbrev.clone()
    1              0.000004 let s:commands.delete.options.delete = 1
                            
                            " }}}1
                            " Maps {{{1
                            
    1              0.000004 function! s:unknown_coercion(letter,word)
                              return a:word
                            endfunction
                            
    1   0.000068   0.000033 call extend(Abolish.Coercions, {
                                  \ 'c': Abolish.camelcase,
                                  \ 'm': Abolish.mixedcase,
                                  \ 's': Abolish.snakecase,
                                  \ '_': Abolish.snakecase,
                                  \ 'u': Abolish.uppercase,
                                  \ 'U': Abolish.uppercase,
                                  \ '-': Abolish.dashcase,
                                  \ 'k': Abolish.dashcase,
                                  \ '.': Abolish.dotcase,
                                  \ ' ': Abolish.spacecase,
                                  \ 't': Abolish.titlecase,
                                  \ "function missing": s:function("s:unknown_coercion")
                                  \}, "keep")
                            
    1              0.000004 function! s:coerce(type) abort
                              if a:type !~# '^\%(line\|char\|block\)'
                                let s:transformation = a:type
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w*')
                                return 'g@'
                              endif
                              let selection = &selection
                              let clipboard = &clipboard
                              try
                                set selection=inclusive clipboard-=unnamed clipboard-=unnamedplus
                                let regbody = getreg('"')
                                let regtype = getregtype('"')
                                let c = v:count1
                                while c > 0
                                  let c -= 1
                                  if a:type ==# 'line'
                                    let move = "'[V']"
                                  elseif a:type ==# 'block'
                                    let move = "`[\<C-V>`]"
                                  else
                                    let move = "`[v`]"
                                  endif
                                  silent exe 'normal!' move.'y'
                                  let word = @@
                                  let @@ = s:send(g:Abolish.Coercions,s:transformation,word)
                                  if !exists('begin')
                                    let begin = getpos("'[")
                                  endif
                                  if word !=# @@
                                    let changed = 1
                                    exe 'normal!' move.'p'
                                  endif
                                endwhile
                                call setreg('"',regbody,regtype)
                                call setpos("'[",begin)
                                call setpos(".",begin)
                              finally
                                let &selection = selection
                                let &clipboard = clipboard
                              endtry
                            endfunction
                            
    1              0.000019 nnoremap <expr> <Plug>(abolish-coerce) <SID>coerce(nr2char(getchar()))
    1              0.000013 nnoremap <expr> <Plug>(abolish-coerce) <SID>coerce(nr2char(getchar()))
    1              0.000013 nnoremap <expr> <plug>(abolish-coerce-word) <sid>coerce(nr2char(getchar())).'iw'
                            
                            " }}}1
                            
    1              0.000006 if !exists("g:abolish_no_mappings") || ! g:abolish_no_mappings
    1              0.000009   nmap cr  <Plug>(abolish-coerce-word)
    1              0.000002 endif
                            
    1              0.000023 command! -nargs=+ -bang -bar -range=0 -complete=custom,s:Complete Abolish
                                  \ :exec s:dispatcher(<bang>0,<line1>,<line2>,<count>,[<f-args>])
    1              0.000020 command! -nargs=1 -bang -bar -range=0 -complete=custom,s:SubComplete Subvert
                                  \ :exec s:subvert_dispatcher(<bang>0,<line1>,<line2>,<count>,<q-args>)
    1              0.000004 if exists(':S') != 2
    1              0.000020   command -nargs=1 -bang -bar -range=0 -complete=custom,s:SubComplete S
                                    \ :exec s:subvert_dispatcher(<bang>0,<line1>,<line2>,<count>,<q-args>)
    1              0.000001 endif
                            
                            " vim:set ft=vim sw=2 sts=2:

SCRIPT  /home/c5262761/configit/vim/modules/vim-qf/plugin/qf.vim
Sourced 1 time
Total time:   0.000456
 Self time:   0.000456

count  total (s)   self (s)
                            " vim-qf - Tame the quickfix window
                            " Maintainer:	romainl <romainlafourcade@gmail.com>
                            " Version:	0.2.0
                            " License:	MIT
                            " Location:	plugin/qf.vim
                            " Website:	https://github.com/romainl/vim-qf
                            "
                            " Use this command to get help on vim-qf:
                            "
                            "     :help qf
                            "
                            " If this doesn't work and you installed vim-qf manually, use the following
                            " command to index vim-qf's documentation:
                            "
                            "     :helptags ~/.vim/doc
                            "
                            " or read your runtimepath/plugin manager documentation.
                            
    1              0.000020 if exists("g:loaded_qf") || v:version < 703 || &compatible
                                finish
    1              0.000001 endif
    1              0.000004 let g:loaded_qf = 1
                            
    1              0.000012 let s:save_cpo = &cpo
    1              0.000013 set cpo&vim
                            
                            " Kept for backward compatibility
    1              0.000027 nmap <silent>        <Plug>QfCprevious <Plug>(qf_qf_previous)
    1              0.000013 nmap <silent>        <Plug>QfCnext     <Plug>(qf_qf_next)
    1              0.000011 nmap <silent>        <Plug>QfLprevious <Plug>(qf_loc_previous)
    1              0.000011 nmap <silent>        <Plug>QfLnext     <Plug>(qf_loc_next)
    1              0.000011 nmap <silent>        <Plug>QfCtoggle   <Plug>(qf_qf_toggle)
    1              0.000011 nmap <silent>        <Plug>QfLtoggle   <Plug>(qf_loc_toggle)
    1              0.000011 nmap <silent> <expr> <Plug>QfSwitch    &filetype ==# 'qf' ? '<C-w>p' : '<C-w>b'
                            
                            " Go up and down quickfix list
    1              0.000013 nnoremap <silent>        <Plug>(qf_qf_previous)     :<C-u> call qf#wrap#WrapCommand('up', 'c')<CR>
    1              0.000012 nnoremap <silent>        <Plug>(qf_qf_next)         :<C-u> call qf#wrap#WrapCommand('down', 'c')<CR>
                            
                            " Go up and down location list
    1              0.000013 nnoremap <silent>        <Plug>(qf_loc_previous)    :<C-u> call qf#wrap#WrapCommand('up', 'l')<CR>
    1              0.000013 nnoremap <silent>        <Plug>(qf_loc_next)        :<C-u> call qf#wrap#WrapCommand('down', 'l')<CR>
                            
                            " Toggle quickfix list
    1              0.000012 nnoremap <silent>        <Plug>(qf_qf_toggle)       :<C-u> call qf#toggle#ToggleQfWindow(0)<CR>
    1              0.000012 nnoremap <silent>        <Plug>(qf_qf_toggle_stay)  :<C-u> call qf#toggle#ToggleQfWindow(1)<CR>
                            
                            " Toggle location list
    1              0.000012 nnoremap <silent>        <Plug>(qf_loc_toggle)      :<C-u> call qf#toggle#ToggleLocWindow(0)<CR>
    1              0.000012 nnoremap <silent>        <Plug>(qf_loc_toggle_stay) :<C-u> call qf#toggle#ToggleLocWindow(1)<CR>
                            
                            " Jump to and from list
    1              0.000011 nnoremap <silent> <expr> <Plug>(qf_qf_switch)       &filetype ==# 'qf' ? '<C-w>p' : '<C-w>b'
                            
                            " Move forward and backward in list history (in a quickfix or location window)
    1              0.000010 nnoremap <silent>        <Plug>(qf_older)           :<C-u> call qf#history#Older()<CR>
    1              0.000010 nnoremap <silent>        <Plug>(qf_newer)           :<C-u> call qf#history#Newer()<CR>
                            
    1              0.000002 augroup qf
    1              0.000064     autocmd!
                            
                                " automatically open the location/quickfix window after :make, :grep,
                                " :lvimgrep and friends if there are valid locations/errors
    1              0.000011     autocmd QuickFixCmdPost [^l]* nested call qf#OpenQuickfix()
    1              0.000007     autocmd QuickFixCmdPost    l* nested call qf#OpenLoclist()
    1              0.000006     autocmd VimEnter            * nested call qf#OpenQuickfix()
                            
                                " automatically close corresponding loclist when quitting a window
    1              0.000007     if exists('##QuitPre')
    1              0.000011         autocmd QuitPre * nested if &filetype != 'qf' | silent! lclose | endif
    1              0.000003     endif
    1              0.000002 augroup END
                            
    1              0.000020 let &cpo = s:save_cpo

SCRIPT  /home/c5262761/configit/vim/modules/vim-diction/plugin/diction.vim
Sourced 1 time
Total time:   0.000162
 Self time:   0.000162

count  total (s)   self (s)
                            " vim-diction
                            " Maintainer:	ntnn <nelo@wallus.de>
                            " Version:	4
                            " License:	MIT
                            " Website:	https://github.com/ntnn/vim-diction
                            
    1              0.000008 if exists("g:loaded_diction")
                                finish
    1              0.000002 endif
    1              0.000003 let g:loaded_diction = 1
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000010 let g:diction_db_sets = get(g:, 'diction_db_sets', {
                                        \ 'default': ['en', 'en-tech_words_to_avoid']
                                        \ })
    1              0.000004 let g:diction_active_set = get(g:, 'diction_active_set', 'default')
                            
    1              0.000007 command Diction     call diction#fill_list(1, 0)
    1              0.000007 command DictionAdd  call diction#fill_list(1, 1)
    1              0.000013 nnoremap <silent>   <Plug>Diction :Diction<cr>
    1              0.000010 nnoremap <silent>   <Plug>DictionAdd :DictionAdd<cr>
                            
    1              0.000006 command LDiction    call diction#fill_list(0, 0)
    1              0.000005 command LDictionAdd call diction#fill_list(0, 1)
    1              0.000009 nnoremap <silent>   <Plug>LDiction :LDiction<cr>
    1              0.000009 nnoremap <silent>   <Plug>LDictionAdd :LDictionAdd<cr>
                            
    1              0.000005 command DictionLog call diction#write_log_to_file()
    1              0.000005 command DictionIndex call diction#reindex()
                            
    1              0.000008 command -complete=customlist,diction#complete_db_sets -nargs=1 DictionSet call diction#set_active_set(<q-args>)
                            
    1              0.000010 let &cpo = s:save_cpo

SCRIPT  /home/c5262761/configit/vim/modules/vim-gutentags/plugin/gutentags.vim
Sourced 1 time
Total time:   0.000400
 Self time:   0.000400

count  total (s)   self (s)
                            " gutentags.vim - Automatic ctags management for Vim
                            " Maintainer:   Ludovic Chabant <http://ludovic.chabant.com>
                            " Version:      2.0.0
                            
                            " Globals {{{
                            
    1              0.000012 if (&cp || get(g:, 'gutentags_dont_load', 0))
                                finish
    1              0.000001 endif
                            
    1              0.000002 if v:version < 704
                                echoerr "gutentags: this plugin requires vim >= 7.4."
                                finish
    1              0.000001 endif
                            
    1              0.000006 if !(has('job') || (has('nvim') && exists('*jobwait')))
                                echoerr "gutentags: this plugin requires the job API from Vim8 or Neovim."
                                finish
    1              0.000001 endif
                            
    1              0.000005 let g:gutentags_debug = get(g:, 'gutentags_debug', 0)
                            
    1              0.000004 if (exists('g:loaded_gutentags') && !g:gutentags_debug)
                                finish
    1              0.000001 endif
    1              0.000003 if (exists('g:loaded_gutentags') && g:gutentags_debug)
                                echom "Reloaded gutentags."
    1              0.000001 endif
    1              0.000002 let g:loaded_gutentags = 1
                            
    1              0.000004 let g:gutentags_trace = get(g:, 'gutentags_trace', 0)
    1              0.000003 let g:gutentags_fake = get(g:, 'gutentags_fake', 0)
    1              0.000004 let g:gutentags_background_update = get(g:, 'gutentags_background_update', 1)
    1              0.000005 let g:gutentags_pause_after_update = get(g:, 'gutentags_pause_after_update', 0)
    1              0.000003 let g:gutentags_enabled = get(g:, 'gutentags_enabled', 1)
    1              0.000005 let g:gutentags_modules = get(g:, 'gutentags_modules', ['ctags'])
                            
    1              0.000007 let g:gutentags_init_user_func = get(g:, 'gutentags_init_user_func', 
                                        \get(g:, 'gutentags_enabled_user_func', ''))
                            
    1              0.000004 let g:gutentags_add_ctrlp_root_markers = get(g:, 'gutentags_add_ctrlp_root_markers', 1)
    1              0.000005 let g:gutentags_add_default_project_roots = get(g:, 'gutentags_add_default_project_roots', 1)
    1              0.000004 let g:gutentags_project_root = get(g:, 'gutentags_project_root', [])
    1              0.000002 if g:gutentags_add_default_project_roots
    1              0.000007     let g:gutentags_project_root += ['.git', '.hg', '.svn', '.bzr', '_darcs', '_FOSSIL_', '.fslckout']
    1              0.000001 endif
                            
    1              0.000004 let g:gutentags_project_root_finder = get(g:, 'gutentags_project_root_finder', '')
                            
    1              0.000004 let g:gutentags_project_info = get(g:, 'gutentags_project_info', [])
    1              0.000008 call add(g:gutentags_project_info, {'type': 'python', 'file': 'setup.py'})
    1              0.000004 call add(g:gutentags_project_info, {'type': 'ruby', 'file': 'Gemfile'})
                            
    1              0.000005 let g:gutentags_exclude_filetypes = get(g:, 'gutentags_exclude_filetypes', [])
    1              0.000005 let g:gutentags_exclude_project_root = get(g:, 'gutentags_exclude_project_root', ['/usr/local'])
    1              0.000004 let g:gutentags_resolve_symlinks = get(g:, 'gutentags_resolve_symlinks', 0)
    1              0.000004 let g:gutentags_generate_on_new = get(g:, 'gutentags_generate_on_new', 1)
    1              0.000004 let g:gutentags_generate_on_missing = get(g:, 'gutentags_generate_on_missing', 1)
    1              0.000004 let g:gutentags_generate_on_write = get(g:, 'gutentags_generate_on_write', 1)
    1              0.000005 let g:gutentags_generate_on_empty_buffer = get(g:, 'gutentags_generate_on_empty_buffer', 0)
    1              0.000004 let g:gutentags_file_list_command = get(g:, 'gutentags_file_list_command', '')
                            
    1              0.000005 let g:gutentags_use_jobs = get(g:, 'gutentags_use_jobs', has('job'))
                            
    1              0.000003 if !exists('g:gutentags_cache_dir')
                                let g:gutentags_cache_dir = ''
    1              0.000003 elseif !empty(g:gutentags_cache_dir)
                                " Make sure we get an absolute/resolved path (e.g. expanding `~/`), and
                                " strip any trailing slash.
    1              0.000012     let g:gutentags_cache_dir = fnamemodify(g:gutentags_cache_dir, ':p')
    1              0.000032     let g:gutentags_cache_dir = fnamemodify(g:gutentags_cache_dir, ':s?[/\\]$??')
    1              0.000002 endif
                            
    1              0.000006 let g:gutentags_define_advanced_commands = get(g:, 'gutentags_define_advanced_commands', 0)
                            
    1              0.000007 if g:gutentags_cache_dir != '' && !isdirectory(g:gutentags_cache_dir)
                                call mkdir(g:gutentags_cache_dir, 'p')
    1              0.000001 endif
                            
    1              0.000005 if has('win32')
                                let g:gutentags_plat_dir = expand('<sfile>:h:h:p') . "\\plat\\win32\\"
                                let g:gutentags_res_dir = expand('<sfile>:h:h:p') . "\\res\\"
                                let g:gutentags_script_ext = '.cmd'
    1              0.000001 else
    1              0.000007     let g:gutentags_plat_dir = expand('<sfile>:h:h:p') . '/plat/unix/'
    1              0.000005     let g:gutentags_res_dir = expand('<sfile>:h:h:p') . '/res/'
    1              0.000003     let g:gutentags_script_ext = '.sh'
    1              0.000001 endif
                            
                            " }}}
                            
                            " Gutentags Setup {{{
                            
    1              0.000003 augroup gutentags_detect
    1              0.000062     autocmd!
    1              0.000010     autocmd BufNewFile,BufReadPost *  call gutentags#setup_gutentags()
    1              0.000007     autocmd VimEnter               *  if expand('<amatch>')==''|call gutentags#setup_gutentags()|endif
    1              0.000002 augroup end
                            
                            " }}}
                            
                            " Toggles and Miscellaneous Commands {{{
                            
    1              0.000003 if g:gutentags_define_advanced_commands
                                command! GutentagsToggleEnabled :let g:gutentags_enabled=!g:gutentags_enabled
                                command! GutentagsToggleTrace   :call gutentags#toggletrace()
    1              0.000001 endif
                            
    1              0.000001 if g:gutentags_debug
                                command! GutentagsToggleFake    :call gutentags#fake()
    1              0.000000 endif
                            
                            " }}}
                            

SCRIPT  /home/c5262761/configit/vim/modules/tlib_vim/plugin/02tlib.vim
Sourced 1 time
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
                            " @Author:      Tom Link (micathom AT gmail com?subject=[vim])
                            " @Created:     2007-04-10.
                            " @Last Change: 2019-04-09.
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Revision:    836
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " GetLatestVimScripts: 1863 1 tlib.vim
                            " tlib.vim -- Some utility functions
                            
    1              0.000017 if &cp || exists("g:loaded_tlib")
                                finish
    1              0.000001 endif
    1              0.000002 if v:version < 700 "{{{2
                                echoerr "tlib requires Vim >= 7"
                                finish
    1              0.000001 endif
    1              0.000003 let g:loaded_tlib = 127
                            
    1              0.000007 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            
                            
                            " :display: :TLet VAR = VALUE
                            " Set a variable only if it doesn't already exist.
                            " EXAMPLES: >
                            "   TLet foo = 1
                            "   TLet foo = 2
                            "   echo foo
                            "   => 1
    1              0.000016 command! -nargs=+ TLet if !exists(matchstr(<q-args>, '^[^=[:space:]]\+')) | exec 'let '. <q-args> | endif
                            
                            
                            " Open a scratch buffer (a buffer without a file).
                            "   TScratch  ... use split window
                            "   TScratch! ... use the whole frame
                            " This command takes an (inner) dictionary as optional argument.
                            " EXAMPLES: >
                            "   TScratch 'scratch': '__FOO__'
                            "   => Open a scratch buffer named __FOO__
    1              0.000015 command! -bar -nargs=* -bang TScratch call tlib#scratch#UseScratch({'scratch_split': empty('<bang>'), <args>})
                            
                            
                            " :display: :TVarArg VAR1, [VAR2, DEFAULT2] ...
                            " A convenience wrapper for |tlib#arg#Let|.
                            " EXAMPLES: >
                            "   function! Foo(...)
                            "       TVarArg ['a', 1], 'b'
                            "       echo 'a='. a
                            "       echo 'b='. b
                            "   endf
    1              0.000008 command! -nargs=+ TVarArg exec tlib#arg#Let([<args>])
                            
                            
                            " :display: :TBrowseOutput COMMAND
                            " Ever wondered how to efficiently browse the output of a command 
                            " without redirecting it to a file? This command takes a command as 
                            " argument and presents the output via |tlib#input#List()| so that you 
                            " can easily search for a keyword (e.g. the name of a variable or 
                            " function) and the like.
                            "
                            " If you press enter, the selected line will be copied to the command 
                            " line. Press ESC to cancel browsing.
                            "
                            " EXAMPLES: >
                            "   TBrowseOutput 20verb TeaseTheCulprit
    1              0.000007 command! -nargs=1 -complete=command TBrowseOutput call tlib#cmd#BrowseOutput(<q-args>)
                            
                            
                            " :display: :TBrowseScriptnames
                            " List all sourced script names (the output of ':scriptnames').
                            "
                            " When you press enter, the selected script will be opened in the current
                            " window. Press ESC to cancel.
                            "
                            " EXAMPLES: >
                            "   TBrowseScriptnames 
    1              0.000006 command! -nargs=0 -complete=command TBrowseScriptnames call tlib#cmd#TBrowseScriptnames()
                            
                            
                            " :display: :Texecqfl CMD
                            " Run CMD and display the quickfix list.
    1              0.000009 command! -nargs=1 Texecqfl <args> | call tlib#qfl#QflList(getqflist())
                            
                            
                            " :display: :Texecloc CMD
                            " Run CMD and display the quickfix list.
    1              0.000009 command! -nargs=1 Texecloc <args> | call tlib#qfl#QflList(getloclist(0))
                            
                            
                            " :display: :Tlibtrace GUARD, VAR1, VAR2...
                            " Do nothing unless |tlib#trace#Enable()| was called.
                            " 
                            " When |:Tlibtraceset| or |tlib#trace#Enable()| were called:
                            "
                            " If GUARD is a number that evaluates to true or if it is a string that 
                            " matches a |regexp|, which was added using Tlibtrace! (with '!'), 
                            " display the values of VAR1, VAR2 ...
    1              0.000003 command! -nargs=+ -bang Tlibtrace :
                            
                            
                            " :Tlibtraceset[!] [--file=FILE] +RX1 -RX2...
                            " If |tlib#trace#Enable()| was called: With the optional <bang>, users 
                            " can add and remove GUARDs (actually a |regexp|) that should be traced.
                            "
                            " If no `+` or `-` is prepended, assume `+`.
                            "
                            " With the optional bang '!', reset any options.
    1              0.000014 command! -nargs=+ -bang Tlibtraceset call tlib#trace#Set(tlib#arg#GetOpts([<f-args>], {'short': 0}), !empty("<bang>"))
                            
                            
                            " :display: :Tlibtrace ASSERTION
    1              0.000003 command! -nargs=+ -bang Tlibassert :
                            
                            " :display: :Tlibtype val, 'type', ...
    1              0.000002 command! -nargs=+ Tlibtype :
                            
                            
                            " Browse the current |quickfix| list.
    1              0.000004 command! -bar Tbrowseqfl call tlib#qfl#Browse()
                            
                            " Browse the current |location-list|.
    1              0.000014 command! -bar Tbrowseloc call tlib#loclist#Browse()
                            
                            
    1              0.000008 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/c5262761/configit/vim/modules/vim-snipmate/plugin/snipMate.vim
Sourced 1 time
Total time:   0.000774
 Self time:   0.000620

count  total (s)   self (s)
                            " File:          snipMate.vim
                            " Description:   snipMate.vim implements some of TextMate's snippets features in
                            "                Vim. A snippet is a piece of often-typed text that you can
                            "                insert into your document using a trigger word followed by a "<tab>".
                            "
                            "                For more help see snipMate.txt; you can do this by using:
                            "                :helptags ~/.vim/doc
                            "                :h SnipMate
                            
    1              0.000013 if exists('loaded_snips') || &cp || version < 700
                            	finish
    1              0.000001 endif
    1              0.000003 let loaded_snips = 1
                            
                            " Save and reset 'cpo'
    1              0.000005 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000002 try
    1   0.000315   0.000187 	call funcref#Function('')
                            catch /.*/
                            	echoe "you're missing vim-addon-mw-utils. See install instructions at ".expand('<sfile>:h:h').'/README.md'
    1              0.000002 endtry
                            
    1              0.000014 if (!exists('g:snipMateSources'))
    1              0.000003   let g:snipMateSources = {}
                              " Default source: get snippets based on runtimepath
    1   0.000015   0.000007   let g:snipMateSources['default'] = funcref#Function('snipMate#DefaultPool')
    1              0.000001 endif
                            
    1              0.000002 augroup SnipMateDetect
    1              0.000017 	au BufRead,BufNewFile *.snippet,*.snippets setlocal filetype=snippets
    1              0.000010 	au FileType snippets if expand('<afile>:e') =~# 'snippet$'
                            				\ | setlocal syntax=snippet
                            				\ | else
                            					\ | setlocal syntax=snippets
                            					\ | endif
    1              0.000001 augroup END
                            
    1              0.000018 inoremap <silent> <Plug>snipMateNextOrTrigger  <C-R>=snipMate#TriggerSnippet()<CR>
    1              0.000015 snoremap <silent> <Plug>snipMateNextOrTrigger  <Esc>a<C-R>=snipMate#TriggerSnippet()<CR>
    1              0.000012 inoremap <silent> <Plug>snipMateTrigger        <C-R>=snipMate#TriggerSnippet(1)<CR>
    1              0.000011 inoremap <silent> <Plug>snipMateBack           <C-R>=snipMate#BackwardsSnippet()<CR>
    1              0.000013 snoremap <silent> <Plug>snipMateBack           <Esc>a<C-R>=snipMate#BackwardsSnippet()<CR>
    1              0.000011 inoremap <silent> <Plug>snipMateShow           <C-R>=snipMate#ShowAvailableSnips()<CR>
    1              0.000014 xnoremap <silent> <Plug>snipMateVisual         :<C-U>call <SID>grab_visual()<CR>gv"_c
                            
                            " config variables
    1              0.000004 if !exists('g:snips_author')
    1              0.000003 	let g:snips_author = 'Me'
    1              0.000001 endif
    1              0.000003 if !exists('g:snipMate')
                            	let g:snipMate = {}
    1              0.000001 endif
                            
                            " SnipMate inserts this string when no snippet expansion can be done
    1              0.000007 let g:snipMate['no_match_completion_feedkeys_chars'] =
                            			\ get(g:snipMate, 'no_match_completion_feedkeys_chars', "\t")
                            
                            " Add default scope aliases, without overriding user settings
    1              0.000005 let g:snipMate.scope_aliases = get(g:snipMate, 'scope_aliases', {})
    1              0.000003 if exists('g:snipMate_no_default_aliases')
                            	echom 'The g:snipMate_no_default_aliases option has been renamed.'
                            				\ 'See :h snipMate-options.'
    1              0.000001 endif
    1              0.000009 if (!exists('g:snipMate_no_default_aliases') || !g:snipMate_no_default_aliases)
                            			\ && (!exists('g:snipMate.no_default_aliases')
                            				\ || !g:snipMate.no_default_aliases)
    1              0.000006 	let g:snipMate.scope_aliases.objc =
                            				\ get(g:snipMate.scope_aliases, 'objc', 'c')
    1              0.000005 	let g:snipMate.scope_aliases.cpp =
                            				\ get(g:snipMate.scope_aliases, 'cpp', 'c')
    1              0.000005 	let g:snipMate.scope_aliases.cu =
                            				\ get(g:snipMate.scope_aliases, 'cu', 'c')
    1              0.000005 	let g:snipMate.scope_aliases.xhtml =
                            				\ get(g:snipMate.scope_aliases, 'xhtml', 'html')
    1              0.000005 	let g:snipMate.scope_aliases.html =
                            				\ get(g:snipMate.scope_aliases, 'html', 'javascript')
    1              0.000006 	let g:snipMate.scope_aliases.php =
                            				\ get(g:snipMate.scope_aliases, 'php', 'php,html,javascript')
    1              0.000005 	let g:snipMate.scope_aliases.ur =
                            				\ get(g:snipMate.scope_aliases, 'ur', 'html,javascript')
    1              0.000005 	let g:snipMate.scope_aliases.mxml =
                            				\ get(g:snipMate.scope_aliases, 'mxml', 'actionscript')
    1              0.000005 	let g:snipMate.scope_aliases.eruby =
                            				\ get(g:snipMate.scope_aliases, 'eruby', 'eruby-rails,html')
    1              0.000005 	let g:snipMate.scope_aliases.scss =
                            				\ get(g:snipMate.scope_aliases, 'scss', 'css')
    1              0.000005 	let g:snipMate.scope_aliases.less =
                            				\ get(g:snipMate.scope_aliases, 'less', 'css')
    1              0.000001 endif
                            
    1   0.000018   0.000009 let g:snipMate['get_snippets'] = get(g:snipMate, 'get_snippets', funcref#Function("snipMate#GetSnippets"))
                            
                            " List of paths where snippets/ dirs are located
    1              0.000008 if exists('g:snipMate.snippet_dirs') && type(g:snipMate['snippet_dirs']) != type([])
                            	echohl WarningMsg
                            	echom "g:snipMate['snippet_dirs'] must be a List"
                            	echohl None
    1              0.000001 endif
                            
                            " _ is default scope added always
                            "
                            " &ft honors multiple filetypes and syntax such as in set ft=html.javascript syntax=FOO
    1   0.000018   0.000009 let g:snipMate['get_scopes'] = get(g:snipMate, 'get_scopes', funcref#Function('return split(&ft,"\\.")+[&syntax, "_"]'))
                            
                            " Modified from Luc Hermitte's function on StackOverflow
                            " <http://stackoverflow.com/a/1534347>
    1              0.000004 function! s:grab_visual() abort
                            	let a_save = @a
                            	try
                            		normal! gv"ay
                            		let b:snipmate_visual = @a
                            	finally
                            		let @a = a_save
                            	endtry
                            endfunction
                            
                            " TODO: Allow specifying an arbitrary snippets file
    1              0.000003 function! s:load_scopes(bang, ...) abort
                            	let gb = a:bang ? g: : b:
                            	let gb.snipMate = get(gb, 'snipMate', {})
                            	let gb.snipMate.scope_aliases = get(gb.snipMate, 'scope_aliases', {})
                            	let gb.snipMate.scope_aliases['_'] = join(split(get(gb.snipMate.scope_aliases, '_', ''), ',') + a:000, ',')
                            endfunction
                            
    1              0.000012 command! -bang -bar -nargs=+ SnipMateLoadScope
                            			\ call s:load_scopes(<bang>0, <f-args>)
                            
                            " Edit snippet files
    1              0.000006 command! SnipMateOpenSnippetFiles call snipMate#OpenSnippetFiles()
                            
                            " restore 'cpo'
    1              0.000010 let &cpo = s:save_cpo
                            
                            " vim:noet:sw=4:ts=4:ft=vim

SCRIPT  /home/c5262761/configit/vim/modules/vim-addon-mw-utils/autoload/funcref.vim
Sourced 1 time
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
                            " funcref.vim
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Last Change: 2010-01-03.
                            " @Revision:    0.1.0
                            
                            " documentation see doc/funcref.txt
                            
                            " usage:
                            "  funcref#Function("filename#Function")
                            "  optionally pass arguments:
                            "  funcref#Function("filename#Function",{'args': [2]})
                            "  optionally define self:
                            "  funcref#Function("filename#Function",{'self': object})
    1              0.000005 function! funcref#Function(name,...)
                              let d = a:0 > 0 ? a:1 : {}
                              let d['faked_function_reference'] = a:name
                              return d
                            endfunction
                            
                            " args : same as used for call(f,[args], self)
                            " f must be either
                            "   - a string which can be evaled (use "return 'value'" to return a value)
                            "   - a Vim function reference created by function('..')
                            "   - a faked function reference created by funcref#Function(..)
                            "
                            " the last "self" argument can be overriden by the function reference
                            " You can pass arguments in a closure like style
    1              0.000002 function! funcref#Call(...)
                              let args = copy(a:000)
                            
                              " add parameters:
                              if (len(args) < 2)
                                call add(args, [])
                              endif
                            
                            
                              let isDict = type(args[0]) == type({})
                            
                              " prepend parameters which were passed by faked function reference:
                              if isDict &&  has_key(args[0], 'args')
                                let args[1] = args[0]['args']+args[1]
                              endif
                            
                              " always pass self. this way you can call functions from dictionaries not
                              " refering to self
                              if (len(args) < 3)
                                call add(args, {})
                              endif
                            
                              " the funcref overrides self:
                              if isDict && has_key(args[0], 'self')
                                let args[2] = args[0]['self']
                              endif
                            
                              if type(a:1) == 2
                                " funcref: function must have been laoded
                                return call(function('call'), args)
                              elseif isDict && has_key(args[0], 'faked_function_reference')
                                let Fun = args[0]['faked_function_reference']
                                if type(Fun) == type('')
                                    \ && (Fun[:len('return ')-1] == 'return ' 
                                          \ || Fun[:len('call ')-1] == 'call '
                                          \ || Fun[:len('if ')-1] == 'if '
                                          \ || Fun[:len('let ')-1] == 'let '
                                          \ || Fun[:len('echo ')-1] == 'echo '
                                          \ || Fun[:len('exec ')-1] == 'exec '
                                          \ || Fun[:len('debug ')-1] == 'debug ')
                                  " it doesn't make sense to list all vim commands here
                                  " So if you want to execute another action consider using 
                                  " funcref#Function('exec  '.string('aw')) or such
                            
                                  " function is a String, call exec
                                  let ARGS = args[1]
                                  let SELF = args[2]
                                  exec Fun
                                else 
                                  " pseudo function, let's load it..
                                  if type(Fun) == 1
                                    if !exists('*'.Fun)
                                      " lazily load function
                                      let file = substitute(substitute(Fun,'#[^#]*$','',''),'#','/','g')
                                      exec 'runtime /autoload/'.file.'.vim'
                                    endif
                                    let Fun2 = function(Fun)
                                  else
                                    let Fun2 = Fun
                                  endif
                                  let args[0] = Fun
                                  return call(function('call'), args)
                                endif
                              else
                                " no function, return the value
                                return args[0]
                              endif
                            endfunction

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/plugin/go.vim
Sourced 1 time
Total time:   0.002606
 Self time:   0.000705

count  total (s)   self (s)
                            " install necessary Go tools
    1              0.000008 if exists("g:go_loaded_install")
                              finish
    1              0.000001 endif
    1              0.000003 let g:go_loaded_install = 1
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000007 let s:cpo_save = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000005 function! s:checkVersion() abort
                              " Not using the has('patch-7.4.2009') syntax because that wasn't added until
                              " 7.4.237, and we want to be sure this works for everyone (this is also why
                              " we're not using utils#EchoError()).
                              "
                              " Version 7.4.2009 was chosen because that's greater than what the most recent Ubuntu LTS
                              " release (16.04) uses and has a couple of features we need (e.g. execute()
                              " and :message clear).
                            
                              let l:unsupported = 0
                              if go#config#VersionWarning() != 0
                                if has('nvim')
                                  let l:unsupported = !has('nvim-0.3.2')
                                else
                                  let l:unsupported = (v:version < 704 || (v:version == 704 && !has('patch2009')))
                                endif
                            
                                if l:unsupported == 1
                                  echohl Error
                                  echom "vim-go requires Vim 7.4.2009 or Neovim 0.3.2, but you're using an older version."
                                  echom "Please update your Vim for the best vim-go experience."
                                  echom "If you really want to continue you can set this to make the error go away:"
                                  echom "    let g:go_version_warning = 0"
                                  echom "Note that some features may error out or behave incorrectly."
                                  echom "Please do not report bugs unless you're using Vim 7.4.2009 or newer or Neovim 0.3.2."
                                  echohl None
                            
                                  " Make sure people see this.
                                  sleep 2
                                endif
                              endif
                            endfunction
                            
    1   0.001184   0.000007 call s:checkVersion()
                            
                            " these packages are used by vim-go and can be automatically installed if
                            " needed by the user with GoInstallBinaries.
    1              0.000058 let s:packages = {
                                  \ 'asmfmt':        ['github.com/klauspost/asmfmt/cmd/asmfmt'],
                                  \ 'dlv':           ['github.com/go-delve/delve/cmd/dlv'],
                                  \ 'errcheck':      ['github.com/kisielk/errcheck'],
                                  \ 'fillstruct':    ['github.com/davidrjenni/reftools/cmd/fillstruct'],
                                  \ 'gocode':        ['github.com/mdempsky/gocode', {'windows': ['-ldflags', '-H=windowsgui']}],
                                  \ 'gocode-gomod':  ['github.com/stamblerre/gocode'],
                                  \ 'godef':         ['github.com/rogpeppe/godef'],
                                  \ 'gogetdoc':      ['github.com/zmb3/gogetdoc'],
                                  \ 'goimports':     ['golang.org/x/tools/cmd/goimports'],
                                  \ 'golint':        ['golang.org/x/lint/golint'],
                                  \ 'gopls':         ['golang.org/x/tools/gopls@latest', {}, {'after': function('go#lsp#Restart', [])}],
                                  \ 'gometalinter':  ['github.com/alecthomas/gometalinter'],
                                  \ 'golangci-lint': ['github.com/golangci/golangci-lint/cmd/golangci-lint'],
                                  \ 'gomodifytags':  ['github.com/fatih/gomodifytags'],
                                  \ 'gorename':      ['golang.org/x/tools/cmd/gorename'],
                                  \ 'gotags':        ['github.com/jstemmer/gotags'],
                                  \ 'guru':          ['golang.org/x/tools/cmd/guru'],
                                  \ 'impl':          ['github.com/josharian/impl'],
                                  \ 'keyify':        ['honnef.co/go/tools/cmd/keyify'],
                                  \ 'motion':        ['github.com/fatih/motion'],
                                  \ 'iferr':         ['github.com/koron/iferr'],
                            \ }
                            
                            " These commands are available on any filetypes
    1              0.000010 command! -nargs=* -complete=customlist,s:complete GoInstallBinaries call s:GoInstallBinaries(-1, <f-args>)
    1              0.000008 command! -nargs=* -complete=customlist,s:complete GoUpdateBinaries  call s:GoInstallBinaries(1, <f-args>)
    1              0.000007 command! -nargs=? -complete=dir GoPath call go#path#GoPath(<f-args>)
                            
    1              0.000004 fun! s:complete(lead, cmdline, cursor)
                              return filter(keys(s:packages), 'strpart(v:val, 0, len(a:lead)) == a:lead')
                            endfun
                            
                            " GoInstallBinaries downloads and installs binaries defined in s:packages to
                            " $GOBIN or $GOPATH/bin. GoInstallBinaries will update already installed
                            " binaries only if updateBinaries = 1. By default, all packages in s:packages
                            " will be installed, but the set can be limited by passing the desired
                            " packages in the unnamed arguments.
    1              0.000003 function! s:GoInstallBinaries(updateBinaries, ...)
                              let err = s:CheckBinaries()
                              if err != 0
                                return
                              endif
                            
                              if go#path#Default() == ""
                                echohl Error
                                echomsg "vim.go: $GOPATH is not set and 'go env GOPATH' returns empty"
                                echohl None
                                return
                              endif
                            
                              let go_bin_path = go#path#BinPath()
                            
                              " change $GOBIN so go get can automatically install to it
                              let $GOBIN = go_bin_path
                            
                              " vim's executable path is looking in PATH so add our go_bin path to it
                              let Restore_path = go#util#SetEnv('PATH', go_bin_path . go#util#PathListSep() . $PATH)
                            
                              " when shellslash is set on MS-* systems, shellescape puts single quotes
                              " around the output string. cmd on Windows does not handle single quotes
                              " correctly. Unsetting shellslash forces shellescape to use double quotes
                              " instead.
                              let resetshellslash = 0
                              if has('win32') && &shellslash
                                let resetshellslash = 1
                                set noshellslash
                              endif
                            
                              let l:get_base_cmd = ['go', 'get', '-v']
                            
                              " Filter packages from arguments (if any).
                              let l:packages = {}
                              if a:0 > 0
                                for l:bin in a:000
                                  let l:pkg = get(s:packages, l:bin, [])
                                  if len(l:pkg) == 0
                                    call go#util#EchoError('unknown binary: ' . l:bin)
                                    return
                                  endif
                                  let l:packages[l:bin] = l:pkg
                                endfor
                              else
                                let l:packages = s:packages
                              endif
                            
                              let l:platform = ''
                              if go#util#IsWin()
                                let l:platform = 'windows'
                              endif
                            
                              let l:oldmore = &more
                              let &more = 0
                            
                              for [l:binary, l:pkg] in items(l:packages)
                                let l:importPath = l:pkg[0]
                            
                                " TODO(bc): how to support this with modules? Do we have to clone and then
                                " install manually? Probably not. I suspect that we can just use GOPATH
                                " mode and then do the legacy method.
                                let bin_setting_name = "go_" . l:binary . "_bin"
                            
                                if exists("g:{bin_setting_name}")
                                  let bin = g:{bin_setting_name}
                                else
                                  if go#util#IsWin()
                                    let bin = l:binary . '.exe'
                                  else
                                    let bin = l:binary
                                  endif
                                endif
                            
                                if !executable(bin) || a:updateBinaries == 1
                                  if a:updateBinaries == 1
                                    echo "vim-go: Updating " . l:binary . ". Reinstalling ". importPath . " to folder " . go_bin_path
                                  else
                                    echo "vim-go: ". l:binary ." not found. Installing ". importPath . " to folder " . go_bin_path
                                  endif
                            
                                  if l:importPath =~ "@"
                                    let Restore_modules = go#util#SetEnv('GO111MODULE', 'on')
                                    let l:tmpdir = go#util#tempdir('vim-go')
                                    let l:cd = exists('*haslocaldir') && haslocaldir() ? 'lcd ' : 'cd '
                                    let l:dir = getcwd()
                                    try
                                      execute l:cd . fnameescape(l:tmpdir)
                                      let l:get_cmd = copy(l:get_base_cmd)
                            
                                      " first download the binary
                                      let [l:out, l:err] = go#util#Exec(l:get_cmd + [l:importPath])
                                      if l:err
                                        echom "Error installing " . l:importPath . ": " . l:out
                                      endif
                            
                                      call call(Restore_modules, [])
                                    finally
                                      execute l:cd . fnameescape(l:dir)
                                    endtry
                                    call call(Restore_modules, [])
                                  else
                                    let l:get_cmd = copy(l:get_base_cmd)
                                    let l:get_cmd += ['-d']
                                    if get(g:, "go_get_update", 1) != 0
                                      let l:get_cmd += ['-u']
                                    endif
                            
                                    " GO111MODULE must be off to install gometalinter.
                                    let Restore_modules = go#util#SetEnv('GO111MODULE', 'off')
                            
                                    " first download the binary
                                    let [l:out, l:err] = go#util#Exec(l:get_cmd + [l:importPath])
                                    if l:err
                                      echom "Error downloading " . l:importPath . ": " . l:out
                                    endif
                            
                                    " and then build and install it
                                    let l:build_cmd = ['go', 'build', '-o', go_bin_path . go#util#PathSep() . bin, l:importPath]
                                    if len(l:pkg) > 1 && get(l:pkg[1], l:platform, '') isnot ''
                                      let l:build_cmd += get(l:pkg[1], l:platform, '')
                                    endif
                            
                                    let [l:out, l:err] = go#util#Exec(l:build_cmd)
                                    if l:err
                                      echom "Error installing " . l:importPath . ": " . l:out
                                    endif
                            
                            
                                    call call(Restore_modules, [])
                                  endif
                            
                                  if len(l:pkg) > 2
                                    call call(get(l:pkg[2], 'after', function('s:noop', [])), [])
                                  endif
                                endif
                              endfor
                            
                              " restore back!
                              call call(Restore_path, [])
                            
                              if resetshellslash
                                set shellslash
                              endif
                            
                              if a:updateBinaries == 1
                                call go#util#EchoInfo('updating finished!')
                              else
                                call go#util#EchoInfo('installing finished!')
                              endif
                            
                              let &more = l:oldmore
                            endfunction
                            
                            " CheckBinaries checks if the necessary binaries to install the Go tool
                            " commands are available.
    1              0.000003 function! s:CheckBinaries()
                              if !executable('go')
                                echohl Error | echomsg "vim-go: go executable not found." | echohl None
                                return -1
                              endif
                            
                              if !executable('git')
                                echohl Error | echomsg "vim-go: git executable not found." | echohl None
                                return -1
                              endif
                            endfunction
                            
                            " Autocommands
                            " ============================================================================
                            "
                            
                            " We take care to preserve the user's fileencodings and fileformats,
                            " because those settings are global (not buffer local), yet we want
                            " to override them for loading Go files, which are defined to be UTF-8.
    1              0.000003 let s:current_fileformats = ''
    1              0.000003 let s:current_fileencodings = ''
                            
                            " define fileencodings to open as utf-8 encoding even if it's ascii.
    1              0.000002 function! s:gofiletype_pre()
                              let s:current_fileformats = &g:fileformats
                              let s:current_fileencodings = &g:fileencodings
                              set fileencodings=utf-8 fileformats=unix
                            endfunction
                            
                            " restore fileencodings as others
    1              0.000002 function! s:gofiletype_post()
                              let &g:fileformats = s:current_fileformats
                              let &g:fileencodings = s:current_fileencodings
                            endfunction
                            
    1              0.000002 function! s:register()
                              if !(&modifiable && expand('<amatch>') ==# 'go')
                                return
                              endif
                            
                              let l:RestoreGopath = function('s:noop')
                              if go#config#AutodetectGopath()
                                let l:RestoreGopath = go#util#SetEnv('GOPATH', go#path#Detect())
                              endif
                              call go#lsp#DidOpen(expand('<afile>:p'))
                              call call(l:RestoreGopath, [])
                            endfunction
                            
    1              0.000002 function! s:noop(...) abort
                            endfunction
                            
    1              0.000002 augroup vim-go
    1              0.000064   autocmd!
                            
    1              0.000011   autocmd BufNewFile *.go if &modifiable | setlocal fileencoding=utf-8 fileformat=unix | endif
    1              0.000004   autocmd BufNewFile *.go call go#auto#template_autocreate()
    1              0.000005   autocmd BufRead *.go call s:gofiletype_pre()
    1              0.000003   autocmd BufReadPost *.go call s:gofiletype_post()
                            
    1              0.000005   autocmd BufNewFile *.s if &modifiable | setlocal fileencoding=utf-8 fileformat=unix | endif
    1              0.000005   autocmd BufRead *.s call s:gofiletype_pre()
    1              0.000003   autocmd BufReadPost *.s call s:gofiletype_post()
                            
    1   0.000890   0.000166   if go#util#has_job()
    1              0.000009     autocmd FileType * call s:register()
    1              0.000002   endif
    1              0.000001 augroup end
                            
                            " restore Vi compatibility settings
    1              0.000009 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/config.vim
Sourced 1 time
Total time:   0.000896
 Self time:   0.000896

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000011 let s:cpo_save = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000004 function! go#config#AutodetectGopath() abort
                            	return get(g:, 'go_autodetect_gopath', 0)
                            endfunction
                            
    1              0.000004 function! go#config#ListTypeCommands() abort
                              return get(g:, 'go_list_type_commands', {})
                            endfunction
                            
    1              0.000003 function! go#config#VersionWarning() abort
                              return get(g:, 'go_version_warning', 1)
                            endfunction
                            
    1              0.000003 function! go#config#BuildTags() abort
                              return get(g:, 'go_build_tags', '')
                            endfunction
                            
    1              0.000003 function! go#config#SetBuildTags(value) abort
                              if a:value is ''
                                silent! unlet g:go_build_tags
                                call go#lsp#ResetWorkspaceDirectories()
                                return
                              endif
                            
                              let g:go_build_tags = a:value
                              call go#lsp#ResetWorkspaceDirectories()
                            endfunction
                            
    1              0.000004 function! go#config#TestTimeout() abort
                             return get(g:, 'go_test_timeout', '10s')
                            endfunction
                            
    1              0.000003 function! go#config#TestShowName() abort
                              return get(g:, 'go_test_show_name', 0)
                            endfunction
                            
    1              0.000003 function! go#config#TermHeight() abort
                              return get(g:, 'go_term_height', winheight(0))
                            endfunction
                            
    1              0.000004 function! go#config#TermWidth() abort
                              return get(g:, 'go_term_width', winwidth(0))
                            endfunction
                            
    1              0.000003 function! go#config#TermMode() abort
                              return get(g:, 'go_term_mode', 'vsplit')
                            endfunction
                            
    1              0.000004 function! go#config#TermCloseOnExit() abort
                              return get(g:, 'go_term_close_on_exit', 1)
                            endfunction
                            
    1              0.000004 function! go#config#SetTermCloseOnExit(value) abort
                              let g:go_term_close_on_exit = a:value
                            endfunction
                            
    1              0.000003 function! go#config#TermEnabled() abort
                              return has('nvim') && get(g:, 'go_term_enabled', 0)
                            endfunction
                            
    1              0.000003 function! go#config#SetTermEnabled(value) abort
                              let g:go_term_enabled = a:value
                            endfunction
                            
    1              0.000002 function! go#config#TemplateUsePkg() abort
                              return get(g:, 'go_template_use_pkg', 0)
                            endfunction
                            
    1              0.000002 function! go#config#TemplateTestFile() abort
                              return get(g:, 'go_template_test_file', "hello_world_test.go")
                            endfunction
                            
    1              0.000002 function! go#config#TemplateFile() abort
                              return get(g:, 'go_template_file', "hello_world.go")
                            endfunction
                            
    1              0.000002 function! go#config#StatuslineDuration() abort
                              return get(g:, 'go_statusline_duration', 60000)
                            endfunction
                            
    1              0.000002 function! go#config#SnippetEngine() abort
                              return get(g:, 'go_snippet_engine', 'automatic')
                            endfunction
                            
    1              0.000002 function! go#config#PlayBrowserCommand() abort
                                if go#util#IsWin()
                                    let go_play_browser_command = '!start rundll32 url.dll,FileProtocolHandler %URL%'
                                elseif go#util#IsMac()
                                    let go_play_browser_command = 'open %URL%'
                                elseif executable('xdg-open')
                                    let go_play_browser_command = 'xdg-open %URL%'
                                elseif executable('firefox')
                                    let go_play_browser_command = 'firefox %URL% &'
                                elseif executable('chromium')
                                    let go_play_browser_command = 'chromium %URL% &'
                                else
                                    let go_play_browser_command = ''
                                endif
                            
                                return get(g:, 'go_play_browser_command', go_play_browser_command)
                            endfunction
                            
    1              0.000002 function! go#config#MetalinterDeadline() abort
                              " gometalinter has a default deadline of 5 seconds only when asynchronous
                              " jobs are not supported.
                            
                              let deadline = '5s'
                              if go#util#has_job() && has('lambda')
                                let deadline = ''
                              endif
                            
                              return get(g:, 'go_metalinter_deadline', deadline)
                            endfunction
                            
    1              0.000002 function! go#config#ListType() abort
                              return get(g:, 'go_list_type', '')
                            endfunction
                            
    1              0.000002 function! go#config#ListAutoclose() abort
                              return get(g:, 'go_list_autoclose', 1)
                            endfunction
                            
    1              0.000002 function! go#config#InfoMode() abort
                              return get(g:, 'go_info_mode', 'gopls')
                            endfunction
                            
    1              0.000002 function! go#config#GuruScope() abort
                              let scope = get(g:, 'go_guru_scope', [])
                            
                              if !empty(scope)
                                " strip trailing slashes for each path in scope. bug:
                                " https://github.com/golang/go/issues/14584
                                let scopes = go#util#StripTrailingSlash(scope)
                              endif
                            
                              return scope
                            endfunction
                            
    1              0.000002 function! go#config#SetGuruScope(scope) abort
                              if empty(a:scope)
                                if exists('g:go_guru_scope')
                                  unlet g:go_guru_scope
                                endif
                              else
                                let g:go_guru_scope = a:scope
                              endif
                            endfunction
                            
    1              0.000003 function! go#config#GocodeUnimportedPackages() abort
                              return get(g:, 'go_gocode_unimported_packages', 0)
                            endfunction
                            
    1              0.000012 let s:sock_type = (has('win32') || has('win64')) ? 'tcp' : 'unix'
    1              0.000002 function! go#config#GocodeSocketType() abort
                              return get(g:, 'go_gocode_socket_type', s:sock_type)
                            endfunction
                            
    1              0.000002 function! go#config#GocodeProposeBuiltins() abort
                              return get(g:, 'go_gocode_propose_builtins', 1)
                            endfunction
                            
    1              0.000002 function! go#config#GocodeProposeSource() abort
                              return get(g:, 'go_gocode_propose_source', 0)
                            endfunction
                            
    1              0.000002 function! go#config#EchoCommandInfo() abort
                              return get(g:, 'go_echo_command_info', 1)
                            endfunction
                            
    1              0.000002 function! go#config#DocUrl() abort
                              let godoc_url = get(g:, 'go_doc_url', 'https://godoc.org')
                              if godoc_url isnot 'https://godoc.org'
                                " strip last '/' character if available
                                let last_char = strlen(godoc_url) - 1
                                if godoc_url[last_char] == '/'
                                  let godoc_url = strpart(godoc_url, 0, last_char)
                                endif
                                " custom godoc installations expect /pkg before package names
                                let godoc_url .= "/pkg"
                              endif
                              return godoc_url
                            endfunction
                            
    1              0.000002 function! go#config#DocPopupWindow() abort
                              return get(g:, 'go_doc_popup_window', 0)
                            endfunction
    1              0.000002 function! go#config#DefReuseBuffer() abort
                              return get(g:, 'go_def_reuse_buffer', 0)
                            endfunction
                            
    1              0.000002 function! go#config#DefMode() abort
                              return get(g:, 'go_def_mode', 'gopls')
                            endfunction
                            
    1              0.000002 function! go#config#DeclsIncludes() abort
                              return get(g:, 'go_decls_includes', 'func,type')
                            endfunction
                            
    1              0.000003 function! go#config#Debug() abort
                              return get(g:, 'go_debug', [])
                            endfunction
                            
    1              0.000002 function! go#config#DebugWindows() abort
                              return get(g:, 'go_debug_windows', {
                                        \ 'stack': 'leftabove 20vnew',
                                        \ 'out':   'botright 10new',
                                        \ 'vars':  'leftabove 30vnew',
                                        \ }
                                     \ )
                            
                            endfunction
                            
    1              0.000002 function! go#config#DebugAddress() abort
                              return get(g:, 'go_debug_address', '127.0.0.1:8181')
                            endfunction
                            
    1              0.000002 function! go#config#DebugCommands() abort
                              " make sure g:go_debug_commands is set so that it can be added to easily.
                              let g:go_debug_commands = get(g:, 'go_debug_commands', [])
                              return g:go_debug_commands
                            endfunction
                            
    1              0.000002 function! go#config#DebugLogOutput() abort
                              return get(g:, 'go_debug_log_output', 'debugger,rpc')
                            endfunction
                            
    1              0.000002 function! go#config#LspLog() abort
                              " make sure g:go_lsp_log is set so that it can be added to easily.
                              let g:go_lsp_log = get(g:, 'go_lsp_log', [])
                              return g:go_lsp_log
                            endfunction
                            
    1              0.000002 function! go#config#SetDebugDiag(value) abort
                              let g:go_debug_diag = a:value
                            endfunction
                            
    1              0.000002 function! go#config#AutoSameids() abort
                                return get(g:, 'go_auto_sameids', 0)
                            endfunction
                            
    1              0.000003 function! go#config#SetAutoSameids(value) abort
                              let g:go_auto_sameids = a:value
                            endfunction
                            
    1              0.000002 function! go#config#AddtagsTransform() abort
                              return get(g:, 'go_addtags_transform', "snakecase")
                            endfunction
                            
    1              0.000002 function! go#config#TemplateAutocreate() abort
                              return get(g:, "go_template_autocreate", 1)
                            endfunction
                            
    1              0.000002 function! go#config#SetTemplateAutocreate(value) abort
                              let g:go_template_autocreate = a:value
                            endfunction
                            
    1              0.000002 function! go#config#MetalinterCommand() abort
                              return get(g:, "go_metalinter_command", "golangci-lint")
                            endfunction
                            
    1              0.000003 function! go#config#MetalinterAutosaveEnabled() abort
                              let l:default_enabled = ["vet", "golint"]
                            
                              if go#config#MetalinterCommand() == "golangci-lint"
                                let l:default_enabled = ["govet", "golint"]
                              endif
                            
                              return get(g:, "go_metalinter_autosave_enabled", default_enabled)
                            endfunction
                            
    1              0.000002 function! go#config#MetalinterEnabled() abort
                              let l:default_enabled = ["vet", "golint", "errcheck"]
                            
                              if go#config#MetalinterCommand() == "golangci-lint"
                                let l:default_enabled = ["govet", "golint"]
                              endif
                            
                              return get(g:, "go_metalinter_enabled", default_enabled)
                            endfunction
                            
    1              0.000002 function! go#config#GolintBin() abort
                              return get(g:, "go_golint_bin", "golint")
                            endfunction
                            
    1              0.000002 function! go#config#ErrcheckBin() abort
                              return get(g:, "go_errcheck_bin", "errcheck")
                            endfunction
                            
    1              0.000002 function! go#config#MetalinterAutosave() abort
                              return get(g:, "go_metalinter_autosave", 0)
                            endfunction
                            
    1              0.000002 function! go#config#SetMetalinterAutosave(value) abort
                              let g:go_metalinter_autosave = a:value
                            endfunction
                            
    1              0.000002 function! go#config#ListHeight() abort
                              return get(g:, "go_list_height", 0)
                            endfunction
                            
    1              0.000005 function! go#config#FmtAutosave() abort
                            	return get(g:, "go_fmt_autosave", 1)
                            endfunction
                            
    1              0.000002 function! go#config#SetFmtAutosave(value) abort
                              let g:go_fmt_autosave = a:value
                            endfunction
                            
    1              0.000002 function! go#config#AsmfmtAutosave() abort
                              return get(g:, "go_asmfmt_autosave", 0)
                            endfunction
                            
    1              0.000002 function! go#config#SetAsmfmtAutosave(value) abort
                              let g:go_asmfmt_autosave = a:value
                            endfunction
                            
    1              0.000002 function! go#config#ModFmtAutosave() abort
                            	return get(g:, "go_mod_fmt_autosave", 1)
                            endfunction
                            
    1              0.000002 function! go#config#SetModFmtAutosave(value) abort
                              let g:go_mod_fmt_autosave = a:value
                            endfunction
                            
    1              0.000001 function! go#config#DocMaxHeight() abort
                              return get(g:, "go_doc_max_height", 20)
                            endfunction
                            
    1              0.000002 function! go#config#AutoTypeInfo() abort
                              return get(g:, "go_auto_type_info", 0)
                            endfunction
                            
    1              0.000002 function! go#config#SetAutoTypeInfo(value) abort
                              let g:go_auto_type_info = a:value
                            endfunction
                            
    1              0.000002 function! go#config#AlternateMode() abort
                              return get(g:, "go_alternate_mode", "edit")
                            endfunction
                            
    1              0.000002 function! go#config#DeclsMode() abort
                              return get(g:, "go_decls_mode", "")
                            endfunction
                            
    1              0.000002 function! go#config#FmtCommand() abort
                              return get(g:, "go_fmt_command", "gofmt")
                            endfunction
                            
    1              0.000002 function! go#config#FmtOptions() abort
                              return get(g:, "go_fmt_options", {})
                            endfunction
                            
    1              0.000002 function! go#config#FmtFailSilently() abort
                              return get(g:, "go_fmt_fail_silently", 0)
                            endfunction
                            
    1              0.000002 function! go#config#FmtExperimental() abort
                              return get(g:, "go_fmt_experimental", 0 )
                            endfunction
                            
    1              0.000002 function! go#config#PlayOpenBrowser() abort
                              return get(g:, "go_play_open_browser", 1)
                            endfunction
                            
    1              0.000002 function! go#config#GorenameBin() abort
                              return get(g:, "go_gorename_bin", "gorename")
                            endfunction
                            
    1              0.000002 function! go#config#GorenamePrefill() abort
                              return get(g:, "go_gorename_prefill", 'expand("<cword>") =~# "^[A-Z]"' .
                                      \ '? go#util#pascalcase(expand("<cword>"))' .
                                      \ ': go#util#camelcase(expand("<cword>"))')
                            endfunction
                            
    1              0.000003 function! go#config#TextobjIncludeFunctionDoc() abort
                              return get(g:, "go_textobj_include_function_doc", 1)
                            endfunction
                            
    1              0.000002 function! go#config#TextobjIncludeVariable() abort
                              return get(g:, "go_textobj_include_variable", 1)
                            endfunction
                            
    1              0.000002 function! go#config#BinPath() abort
                              return get(g:, "go_bin_path", "")
                            endfunction
                            
    1              0.000002 function! go#config#SearchBinPathFirst() abort
                              return get(g:, 'go_search_bin_path_first', 1)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightArrayWhitespaceError() abort
                              return get(g:, 'go_highlight_array_whitespace_error', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightChanWhitespaceError() abort
                              return get(g:, 'go_highlight_chan_whitespace_error', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightExtraTypes() abort
                              return get(g:, 'go_highlight_extra_types', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightSpaceTabError() abort
                              return get(g:, 'go_highlight_space_tab_error', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightTrailingWhitespaceError() abort
                              return get(g:, 'go_highlight_trailing_whitespace_error', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightOperators() abort
                              return get(g:, 'go_highlight_operators', 0)
                            endfunction
                            
    1              0.000003 function! go#config#HighlightFunctions() abort
                              return get(g:, 'go_highlight_functions', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightFunctionParameters() abort
                              " fallback to highlight_function_arguments for backwards compatibility
                              return get(g:, 'go_highlight_function_parameters', get(g:, 'go_highlight_function_arguments', 0))
                            endfunction
                            
    1              0.000002 function! go#config#HighlightFunctionCalls() abort
                              return get(g:, 'go_highlight_function_calls', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightFields() abort
                              return get(g:, 'go_highlight_fields', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightTypes() abort
                              return get(g:, 'go_highlight_types', 0)
                            endfunction
                            
    1              0.000003 function! go#config#HighlightBuildConstraints() abort
                              return get(g:, 'go_highlight_build_constraints', 0)
                            endfunction
                            
    1              0.000009 function! go#config#HighlightStringSpellcheck() abort
                              return get(g:, 'go_highlight_string_spellcheck', 1)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightFormatStrings() abort
                              return get(g:, 'go_highlight_format_strings', 1)
                            endfunction
                            
    1              0.000005 function! go#config#HighlightGenerateTags() abort
                              return get(g:, 'go_highlight_generate_tags', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightVariableAssignments() abort
                              return get(g:, 'go_highlight_variable_assignments', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightVariableDeclarations() abort
                              return get(g:, 'go_highlight_variable_declarations', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightDebug() abort
                              return get(g:, 'go_highlight_debug', 1)
                            endfunction
                            
    1              0.000002 function! go#config#FoldEnable(...) abort
                              if a:0 > 0
                                return index(go#config#FoldEnable(), a:1) > -1
                              endif
                              return get(g:, 'go_fold_enable', ['block', 'import', 'varconst', 'package_comment'])
                            endfunction
                            
    1              0.000002 function! go#config#EchoGoInfo() abort
                              return get(g:, "go_echo_go_info", 1)
                            endfunction
                            
    1              0.000002 function! go#config#CodeCompletionEnabled() abort
                              return get(g:, "go_code_completion_enabled", 1)
                            endfunction
                            
                            " Set the default value. A value of "1" is a shortcut for this, for
                            " compatibility reasons.
    1              0.000007 if exists("g:go_gorename_prefill") && g:go_gorename_prefill == 1
                              unlet g:go_gorename_prefill
    1              0.000001 endif
                            
                            " restore Vi compatibility settings
    1              0.000010 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/util.vim
Sourced 1 time
Total time:   0.000681
 Self time:   0.000681

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000010 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
                            " PathSep returns the appropriate OS specific path separator.
    1              0.000003 function! go#util#PathSep() abort
                              if go#util#IsWin()
                                return '\'
                              endif
                              return '/'
                            endfunction
                            
                            " PathListSep returns the appropriate OS specific path list separator.
    1              0.000002 function! go#util#PathListSep() abort
                              if go#util#IsWin()
                                return ";"
                              endif
                              return ":"
                            endfunction
                            
                            " LineEnding returns the correct line ending, based on the current fileformat
    1              0.000012 function! go#util#LineEnding() abort
                              if &fileformat == 'dos'
                                return "\r\n"
                              elseif &fileformat == 'mac'
                                return "\r"
                              endif
                            
                              return "\n"
                            endfunction
                            
                            " Join joins any number of path elements into a single path, adding a
                            " Separator if necessary and returns the result
    1              0.000002 function! go#util#Join(...) abort
                              return join(a:000, go#util#PathSep())
                            endfunction
                            
                            " IsWin returns 1 if current OS is Windows or 0 otherwise
                            " Note that has('win32') is always 1 when has('win64') is 1, so has('win32') is enough.
    1              0.000002 function! go#util#IsWin() abort
                              return has('win32')
                            endfunction
                            
                            " IsMac returns 1 if current OS is macOS or 0 otherwise.
    1              0.000002 function! go#util#IsMac() abort
                              return has('mac') ||
                                    \ has('macunix') ||
                                    \ has('gui_macvim') ||
                                    \ go#util#Exec(['uname'])[0] =~? '^darwin'
                            endfunction
                            
                             " Checks if using:
                             " 1) Windows system,
                             " 2) And has cygpath executable,
                             " 3) And uses *sh* as 'shell'
    1              0.000003 function! go#util#IsUsingCygwinShell()
                              return go#util#IsWin() && executable('cygpath') && &shell =~ '.*sh.*'
                            endfunction
                            
                            " Check if Vim jobs API is supported.
                            "
                            " The (optional) first parameter can be added to indicate the 'cwd' or 'env'
                            " parameters will be used, which wasn't added until a later version.
    1              0.000002 function! go#util#has_job(...) abort
                              if has('nvim')
                                return 1
                              endif
                            
                              " cwd and env parameters to job_start was added in this version.
                              if a:0 > 0 && a:1 is 1
                                return has('job') && has("patch-8.0.0902")
                              endif
                            
                              " job was introduced in 7.4.xxx however there are multiple bug fixes and one
                              " of the latest is 8.0.0087 which is required for a stable async API.
                              return has('job') && has("patch-8.0.0087")
                            endfunction
                            
    1              0.000004 let s:env_cache = {}
                            
                            " env returns the go environment variable for the given key. Where key can be
                            " GOARCH, GOOS, GOROOT, etc... It caches the result and returns the cached
                            " version.
    1              0.000002 function! go#util#env(key) abort
                              let l:key = tolower(a:key)
                              if has_key(s:env_cache, l:key)
                                return s:env_cache[l:key]
                              endif
                            
                              if executable('go')
                                let l:var = call('go#util#'.l:key, [])
                                if go#util#ShellError() != 0
                                  call go#util#EchoError(printf("'go env %s' failed", toupper(l:key)))
                                  return ''
                                endif
                              else
                                let l:var = eval("$".toupper(a:key))
                              endif
                            
                              let s:env_cache[l:key] = l:var
                              return l:var
                            endfunction
                            
                            " goarch returns 'go env GOARCH'. This is an internal function and shouldn't
                            " be used. Instead use 'go#util#env("goarch")'
    1              0.000002 function! go#util#goarch() abort
                              return substitute(s:exec(['go', 'env', 'GOARCH'])[0], '\n', '', 'g')
                            endfunction
                            
                            " goos returns 'go env GOOS'. This is an internal function and shouldn't
                            " be used. Instead use 'go#util#env("goos")'
    1              0.000002 function! go#util#goos() abort
                              return substitute(s:exec(['go', 'env', 'GOOS'])[0], '\n', '', 'g')
                            endfunction
                            
                            " goroot returns 'go env GOROOT'. This is an internal function and shouldn't
                            " be used. Instead use 'go#util#env("goroot")'
    1              0.000002 function! go#util#goroot() abort
                              return substitute(s:exec(['go', 'env', 'GOROOT'])[0], '\n', '', 'g')
                            endfunction
                            
                            " gopath returns 'go env GOPATH'. This is an internal function and shouldn't
                            " be used. Instead use 'go#util#env("gopath")'
    1              0.000001 function! go#util#gopath() abort
                              return substitute(s:exec(['go', 'env', 'GOPATH'])[0], '\n', '', 'g')
                            endfunction
                            
                            " gomod returns 'go env GOMOD'. gomod changes depending on the folder. Don't
                            " use go#util#env as it caches the value.
    1              0.000002 function! go#util#gomod() abort
                              return substitute(s:exec(['go', 'env', 'GOMOD'])[0], '\n', '', 'g')
                            endfunction
                            
    1              0.000005 function! go#util#osarch() abort
                              return go#util#env("goos") . '_' . go#util#env("goarch")
                            endfunction
                            
                            " go#util#ModuleRoot returns the root directory of the module of the current
                            " buffer.
    1              0.000002 function! go#util#ModuleRoot() abort
                              let [l:out, l:err] = go#util#ExecInDir(['go', 'env', 'GOMOD'])
                              if l:err != 0
                                return -1
                              endif
                            
                              let l:module = split(l:out, '\n', 1)[0]
                            
                              " When run with `GO111MODULE=on and not in a module directory, the module will be reported as /dev/null.
                              let l:fakeModule = '/dev/null'
                              if go#util#IsWin()
                                let l:fakeModule = 'NUL'
                              endif
                            
                              if l:fakeModule == l:module
                                return expand('%:p:h')
                              endif
                            
                              return fnamemodify(l:module, ':p:h')
                            endfunction
                            
                            " Run a shell command.
                            "
                            " It will temporary set the shell to /bin/sh for Unix-like systems if possible,
                            " so that we always use a standard POSIX-compatible Bourne shell (and not e.g.
                            " csh, fish, etc.) See #988 and #1276.
    1              0.000003 function! s:system(cmd, ...) abort
                              " Preserve original shell, shellredir and shellcmdflag values
                              let l:shell = &shell
                              let l:shellredir = &shellredir
                              let l:shellcmdflag = &shellcmdflag
                            
                              if !go#util#IsWin() && executable('/bin/sh')
                                  set shell=/bin/sh shellredir=>%s\ 2>&1 shellcmdflag=-c
                              endif
                            
                              try
                                return call('system', [a:cmd] + a:000)
                              finally
                                " Restore original values
                                let &shell = l:shell
                                let &shellredir = l:shellredir
                                let &shellcmdflag = l:shellcmdflag
                              endtry
                            endfunction
                            
                            " System runs a shell command "str". Every arguments after "str" is passed to
                            " stdin.
    1              0.000002 function! go#util#System(str, ...) abort
                              return call('s:system', [a:str] + a:000)
                            endfunction
                            
                            " Exec runs a shell command "cmd", which must be a list, one argument per item.
                            " Every list entry will be automatically shell-escaped
                            " Every other argument is passed to stdin.
    1              0.000002 function! go#util#Exec(cmd, ...) abort
                              if len(a:cmd) == 0
                                call go#util#EchoError("go#util#Exec() called with empty a:cmd")
                                return ['', 1]
                              endif
                            
                              let l:bin = a:cmd[0]
                            
                              " Lookup the full path, respecting settings such as 'go_bin_path'. On errors,
                              " CheckBinPath will show a warning for us.
                              let l:bin = go#path#CheckBinPath(l:bin)
                              if empty(l:bin)
                                return ['', 1]
                              endif
                            
                              " Finally execute the command using the full, resolved path. Do not pass the
                              " unmodified command as the correct program might not exist in $PATH.
                              return call('s:exec', [[l:bin] + a:cmd[1:]] + a:000)
                            endfunction
                            
    1              0.000002 function! go#util#ExecInDir(cmd, ...) abort
                              if !isdirectory(expand("%:p:h"))
                                return ['', 1]
                              endif
                            
                              let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd ' : 'cd '
                              let dir = getcwd()
                              try
                                execute cd . fnameescape(expand("%:p:h"))
                                let [l:out, l:err] = call('go#util#Exec', [a:cmd] + a:000)
                              finally
                                execute cd . fnameescape(l:dir)
                              endtry
                              return [l:out, l:err]
                            endfunction
                            
    1              0.000002 function! s:exec(cmd, ...) abort
                              let l:bin = a:cmd[0]
                              let l:cmd = go#util#Shelljoin([l:bin] + a:cmd[1:])
                              if go#util#HasDebug('shell-commands')
                                call go#util#EchoInfo('shell command: ' . l:cmd)
                              endif
                            
                              let l:out = call('s:system', [l:cmd] + a:000)
                              return [l:out, go#util#ShellError()]
                            endfunction
                            
    1              0.000002 function! go#util#ShellError() abort
                              return v:shell_error
                            endfunction
                            
                            " StripPath strips the path's last character if it's a path separator.
                            " example: '/foo/bar/'  -> '/foo/bar'
    1              0.000003 function! go#util#StripPathSep(path) abort
                              let last_char = strlen(a:path) - 1
                              if a:path[last_char] == go#util#PathSep()
                                return strpart(a:path, 0, last_char)
                              endif
                            
                              return a:path
                            endfunction
                            
                            " StripTrailingSlash strips the trailing slash from the given path list.
                            " example: ['/foo/bar/']  -> ['/foo/bar']
    1              0.000002 function! go#util#StripTrailingSlash(paths) abort
                              return map(copy(a:paths), 'go#util#StripPathSep(v:val)')
                            endfunction
                            
                            " Shelljoin returns a shell-safe string representation of arglist. The
                            " {special} argument of shellescape() may optionally be passed.
    1              0.000002 function! go#util#Shelljoin(arglist, ...) abort
                              try
                                let ssl_save = &shellslash
                                set noshellslash
                                if a:0
                                  return join(map(copy(a:arglist), 'shellescape(v:val, ' . a:1 . ')'), ' ')
                                endif
                            
                                return join(map(copy(a:arglist), 'shellescape(v:val)'), ' ')
                              finally
                                let &shellslash = ssl_save
                              endtry
                            endfunction
                            
    1              0.000002 fu! go#util#Shellescape(arg)
                              try
                                let ssl_save = &shellslash
                                set noshellslash
                                return shellescape(a:arg)
                              finally
                                let &shellslash = ssl_save
                              endtry
                            endf
                            
                            " Shelllist returns a shell-safe representation of the items in the given
                            " arglist. The {special} argument of shellescape() may optionally be passed.
    1              0.000002 function! go#util#Shelllist(arglist, ...) abort
                              try
                                let ssl_save = &shellslash
                                set noshellslash
                                if a:0
                                  return map(copy(a:arglist), 'shellescape(v:val, ' . a:1 . ')')
                                endif
                                return map(copy(a:arglist), 'shellescape(v:val)')
                              finally
                                let &shellslash = ssl_save
                              endtry
                            endfunction
                            
                            " Returns the byte offset for line and column
    1              0.000002 function! go#util#Offset(line, col) abort
                              if &encoding != 'utf-8'
                                let sep = go#util#LineEnding()
                                let buf = a:line == 1 ? '' : (join(getline(1, a:line-1), sep) . sep)
                                let buf .= a:col == 1 ? '' : getline('.')[:a:col-2]
                                return len(iconv(buf, &encoding, 'utf-8'))
                              endif
                              return line2byte(a:line) + (a:col-2)
                            endfunction
                            "
                            " Returns the byte offset for the cursor
    1              0.000002 function! go#util#OffsetCursor() abort
                              return go#util#Offset(line('.'), col('.'))
                            endfunction
                            
                            " Windo is like the built-in :windo, only it returns to the window the command
                            " was issued from
    1              0.000002 function! go#util#Windo(command) abort
                              let s:currentWindow = winnr()
                              try
                                execute "windo " . a:command
                              finally
                                execute s:currentWindow. "wincmd w"
                                unlet s:currentWindow
                              endtry
                            endfunction
                            
                            " snippetcase converts the given word to given preferred snippet setting type
                            " case.
    1              0.000002 function! go#util#snippetcase(word) abort
                              let l:snippet_case = go#config#AddtagsTransform()
                              if l:snippet_case == "snakecase"
                                return go#util#snakecase(a:word)
                              elseif l:snippet_case == "camelcase"
                                return go#util#camelcase(a:word)
                              else
                                return a:word " do nothing
                              endif
                            endfunction
                            
                            " snakecase converts a string to snake case. i.e: FooBar -> foo_bar
                            " Copied from tpope/vim-abolish
    1              0.000002 function! go#util#snakecase(word) abort
                              let word = substitute(a:word, '::', '/', 'g')
                              let word = substitute(word, '\(\u\+\)\(\u\l\)', '\1_\2', 'g')
                              let word = substitute(word, '\(\l\|\d\)\(\u\)', '\1_\2', 'g')
                              let word = substitute(word, '[.-]', '_', 'g')
                              let word = tolower(word)
                              return word
                            endfunction
                            
                            " camelcase converts a string to camel case. e.g. FooBar or foo_bar will become
                            " fooBar.
                            " Copied from tpope/vim-abolish.
    1              0.000002 function! go#util#camelcase(word) abort
                              let word = substitute(a:word, '-', '_', 'g')
                              if word !~# '_' && word =~# '\l'
                                return substitute(word, '^.', '\l&', '')
                              else
                                return substitute(word, '\C\(_\)\=\(.\)', '\=submatch(1)==""?tolower(submatch(2)) : toupper(submatch(2))','g')
                              endif
                            endfunction
                            
                            " pascalcase converts a string to 'PascalCase'. e.g. fooBar or foo_bar will
                            " become FooBar.
    1              0.000002 function! go#util#pascalcase(word) abort
                              let word = go#util#camelcase(a:word)
                              return toupper(word[0]) . word[1:]
                            endfunction
                            
                            " Echo a message to the screen and highlight it with the group in a:hi.
                            "
                            " The message can be a list or string; every line with be :echomsg'd separately.
    1              0.000003 function! s:echo(msg, hi)
                              let l:msg = []
                              if type(a:msg) != type([])
                                let l:msg = split(a:msg, "\n")
                              else
                                let l:msg = a:msg
                              endif
                            
                              " Tabs display as ^I or <09>, so manually expand them.
                              let l:msg = map(l:msg, 'substitute(v:val, "\t", "        ", "")')
                            
                              exe 'echohl ' . a:hi
                              for line in l:msg
                                echom "vim-go: " . line
                              endfor
                              echohl None
                            endfunction
                            
    1              0.000003 function! go#util#EchoSuccess(msg)
                              call s:echo(a:msg, 'Function')
                            endfunction
    1              0.000002 function! go#util#EchoError(msg)
                              call s:echo(a:msg, 'ErrorMsg')
                            endfunction
    1              0.000002 function! go#util#EchoWarning(msg)
                              call s:echo(a:msg, 'WarningMsg')
                            endfunction
    1              0.000002 function! go#util#EchoProgress(msg)
                              redraw
                              call s:echo(a:msg, 'Identifier')
                            endfunction
    1              0.000002 function! go#util#EchoInfo(msg)
                              call s:echo(a:msg, 'Debug')
                            endfunction
                            
                            " Get all lines in the buffer as a a list.
    1              0.000002 function! go#util#GetLines()
                              let buf = getline(1, '$')
                              if &encoding != 'utf-8'
                                let buf = map(buf, 'iconv(v:val, &encoding, "utf-8")')
                              endif
                              if &l:fileformat == 'dos'
                                " XXX: line2byte() depend on 'fileformat' option.
                                " so if fileformat is 'dos', 'buf' must include '\r'.
                                let buf = map(buf, 'v:val."\r"')
                              endif
                              return buf
                            endfunction
                            
                            " Convert the current buffer to the "archive" format of
                            " golang.org/x/tools/go/buildutil:
                            " https://godoc.org/golang.org/x/tools/go/buildutil#ParseOverlayArchive
                            "
                            " > The archive consists of a series of files. Each file consists of a name, a
                            " > decimal file size and the file contents, separated by newlinews. No newline
                            " > follows after the file contents.
    1              0.000002 function! go#util#archive()
                                let l:buffer = join(go#util#GetLines(), "\n")
                                return expand("%:p:gs!\\!/!") . "\n" . strlen(l:buffer) . "\n" . l:buffer
                            endfunction
                            
                            " Make a named temporary directory which starts with "prefix".
                            "
                            " Unfortunately Vim's tempname() is not portable enough across various systems;
                            " see: https://github.com/mattn/vim-go/pull/3#discussion_r138084911
    1              0.000002 function! go#util#tempdir(prefix) abort
                              " See :help tempfile
                              if go#util#IsWin()
                                let l:dirs = [$TMP, $TEMP, 'c:\tmp', 'c:\temp']
                              else
                                let l:dirs = [$TMPDIR, '/tmp', './', $HOME]
                              endif
                            
                              let l:dir = ''
                              for l:d in dirs
                                if !empty(l:d) && filewritable(l:d) == 2
                                  let l:dir = l:d
                                  break
                                endif
                              endfor
                            
                              if l:dir == ''
                                call go#util#EchoError('Unable to find directory to store temporary directory in')
                                return
                              endif
                            
                              " Not great randomness, but "good enough" for our purpose here.
                              let l:rnd = sha256(printf('%s%s', reltimestr(reltime()), fnamemodify(bufname(''), ":p")))
                              let l:tmp = printf("%s/%s%s", l:dir, a:prefix, l:rnd)
                              call mkdir(l:tmp, 'p', 0700)
                              return l:tmp
                            endfunction
                            
                            " Report if the user enabled a debug flag in g:go_debug.
    1              0.000002 function! go#util#HasDebug(flag)
                              return index(go#config#Debug(), a:flag) >= 0
                            endfunction
                            
    1              0.000002 function! go#util#OpenBrowser(url) abort
                                let l:cmd = go#config#PlayBrowserCommand()
                                if len(l:cmd) == 0
                                    redraw
                                    echohl WarningMsg
                                    echo "It seems that you don't have general web browser. Open URL below."
                                    echohl None
                                    echo a:url
                                    return
                                endif
                            
                                " if setting starts with a !.
                                if l:cmd =~ '^!'
                                    let l:cmd = substitute(l:cmd, '%URL%', '\=escape(shellescape(a:url), "#")', 'g')
                                    silent! exec l:cmd
                                elseif cmd =~ '^:[A-Z]'
                                    let l:cmd = substitute(l:cmd, '%URL%', '\=escape(a:url,"#")', 'g')
                                    exec l:cmd
                                else
                                    let l:cmd = substitute(l:cmd, '%URL%', '\=shellescape(a:url)', 'g')
                                    call go#util#System(l:cmd)
                                endif
                            endfunction
                            
    1              0.000002 function! go#util#ParseErrors(lines) abort
                              let errors = []
                            
                              for line in a:lines
                                let fatalerrors = matchlist(line, '^\(fatal error:.*\)$')
                                let tokens = matchlist(line, '^\s*\(.\{-}\):\(\d\+\):\s*\(.*\)')
                            
                                if !empty(fatalerrors)
                                  call add(errors, {"text": fatalerrors[1]})
                                elseif !empty(tokens)
                                  " strip endlines of form ^M
                                  let out = substitute(tokens[3], '\r$', '', '')
                            
                                  call add(errors, {
                                        \ "filename" : fnamemodify(tokens[1], ':p'),
                                        \ "lnum"     : tokens[2],
                                        \ "text"     : out,
                                        \ })
                                elseif !empty(errors)
                                  " Preserve indented lines.
                                  " This comes up especially with multi-line test output.
                                  if match(line, '^\s') >= 0
                                    call add(errors, {"text": substitute(line, '\r$', '', '')})
                                  endif
                                endif
                              endfor
                            
                              return errors
                            endfunction
                            
    1              0.000003 function! go#util#ShowInfo(info)
                              if empty(a:info)
                                return
                              endif
                            
                              echo "vim-go: " | echohl Function | echon a:info | echohl None
                            endfunction
                            
                            " go#util#SetEnv takes the name of an environment variable and what its value
                            " should be and returns a function that will restore it to its original value.
    1              0.000003 function! go#util#SetEnv(name, value) abort
                              let l:state = {}
                            
                              if len(a:name) == 0
                                return function('s:noop', [], l:state)
                              endif
                            
                              let l:remove = 0
                              if exists('$' . a:name)
                                let l:oldvalue = eval('$' . a:name)
                              else
                                let l:remove = 1
                              endif
                            
                              " wrap the value in single quotes so that it will work on windows when there
                              " are backslashes present in the value (e.g. $PATH).
                              call execute('let $' . a:name . " = '" . a:value . "'")
                            
                              if l:remove
                                function! s:remove(name) abort
                                  call execute('unlet $' . a:name)
                                endfunction
                                return function('s:remove', [a:name], l:state)
                              endif
                            
                              return function('go#util#SetEnv', [a:name, l:oldvalue], l:state)
                            endfunction
                            
    1              0.000003 function! s:noop(...) abort dict
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000010 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-linux-coding-style/plugin/linuxsty.vim
Sourced 1 time
Total time:   0.000217
 Self time:   0.000217

count  total (s)   self (s)
                            " Vim plugin to fit the Linux kernel coding style and help kernel development
                            " Maintainer:   Vivien Didelot <vivien.didelot@savoirfairelinux.com>
                            " License:      Distributed under the same terms as Vim itself.
                            "
                            " This script is inspired from an article written by Bart:
                            " http://www.jukie.net/bart/blog/vim-and-linux-coding-style
                            " and various user comments.
                            "
                            " For those who want to apply these options conditionally, you can define an
                            " array of patterns in your vimrc and these options will be applied only if
                            " the buffer's path matches one of the pattern. In the following example,
                            " options will be applied only if "/linux/" or "/kernel" is in buffer's path.
                            "
                            "   let g:linuxsty_patterns = [ "/linux/", "/kernel/" ]
                            
    1              0.000008 if exists("g:loaded_linuxsty")
                                finish
    1              0.000001 endif
    1              0.000003 let g:loaded_linuxsty = 1
                            
    1              0.000007 set wildignore+=*.ko,*.mod.c,*.order,modules.builtin
                            
    1              0.000002 augroup linuxsty
    1              0.000063     autocmd!
                            
    1              0.000011     autocmd FileType c,cpp call s:LinuxConfigure()
    1              0.000006     autocmd FileType diff setlocal ts=8
    1              0.000006     autocmd FileType kconfig setlocal ts=8 sw=8 sts=8 noet
    1              0.000005     autocmd FileType dts setlocal ts=8 sw=8 sts=8 noet
    1              0.000001 augroup END
                            
    1              0.000005 function s:LinuxConfigure()
                                let apply_style = 0
                            
                                if exists("g:linuxsty_patterns")
                                    let path = expand('%:p')
                                    for p in g:linuxsty_patterns
                                        if path =~ p
                                            let apply_style = 1
                                            break
                                        endif
                                    endfor
                                else
                                    let apply_style = 1
                                endif
                            
                                if apply_style
                                    call s:LinuxCodingStyle()
                                endif
                            endfunction
                            
    1              0.000008 command! LinuxCodingStyle call s:LinuxCodingStyle()
                            
    1              0.000002 function! s:LinuxCodingStyle()
                                call s:LinuxFormatting()
                                call s:LinuxKeywords()
                                call s:LinuxHighlighting()
                            endfunction
                            
    1              0.000003 function s:LinuxFormatting()
                                setlocal tabstop=8
                                setlocal shiftwidth=8
                                setlocal softtabstop=8
                                setlocal textwidth=80
                                setlocal noexpandtab
                            
                                setlocal cindent
                                setlocal cinoptions=:0,l1,t0,g0,(0
                            endfunction
                            
    1              0.000003 function s:LinuxKeywords()
                                syn keyword cOperator likely unlikely
                                syn keyword cType u8 u16 u32 u64 s8 s16 s32 s64
                                syn keyword cType __u8 __u16 __u32 __u64 __s8 __s16 __s32 __s64
                            endfunction
                            
    1              0.000002 function s:LinuxHighlighting()
                                highlight default link LinuxError ErrorMsg
                            
                                syn match LinuxError / \+\ze\t/     " spaces before tab
                                syn match LinuxError /\%>80v[^()\{\}\[\]<>]\+/ " virtual column 81 and more
                            
                                " Highlight trailing whitespace, unless we're in insert mode and the
                                " cursor's placed right after the whitespace. This prevents us from having
                                " to put up with whitespace being highlighted in the middle of typing
                                " something
                                autocmd InsertEnter * match LinuxError /\s\+\%#\@<!$/
                                autocmd InsertLeave * match LinuxError /\s\+$/
                            endfunction
                            
                            " vim: ts=4 et sw=4

SCRIPT  /home/c5262761/configit/vim/modules/rust.vim/plugin/cargo.vim
Sourced 1 time
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
    1              0.000010 if exists('g:loaded_rust_vim_plugin_cargo')
                                finish
    1              0.000001 endif
    1              0.000004 let g:loaded_rust_vim_plugin_cargo = 1
    1              0.000003 let s:save_cpo = &cpoptions
    1              0.000005 set cpoptions&vim
                            
    1              0.000009 command! -nargs=+ Cargo call cargo#cmd(<q-args>)
    1              0.000006 command! -nargs=* Cbuild call cargo#build(<q-args>)
    1              0.000006 command! -nargs=* Cclean call cargo#clean(<q-args>)
    1              0.000006 command! -nargs=* Cdoc call cargo#doc(<q-args>)
    1              0.000006 command! -nargs=+ Cnew call cargo#new(<q-args>)
    1              0.000011 command! -nargs=* Cinit call cargo#init(<q-args>)
    1              0.000005 command! -nargs=* Crun call cargo#run(<q-args>)
    1              0.000006 command! -nargs=* Ctest call cargo#test(<q-args>)
    1              0.000006 command! -nargs=* Cbench call cargo#bench(<q-args>)
    1              0.000005 command! -nargs=* Cupdate call cargo#update(<q-args>)
    1              0.000006 command! -nargs=* Csearch  call cargo#search(<q-args>)
    1              0.000005 command! -nargs=* Cpublish call cargo#publish(<q-args>)
    1              0.000006 command! -nargs=* Cinstall call cargo#install(<q-args>)
    1              0.000006 command! -nargs=* Cruntarget call cargo#runtarget(<q-args>)
                            
    1              0.000005 let &cpoptions = s:save_cpo
    1              0.000007 unlet s:save_cpo
                            
                            " vim: set et sw=4 sts=4 ts=8:

SCRIPT  /home/c5262761/configit/vim/modules/rust.vim/plugin/rust.vim
Sourced 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
                            " Vim syntastic plugin helper
                            " Language:     Rust
                            " Maintainer:   Andrew Gallant <jamslam@gmail.com>
                            
    1              0.000007 if exists('g:loaded_rust_vim')
                                finish
    1              0.000001 endif
    1              0.000004 let g:loaded_rust_vim = 1
    1              0.000003 let s:save_cpo = &cpoptions
    1              0.000004 set cpoptions&vim
                            
                            " This is to let Syntastic know about the Rust filetype.
                            " It enables tab completion for the 'SyntasticInfo' command.
                            " (This does not actually register the syntax checker.)
    1              0.000004 if exists('g:syntastic_extra_filetypes')
                                call add(g:syntastic_extra_filetypes, 'rust')
    1              0.000002 else
    1              0.000003     let g:syntastic_extra_filetypes = ['rust']
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:syntastic_rust_checkers')
    1              0.000003     let g:syntastic_rust_checkers = ['cargo']
    1              0.000001 endif
                            
    1              0.000003 let &cpoptions = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set et sw=4 sts=4 ts=8:

SCRIPT  /home/c5262761/configit/vim/modules/tcomment_vim/plugin/tcomment.vim
Sourced 1 time
Total time:   0.005199
 Self time:   0.003309

count  total (s)   self (s)
                            " tComment.vim -- An easily extensible & universal comment plugin 
                            " @Author:      Tom Link (micathom AT gmail com)
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Created:     27-Dez-2004.
                            " @Last Change: 2018-06-18.
                            " @Revision:    996
                            " GetLatestVimScripts: 1173 1 tcomment.vim
                            
    1              0.000012 if &cp || exists('loaded_tcomment')
                                finish
    1              0.000001 endif
    1              0.000003 let loaded_tcomment = 400
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1   0.000609   0.000209 call tcomment#deprecated#Check()
                            
                            
    1              0.000004 if !exists('g:tcomment_maps')
                                " If true, set maps.
    1              0.000002     let g:tcomment_maps = 1   "{{{2
    1              0.000001 endif
                            
    1              0.000003 if !exists("g:tcomment_mapleader1")
                                " g:tcomment_mapleader1 should be a shortcut that can be used with 
                                " map, imap, vmap.
    1              0.000003     let g:tcomment_mapleader1 = '<c-_>' "{{{2
    1              0.000001 endif
                            
    1              0.000002 if !exists("g:tcomment_mapleader2")
                                " g:tcomment_mapleader2 should be a shortcut that can be used with 
                                " map, xmap.
    1              0.000002     let g:tcomment_mapleader2 = '<Leader>_' "{{{2
    1              0.000001 endif
                            
    1              0.000003 if !exists("g:tcomment_opleader1")
                                " See |tcomment-operator|.
    1              0.000008     let g:tcomment_opleader1 = 'gc' "{{{2
    1              0.000001 endif
                            
    1              0.000004 if !exists("g:tcomment_mapleader_uncomment_anyway")
                                " See |tcomment-operator|.
    1              0.000003     let g:tcomment_mapleader_uncomment_anyway = 'g<' "{{{2
    1              0.000001 endif
                            
    1              0.000003 if !exists("g:tcomment_mapleader_comment_anyway")
                                " See |tcomment-operator|.
    1              0.000003     let g:tcomment_mapleader_comment_anyway = 'g>' "{{{2
    1              0.000001 endif
                            
    1              0.000004 if !exists('g:tcomment_textobject_inlinecomment')
    1              0.000002     let g:tcomment_textobject_inlinecomment = 'ic'   "{{{2
    1              0.000001 endif
                            
                            
                            " :display: :[range]TComment[!] ?ARGS...
                            " If there is a visual selection that begins and ends in the same line, 
                            " then |:TCommentInline| is used instead.
                            " The optional range defaults to the current line. With a bang '!', 
                            " always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000031 command! -bar -bang -range -nargs=* -complete=customlist,tcomment#complete#Args TComment
                                        \ keepjumps call tcomment#Comment(<line1>, <line2>, 'G', "<bang>", <f-args>)
                            
                            " :display: :[range]TCommentAs[!] commenttype ?ARGS...
                            " TCommentAs requires g:tcomment_{filetype} to be defined.
                            " With a bang '!', always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000019 command! -bar -bang -complete=customlist,tcomment#complete#Complete -range -nargs=+ TCommentAs 
                                        \ call tcomment#CommentAs(<line1>, <line2>, "<bang>", <f-args>)
                            
                            " :display: :[range]TCommentRight[!] ?ARGS...
                            " Comment the text to the right of the cursor. If a visual selection was 
                            " made (be it block-wise or not), all lines are commented out at from 
                            " the current cursor position downwards.
                            " With a bang '!', always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000018 command! -bar -bang -range -nargs=* -complete=customlist,tcomment#complete#Args TCommentRight
                                        \ keepjumps call tcomment#Comment(<line1>, <line2>, 'R', "<bang>", <f-args>)
                            
                            " :display: :[range]TCommentBlock[!] ?ARGS...
                            " Comment as "block", e.g. use the {&ft}_block comment style. The 
                            " commented text isn't indented or reformated.
                            " With a bang '!', always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000016 command! -bar -bang -range -nargs=* -complete=customlist,tcomment#complete#Args TCommentBlock
                                        \ keepjumps call tcomment#Comment(<line1>, <line2>, 'B', "<bang>", <f-args>)
                            
                            " :display: :[range]TCommentInline[!] ?ARGS...
                            " Use the {&ft}_inline comment style.
                            " With a bang '!', always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000018 command! -bar -bang -range -nargs=* -complete=customlist,tcomment#complete#Args TCommentInline
                                        \ keepjumps call tcomment#Comment(<line1>, <line2>, 'I', "<bang>", <f-args>)
                            
                            " :display: :[range]TCommentMaybeInline[!] ?ARGS...
                            " With a bang '!', always comment the line.
                            "
                            " ARGS... are either (see also |tcomment#Comment()|):
                            "   1. a list of key=value pairs
                            "   2. 1-2 values for: ?commentBegin, ?commentEnd
    1              0.000017 command! -bar -bang -range -nargs=* -complete=customlist,tcomment#complete#Args TCommentMaybeInline
                                        \ keepjumps call tcomment#Comment(<line1>, <line2>, 'i', "<bang>", <f-args>)
                            
                            
                            " command! -range TCommentMap call tcomment#ResetOption() | <args>
                            
    1              0.000015 noremap <Plug>TComment_<c-_><c-_> :TComment<cr>
    1              0.000012 vnoremap <Plug>TComment_<c-_><c-_> :TCommentMaybeInline<cr>
    1              0.000011 inoremap <Plug>TComment_<c-_><c-_> <c-o>:TComment<cr>
    1              0.000011 noremap <Plug>TComment_<c-_>p m`vip:TComment<cr>``
    1              0.000011 inoremap <Plug>TComment_<c-_>p <c-o>:norm! m`vip<cr>:TComment<cr><c-o>``
    1              0.000010 noremap <Plug>TComment_<c-_><space> :TComment 
    1              0.000010 inoremap <Plug>TComment_<c-_><space> <c-o>:TComment 
    1              0.000010 inoremap <Plug>TComment_<c-_>r <c-o>:TCommentRight<cr>
    1              0.000018 noremap <Plug>TComment_<c-_>r :TCommentRight<cr>
    1              0.000011 vnoremap <Plug>TComment_<c-_>i :TCommentInline<cr>
    1              0.000011 noremap <Plug>TComment_<c-_>i v:TCommentInline mode=I#<cr>
    1              0.000011 inoremap <Plug>TComment_<c-_>i <c-\><c-o>v:TCommentInline mode=#<cr>
    1              0.000009 noremap <Plug>TComment_<c-_>b :TCommentBlock<cr>
    1              0.000011 inoremap <Plug>TComment_<c-_>b <c-\><c-o>:TCommentBlock mode=#<cr>
    1              0.000009 noremap <Plug>TComment_<c-_>a :TCommentAs 
    1              0.000010 inoremap <Plug>TComment_<c-_>a <c-o>:TCommentAs 
    1              0.000011 noremap <Plug>TComment_<c-_>n :TCommentAs <c-r>=&ft<cr> 
    1              0.000010 inoremap <Plug>TComment_<c-_>n <c-o>:TCommentAs <c-r>=&ft<cr> 
    1              0.000010 noremap <Plug>TComment_<c-_>s :TCommentAs <c-r>=&ft<cr>_
    1              0.000011 inoremap <Plug>TComment_<c-_>s <c-o>:TCommentAs <c-r>=&ft<cr>_
    1              0.000013 noremap <Plug>TComment_<c-_>cc :<c-u>call tcomment#SetOption("count", v:count1)<cr>
    1              0.000018 noremap <Plug>TComment_<c-_>ca :<c-u>call tcomment#SetOption("as", input("Comment as: ", &filetype, "customlist,tcomment#complete#Complete"))<cr>
                            
    1              0.000012 noremap <Plug>TComment_<Leader>__ :TComment<cr>
    1              0.000012 xnoremap <Plug>TComment_<Leader>__ :TCommentMaybeInline<cr>
    1              0.000012 noremap <Plug>TComment_<Leader>_p vip:TComment<cr>
    1              0.000012 noremap <Plug>TComment_<Leader>_<space> :TComment 
    1              0.000012 xnoremap <Plug>TComment_<Leader>_i :TCommentInline<cr>
    1              0.000012 noremap <Plug>TComment_<Leader>_r :TCommentRight<cr>
    1              0.000011 noremap <Plug>TComment_<Leader>_b :TCommentBlock<cr>
    1              0.000012 noremap <Plug>TComment_<Leader>_a :TCommentAs 
    1              0.000012 noremap <Plug>TComment_<Leader>_n :TCommentAs <c-r>=&ft<cr> 
    1              0.000012 noremap <Plug>TComment_<Leader>_s :TCommentAs <c-r>=&ft<cr>_
                            
                            
    1              0.000007 function! s:MapOp(name, extra, op, invoke) "{{{3
                                let opfunc = 'TCommentOpFunc_'. substitute(a:name, '[^a-zA-Z0-9_]', '_', 'G')
                                let fn = [
                                            \ 'function! '. opfunc .'(...)',
                                            \ 'call tcomment#MaybeReuseOptions('. string(opfunc) .')',
                                            \ a:extra,
                                            \ 'return call('. string(a:op) .', a:000)',
                                            \ 'endf'
                                            \ ]
                                exec join(fn, "\n")
                                exec printf('nnoremap <silent> <Plug>TComment_%s '.
                                            \ ':<c-u>call tcomment#ResetOption() \| if v:count > 0 \| call tcomment#SetOption("count", v:count) \| endif \| let w:tcommentPos = getpos(".") \|'.
                                            \ 'set opfunc=%s<cr>%s',
                                            \ a:name, opfunc, a:invoke)
                            endf
                            
                            
    1   0.000109   0.000020 call s:MapOp('Uncomment',  'call tcomment#SetOption("mode_extra", "U")', 'tcomment#operator#Op', 'g@')
    1   0.000092   0.000011 call s:MapOp('Uncommentc', 'call tcomment#SetOption("mode_extra", "U")', 'tcomment#operator#Line', 'g@$')
    1   0.000089   0.000010 call s:MapOp('Uncommentb', 'call tcomment#SetOption("mode_extra", "UB")', 'tcomment#operator#Line', 'g@')
    1              0.000025 xnoremap <silent> <Plug>TComment_Uncomment :<c-u>if v:count > 0 \| call tcomment#SetOption("count", v:count) \| endif \| call tcomment#SetOption("mode_extra", "U") \| '<,'>TCommentMaybeInline<cr>
                            
    1   0.000080   0.000008 call s:MapOp('Comment',  '', 'tcomment#operator#Anyway', 'g@')
    1   0.000077   0.000008 call s:MapOp('Commentl', '', 'tcomment#operator#Line', 'g@$')
    1   0.000075   0.000008 call s:MapOp('Commentc', '', 'tcomment#operator#LineAnyway', 'g@$')
    1   0.000112   0.000009 call s:MapOp('Commentb', 'call tcomment#SetOption("mode_extra", "B")', 'tcomment#operator#Line', 'g@')
    1              0.000058 xnoremap <silent> <Plug>TComment_Comment :<c-u>if v:count > 0 \| call tcomment#SetOption("count", v:count) \| endif \| '<,'>TCommentMaybeInline!<cr>
                            
    1              0.000015 vnoremap <Plug>TComment_ic :<c-U>call tcomment#textobject#InlineComment()<cr>
    1              0.000014 noremap <Plug>TComment_ic :<c-U>call tcomment#textobject#InlineComment()<cr>
                            
    1   0.000083   0.000012 call s:MapOp('gcc', '', 'tcomment#operator#Line', 'g@$')
    1   0.000075   0.000010 call s:MapOp('gcb', 'call tcomment#SetOption("mode_extra", "B")', 'tcomment#operator#Line', 'g@')
    1              0.000012 xnoremap <Plug>TComment_gc :TCommentMaybeInline<cr>
                            
    1   0.000083   0.000007 call s:MapOp('gc', '', 'tcomment#operator#Op', 'g@')
    1   0.000072   0.000007 call s:MapOp('gC', '', 'tcomment#operator#Line', 'g@')
                            
   10              0.000017 for s:i in range(1, 9)
    9              0.000161     exec 'noremap <Plug>TComment_<c-_>' . s:i . ' :call tcomment#SetOption("count", '. s:i .')<cr>'
    9              0.000159     exec 'inoremap <Plug>TComment_<c-_>' . s:i . ' <c-\><c-o>:call tcomment#SetOption("count", '. s:i .')<cr>'
    9              0.000167     exec 'vnoremap <Plug>TComment_<c-_>' . s:i . ' :call tcomment#SetOption("count", '. s:i .')<cr>'
   10              0.000010 endfor
   10              0.000021 for s:i in range(1, 9)
    9   0.000748   0.000095     call s:MapOp('gc' . s:i .'c', 'call tcomment#SetOption("count", '. s:i .')', 'tcomment#operator#Op', 'g@')
   10              0.000022 endfor
    1              0.000003 unlet s:i
                            
    1              0.000004 delfun s:MapOp
                            
                            
    1              0.000002 if g:tcomment_maps
    1              0.000003     if g:tcomment_mapleader1 != ''
    1              0.000017         exec 'map '. g:tcomment_mapleader1 . g:tcomment_mapleader1 .' <Plug>TComment_<c-_><c-_>'
    1              0.000015         exec 'vmap '. g:tcomment_mapleader1 . g:tcomment_mapleader1 .' <Plug>TComment_<c-_><c-_>'
    1              0.000014         exec 'imap '. g:tcomment_mapleader1 . g:tcomment_mapleader1 .' <Plug>TComment_<c-_><c-_>'
    1              0.000022         exec 'map '. g:tcomment_mapleader1 .'p <Plug>TComment_<c-_>p'
    1              0.000014         exec 'imap '. g:tcomment_mapleader1 .'p <Plug>TComment_<c-_>p'
    1              0.000021         exec 'map '. g:tcomment_mapleader1 .'<space> <Plug>TComment_<c-_><space>'
    1              0.000013         exec 'imap '. g:tcomment_mapleader1 .'<space> <Plug>TComment_<c-_><space>'
    1              0.000012         exec 'imap '. g:tcomment_mapleader1 .'r <Plug>TComment_<c-_>r'
    1              0.000013         exec 'map '. g:tcomment_mapleader1 .'r <Plug>TComment_<c-_>r'
    1              0.000013         exec 'vmap '. g:tcomment_mapleader1 .'i <Plug>TComment_<c-_>i'
    1              0.000013         exec 'map '. g:tcomment_mapleader1 .'i <Plug>TComment_<c-_>i'
    1              0.000012         exec 'imap '. g:tcomment_mapleader1 .'i <Plug>TComment_<c-_>i'
    1              0.000013         exec 'map '. g:tcomment_mapleader1 .'b <Plug>TComment_<c-_>b'
    1              0.000012         exec 'imap '. g:tcomment_mapleader1 .'b <Plug>TComment_<c-_>b'
    1              0.000012         exec 'map '. g:tcomment_mapleader1 .'a <Plug>TComment_<c-_>a'
    1              0.000027         exec 'imap '. g:tcomment_mapleader1 .'a <Plug>TComment_<c-_>a'
    1              0.000013         exec 'map '. g:tcomment_mapleader1 .'n <Plug>TComment_<c-_>n'
    1              0.000012         exec 'imap '. g:tcomment_mapleader1 .'n <Plug>TComment_<c-_>n'
    1              0.000013         exec 'map '. g:tcomment_mapleader1 .'s <Plug>TComment_<c-_>s'
    1              0.000012         exec 'imap '. g:tcomment_mapleader1 .'s <Plug>TComment_<c-_>s'
    1              0.000013         exec 'map '. g:tcomment_mapleader1 .'cc <Plug>TComment_<c-_>cc'
    1              0.000022         exec 'map '. g:tcomment_mapleader1 .'ca <Plug>TComment_<c-_>ca'
   10              0.000019         for s:i in range(1, 9)
    9              0.000140             exec 'map '. g:tcomment_mapleader1 . s:i .' <Plug>TComment_<c-_>'.s:i
    9              0.000119             exec 'imap '. g:tcomment_mapleader1 . s:i .' <Plug>TComment_<c-_>'.s:i
    9              0.000132             exec 'vmap '. g:tcomment_mapleader1 . s:i .' <Plug>TComment_<c-_>'.s:i
   10              0.000009         endfor
    1              0.000002         unlet s:i
    1              0.000001     endif
    1              0.000002     if g:tcomment_mapleader2 != ''
    1              0.000018         exec 'map '. g:tcomment_mapleader2 .'_ <Plug>TComment_<Leader>__'
    1              0.000017         exec 'xmap '. g:tcomment_mapleader2 .'_ <Plug>TComment_<Leader>__'
    1              0.000016         exec 'map '. g:tcomment_mapleader2 .'p <Plug>TComment_<Leader>_p'
    1              0.000017         exec 'map '. g:tcomment_mapleader2 .'<space> <Plug>TComment_<Leader>_<space>'
    1              0.000016         exec 'xmap '. g:tcomment_mapleader2 .'i <Plug>TComment_<Leader>_i'
    1              0.000016         exec 'map '. g:tcomment_mapleader2 .'r <Plug>TComment_<Leader>_r'
    1              0.000016         exec 'map '. g:tcomment_mapleader2 .'b <Plug>TComment_<Leader>_b'
    1              0.000015         exec 'map '. g:tcomment_mapleader2 .'a <Plug>TComment_<Leader>_a'
    1              0.000016         exec 'map '. g:tcomment_mapleader2 .'n <Plug>TComment_<Leader>_n'
    1              0.000016         exec 'map '. g:tcomment_mapleader2 .'s <Plug>TComment_<Leader>_s'
    1              0.000002     endif
    1              0.000002     if g:tcomment_opleader1 != ''
    1              0.000014         exec 'nmap <silent> '. g:tcomment_opleader1 .' <Plug>TComment_gc'
   10              0.000016         for s:i in range(1, 9)
    9              0.000149             exec 'nmap <silent> '. g:tcomment_opleader1 . s:i .' <Plug>TComment_gc'.s:i
    9              0.000134             exec 'nmap <silent> '. g:tcomment_opleader1 . s:i .'c <Plug>TComment_gc'.s:i.'c'
   10              0.000010         endfor
    1              0.000003         unlet s:i
    1              0.000013         exec 'nmap <silent> '. g:tcomment_opleader1 .'c <Plug>TComment_gcc'
    1              0.000012         exec 'nmap <silent> '. g:tcomment_opleader1 .'b <Plug>TComment_gcb'
    1              0.000013         exec 'xmap '. g:tcomment_opleader1 .' <Plug>TComment_gc'
    1              0.000002     endif
    1              0.000003    if g:tcomment_mapleader_uncomment_anyway != ''
    1              0.000015         exec 'nmap <silent> '. g:tcomment_mapleader_uncomment_anyway .' <Plug>TComment_Uncomment'
    1              0.000015         exec 'nmap <silent> '. g:tcomment_mapleader_uncomment_anyway .'c <Plug>TComment_Uncommentc'
    1              0.000014         exec 'nmap <silent> '. g:tcomment_mapleader_uncomment_anyway .'b <Plug>TComment_Uncommentb'
    1              0.000014         exec 'xmap '. g:tcomment_mapleader_uncomment_anyway .' <Plug>TComment_Uncomment'
    1              0.000001     endif
    1              0.000002    if g:tcomment_mapleader_comment_anyway != ''
    1              0.000013         exec 'nmap <silent> '. g:tcomment_mapleader_comment_anyway .' <Plug>TComment_Comment'
    1              0.000014         exec 'nmap <silent> '. g:tcomment_mapleader_comment_anyway .'c <Plug>TComment_Commentc'
    1              0.000013         exec 'nmap <silent> '. g:tcomment_mapleader_comment_anyway .'b <Plug>TComment_Commentb'
    1              0.000013         exec 'xmap '. g:tcomment_mapleader_comment_anyway .' <Plug>TComment_Comment'
    1              0.000001     endif
    1              0.000003     if g:tcomment_textobject_inlinecomment != ''
    1              0.000012         exec 'vmap' g:tcomment_textobject_inlinecomment ' <Plug>TComment_ic'
    1              0.000012         exec 'omap' g:tcomment_textobject_inlinecomment ' <Plug>TComment_ic'
    1              0.000001     endif
    1              0.000001 endif
                            
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " vi: ft=vim:tw=72:ts=4:fo=w2croql

SCRIPT  /home/c5262761/configit/vim/modules/tcomment_vim/autoload/tcomment/deprecated.vim
Sourced 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
                            " @Author:      Tom Link (mailto:micathom AT gmail com?subject=[vim])
                            " @Website:     https://github.com/tomtom
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Last Change: 2018-06-22
                            " @Revision:    55
                            
    1              0.000005 function! tcomment#deprecated#Check() abort "{{{3
                                let vars = {
                                            \   'tcommentModeExtra': 'g:tcomment#mode_extra'
                                            \ , 'tcommentOpModeExtra': 'g:tcomment#operator#mode_extra'
                                            \ , 'tcommentOptions': 'g:tcomment#options'
                                            \ , 'tcommentGuessFileType': 'g:tcomment#filetype#guess'
                                            \ , 'tcommentMaps': 'g:tcomment_maps'
                                            \ , 'tcommentMapLeader1': 'g:tcomment_mapleader1'
                                            \ , 'tcommentMapLeader2': 'g:tcomment_mapleader2'
                                            \ , 'tcommentMapLeaderOp1': 'g:tcomment_opleader1'
                                            \ , 'tcommentMapLeaderUncommentAnyway': 'g:tcomment_mapleader_uncomment_anyway'
                                            \ , 'tcommentMapLeaderCommentAnyway': 'g:tcomment_mapleader_comment_anyway'
                                            \ , 'tcommentTextObjectInlineComment': 'g:tcomment_textobject_inlinecomment'
                                            \ , 'tcomment#filetype_map': 'g:tcomment#filetype#map'
                                            \ , 'tcomment#syntax_substitute': 'g:tcomment#syntax#substitute'
                                            \ , 'tcommentSyntaxMap': 'g:tcomment#filetype#syntax_map'
                                            \ , 'tcommentLineC_fmt': 'g:tcomment#line_fmt_c'
                                            \ , 'tcommentInlineC': 'g:tcomment#inline_fmt_c'
                                            \ , 'tcommentInlineXML': 'g:tcomment#inline_fmt_xml'
                                            \ , 'tcommentBlockC': 'g:tcomment#block_fmt_c'
                                            \ , 'tcommentBlockXML': 'g:tcomment#block_fmt_xml'
                                            \ , 'tcommentBlockC2': 'g:tcomment#block2_fmt_c'
                                            \ }
                            
                                let patterns = {
                                            \   'tcommentGuessFileType_\(\w\+\)': 'g:tcomment#filetype#guess_\1'
                                            \ , 'tcommentIgnoreTypes_\(\w\+\)': 'g:tcomment#filetype#ignore_\1'
                                            \ }
                            
                                let pattern = '\C^\%(' . join(keys(patterns) + keys(vars), '\|') . '\)$'
                                " let gvars = filter(keys(g:), 'v:val =~# pattern')
                                " let gvars = filter(keys(g:), 'v:val =~# ''^tcomment''')
                                let gvars = filter(keys(g:), 'strpart(v:val, 0, '. strlen('tcomment') .') ==# ''tcomment''')
                            
                                for gold in gvars
                                    let gnew = ''
                            
                                    if has_key(vars, gold)
                                        let gnew = vars[gold]
                                    elseif gold =~# pattern
                                        for [search, replace] in items(patterns)
                                            if gold =~# search
                                                let gnew = substitute(gold, search, replace, '')
                                                break
                                            endif
                                        endfor
                                    endif
                            
                                    if !empty(gnew)
                                        echom 'tcomment:' gold 'is deprecated; please use' gnew 'instead; your setting might be ignored'
                                        exec 'let' gnew '= g:'. gold
                                    endif
                                endfor
                            endf
                            

SCRIPT  /home/c5262761/configit/vim/modules/vim-surround/plugin/surround.vim
Sourced 1 time
Total time:   0.000921
 Self time:   0.000921

count  total (s)   self (s)
                            " surround.vim - Surroundings
                            " Author:       Tim Pope <http://tpo.pe/>
                            " Version:      2.1
                            " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim
                            
    1              0.000014 if exists("g:loaded_surround") || &cp || v:version < 700
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_surround = 1
                            
                            " Input functions {{{1
                            
    1              0.000004 function! s:getchar()
                              let c = getchar()
                              if c =~ '^\d\+$'
                                let c = nr2char(c)
                              endif
                              return c
                            endfunction
                            
    1              0.000002 function! s:inputtarget()
                              let c = s:getchar()
                              while c =~ '^\d\+$'
                                let c .= s:getchar()
                              endwhile
                              if c == " "
                                let c .= s:getchar()
                              endif
                              if c =~ "\<Esc>\|\<C-C>\|\0"
                                return ""
                              else
                                return c
                              endif
                            endfunction
                            
    1              0.000002 function! s:inputreplacement()
                              let c = s:getchar()
                              if c == " "
                                let c .= s:getchar()
                              endif
                              if c =~ "\<Esc>" || c =~ "\<C-C>"
                                return ""
                              else
                                return c
                              endif
                            endfunction
                            
    1              0.000002 function! s:beep()
                              exe "norm! \<Esc>"
                              return ""
                            endfunction
                            
    1              0.000002 function! s:redraw()
                              redraw
                              return ""
                            endfunction
                            
                            " }}}1
                            
                            " Wrapping functions {{{1
                            
    1              0.000002 function! s:extractbefore(str)
                              if a:str =~ '\r'
                                return matchstr(a:str,'.*\ze\r')
                              else
                                return matchstr(a:str,'.*\ze\n')
                              endif
                            endfunction
                            
    1              0.000002 function! s:extractafter(str)
                              if a:str =~ '\r'
                                return matchstr(a:str,'\r\zs.*')
                              else
                                return matchstr(a:str,'\n\zs.*')
                              endif
                            endfunction
                            
    1              0.000003 function! s:fixindent(str,spc)
                              let str = substitute(a:str,'\t',repeat(' ',&sw),'g')
                              let spc = substitute(a:spc,'\t',repeat(' ',&sw),'g')
                              let str = substitute(str,'\(\n\|\%^\).\@=','\1'.spc,'g')
                              if ! &et
                                let str = substitute(str,'\s\{'.&ts.'\}',"\t",'g')
                              endif
                              return str
                            endfunction
                            
    1              0.000002 function! s:process(string)
                              let i = 0
                              for i in range(7)
                                let repl_{i} = ''
                                let m = matchstr(a:string,nr2char(i).'.\{-\}\ze'.nr2char(i))
                                if m != ''
                                  let m = substitute(strpart(m,1),'\r.*','','')
                                  let repl_{i} = input(match(m,'\w\+$') >= 0 ? m.': ' : m)
                                endif
                              endfor
                              let s = ""
                              let i = 0
                              while i < strlen(a:string)
                                let char = strpart(a:string,i,1)
                                if char2nr(char) < 8
                                  let next = stridx(a:string,char,i+1)
                                  if next == -1
                                    let s .= char
                                  else
                                    let insertion = repl_{char2nr(char)}
                                    let subs = strpart(a:string,i+1,next-i-1)
                                    let subs = matchstr(subs,'\r.*')
                                    while subs =~ '^\r.*\r'
                                      let sub = matchstr(subs,"^\r\\zs[^\r]*\r[^\r]*")
                                      let subs = strpart(subs,strlen(sub)+1)
                                      let r = stridx(sub,"\r")
                                      let insertion = substitute(insertion,strpart(sub,0,r),strpart(sub,r+1),'')
                                    endwhile
                                    let s .= insertion
                                    let i = next
                                  endif
                                else
                                  let s .= char
                                endif
                                let i += 1
                              endwhile
                              return s
                            endfunction
                            
    1              0.000004 function! s:wrap(string,char,type,removed,special)
                              let keeper = a:string
                              let newchar = a:char
                              let s:input = ""
                              let type = a:type
                              let linemode = type ==# 'V' ? 1 : 0
                              let before = ""
                              let after  = ""
                              if type ==# "V"
                                let initspaces = matchstr(keeper,'\%^\s*')
                              else
                                let initspaces = matchstr(getline('.'),'\%^\s*')
                              endif
                              let pairs = "b()B{}r[]a<>"
                              let extraspace = ""
                              if newchar =~ '^ '
                                let newchar = strpart(newchar,1)
                                let extraspace = ' '
                              endif
                              let idx = stridx(pairs,newchar)
                              if newchar == ' '
                                let before = ''
                                let after  = ''
                              elseif exists("b:surround_".char2nr(newchar))
                                let all    = s:process(b:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif exists("g:surround_".char2nr(newchar))
                                let all    = s:process(g:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif newchar ==# "p"
                                let before = "\n"
                                let after  = "\n\n"
                              elseif newchar ==# 's'
                                let before = ' '
                                let after  = ''
                              elseif newchar ==# ':'
                                let before = ':'
                                let after = ''
                              elseif newchar =~# "[tT\<C-T><]"
                                let dounmapp = 0
                                let dounmapb = 0
                                if !maparg(">","c")
                                  let dounmapb = 1
                                  " Hide from AsNeeded
                                  exe "cn"."oremap > ><CR>"
                                endif
                                let default = ""
                                if newchar ==# "T"
                                  if !exists("s:lastdel")
                                    let s:lastdel = ""
                                  endif
                                  let default = matchstr(s:lastdel,'<\zs.\{-\}\ze>')
                                endif
                                let tag = input("<",default)
                                if dounmapb
                                  silent! cunmap >
                                endif
                                let s:input = tag
                                if tag != ""
                                  let keepAttributes = ( match(tag, ">$") == -1 )
                                  let tag = substitute(tag,'>*$','','')
                                  let attributes = ""
                                  if keepAttributes
                                    let attributes = matchstr(a:removed, '<[^ \t\n]\+\zs\_.\{-\}\ze>')
                                  endif
                                  let s:input = tag . '>'
                                  if tag =~ '/$'
                                    let tag = substitute(tag, '/$', '', '')
                                    let before = '<'.tag.attributes.' />'
                                    let after = ''
                                  else
                                    let before = '<'.tag.attributes.'>'
                                    let after  = '</'.substitute(tag,' .*','','').'>'
                                  endif
                                  if newchar == "\<C-T>"
                                    if type ==# "v" || type ==# "V"
                                      let before .= "\n\t"
                                    endif
                                    if type ==# "v"
                                      let after  = "\n". after
                                    endif
                                  endif
                                endif
                              elseif newchar ==# 'l' || newchar == '\'
                                " LaTeX
                                let env = input('\begin{')
                                if env != ""
                                  let s:input = env."\<CR>"
                                  let env = '{' . env
                                  let env .= s:closematch(env)
                                  echo '\begin'.env
                                  let before = '\begin'.env
                                  let after  = '\end'.matchstr(env,'[^}]*').'}'
                                endif
                              elseif newchar ==# 'f' || newchar ==# 'F'
                                let fnc = input('function: ')
                                if fnc != ""
                                  let s:input = fnc."\<CR>"
                                  let before = substitute(fnc,'($','','').'('
                                  let after  = ')'
                                  if newchar ==# 'F'
                                    let before .= ' '
                                    let after = ' ' . after
                                  endif
                                endif
                              elseif newchar ==# "\<C-F>"
                                let fnc = input('function: ')
                                let s:input = fnc."\<CR>"
                                let before = '('.fnc.' '
                                let after = ')'
                              elseif idx >= 0
                                let spc = (idx % 3) == 1 ? " " : ""
                                let idx = idx / 3 * 3
                                let before = strpart(pairs,idx+1,1) . spc
                                let after  = spc . strpart(pairs,idx+2,1)
                              elseif newchar == "\<C-[>" || newchar == "\<C-]>"
                                let before = "{\n\t"
                                let after  = "\n}"
                              elseif newchar !~ '\a'
                                let before = newchar
                                let after  = newchar
                              else
                                let before = ''
                                let after  = ''
                              endif
                              let after  = substitute(after ,'\n','\n'.initspaces,'g')
                              if type ==# 'V' || (a:special && type ==# "v")
                                let before = substitute(before,' \+$','','')
                                let after  = substitute(after ,'^ \+','','')
                                if after !~ '^\n'
                                  let after  = initspaces.after
                                endif
                                if keeper !~ '\n$' && after !~ '^\n'
                                  let keeper .= "\n"
                                elseif keeper =~ '\n$' && after =~ '^\n'
                                  let after = strpart(after,1)
                                endif
                                if keeper !~ '^\n' && before !~ '\n\s*$'
                                  let before .= "\n"
                                  if a:special
                                    let before .= "\t"
                                  endif
                                elseif keeper =~ '^\n' && before =~ '\n\s*$'
                                  let keeper = strcharpart(keeper,1)
                                endif
                                if type ==# 'V' && keeper =~ '\n\s*\n$'
                                  let keeper = strcharpart(keeper,0,strchars(keeper) - 1)
                                endif
                              endif
                              if type ==# 'V'
                                let before = initspaces.before
                              endif
                              if before =~ '\n\s*\%$'
                                if type ==# 'v'
                                  let keeper = initspaces.keeper
                                endif
                                let padding = matchstr(before,'\n\zs\s\+\%$')
                                let before  = substitute(before,'\n\s\+\%$','\n','')
                                let keeper = s:fixindent(keeper,padding)
                              endif
                              if type ==# 'V'
                                let keeper = before.keeper.after
                              elseif type =~ "^\<C-V>"
                                " Really we should be iterating over the buffer
                                let repl = substitute(before,'[\\~]','\\&','g').'\1'.substitute(after,'[\\~]','\\&','g')
                                let repl = substitute(repl,'\n',' ','g')
                                let keeper = substitute(keeper."\n",'\(.\{-\}\)\(\n\)',repl.'\n','g')
                                let keeper = substitute(keeper,'\n\%$','','')
                              else
                                let keeper = before.extraspace.keeper.extraspace.after
                              endif
                              return keeper
                            endfunction
                            
    1              0.000003 function! s:wrapreg(reg,char,removed,special)
                              let orig = getreg(a:reg)
                              let type = substitute(getregtype(a:reg),'\d\+$','','')
                              let new = s:wrap(orig,a:char,type,a:removed,a:special)
                              call setreg(a:reg,new,type)
                            endfunction
                            " }}}1
                            
    1              0.000002 function! s:insert(...) " {{{1
                              " Optional argument causes the result to appear on 3 lines, not 1
                              let linemode = a:0 ? a:1 : 0
                              let char = s:inputreplacement()
                              while char == "\<CR>" || char == "\<C-S>"
                                " TODO: use total count for additional blank lines
                                let linemode += 1
                                let char = s:inputreplacement()
                              endwhile
                              if char == ""
                                return ""
                              endif
                              let cb_save = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let reg_save = @@
                              call setreg('"',"\r",'v')
                              call s:wrapreg('"',char,"",linemode)
                              " If line mode is used and the surrounding consists solely of a suffix,
                              " remove the initial newline.  This fits a use case of mine but is a
                              " little inconsistent.  Is there anyone that would prefer the simpler
                              " behavior of just inserting the newline?
                              if linemode && match(getreg('"'),'^\n\s*\zs.*') == 0
                                call setreg('"',matchstr(getreg('"'),'^\n\s*\zs.*'),getregtype('"'))
                              endif
                              " This can be used to append a placeholder to the end
                              if exists("g:surround_insert_tail")
                                call setreg('"',g:surround_insert_tail,"a".getregtype('"'))
                              endif
                              if &ve != 'all' && col('.') >= col('$')
                                if &ve == 'insert'
                                  let extra_cols = virtcol('.') - virtcol('$')
                                  if extra_cols > 0
                                    let [regval,regtype] = [getreg('"',1,1),getregtype('"')]
                                    call setreg('"',join(map(range(extra_cols),'" "'),''),'v')
                                    norm! ""p
                                    call setreg('"',regval,regtype)
                                  endif
                                endif
                                norm! ""p
                              else
                                norm! ""P
                              endif
                              if linemode
                                call s:reindent()
                              endif
                              norm! `]
                              call search('\r','bW')
                              let @@ = reg_save
                              let &clipboard = cb_save
                              return "\<Del>"
                            endfunction " }}}1
                            
    1              0.000003 function! s:reindent() " {{{1
                              if exists("b:surround_indent") ? b:surround_indent : (!exists("g:surround_indent") || g:surround_indent)
                                silent norm! '[=']
                              endif
                            endfunction " }}}1
                            
    1              0.000002 function! s:dosurround(...) " {{{1
                              let scount = v:count1
                              let char = (a:0 ? a:1 : s:inputtarget())
                              let spc = ""
                              if char =~ '^\d\+'
                                let scount = scount * matchstr(char,'^\d\+')
                                let char = substitute(char,'^\d\+','','')
                              endif
                              if char =~ '^ '
                                let char = strpart(char,1)
                                let spc = 1
                              endif
                              if char == 'a'
                                let char = '>'
                              endif
                              if char == 'r'
                                let char = ']'
                              endif
                              let newchar = ""
                              if a:0 > 1
                                let newchar = a:2
                                if newchar == "\<Esc>" || newchar == "\<C-C>" || newchar == ""
                                  return s:beep()
                                endif
                              endif
                              let cb_save = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let append = ""
                              let original = getreg('"')
                              let otype = getregtype('"')
                              call setreg('"',"")
                              let strcount = (scount == 1 ? "" : scount)
                              if char == '/'
                                exe 'norm! '.strcount.'[/d'.strcount.']/'
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>"''`]'
                                exe 'norm! T'.char
                                if getline('.')[col('.')-1] == char
                                  exe 'norm! l'
                                endif
                                exe 'norm! dt'.char
                              else
                                exe 'norm! d'.strcount.'i'.char
                              endif
                              let keeper = getreg('"')
                              let okeeper = keeper " for reindent below
                              if keeper == ""
                                call setreg('"',original,otype)
                                let &clipboard = cb_save
                                return ""
                              endif
                              let oldline = getline('.')
                              let oldlnum = line('.')
                              if char ==# "p"
                                call setreg('"','','V')
                              elseif char ==# "s" || char ==# "w" || char ==# "W"
                                " Do nothing
                                call setreg('"','')
                              elseif char =~ "[\"'`]"
                                exe "norm! i \<Esc>d2i".char
                                call setreg('"',substitute(getreg('"'),' ','',''))
                              elseif char == '/'
                                norm! "_x
                                call setreg('"','/**/',"c")
                                let keeper = substitute(substitute(keeper,'^/\*\s\=','',''),'\s\=\*$','','')
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>]'
                                exe 'norm! F'.char
                                exe 'norm! df'.char
                              else
                                " One character backwards
                                call search('\m.', 'bW')
                                exe "norm! da".char
                              endif
                              let removed = getreg('"')
                              let rem2 = substitute(removed,'\n.*','','')
                              let oldhead = strpart(oldline,0,strlen(oldline)-strlen(rem2))
                              let oldtail = strpart(oldline,  strlen(oldline)-strlen(rem2))
                              let regtype = getregtype('"')
                              if char =~# '[\[({<T]' || spc
                                let keeper = substitute(keeper,'^\s\+','','')
                                let keeper = substitute(keeper,'\s\+$','','')
                              endif
                              if col("']") == col("$") && col('.') + 1 == col('$')
                                if oldhead =~# '^\s*$' && a:0 < 2
                                  let keeper = substitute(keeper,'\%^\n'.oldhead.'\(\s*.\{-\}\)\n\s*\%$','\1','')
                                endif
                                let pcmd = "p"
                              else
                                let pcmd = "P"
                              endif
                              if line('.') + 1 < oldlnum && regtype ==# "V"
                                let pcmd = "p"
                              endif
                              call setreg('"',keeper,regtype)
                              if newchar != ""
                                let special = a:0 > 2 ? a:3 : 0
                                call s:wrapreg('"',newchar,removed,special)
                              endif
                              silent exe 'norm! ""'.pcmd.'`['
                              if removed =~ '\n' || okeeper =~ '\n' || getreg('"') =~ '\n'
                                call s:reindent()
                              endif
                              if getline('.') =~ '^\s\+$' && keeper =~ '^\s*\n'
                                silent norm! cc
                              endif
                              call setreg('"',original,otype)
                              let s:lastdel = removed
                              let &clipboard = cb_save
                              if newchar == ""
                                silent! call repeat#set("\<Plug>Dsurround".char,scount)
                              else
                                silent! call repeat#set("\<Plug>C".(a:0 > 2 && a:3 ? "S" : "s")."urround".char.newchar.s:input,scount)
                              endif
                            endfunction " }}}1
                            
    1              0.000002 function! s:changesurround(...) " {{{1
                              let a = s:inputtarget()
                              if a == ""
                                return s:beep()
                              endif
                              let b = s:inputreplacement()
                              if b == ""
                                return s:beep()
                              endif
                              call s:dosurround(a,b,a:0 && a:1)
                            endfunction " }}}1
                            
    1              0.000002 function! s:opfunc(type, ...) abort " {{{1
                              if a:type ==# 'setup'
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
                                return 'g@'
                              endif
                              let char = s:inputreplacement()
                              if char == ""
                                return s:beep()
                              endif
                              let reg = '"'
                              let sel_save = &selection
                              let &selection = "inclusive"
                              let cb_save  = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let reg_save = getreg(reg)
                              let reg_type = getregtype(reg)
                              let type = a:type
                              if a:type == "char"
                                silent exe 'norm! v`[o`]"'.reg.'y'
                                let type = 'v'
                              elseif a:type == "line"
                                silent exe 'norm! `[V`]"'.reg.'y'
                                let type = 'V'
                              elseif a:type ==# "v" || a:type ==# "V" || a:type ==# "\<C-V>"
                                let &selection = sel_save
                                let ve = &virtualedit
                                if !(a:0 && a:1)
                                  set virtualedit=
                                endif
                                silent exe 'norm! gv"'.reg.'y'
                                let &virtualedit = ve
                              elseif a:type =~ '^\d\+$'
                                let type = 'v'
                                silent exe 'norm! ^v'.a:type.'$h"'.reg.'y'
                                if mode() ==# 'v'
                                  norm! v
                                  return s:beep()
                                endif
                              else
                                let &selection = sel_save
                                let &clipboard = cb_save
                                return s:beep()
                              endif
                              let keeper = getreg(reg)
                              if type ==# "v" && a:type !=# "v"
                                let append = matchstr(keeper,'\_s\@<!\s*$')
                                let keeper = substitute(keeper,'\_s\@<!\s*$','','')
                              endif
                              call setreg(reg,keeper,type)
                              call s:wrapreg(reg,char,"",a:0 && a:1)
                              if type ==# "v" && a:type !=# "v" && append != ""
                                call setreg(reg,append,"ac")
                              endif
                              silent exe 'norm! gv'.(reg == '"' ? '' : '"' . reg).'p`['
                              if type ==# 'V' || (getreg(reg) =~ '\n' && type ==# 'v')
                                call s:reindent()
                              endif
                              call setreg(reg,reg_save,reg_type)
                              let &selection = sel_save
                              let &clipboard = cb_save
                              if a:type =~ '^\d\+$'
                                silent! call repeat#set("\<Plug>Y".(a:0 && a:1 ? "S" : "s")."surround".char.s:input,a:type)
                              else
                                silent! call repeat#set("\<Plug>SurroundRepeat".char.s:input)
                              endif
                            endfunction
                            
    1              0.000003 function! s:opfunc2(...) abort
                              if !a:0 || a:1 ==# 'setup'
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
                                return 'g@'
                              endif
                              call s:opfunc(a:1, 1)
                            endfunction " }}}1
                            
    1              0.000002 function! s:closematch(str) " {{{1
                              " Close an open (, {, [, or < on the command line.
                              let tail = matchstr(a:str,'.[^\[\](){}<>]*$')
                              if tail =~ '^\[.\+'
                                return "]"
                              elseif tail =~ '^(.\+'
                                return ")"
                              elseif tail =~ '^{.\+'
                                return "}"
                              elseif tail =~ '^<.+'
                                return ">"
                              else
                                return ""
                              endif
                            endfunction " }}}1
                            
    1              0.000027 nnoremap <silent> <Plug>SurroundRepeat .
    1              0.000016 nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>
    1              0.000012 nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>
    1              0.000012 nnoremap <silent> <Plug>CSurround  :<C-U>call <SID>changesurround(1)<CR>
    1              0.000014 nnoremap <expr>   <Plug>Yssurround '^'.v:count1.<SID>opfunc('setup').'g_'
    1              0.000025 nnoremap <expr>   <Plug>YSsurround <SID>opfunc2('setup').'_'
    1              0.000012 nnoremap <expr>   <Plug>Ysurround  <SID>opfunc('setup')
    1              0.000014 nnoremap <expr>   <Plug>YSurround  <SID>opfunc2('setup')
    1              0.000016 vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>
    1              0.000015 vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>
    1              0.000012 inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>
    1              0.000011 inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>
                            
    1              0.000006 if !exists("g:surround_no_mappings") || ! g:surround_no_mappings
    1              0.000010   nmap ds  <Plug>Dsurround
    1              0.000012   nmap cs  <Plug>Csurround
    1              0.000009   nmap cS  <Plug>CSurround
    1              0.000009   nmap ys  <Plug>Ysurround
    1              0.000009   nmap yS  <Plug>YSurround
    1              0.000009   nmap yss <Plug>Yssurround
    1              0.000009   nmap ySs <Plug>YSsurround
    1              0.000009   nmap ySS <Plug>YSsurround
    1              0.000010   xmap S   <Plug>VSurround
    1              0.000012   xmap gS  <Plug>VgSurround
    1              0.000006   if !exists("g:surround_no_insert_mappings") || ! g:surround_no_insert_mappings
    1              0.000022     if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")
    1              0.000011       imap    <C-S> <Plug>Isurround
    1              0.000001     endif
    1              0.000010     imap      <C-G>s <Plug>Isurround
    1              0.000018     imap      <C-G>S <Plug>ISurround
    1              0.000001   endif
    1              0.000001 endif
                            
                            " vim:set ft=vim sw=2 sts=2 et:

SCRIPT  /home/c5262761/configit/vim/modules/targets.vim/plugin/targets.vim
Sourced 1 time
Total time:   0.000360
 Self time:   0.000116

count  total (s)   self (s)
                            " targets.vim Provides additional text objects
                            " Author:  Christian Wellenbrock <christian.wellenbrock@gmail.com>
                            " License: MIT license
                            
    1              0.000014 if exists("g:loaded_targets") || &cp || v:version < 700
                                finish
    1              0.000001 endif
    1              0.000004 let g:loaded_targets = '0.5.0' " version number
    1              0.000003 let s:save_cpoptions = &cpoptions
    1              0.000008 set cpo&vim
                            
    1              0.000004 function! s:addAllMappings()
                                " this is somewhat ugly, but we still need these nl values inside of the
                                " expression mapping and don't want to have this legacy fallback in two
                                " places
                                let g:targets_nl = get(g:, 'targets_nl', get(g:, 'targets_nlNL', 'nl')[0:1]) " legacy fallback
                                let aiAI         = get(g:, 'targets_aiAI', 'aiAI')
                                let mapped_aiAI  = get(g:, 'targets_mapped_aiAI', aiAI)
                                let [s:a,  s:i,  s:A,  s:I]  = split(aiAI, '\zs')
                                let [s:ma, s:mi, s:mA, s:mI] = split(mapped_aiAI, '\zs')
                                let [s:n, s:l]               = split(g:targets_nl, '\zs')
                            
                                if v:version >= 704 || (v:version == 703 && has('patch338'))
                                    " if possible, create only a few expression mappings to speed up loading times
                                    silent! execute 'omap <expr> <unique>' s:i "targets#e('o', 'i', '" . s:mi . "')"
                                    silent! execute 'omap <expr> <unique>' s:a "targets#e('o', 'a', '" . s:ma . "')"
                                    silent! execute 'omap <expr> <unique>' s:I "targets#e('o', 'I', '" . s:mI . "')"
                                    silent! execute 'omap <expr> <unique>' s:A "targets#e('o', 'A', '" . s:mA . "')"
                            
                                    silent! execute 'xmap <expr> <unique>' s:i "targets#e('x', 'i', '" . s:mi . "')"
                                    silent! execute 'xmap <expr> <unique>' s:a "targets#e('x', 'a', '" . s:ma . "')"
                                    silent! execute 'xmap <expr> <unique>' s:I "targets#e('x', 'I', '" . s:mI . "')"
                                    silent! execute 'xmap <expr> <unique>' s:A "targets#e('x', 'A', '" . s:mA . "')"
                            
                                    " #209: The above mappings don't use <silent> for better visual
                                    " feedback on `!ip` (when we pass back control to Vim). To be silent
                                    " when calling internal targest functions, we use this special mapping
                                    " which does use <silent>. It should not lead to conflicts because (
                                    " is not a valid register.
                                    onoremap <silent> @(targets) :<C-U>call targets#do()<CR>
                                    xnoremap <silent> @(targets) :<C-U>call targets#do()<CR>
                            
                                else
                                    " otherwise create individual mappings #117
                                    " NOTE: for old versions only these legacy settings are used
                                    " the more flexible targets#mappings only work with the expression
                                    " mappings above (from Vim version 7.3.338 on)
                                    call targets#legacy#addMappings(s:a, s:i, s:A, s:I, s:n, s:l)
                                endif
                            endfunction
                            
    1   0.000252   0.000008 call s:addAllMappings()
                            
    1              0.000006 let &cpoptions = s:save_cpoptions
    1              0.000006 unlet s:save_cpoptions

SCRIPT  /home/c5262761/configit/vim/modules/vim-fugitive/plugin/fugitive.vim
Sourced 1 time
Total time:   0.001958
 Self time:   0.001517

count  total (s)   self (s)
                            " fugitive.vim - A Git wrapper so awesome, it should be illegal
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      3.0
                            " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
                            
    1              0.000007 if exists('g:loaded_fugitive')
                              finish
    1              0.000001 endif
    1              0.000004 let g:loaded_fugitive = 1
                            
    1              0.000003 function! FugitiveGitDir(...) abort
                              if !a:0 || type(a:1) == type(0) && a:1 < 0
                                let dir = get(b:, 'git_dir', '')
                                if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
                                endif
                                return dir
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif
                            endfunction
                            
                            " FugitiveReal() takes a fugitive:// URL and returns the corresponding path in
                            " the work tree.  This may be useful to get a cleaner path for inclusion in
                            " the statusline, for example.  Note that the file and its parent directories
                            " are not guaranteed to exist.
                            "
                            " This is intended as an abstract API to be used on any "virtual" path.  For a
                            " buffer named foo://bar, check for a function named FooReal(), and if it
                            " exists, call FooReal("foo://bar").
    1              0.000002 function! FugitiveReal(...) abort
                              let file = a:0 ? a:1 : @%
                              if file =~# '^\a\a\+:' || a:0 > 1
                                return call('fugitive#Real', [file] + a:000[1:-1])
                              elseif file =~# '^/\|^\a:\|^$'
                                return file
                              else
                                return fnamemodify(file, ':p' . (file =~# '[\/]$' ? '' : ':s?[\/]$??'))
                              endif
                            endfunction
                            
                            " FugitiveFind() takes a Fugitive object and returns the appropriate Vim
                            " buffer name.  You can use this to generate Fugitive URLs ("HEAD:README") or
                            " to get the absolute path to a file in the Git dir (".git/HEAD"), the common
                            " dir (".git/config"), or the work tree (":(top)Makefile").
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000002 function! FugitiveFind(...) abort
                              return fugitive#Find(a:0 ? a:1 : bufnr(''), FugitiveGitDir(a:0 > 1 ? a:2 : -1))
                            endfunction
                            
    1              0.000001 function! FugitivePath(...) abort
                              if a:0 > 1
                                return fugitive#Path(a:1, a:2, FugitiveGitDir(a:0 > 2 ? a:3 : -1))
                              else
                                return FugitiveReal(a:0 ? a:1 : @%)
                              endif
                            endfunction
                            
                            " FugitiveParse() takes a fugitive:// URL and returns a 2 element list
                            " containing the Git dir and an object name ("commit:file").  It's effectively
                            " then inverse of FugitiveFind().
    1              0.000002 function! FugitiveParse(...) abort
                              let path = s:Slash(a:0 ? a:1 : @%)
                              if path !~# '^fugitive:'
                                return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg
                            endfunction
                            
                            " FugitivePrepare() constructs a Git command string which can be executed with
                            " functions like system() and commands like :!.  Integer arguments will be
                            " treated as buffer numbers, and the appropriate relative path inserted in
                            " their place.
                            "
                            " If the first argument is a string that looks like a path or an empty string,
                            " it will be used as the Git dir.  If it's a buffer number, the Git dir for
                            " that buffer will be used.  The default is the current buffer.
    1              0.000001 function! FugitivePrepare(...) abort
                              return call('fugitive#Prepare', a:000)
                            endfunction
                            
    1              0.000002 function! FugitiveConfig(...) abort
                              if a:0 == 2 && type(a:2) != type({})
                                return fugitive#Config(a:1, FugitiveGitDir(a:2))
                              elseif a:0 == 1 && a:1 !~# '^[[:alnum:]-]\+\.'
                                return fugitive#Config(FugitiveGitDir(a:1))
                              else
                                return call('fugitive#Config', a:000)
                              endif
                            endfunction
                            
    1              0.000002 function! FugitiveRemoteUrl(...) abort
                              return fugitive#RemoteUrl(a:0 ? a:1 : '', FugitiveGitDir(a:0 > 1 ? a:2 : -1))
                            endfunction
                            
    1              0.000001 function! FugitiveHead(...) abort
                              let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
                              if empty(dir)
                                return ''
                              endif
                              return fugitive#Head(a:0 ? a:1 : 0, dir)
                            endfunction
                            
    1              0.000002 function! FugitiveStatusline(...) abort
                              if !exists('b:git_dir')
                                return ''
                              endif
                              return fugitive#Statusline()
                            endfunction
                            
    1              0.000002 function! FugitiveCommonDir(...) abort
                              let dir = FugitiveGitDir(a:0 ? a:1 : -1)
                              if empty(dir)
                                return ''
                              endif
                              return fugitive#CommonDir(dir)
                            endfunction
                            
    1              0.000002 function! FugitiveWorkTree(...) abort
                              return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))
                            endfunction
                            
    1              0.000002 function! FugitiveIsGitDir(path) abort
                              let path = substitute(a:path, '[\/]$', '', '') . '/'
                              return len(a:path) && getfsize(path.'HEAD') > 10 && (
                                    \ isdirectory(path.'objects') && isdirectory(path.'refs') ||
                                    \ getftype(path.'commondir') ==# 'file')
                            endfunction
                            
    1              0.000003 let s:worktree_for_dir = {}
    1              0.000002 let s:dir_for_worktree = {}
    1              0.000004 function! s:Tree(path) abort
                              let dir = a:path
                              if dir =~# '/\.git$'
                                return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = s:Slash(FugitiveVimPath(matchstr(config[0], '= *\zs.*')))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = s:Slash(fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h'))
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = worktree
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif
                            endfunction
                            
    1              0.000002 function! FugitiveExtractGitDir(path) abort
                              let path = s:Slash(a:path)
                              if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
                              elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
                              else
                                let path = fnamemodify(path, ':p:h:s?/$??')
                              endif
                              let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
                              if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
                              endif
                              let root = resolve(path)
                              if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
                              endif
                              let previous = ""
                              let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
                              call s:Tree(env_git_dir)
                              while root !=# previous
                                if root =~# '\v^//%([^/]+/?)?$'
                                  break
                                endif
                                if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
                                if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
                                elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
                                endif
                                let dir = substitute(root, '[\/]$', '', '') . '/.git'
                                let type = getftype(dir)
                                if type ==# 'dir' && FugitiveIsGitDir(dir)
                                  return dir
                                elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
                                elseif FugitiveIsGitDir(root)
                                  return root
                                endif
                                let previous = root
                                let root = fnamemodify(root, ':h')
                              endwhile
                              return ''
                            endfunction
                            
    1              0.000002 function! FugitiveDetect(path) abort
                              if exists('b:git_dir') && b:git_dir =~# '^$\|/$\|^fugitive:'
                                unlet b:git_dir
                              endif
                              if !exists('b:git_dir')
                                let dir = FugitiveExtractGitDir(a:path)
                                if dir !=# ''
                                  let b:git_dir = dir
                                endif
                              endif
                              if exists('b:git_dir')
                                return fugitive#Init()
                              endif
                            endfunction
                            
    1              0.000002 function! FugitiveVimPath(path) abort
                              if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
                              else
                                return a:path
                              endif
                            endfunction
                            
    1              0.000002 function! FugitiveGitPath(path) abort
                              return s:Slash(a:path)
                            endfunction
                            
    1              0.000010 function! s:Slash(path) abort
                              if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
                                return a:path
                              endif
                            endfunction
                            
    1              0.000003 function! s:ProjectionistDetect() abort
                              let file = s:Slash(get(g:, 'projectionist_file', ''))
                              let dir = FugitiveExtractGitDir(file)
                              let base = matchstr(file, '^fugitive://.\{-\}//\x\+')
                              if empty(base)
                                let base = s:Tree(dir)
                              endif
                              if len(base)
                                if exists('+shellslash') && !&shellslash
                                  let base = tr(base, '/', '\')
                                endif
                                let file = FugitiveCommonDir(dir) . '/info/projections.json'
                                if filereadable(file)
                                  call projectionist#append(base, file)
                                endif
                              endif
                            endfunction
                            
    1              0.000041 let g:io_fugitive = {
                                  \ 'simplify': function('fugitive#simplify'),
                                  \ 'resolve': function('fugitive#resolve'),
                                  \ 'getftime': function('fugitive#getftime'),
                                  \ 'getfsize': function('fugitive#getfsize'),
                                  \ 'getftype': function('fugitive#getftype'),
                                  \ 'filereadable': function('fugitive#filereadable'),
                                  \ 'filewritable': function('fugitive#filewritable'),
                                  \ 'isdirectory': function('fugitive#isdirectory'),
                                  \ 'getfperm': function('fugitive#getfperm'),
                                  \ 'setfperm': function('fugitive#setfperm'),
                                  \ 'readfile': function('fugitive#readfile'),
                                  \ 'writefile': function('fugitive#writefile'),
                                  \ 'glob': function('fugitive#glob'),
                                  \ 'delete': function('fugitive#delete'),
                                  \ 'Real': function('FugitiveReal')}
                            
    1              0.000003 augroup fugitive
    1              0.000074   autocmd!
                            
    1              0.000011   autocmd BufNewFile,BufReadPost * call FugitiveDetect(expand('<amatch>:p'))
    1              0.000008   autocmd FileType           netrw call FugitiveDetect(fnamemodify(get(b:, 'netrw_curdir', expand('<amatch>')), ':p'))
                            
    1              0.000008   autocmd FileType git
                                    \ if len(FugitiveGitDir()) |
                                    \   call fugitive#MapJumps() |
                                    \   call fugitive#MapCfile() |
                                    \ endif
    1              0.000009   autocmd FileType gitcommit
                                    \ if len(FugitiveGitDir()) |
                                    \   call fugitive#MapCfile('fugitive#MessageCfile()') |
                                    \ endif
    1              0.000008   autocmd FileType fugitive
                                    \ if len(FugitiveGitDir()) |
                                    \   call fugitive#MapCfile('fugitive#StatusCfile()') |
                                    \ endif
    1              0.000014   autocmd FileType gitrebase
                                    \ let &l:include = '^\%(pick\|squash\|edit\|reword\|fixup\|drop\|[pserfd]\)\>' |
                                    \ if len(FugitiveGitDir()) |
                                    \   let &l:includeexpr = 'v:fname =~# ''^\x\{4,\}$'' ? FugitiveFind(v:fname) : ' .
                                    \   (len(&l:includeexpr) ? &l:includeexpr : 'v:fname') |
                                    \ endif |
                                    \ let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|setl inex= inc='
                            
    1              0.000032   autocmd BufReadCmd index{,.lock}
                                    \ if FugitiveIsGitDir(expand('<amatch>:p:h')) |
                                    \   let b:git_dir = s:Slash(expand('<amatch>:p:h')) |
                                    \   exe fugitive#BufReadStatus() |
                                    \ elseif filereadable(expand('<amatch>')) |
                                    \   silent doautocmd BufReadPre |
                                    \   keepalt read <amatch> |
                                    \   1delete_ |
                                    \   silent doautocmd BufReadPost |
                                    \ else |
                                    \   silent doautocmd BufNewFile |
                                    \ endif
                            
    1              0.000010   autocmd BufReadCmd    fugitive://*//*             exe fugitive#BufReadCmd() |
                                    \ if &path =~# '^\.\%(,\|$\)' |
                                    \   let &l:path = substitute(&path, '^\.,\=', '', '') |
                                    \ endif
    1              0.000009   autocmd BufWriteCmd   fugitive://*//[0-3]/*       exe fugitive#BufWriteCmd()
    1              0.000007   autocmd FileReadCmd   fugitive://*//*             exe fugitive#FileReadCmd()
    1              0.000007   autocmd FileWriteCmd  fugitive://*//[0-3]/*       exe fugitive#FileWriteCmd()
    1              0.000029   if exists('##SourceCmd')
    1              0.000009     autocmd SourceCmd     fugitive://*//*    nested exe fugitive#SourceCmd()
    1              0.000001   endif
                            
    1              0.000006   autocmd User Flags call Hoist('buffer', function('FugitiveStatusline'))
                            
    1              0.000009   autocmd User ProjectionistDetect call s:ProjectionistDetect()
    1              0.000002 augroup END
                            
    1              0.000009 let s:addr_other = has('patch-8.1.560') ? '-addr=other' : ''
    1              0.000006 let s:addr_tabs  = has('patch-7.4.542') ? '-addr=tabs' : ''
    1              0.000010 let s:addr_wins  = has('patch-7.4.542') ? '-addr=windows' : ''
    1              0.000040 exe 'command! -bang -nargs=? -range=-1' s:addr_other '-complete=customlist,fugitive#Complete G   exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000029 exe 'command! -bang -nargs=? -range=-1' s:addr_other '-complete=customlist,fugitive#Complete Git exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000019 exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Gcd  exe fugitive#Cd(<q-args>, 0)"
    1              0.000010 exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Glcd exe fugitive#Cd(<q-args>, 1)"
                            
    1              0.000028 exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Ggrep  exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "grep " . <q-args>)'
    1              0.000029 exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Gcgrep exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "grep " . <q-args>)'
    1              0.000030 exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Glgrep exe fugitive#Command(0, <count> > 0 ? <count> : 0, +"<range>", <bang>0, "<mods>", "grep " . <q-args>)'
                            
    1              0.000037 exe 'command! -bang -nargs=? -range=-1' s:addr_other '-complete=customlist,fugitive#LogComplete Glog  :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "")'
    1              0.000030 exe 'command! -bang -nargs=? -range=-1' s:addr_other '-complete=customlist,fugitive#LogComplete Gclog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
    1              0.000026 exe 'command! -bang -nargs=? -range=-1' s:addr_other '-complete=customlist,fugitive#LogComplete Gllog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
                            
    1              0.000019 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#CompleteObject Ge       exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>, [<f-args>])'
    1              0.000019 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#CompleteObject Gedit    exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>, [<f-args>])'
    1              0.000019 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#ReadComplete   Gpedit   exe fugitive#Open("pedit", <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000032 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#ReadComplete   Gsplit   exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "split" : "edit"), <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000032 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#ReadComplete   Gvsplit  exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "vsplit" : "edit!"), <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000027 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_tabs  '-complete=customlist,fugitive#ReadComplete   Gtabedit exe fugitive#Open((<count> >= 0 ? <count> : "")."tabedit", <bang>0, "<mods>", <q-args>, [<f-args>])'
                            
    1              0.000006 if exists(':Gr') != 2
    1              0.000029   exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gr     exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000001 endif
    1              0.000028 exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gread    exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'
                            
    1              0.000020 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gdiffsplit  exe fugitive#Diffsplit(1, <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000018 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Ghdiffsplit exe fugitive#Diffsplit(0, <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000019 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gvdiffsplit exe fugitive#Diffsplit(0, <bang>0, "vert <mods>", <q-args>, [<f-args>])'
                            
    1              0.000032 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gw     exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000026 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gwrite exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000027 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#CompleteObject Gwq    exe fugitive#WqCommand(   <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'
                            
    1              0.000026 exe 'command! -bar -bang -nargs=0 -complete=customlist,fugitive#CompleteObject Gremove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000026 exe 'command! -bar -bang -nargs=0 -complete=customlist,fugitive#CompleteObject Gdelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000033 exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject Gmove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'
    1              0.000026 exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete Grename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'
                            
    1              0.000028 exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>, [<f-args>])'
                            
    1              0.000005 if get(g:, 'fugitive_no_maps')
                              finish
    1              0.000010 endif
                            
    1              0.000004 let s:nowait = v:version >= 704 ? '<nowait>' : ''
                            
    1              0.000004 function! s:Map(mode, lhs, rhs, ...) abort
                              for mode in split(a:mode, '\zs')
                                let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')
                                let head = a:lhs
                                let tail = ''
                                let keys = get(g:, mode.'remap', {})
                                if type(keys) == type([])
                                  return
                                endif
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
                                if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))
                                  exe mode.'map' s:nowait flags head.tail a:rhs
                                endif
                              endfor
                            endfunction
                            
    1   0.000247   0.000021 call s:Map('c', '<C-R><C-G>', 'fnameescape(fugitive#Object(@%))', '<expr>')
    1   0.000229   0.000014 call s:Map('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')

SCRIPT  /home/c5262761/configit/vim/modules/vim-dispatch/plugin/dispatch.vim
Sourced 1 time
Total time:   0.003169
 Self time:   0.000552

count  total (s)   self (s)
                            " Location:     plugin/dispatch.vim
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      1.8
                            " GetLatestVimScripts: 4504 1 :AutoInstall: dispatch.vim
                            
    1              0.000010 if exists("g:loaded_dispatch") || v:version < 700 || &compatible
                              finish
    1              0.000001 endif
    1              0.000004 let g:loaded_dispatch = 1
                            
    1              0.000032 command! -bang -nargs=* -range=-1 -complete=customlist,dispatch#command_complete Dispatch
                                  \ execute dispatch#compile_command(<bang>0, <q-args>,
                                  \   <count> < 0 || <line1> == <line2> ? <count> : 0, '<mods>')
                            
    1              0.000027 command! -bang -nargs=* -range=-1 -complete=customlist,dispatch#command_complete FocusDispatch
                                  \ execute dispatch#focus_command(<bang>0, <q-args>,
                                  \   <count> < 0 || <line1> == <line2> ? <count> : 0, '<mods>')
                            
    1              0.000029 command! -bang -nargs=* -range=-1 -complete=customlist,dispatch#make_complete Make
                                  \ execute dispatch#compile_command(<bang>0, '-- ' . <q-args>,
                                  \   <count> < 0 || <line1> == <line2> ? <count> : 0, '<mods>')
                            
    1              0.000028 command! -bang -nargs=* -range=-1 -complete=customlist,dispatch#command_complete Spawn
                                  \ execute dispatch#spawn_command(<bang>0, <q-args>,
                                  \   <count> < 0 || <line1> == <line2> ? <count> : 0, '<mods>')
                            
    1              0.000026 command! -bang -nargs=* -range=-1 -complete=customlist,dispatch#command_complete Start
                                  \ execute dispatch#start_command(<bang>0, <q-args>,
                                  \   <count> < 0 || <line1> == <line2> ? <count> : 0, '<mods>')
                            
    1              0.000010 command! -bang -bar Copen call dispatch#copen(<bang>0, '<mods>')
                            
    1              0.000010 command! -bang -bar -nargs=* AbortDispatch
                                  \ execute dispatch#abort_command(<bang>0, <q-args>)
                            
    1              0.000005 function! s:map(mode, lhs, rhs, ...) abort
                              let flags = (a:0 ? a:1 : '') . (a:rhs =~# '^<Plug>' ? '' : '<script>')
                              let head = a:lhs
                              let tail = ''
                              let keys = get(g:, a:mode.'remap', {})
                              if type(keys) == type([])
                                return
                              endif
                              while !empty(head)
                                if has_key(keys, head)
                                  let head = keys[head]
                                  if empty(head)
                                    return
                                  endif
                                  break
                                endif
                                let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                              endwhile
                              exe a:mode.'map' flags head.tail a:rhs
                            endfunction
                            
    1              0.000019 nmap <script> <SID>:.    :<C-R>=getcmdline() =~ ',' ? "\0250" : ""<CR>
                            
    1              0.000005 if !get(g:, 'dispatch_no_maps')
    1   0.000163   0.000009   call s:map('n', 'm<CR>',      '<SID>:.Make<CR>')
    1   0.000129   0.000010   call s:map('n', 'm<Space>',   '<SID>:.Make<Space>')
    1   0.000121   0.000008   call s:map('n', 'm!',         '<SID>:.Make!')
    1   0.000129   0.000010   call s:map('n', 'm?',         ':<C-U>echo ":Dispatch" dispatch#make_focus(v:count > 1 ? 0 : v:count ? line(".") : -1)<CR>', '<silent>')
    1   0.000126   0.000010   call s:map('n', '`<CR>',      '<SID>:.Dispatch<CR>')
    1   0.000122   0.000009   call s:map('n', '`<Space>',   '<SID>:.Dispatch<Space>')
    1   0.000116   0.000009   call s:map('n', '`!',         '<SID>:.Dispatch!')
    1   0.000118   0.000008   call s:map('n', '`?',         '<SID>:.FocusDispatch<CR>')
    1   0.000119   0.000008   call s:map('n', '''<CR>',     '<SID>:.Start<CR>')
    1   0.000122   0.000009   call s:map('n', '''<Space>',  '<SID>:.Start<Space>')
    1   0.000116   0.000008   call s:map('n', '''!',        '<SID>:.Start!')
    1   0.000137   0.000011   call s:map('n', '''?',        ':<C-U>echo ":Start" dispatch#start_focus(v:count > 1 ? 0 : v:count ? line(".") : -1)<CR>', '<silent>')
    1   0.000166   0.000016   call s:map('n', 'g''<CR>',    '<SID>:.Spawn<CR>')
    1   0.000171   0.000007   call s:map('n', 'g''<Space>', '<SID>:.Spawn<Space>')
    1   0.000151   0.000008   call s:map('n', 'g''!',       '<SID>:.Spawn!')
    1   0.000151   0.000010   call s:map('n', 'g''?',       ':<C-U>echo ":Spawn" dispatch#spawn_focus(v:count > 1 ? 0 : v:count ? line(".") : -1)<CR>', '<silent>')
    1   0.000156   0.000009   call s:map('n', 'g`<CR>',     '<SID>:.Spawn<CR>')
    1   0.000170   0.000008   call s:map('n', 'g`<Space>',  '<SID>:.Spawn<Space>')
    1   0.000164   0.000008   call s:map('n', 'g`!',        '<SID>:.Spawn!')
    1   0.000155   0.000010   call s:map('n', 'g`?',        ':<C-U>echo ":Spawn" dispatch#spawn_focus(v:count > 1 ? 0 : v:count ? line(".") : -1)<CR>', '<silent>')
    1              0.000002 endif
                            
    1              0.000004 function! DispatchComplete(id) abort
                              return dispatch#complete(a:id)
                            endfunction
                            
    1              0.000005 if !exists('g:dispatch_handlers')
    1              0.000007   let g:dispatch_handlers = [
                                    \ 'tmux',
                                    \ 'job',
                                    \ 'screen',
                                    \ 'windows',
                                    \ 'iterm',
                                    \ 'x11',
                                    \ 'headless',
                                    \ ]
    1              0.000001 endif
                            
    1              0.000002 augroup dispatch
    1              0.000065   autocmd!
    1              0.000020   autocmd FileType qf
                                    \ if &buftype ==# 'quickfix' && empty(getloclist(winnr())) && get(w:, 'quickfix_title') =~# '^:noautocmd cgetfile\>\|^:\d*Dispatch\>' |
                                    \   call dispatch#quickfix_init() |
                                    \ endif
    1              0.000003 augroup END

SCRIPT  /home/c5262761/configit/vim/modules/vim-ctagser/plugin/ctagser.vim
Sourced 1 time
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
                            " ctagser.vim - add header files
                            " Maintainer:	Nelo-T. Wallus <nelo@wallus.de>
                            " License:	MIT
                            
                            " set TAGSDIR to a default
    1              0.000011 if $TAGSDIR == '' | let $TAGSDIR = resolve($HOME . "/.tags") | endif
                            
    1              0.000004 if ! exists('g:ctagser_params')
    1              0.000006     let g:ctagser_params = [
                                            \ 'c /usr/include /usr/local/include',
                                            \ ]
    1              0.000001 endif
                            
    1              0.000008 com! ListTags call ctagser#list_tags()
    1              0.000008 com! CtagsIndex call ctagser#index_system()

SCRIPT  /home/c5262761/configit/vim/modules/YCM-Generator/plugin/ycm-generator.vim
Sourced 1 time
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
                            
    1              0.000015 let s:config_gen = expand("<sfile>:p:h:h") . "/config_gen.py"
                            
    1              0.000015 command! -nargs=? -complete=file_in_path -bang CCGenerateConfig call s:GenerateConfig("cc", <bang>0, "<args>")
    1              0.000015 command! -nargs=? -complete=file_in_path -bang YcmGenerateConfig call s:GenerateConfig("ycm", <bang>0, "<args>")
                            
    1              0.000006 function! s:GenerateConfig(fmt, overwrite, flags)
                                let l:cmd = "! " . s:config_gen . " -F " . a:fmt . " " . a:flags
                            
                                if a:overwrite
                                    let l:cmd = l:cmd . " -f"
                                endif
                            
                                " Only append the working directory if the last option is a flag
                                let l:split_flags = split(a:flags)
                                if len(l:split_flags) == 0 || l:split_flags[-1] =~ "^-"
                                    let l:cmd = l:cmd . " " . shellescape(getcwd())
                                endif
                            
                                " Disable interactive prompts for consistency with Neovim
                                execute l:cmd . " </dev/null"
                            endfunction
                            

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/getscriptPlugin.vim
Sourced 1 time
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
                            " ---------------------------------------------------------------------
                            " getscriptPlugin.vim
                            "  Author:	Charles E. Campbell
                            "  Date:	Nov 29, 2013
                            "  Installing:	:help glvs-install
                            "  Usage:	:help glvs
                            "
                            " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
                            "
                            " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
                            " all the peoples praise Him."
                            " ---------------------------------------------------------------------
                            " Initialization:	{{{1
                            " if you're sourcing this file, surely you can't be
                            " expecting vim to be in its vi-compatible mode
    1              0.000008 if exists("g:loaded_getscriptPlugin")
                             finish
    1              0.000001 endif
    1              0.000005 if &cp
                             if &verbose
                              echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
                             endif
                             finish
    1              0.000001 endif
    1              0.000003 let g:loaded_getscriptPlugin = "v36"
    1              0.000007 let s:keepcpo                = &cpo
    1              0.000008 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000010 com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
    1              0.000006 com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
    1              0.000007 silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
                            
                            " ---------------------------------------------------------------------
                            " Restore Options: {{{1
    1              0.000008 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo
                            
                            " ---------------------------------------------------------------------
                            " vim: ts=8 sts=2 fdm=marker nowrap

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/gzip.vim
Sourced 1 time
Total time:   0.000311
 Self time:   0.000311

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2016 Oct 30
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000014 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
    1              0.000001 endif
    1              0.000003 let loaded_gzip = 1
                            
    1              0.000002 augroup gzip
                              " Remove all gzip autocommands
    1              0.000064   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000032   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin
    1              0.000008   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000007   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000007   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000007   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000006   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000006   autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
    1              0.000007   autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
    1              0.000007   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000007   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000011   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000007   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
    1              0.000007   autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
    1              0.000004   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000005   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000004   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000005   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000005   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000004   autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
    1              0.000005   autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
    1              0.000004   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000005   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000004   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000005   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000004   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000005   autocmd FileAppendPost		*.lz call gzip#write("lzip")
    1              0.000005   autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
    1              0.000005 augroup END

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/logiPat.vim
Sourced 1 time
Total time:   0.000409
 Self time:   0.000409

count  total (s)   self (s)
                            " LogiPat: Boolean logical pattern matcher
                            "   Author:  Charles E. Campbell
                            "   Date:    Apr 04, 2016
                            "   Version: 4
                            "   Purpose: to do Boolean-logic based regular expression pattern matching
                            " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like most anything else that's free,
                            "               LogiPat.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            "   Usage: {{{1
                            "       :LogiPat ...
                            "
                            "         Boolean logic supported:
                            "            () grouping operators
                            "            !  not the following pattern
                            "            |  logical or
                            "            &  logical and
                            "            "..pattern.."
                            "	Example: {{{1
                            "		:LogiPat !("january"|"february")
                            "		  would match all strings not containing the strings january
                            "		  or february
                            "	GetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
                            "
                            "  Behold, you will conceive in your womb, and bring forth a son, {{{1
                            "  and will call his name Jesus. He will be great, and will be
                            "  called the Son of the Most High. The Lord God will give him the
                            "  throne of his father, David, and he will reign over the house of
                            "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
                            
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000013 if &cp || exists("loaded_logiPat")
                             finish
    1              0.000001 endif
    1              0.000003 let g:loaded_logiPat = "v4"
    1              0.000007 let s:keepcpo        = &cpo
    1              0.000007 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000010 com!     -nargs=* LogiPat		call   LogiPat(<q-args>,1)
    1              0.000010 sil! com -nargs=* LP			call   LogiPat(<q-args>,1)
    1              0.000007 sil! com -nargs=* LPR			call   LogiPat(<q-args>,1,"r")
    1              0.000006 com!     -nargs=+ LPE			echomsg LogiPat(<q-args>)
    1              0.000008 com!     -nargs=+ LogiPatFlags	let  s:LogiPatFlags="<args>"
    1              0.000009 sil! com -nargs=+ LPF			let  s:LogiPatFlags="<args>"
                            
                            " =====================================================================
                            " Functions: {{{1
                            
                            " ---------------------------------------------------------------------
                            " LogiPat: this function interprets the boolean-logic pattern {{{2
    1              0.000003 fun! LogiPat(pat,...)
                            "  call Dfunc("LogiPat(pat<".a:pat.">)")
                            
                              " LogiPat(pat,dosearch)
                              if a:0 > 0
                               let dosearch= a:1
                              else
                               let dosearch= 0
                              endif
                              if a:0 >= 3
                               let s:LogiPatFlags= a:3
                              endif
                            
                              let s:npatstack = 0
                              let s:nopstack  = 0
                              let s:preclvl   = 0
                              let expr        = a:pat
                            
                              " Lexer/Parser
                              while expr != ""
                            "   call Decho("expr<".expr.">")
                            
                               if expr =~ '^"'
                            	" push a Pattern; accept "" as a single " in the pattern
                                let expr = substitute(expr,'^\s*"','','')
                                let pat  = substitute(expr,'^\(\%([^"]\|\"\"\)\{-}\)"\([^"].*$\|$\)','\1','')
                            	let pat  = substitute(pat,'""','"','g')
                                let expr = substitute(expr,'^\(\%([^"]\|\"\"\)\{-}\)"\([^"].*$\|$\)','\2','')
                                let expr = substitute(expr,'^\s*','','')
                            "    call Decho("pat<".pat."> expr<".expr.">")
                            
                                call s:LP_PatPush('.*'.pat.'.*')
                            
                               elseif expr =~ '^[!()|&]'
                                " push an operator
                                let op   = strpart(expr,0,1)
                                let expr = strpart(expr,strlen(op))
                            	" allow for those who can't resist doubling their and/or operators
                            	if op =~ '[|&]' && expr[0] == op
                                 let expr = strpart(expr,strlen(op))
                            	endif
                                call s:LP_OpPush(op)
                            
                               elseif expr =~ '^\s'
                                " skip whitespace
                                let expr= strpart(expr,1)
                            
                               else
                                echoerr "operator<".strpart(expr,0,1)."> not supported (yet)"
                                let expr= strpart(expr,1)
                               endif
                            
                              endwhile
                            
                              " Final Execution
                              call s:LP_OpPush('Z')
                            
                              let result= s:LP_PatPop(1)
                            "  call Decho("result=".result)
                            
                              " sanity checks and cleanup
                              if s:npatstack > 0
                               echoerr s:npatstack." patterns left on stack!"
                               let s:npatstack= 0
                              endif
                              if s:nopstack > 0
                               echoerr s:nopstack." operators left on stack!"
                               let s:nopstack= 0
                              endif
                            
                              " perform the indicated search
                              if dosearch
                               if exists("s:LogiPatFlags") && s:LogiPatFlags != ""
                            "  call Decho("search(result<".result."> LogiPatFlags<".s:LogiPatFlags.">)")
                                call search(result,s:LogiPatFlags)
                               else
                            "  call Decho("search(result<".result.">)")
                                call search(result)
                               endif
                               let @/= result
                              endif
                            
                            "  call Dret("LogiPat ".result)
                              return result
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:String: Vim6.4 doesn't have string() {{{2
    1              0.000005 func! s:String(str)
                              return "'".escape(a:str, '"')."'"
                            endfunc
                            
                            " ---------------------------------------------------------------------
                            " LP_PatPush: {{{2
    1              0.000002 fun! s:LP_PatPush(pat)
                            "  call Dfunc("LP_PatPush(pat<".a:pat.">)")
                              let s:npatstack              = s:npatstack + 1
                              let s:patstack_{s:npatstack} = a:pat
                            "  call s:StackLook("patpush") "Decho
                            "  call Dret("LP_PatPush : npatstack=".s:npatstack)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
    1              0.000003 fun! s:LP_PatPop(lookup)
                            "  call Dfunc("LP_PatPop(lookup=".a:lookup.")")
                              if s:npatstack > 0
                               let ret         = s:patstack_{s:npatstack}
                               let s:npatstack = s:npatstack - 1
                              else
                               let ret= "---error---"
                               echoerr "(LogiPat) invalid expression"
                              endif
                            "  call s:StackLook("patpop") "Decho
                            "  call Dret("LP_PatPop ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_OpPush: {{{2
    1              0.000003 fun! s:LP_OpPush(op)
                            "  call Dfunc("LP_OpPush(op<".a:op.">)")
                            
                              " determine new operator's precedence level
                              if a:op == '('
                              	let s:preclvl= s:preclvl + 10
                            	let preclvl  = s:preclvl
                              elseif a:op == ')'
                              	let s:preclvl= s:preclvl - 10
                               if s:preclvl < 0
                                let s:preclvl= 0
                                echoerr "too many )s"
                               endif
                               let preclvl= s:preclvl
                              elseif a:op =~ '|'
                               let preclvl= s:preclvl + 2
                              elseif a:op =~ '&'
                               let preclvl= s:preclvl + 4
                              elseif a:op == '!'
                               let preclvl= s:preclvl + 6
                              elseif a:op == 'Z'
                               let preclvl= -1
                              else
                               echoerr "expr<".expr."> not supported (yet)"
                               let preclvl= s:preclvl
                              endif
                            "  call Decho("new operator<".a:op."> preclvl=".preclvl)
                            
                              " execute higher-precdence operators
                            "  call Decho("execute higher-precedence operators")
                              call s:LP_Execute(preclvl)
                            
                              " push new operator onto operator-stack
                            "  call Decho("push new operator<".a:op."> onto stack with preclvl=".preclvl." at nopstack=".(s:nopstack+1))
                              if a:op =~ '!'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              elseif a:op =~ '|'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              elseif a:op == '&'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              endif
                            
                            "  call s:StackLook("oppush") "Decho
                            "  call Dret("LP_OpPush : s:preclvl=".s:preclvl)
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Execute: execute operators from opstack using pattern stack {{{2
    1              0.000002 fun! s:LP_Execute(preclvl)
                            "  call Dfunc("LP_Execute(preclvl=".a:preclvl.") npatstack=".s:npatstack." nopstack=".s:nopstack)
                            
                              " execute all higher precedence operators
                              while s:nopstack > 0 && a:preclvl < s:opprec_{s:nopstack}
                               let op= s:opstack_{s:nopstack}
                            "   call Decho("op<".op."> nop=".s:nopstack." [preclvl=".a:preclvl."] < [opprec_".s:nopstack."=".s:opprec_{s:nopstack}."]")
                            
                               let s:nopstack = s:nopstack - 1
                             
                               if     op == '!'
                                let n1= s:LP_PatPop(1)
                            	call s:LP_PatPush(s:LP_Not(n1))
                             
                               elseif op == '|'
                                let n1= s:LP_PatPop(1)
                                let n2= s:LP_PatPop(1)
                                call s:LP_PatPush(s:LP_Or(n2,n1))
                             
                               elseif op =~ '&'
                                let n1= s:LP_PatPop(1)
                                let n2= s:LP_PatPop(1)
                                call s:LP_PatPush(s:LP_And(n2,n1))
                               endif
                             
                            "   call s:StackLook("execute") "Decho
                              endwhile
                            
                            "  call Dret("LP_Execute")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Not: writes a logical-not for a pattern {{{2
    1              0.000003 fun! s:LP_Not(pat)
                            "  call Dfunc("LP_Not(pat<".a:pat.">)")
                              if a:pat =~ '^\.\*' && a:pat =~ '\.\*$'
                               let pat= substitute(a:pat,'^\.\*\(.*\)\.\*$','\1','')
                               let ret= '^\%(\%('.pat.'\)\@!.\)*$'
                              else
                               let ret= '^\%(\%('.a:pat.'\)\@!.\)*$'
                              endif
                            "  call Dret("LP_Not ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_Or: writes a logical-or branch using two patterns {{{2
    1              0.000002 fun! s:LP_Or(pat1,pat2)
                            "  call Dfunc("LP_Or(pat1<".a:pat1."> pat2<".a:pat2.">)")
                              let ret= '\%('.a:pat1.'\|'.a:pat2.'\)'
                            "  call Dret("LP_Or ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " LP_And: writes a logical-and concat using two patterns {{{2
    1              0.000003 fun! s:LP_And(pat1,pat2)
                            "  call Dfunc("LP_And(pat1<".a:pat1."> pat2<".a:pat2.">)")
                              let ret= '\%('.a:pat1.'\&'.a:pat2.'\)'
                            "  call Dret("LP_And ".ret)
                              return ret
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " StackLook: {{{2
    1              0.000002 fun! s:StackLook(description)
                            "  call Dfunc("StackLook(description<".a:description.">)")
                              let iop = 1
                              let ifp = 1
                            "  call Decho("Pattern                       Operator")
                            
                              " print both pattern and operator
                              while ifp <= s:npatstack && iop <= s:nopstack
                               let fp = s:patstack_{ifp}
                               let op = s:opstack_{iop}." (P".s:opprec_{s:nopstack}.')'
                               let fplen= strlen(fp)
                               if fplen < 30
                               	let fp= fp.strpart("                              ",1,30-fplen)
                               endif
                            "   call Decho(fp.op)
                               let ifp = ifp + 1
                               let iop = iop + 1
                              endwhile
                            
                              " print just pattern
                              while ifp <= s:npatstack
                               let fp  = s:patstack_{ifp}
                            "   call Decho(fp)
                               let ifp = ifp + 1
                              endwhile
                            
                              " print just operator
                              while iop <= s:nopstack
                               let op  = s:opstack_{iop}." (P".s:opprec_{s:nopstack}.')'
                            "   call Decho("                              ".op)
                               let iop = iop + 1
                              endwhile
                            "  call Dret("StackLook")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            "  Cleanup And Modeline: {{{1
    1              0.000009 let &cpo= s:keepcpo
    1              0.000003 unlet s:keepcpo
                            " vim: ts=4 fdm=marker

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000303
 Self time:   0.000303

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2018 Jul 3
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - the "CursorMoved" autocmd event is not available.
    1              0.000015 if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_matchparen = 1
                            
    1              0.000003 if !exists("g:matchparen_timeout")
    1              0.000002   let g:matchparen_timeout = 300
    1              0.000001 endif
    1              0.000004 if !exists("g:matchparen_insert_timeout")
    1              0.000002   let g:matchparen_insert_timeout = 60
    1              0.000001 endif
                            
    1              0.000002 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000013   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
    1              0.000005   if exists('##TextChanged')
    1              0.000010     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000001   endif
    1              0.000001 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000006 if exists("*s:Highlight_Matching_Pair")
                              finish
    1              0.000001 endif
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000008 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000004 function! s:Highlight_Matching_Pair()
                              " Remove any previous match.
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
                              if empty(matches)
                                let [c_before, c] = ['', '']
                              else
                                let [c_before, c] = matches[1:2]
                              endif
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' .
                            	\ '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000007 command! DoMatchParen call s:DoMatchParen()
    1              0.000006 command! NoMatchParen call s:NoMatchParen()
                            
    1              0.000004 func! s:NoMatchParen()
                              let w = winnr()
                              noau windo silent! call matchdelete(3)
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000002 func! s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000009 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000911
 Self time:   0.000911

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Date:		Feb 08, 2016
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000012 if &cp || exists("g:loaded_netrwPlugin")
                             finish
    1              0.000001 endif
    1              0.000003 let g:loaded_netrwPlugin = "v156"
    1              0.000006 let s:keepcpo = &cpo
    1              0.000007 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
    1              0.000002 augroup FileExplorer
    1              0.000066  au!
    1              0.000036  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
    1              0.000006  au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000006  au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
    1              0.000013  if has("win32") || has("win95") || has("win64") || has("win16")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000001  endif
    1              0.000001 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000002 augroup Network
    1              0.000057  au!
    1              0.000010  au BufReadCmd   file://*											call netrw#FileUrlRead(expand("<amatch>"))
    1              0.000035  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000031  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000044  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000025  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000002  try                                                       
    1              0.000026   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             catch /^Vim\%((\a\+)\)\=:E216/                            
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000002  endtry
    1              0.000001 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000026 com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
    1              0.000019 com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000006 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000013 com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000006 com! -nargs=?		Ntree		call netrw#SetTreetop(<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
    1              0.000013 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000013 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000013 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000013 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000012 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000007 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000007 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
    1              0.000012 com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000007 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000007 com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
    1              0.000005 if !exists("g:netrw_nogx")
    1              0.000017  if maparg('gx','n') == ""
    1              0.000021   if !hasmapto('<Plug>NetrwBrowseX')
    1              0.000026    nmap <unique> gx <Plug>NetrwBrowseX
    1              0.000001   endif
    1              0.000023   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
    1              0.000002  endif
    1              0.000011  if maparg('gx','v') == ""
    1              0.000017   if !hasmapto('<Plug>NetrwBrowseXVis')
    1              0.000013    vmap <unique> gx <Plug>NetrwBrowseXVis
    1              0.000002   endif
    1              0.000014   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
    1              0.000001  endif
    1              0.000001 endif
    1              0.000005 if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
    1              0.000006 fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
    1              0.000003 fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000002 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000001 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000011 let &cpo= s:keepcpo
    1              0.000003 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/rrhelper.vim
Sourced 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
                            " Vim plugin with helper function(s) for --remote-wait
                            " Maintainer: Flemming Madsen <fma@cci.dk>
                            " Last Change: 2008 May 29
                            
                            " Has this already been loaded?
    1              0.000011 if exists("loaded_rrhelper") || !has("clientserver")
    1              0.000002   finish
                            endif
                            let loaded_rrhelper = 1
                            
                            " Setup answers for a --remote-wait client who will assume
                            " a SetupRemoteReplies() function in the command server
                            
                            function SetupRemoteReplies()
                              let cnt = 0
                              let max = argc()
                            
                              let id = expand("<client>")
                              if id == 0
                                return
                              endif
                              while cnt < max
                                " Handle same file from more clients and file being more than once
                                " on the command line by encoding this stuff in the group name
                                let uniqueGroup = "RemoteReply_".id."_".cnt
                            
                                " Path separators are always forward slashes for the autocommand pattern.
                                " Escape special characters with a backslash.
                                let f = substitute(argv(cnt), '\\', '/', "g")
                                if exists('*fnameescape')
                                  let f = fnameescape(f)
                                else
                                  let f = escape(f, " \t\n*?[{`$\\%#'\"|!<")
                                endif
                                execute "augroup ".uniqueGroup
                                execute "autocmd ".uniqueGroup." BufUnload ". f ."  call DoRemoteReply('".id."', '".cnt."', '".uniqueGroup."', '". f ."')"
                                let cnt = cnt + 1
                              endwhile
                              augroup END
                            endfunc
                            
                            function DoRemoteReply(id, cnt, group, file)
                              call server2client(a:id, a:cnt)
                              execute 'autocmd! '.a:group.' BufUnload '.a:file
                              execute 'augroup! '.a:group
                            endfunc
                            
                            " vim: set sw=2 sts=2 :

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2006 Feb 01
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of spell files
    1              0.000015 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
    1              0.000001 endif
    1              0.000004 let loaded_spellfile_plugin = 1
                            
                            " The function is in the autoload directory.
    1              0.000011 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000269
 Self time:   0.000269

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000012 if &cp || exists("g:loaded_tarPlugin")
                             finish
    1              0.000001 endif
    1              0.000003 let g:loaded_tarPlugin = "v29"
    1              0.000006 let s:keepcpo          = &cpo
    1              0.000008 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000003 augroup tar
    1              0.000067   au!
    1              0.000009   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000008   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000005   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000006   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000004   if has("unix")
    1              0.000007    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000007    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000005    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000006    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000002   endif
                            
    1              0.000006   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000005   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000005   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000005   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
    1              0.000006   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000005   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000008   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000002 augroup END
    1              0.000010 com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000009 let &cpo= s:keepcpo
    1              0.000006 unlet s:keepcpo

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2015 Sep 08
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
                            " TODO: {{{
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support? Good start
                            "     by Erik Falor
                            "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
                            "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
                            "     term) to use for the styling. Suggestion by "nacitar".
                            "   * Add way to override or specify which RGB colors map to the color numbers
                            "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
                            "   * Disable filetype detection until after all processing is done.
                            "   * Add option for not generating the hyperlink on stuff that looks like a
                            "     URL? Or just color the link to fit with the colorscheme (and only special
                            "     when hovering)?
                            "   * Bug: Opera does not allow printing more than one page if uncopyable
                            "     regions is turned on. Possible solution: Add normal text line numbers with
                            "     display:none, set to display:inline for print style sheets, and hide
                            "     <input> elements for print, to allow Opera printing multiple pages (and
                            "     other uncopyable areas?). May need to make the new text invisible to IE
                            "     with conditional comments to prevent copying it, IE for some reason likes
                            "     to copy hidden text. Other browsers too?
                            "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
                            "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
                            "     on Windows). Perhaps it is font related?
                            "   * Bug: still some gaps in the fold column when html_prevent_copy contains
                            "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
                            "     on diff lines though.
                            "   * Undercurl support via CSS3, with fallback to dotted or something:
                            "	https://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
                            "   * Redo updates for modified default foldtext (v11) when/if the patch is
                            "     accepted to modify it.
                            "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
                            "		+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
                            "		+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
                            "     does not show the whole diff filler as it is supposed to?
                            "   * Bug: when 'isprint' is wrong for the current encoding, will generate
                            "     invalid content. Can/should anything be done about this? Maybe a separate
                            "     plugin to correct 'isprint' based on encoding?
                            "   * Check to see if the windows-125\d encodings actually work in Unix without
                            "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
                            "     platforms.
                            "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Make it so deleted lines in a diff don't create side-scrolling (get it
                            "     free with full-line background highlight above).
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase.
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "}}}
                            
    1              0.000007 if exists('g:loaded_2html_plugin')
                              finish
    1              0.000001 endif
    1              0.000004 let g:loaded_2html_plugin = 'vim7.4_v2'
                            
                            "
                            " Changelog: {{{
                            "   7.4_v2  (this version): Fix error raised when converting a diff containing
                            "                           an empty buffer. Jan Stocker: allow g:html_font to
                            "                           take a list so it is easier to specfiy fallback
                            "                           fonts in the generated CSS.
                            "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
                            "			    also for version-specific modelines like "vim>703:".
                            "
                            "   7.3 updates: {{{
                            "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
                            "			    g:html_line_ids=0. Allow customizing
                            "			    important IDs (like line IDs and fold IDs) using
                            "			    g:html_id_expr evalutated when the buffer conversion
                            "			    is started.
                            "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
                            "			    insert modeline to set it to manual.
                            "			    Fix bug: diff mode with 2 unsaved buffers creates a
                            "			    duplicate of one buffer instead of including both.
                            "			    Add anchors to each line so you can put '#L123'
                            "			    or '#123' at the end of the URL to jump to line 123
                            "			    (idea by Andy Spencer). Add javascript to open folds
                            "			    to show the anchor being jumped to if it is hidden.
                            "			    Fix XML validation error: &nsbp; not part of XML.
                            "			    Allow TOhtml to chain together with other commands
                            "			    using |.
                            "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
                            "			    highlight groups make up the start-of-modeline text.
                            "			    Improve render time of page with uncopyable regions
                            "			    by not using one-input-per-char. Change name of
                            "			    uncopyable option from html_unselectable to
                            "			    html_prevent_copy. Added html_no_invalid option and
                            "			    default to inserting invalid markup for uncopyable
                            "			    regions to prevent MS Word from pasting undeletable
                            "			    <input> elements. Fix 'cpo' handling (Thilo Six).
                            "		 7.3_v12b1: Add html_unselectable option. Rework logic to
                            "			    eliminate post-processing substitute commands in
                            "			    favor of doing the work up front. Remove unnecessary
                            "			    special treatment of 'LineNr' highlight group. Minor
                            "			    speed improvements. Fix modeline mangling in
                            "			    generated output so it works for text in the first
                            "			    column. Fix missing line number and fold column in
                            "			    diff filler lines. Fix that some fonts have a 1px
                            "			    gap (using a dirty hack, improvements welcome). Add
                            "			    "colorscheme" meta tag. Does NOT include support for
                            "			    the new default foldtext added in v11, as the patch
                            "			    adding it has not yet been included in Vim.
                            "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
                            "			    Brabandt in
                            "			    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
                            "			    This patch has not yet been included in Vim, thus
                            "			    these changes are removed in the next version.
                            "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
                            "			    multiple nested folds with dynamic folding on.
                            "			    Also fix problem with foldtext in this situation.
                            "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
                            "			    and without html_no_pre, default value same as
                            "			    'wrap' option, (Andy Spencer). Don't use
                            "			    'fileencoding' for converted document encoding if
                            "			    'buftype' indicates a special buffer which isn't
                            "			    written.
                            "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
                            "			    characters in generated output (Andy Spencer).
                            "			    Escape text that looks like a modeline so Vim
                            "			    doesn't use anything in the converted HTML as a
                            "			    modeline. Bugfixes: Fix folding when a fold starts
                            "			    before the conversion range. Remove fold column when
                            "			    there are no folds.
                            "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
                            "		  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "		  7.3_v7b2: Remove automatic detection of encodings that are not
                            "			    supported by all major browsers according to
                            "			    http://wiki.whatwg.org/wiki/Web_Encodings and
                            "			    convert to UTF-8 for all Unicode encodings. Make
                            "			    HTML encoding to Vim encoding detection be
                            "			    case-insensitive for built-in pairs.
                            "		  7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "			    called in restricted mode (Andy Spencer). Use
                            "			    'fencoding' instead of 'encoding' to determine by
                            "			    charset, and make sure the 'fenc' of the generated
                            "			    file matches its indicated charset. Add charsets for
                            "			    all of Vim's natively supported encodings.
                            "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
                            "			    user settings interfering with diff mode generation,
                            "			    trailing whitespace (e.g. line number column) when
                            "			    using html_no_pre, and bugs when using
                            "			    html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "			    folds in diff mode when first line was folded.
                            "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
                            "			    default to true when not set to anything. Use strict
                            "			    doctypes where possible. Rename use_xhtml option to
                            "			    html_use_xhtml for consistency. Use .xhtml extension
                            "			    when using this option. Add meta tag for settings.
                            "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
                            "			    diff colors and the normal syntax colors
                            "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
                            "}}}
                            "}}}
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin was not already loaded
                            " - user commands are available. {{{
    1              0.000015 if !&cp && !exists(":TOhtml") && has("user_commands")
    1              0.000020   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
    1              0.000002 endif "}}}
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet fdm=marker

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/vimballPlugin.vim
Sourced 1 time
Total time:   0.000290
 Self time:   0.000290

count  total (s)   self (s)
                            " vimballPlugin : construct a file containing both paths and files
                            " Author: Charles E. Campbell
                            " Copyright: (c) 2004-2014 by Charles E. Campbell
                            "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
                            "            (see |copyright|) except use "Vimball" instead of "Vim".
                            "            No warranty, express or implied.
                            "  *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
                            "      judge. For in that which you judge another, you condemn yourself. For
                            "      you who judge practice the same things.
                            " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
                            
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000012 if &cp || exists("g:loaded_vimballPlugin")
                             finish
    1              0.000001 endif
    1              0.000004 let g:loaded_vimballPlugin = "v37"
    1              0.000006 let s:keepcpo              = &cpo
    1              0.000007 set cpo&vim
                            
                            " ------------------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000020 com! -range   -complete=file -nargs=+ -bang MkVimball		call vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
    1              0.000008 com! -nargs=? -complete=dir  UseVimball						call vimball#Vimball(1,<f-args>)
    1              0.000007 com! -nargs=0                VimballList					call vimball#Vimball(0)
    1              0.000014 com! -nargs=* -complete=dir  RmVimball						call vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
    1              0.000003 augroup Vimball
    1              0.000067  au!
    1              0.000022  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz	setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
    1              0.000017  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz			let s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
    1              0.000009  au SourceCmd *.vba											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
    1              0.000016  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz	setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
    1              0.000026  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz			let s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
    1              0.000009  au SourceCmd *.vmb											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
    1              0.000001 augroup END
                            
                            " =====================================================================
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000009 let &cpo= s:keepcpo
    1              0.000006 unlet s:keepcpo

SCRIPT  /home/c5262761/local/share/vim/vim81/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000348
 Self time:   0.000348

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Sep 13, 2016
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000011 if &cp || exists("g:loaded_zipPlugin")
                             finish
    1              0.000001 endif
    1              0.000003 let g:loaded_zipPlugin = "v28"
    1              0.000006 let s:keepcpo          = &cpo
    1              0.000007 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000005 if !exists("g:zipPlugin_ext")
    1              0.000007  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000002 augroup zip
    1              0.000096  au!
    1              0.000012  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000006  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000006  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000005  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000006  if has("unix")
    1              0.000014   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000007   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000005   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000006   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000002  endif
                            
    1              0.000089  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000002 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000010 let &cpo= s:keepcpo
    1              0.000005 unlet s:keepcpo

SCRIPT  /usr/share/vim/vim74/plugin/getscriptPlugin.vim
Sourced 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                            " ---------------------------------------------------------------------
                            " getscriptPlugin.vim
                            "  Author:	Charles E. Campbell
                            "  Date:	Jan 07, 2008
                            "  Installing:	:help glvs-install
                            "  Usage:	:help glvs
                            "
                            " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
                            "
                            " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
                            " all the peoples praise Him."
                            " ---------------------------------------------------------------------
                            " Initialization:	{{{1
                            " if you're sourcing this file, surely you can't be
                            " expecting vim to be in its vi-compatible mode
    1              0.000013 if &cp || exists("g:loaded_getscriptPlugin")
    1              0.000003  if &verbose
                              echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
    1              0.000001  endif
    1              0.000001  finish
                            endif
                            let g:loaded_getscriptPlugin = "v35"
                            let s:keepcpo                = &cpo
                            set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
                            com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
                            com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
                            silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
                            
                            " ---------------------------------------------------------------------
                            " Restore Options: {{{1
                            let &cpo= s:keepcpo
                            unlet s:keepcpo
                            
                            " ---------------------------------------------------------------------
                            " vim: ts=8 sts=2 fdm=marker nowrap

SCRIPT  /usr/share/vim/vim74/plugin/gzip.vim
Sourced 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2010 Mar 10
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000008 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
    1              0.000002   finish
                            endif
                            let loaded_gzip = 1
                            
                            augroup gzip
                              " Remove all gzip autocommands
                              au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
                              autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz setlocal bin
                              autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
                              autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
                              autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
                              autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
                              autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
                              autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
                              autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
                              autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
                              autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
                              autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
                              autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
                              autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
                              autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
                              autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
                              autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
                              autocmd FileAppendPost		*.gz  call gzip#write("gzip")
                              autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
                              autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
                              autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
                              autocmd FileAppendPost		*.xz call gzip#write("xz -z")
                            augroup END

SCRIPT  /usr/share/vim/vim74/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2013 May 08
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - the "CursorMoved" autocmd event is not available.
    1              0.000007 if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
    1              0.000002   finish
                            endif
                            let g:loaded_matchparen = 1
                            
                            if !exists("g:matchparen_timeout")
                              let g:matchparen_timeout = 300
                            endif
                            if !exists("g:matchparen_insert_timeout")
                              let g:matchparen_insert_timeout = 60
                            endif
                            
                            augroup matchparen
                              " Replace all matchparen autocommands
                              autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
                              if exists('##TextChanged')
                                autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
                              endif
                            augroup END
                            
                            " Skip the rest if it was already done.
                            if exists("*s:Highlight_Matching_Pair")
                              finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
                            function! s:Highlight_Matching_Pair()
                              " Remove any previous match.
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                3match none
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let c = getline(c_lnum)[c_col - 1]
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = 1
                                  let c = getline(c_lnum)[c_col - 2]
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let save_cursor = winsaveview()
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " When not in a string or comment ignore matches inside them.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' .
                            	\ '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                call winrestview(save_cursor)
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	  \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
                            " Define commands that will disable and enable the plugin.
                            command! NoMatchParen windo 3match none | unlet! g:loaded_matchparen |
                            	  \ au! matchparen
                            command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /usr/share/vim/vim74/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Date:		Apr 30, 2013
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2012 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000021 if &cp || exists("g:loaded_netrwPlugin")
    1              0.000011  finish
                            endif
                            "DechoTabOn
                            let g:loaded_netrwPlugin = "v149"
                            if v:version < 702
                             echohl WarningMsg | echo "***netrw*** you need vim version 7.2 for this version of netrw" | echohl None
                             finish
                            endif
                            let s:keepcpo = &cpo
                            set cpo&vim
                            "DechoTabOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing: {{{2
                            augroup FileExplorer
                             au!
                             " SEE Benzinger problem...
                             au BufEnter *	sil! call s:LocalBrowse(expand("<amatch>"))
                             au VimEnter *	sil! call s:VimEnter(expand("<amatch>"))
                             if has("win32") || has("win95") || has("win64") || has("win16")
                              au BufEnter .* sil! call s:LocalBrowse(expand("<amatch>"))
                             endif
                            augroup END
                            
                            " Network Browsing Reading Writing: {{{2
                            augroup Network
                             au!
                             au BufReadCmd   file://*									call netrw#FileUrlRead(expand("<amatch>"))
                             au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
                             au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
                             au BufWriteCmd  ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
                             au FileWriteCmd ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
                             try
                              au SourceCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             catch /^Vim\%((\a\+)\)\=:E216/
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             endtry
                            augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
                            com! -count=1 -nargs=*	Nread		call netrw#NetrwSavePosn()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call netrw#NetrwRestorePosn()
                            com! -range=% -nargs=*	Nwrite		call netrw#NetrwSavePosn()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call netrw#NetrwRestorePosn()
                            com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
                            com! -nargs=*	        Nsource		call netrw#NetrwSavePosn()<bar>call netrw#NetSource(<f-args>)<bar>call netrw#NetrwRestorePosn()
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore {{{2
                            com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
                            com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
                            com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
                            com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
                            com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
                            com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
                            com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
                            com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
                            com! -bang	NetrwClean	call netrw#NetrwClean(<bang>0)
                            
                            " Maps:
                            if !exists("g:netrw_nogx") && maparg('gx','n') == ""
                             if !hasmapto('<Plug>NetrwBrowseX')
                              nmap <unique> gx <Plug>NetrwBrowseX
                             endif
                             nno <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)<cr>
                            endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: {{{2
                            fun! s:LocalBrowse(dirname)
                              " unfortunate interaction -- debugging calls can't be used here;
                              " the BufEnter event causes triggering when attempts to write to
                              " the DBG buffer are made.
                              if !exists("s:vimentered")
                               return
                              endif
                            "  call Decho("s:LocalBrowse(dirname<".a:dirname.">){")
                            "  echomsg "dirname<".a:dirname.">"
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                               endif
                              elseif isdirectory(a:dirname)
                            "   echomsg "dirname<".dirname."> isdir"
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (not amiga)")
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                              endif
                              " not a directory, ignore it
                            "  call Decho("|return s:LocalBrowse }")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: {{{2
                            fun! s:VimEnter(dirname)
                            "  call Decho("VimEnter(dirname<".a:dirname.">){")
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo if a:dirname != expand("%")|call s:LocalBrowse(expand("%:p"))|endif
                              exe curwin."wincmd w"
                            "  call Decho("|return VimEnter }")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
                            fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
                            fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
                            let &cpo= s:keepcpo
                            unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /usr/share/vim/vim74/plugin/rrhelper.vim
Sourced 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                            " Vim plugin with helper function(s) for --remote-wait
                            " Maintainer: Flemming Madsen <fma@cci.dk>
                            " Last Change: 2008 May 29
                            
                            " Has this already been loaded?
    1              0.000011 if exists("loaded_rrhelper") || !has("clientserver")
    1              0.000002   finish
                            endif
                            let loaded_rrhelper = 1
                            
                            " Setup answers for a --remote-wait client who will assume
                            " a SetupRemoteReplies() function in the command server
                            
                            function SetupRemoteReplies()
                              let cnt = 0
                              let max = argc()
                            
                              let id = expand("<client>")
                              if id == 0
                                return
                              endif
                              while cnt < max
                                " Handle same file from more clients and file being more than once
                                " on the command line by encoding this stuff in the group name
                                let uniqueGroup = "RemoteReply_".id."_".cnt
                            
                                " Path separators are always forward slashes for the autocommand pattern.
                                " Escape special characters with a backslash.
                                let f = substitute(argv(cnt), '\\', '/', "g")
                                if exists('*fnameescape')
                                  let f = fnameescape(f)
                                else
                                  let f = escape(f, " \t\n*?[{`$\\%#'\"|!<")
                                endif
                                execute "augroup ".uniqueGroup
                                execute "autocmd ".uniqueGroup." BufUnload ". f ."  call DoRemoteReply('".id."', '".cnt."', '".uniqueGroup."', '". f ."')"
                                let cnt = cnt + 1
                              endwhile
                              augroup END
                            endfunc
                            
                            function DoRemoteReply(id, cnt, group, file)
                              call server2client(a:id, a:cnt)
                              execute 'autocmd! '.a:group.' BufUnload '.a:file
                              execute 'augroup! '.a:group
                            endfunc
                            
                            " vim: set sw=2 sts=2 :

SCRIPT  /usr/share/vim/vim74/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2006 Feb 01
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of spell files
    1              0.000014 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
    1              0.000002   finish
                            endif
                            let loaded_spellfile_plugin = 1
                            
                            " The function is in the autoload directory.
                            autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /usr/share/vim/vim74/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000013 if &cp || exists("g:loaded_tarPlugin")
    1              0.000002  finish
                            endif
                            let g:loaded_tarPlugin = "v29"
                            let s:keepcpo          = &cpo
                            set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
                            augroup tar
                              au!
                              au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
                              au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
                              au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
                              au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
                              if has("unix")
                               au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
                               au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
                               au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
                               au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
                              endif
                            
                              au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
                              au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
                            augroup END
                            com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
                            let &cpo= s:keepcpo
                            unlet s:keepcpo

SCRIPT  /usr/share/vim/vim74/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2013 Jul 08
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
                            " TODO: {{{
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support? Good start
                            "     by Erik Falor
                            "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
                            "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
                            "     term) to use for the styling. Suggestion by "nacitar".
                            "   * Add way to override or specify which RGB colors map to the color numbers
                            "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
                            "   * Disable filetype detection until after all processing is done.
                            "   * Add option for not generating the hyperlink on stuff that looks like a
                            "     URL? Or just color the link to fit with the colorscheme (and only special
                            "     when hovering)?
                            "   * Bug: Opera does not allow printing more than one page if uncopyable
                            "     regions is turned on. Possible solution: Add normal text line numbers with
                            "     display:none, set to display:inline for print style sheets, and hide
                            "     <input> elements for print, to allow Opera printing multiple pages (and
                            "     other uncopyable areas?). May need to make the new text invisible to IE
                            "     with conditional comments to prevent copying it, IE for some reason likes
                            "     to copy hidden text. Other browsers too?
                            "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
                            "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
                            "     on Windows). Perhaps it is font related?
                            "   * Bug: still some gaps in the fold column when html_prevent_copy contains
                            "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
                            "     on diff lines though.
                            "   * Undercurl support via CSS3, with fallback to dotted or something:
                            "	https://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
                            "   * Redo updates for modified default foldtext (v11) when/if the patch is
                            "     accepted to modify it.
                            "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
                            "		+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
                            "		+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
                            "     does not show the whole diff filler as it is supposed to?
                            "   * Bug: when 'isprint' is wrong for the current encoding, will generate
                            "     invalid content. Can/should anything be done about this? Maybe a separate
                            "     plugin to correct 'isprint' based on encoding?
                            "   * Check to see if the windows-125\d encodings actually work in Unix without
                            "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
                            "     platforms.
                            "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Make it so deleted lines in a diff don't create side-scrolling (get it
                            "     free with full-line background highlight above).
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase.
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "}}}
                            
    1              0.000007 if exists('g:loaded_2html_plugin')
    1              0.000002   finish
                            endif
                            let g:loaded_2html_plugin = 'vim7.4_v1'
                            
                            "
                            " Changelog: {{{
                            "   7.4_v1  (this version): Fix modeline mangling for new "Vim:" format, and
                            "			    also for version-specific modelines like "vim>703:".
                            "
                            "   7.3 updates: {{{
                            "   7.3_v14 (ad6996a23e3e): Allow suppressing line number anchors using
                            "			    g:html_line_ids=0. Allow customizing
                            "			    important IDs (like line IDs and fold IDs) using
                            "			    g:html_id_expr evalutated when the buffer conversion
                            "			    is started.
                            "   7.3_v13 (2eb30f341e8d): Keep foldmethod at manual in the generated file and
                            "			    insert modeline to set it to manual.
                            "			    Fix bug: diff mode with 2 unsaved buffers creates a
                            "			    duplicate of one buffer instead of including both.
                            "			    Add anchors to each line so you can put '#L123'
                            "			    or '#123' at the end of the URL to jump to line 123
                            "			    (idea by Andy Spencer). Add javascript to open folds
                            "			    to show the anchor being jumped to if it is hidden.
                            "			    Fix XML validation error: &nsbp; not part of XML.
                            "			    Allow TOhtml to chain together with other commands
                            "			    using |.
                            "   7.3_v12 (9910cbff5f16): Fix modeline mangling to also work for when multiple
                            "			    highlight groups make up the start-of-modeline text.
                            "			    Improve render time of page with uncopyable regions
                            "			    by not using one-input-per-char. Change name of
                            "			    uncopyable option from html_unselectable to
                            "			    html_prevent_copy. Added html_no_invalid option and
                            "			    default to inserting invalid markup for uncopyable
                            "			    regions to prevent MS Word from pasting undeletable
                            "			    <input> elements. Fix 'cpo' handling (Thilo Six).
                            "		 7.3_v12b1: Add html_unselectable option. Rework logic to
                            "			    eliminate post-processing substitute commands in
                            "			    favor of doing the work up front. Remove unnecessary
                            "			    special treatment of 'LineNr' highlight group. Minor
                            "			    speed improvements. Fix modeline mangling in
                            "			    generated output so it works for text in the first
                            "			    column. Fix missing line number and fold column in
                            "			    diff filler lines. Fix that some fonts have a 1px
                            "			    gap (using a dirty hack, improvements welcome). Add
                            "			    "colorscheme" meta tag. Does NOT include support for
                            "			    the new default foldtext added in v11, as the patch
                            "			    adding it has not yet been included in Vim.
                            "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
                            "			    Brabandt in
                            "			    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
                            "			    This patch has not yet been included in Vim, thus
                            "			    these changes are removed in the next version.
                            "   7.3_v10 (fd09a9c8468e): Fix error E684 when converting a range wholly inside
                            "			    multiple nested folds with dynamic folding on.
                            "			    Also fix problem with foldtext in this situation.
                            "   7.3_v9  (0877b8d6370e): Add html_pre_wrap option active with html_use_css
                            "			    and without html_no_pre, default value same as
                            "			    'wrap' option, (Andy Spencer). Don't use
                            "			    'fileencoding' for converted document encoding if
                            "			    'buftype' indicates a special buffer which isn't
                            "			    written.
                            "   7.3_v8  (85c5a72551e2): Add html_expand_tabs option to allow leaving tab
                            "			    characters in generated output (Andy Spencer).
                            "			    Escape text that looks like a modeline so Vim
                            "			    doesn't use anything in the converted HTML as a
                            "			    modeline. Bugfixes: Fix folding when a fold starts
                            "			    before the conversion range. Remove fold column when
                            "			    there are no folds.
                            "   7.3_v7  (840c3cadb842): see betas released on vim_dev below:
                            "		  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "		  7.3_v7b2: Remove automatic detection of encodings that are not
                            "			    supported by all major browsers according to
                            "			    http://wiki.whatwg.org/wiki/Web_Encodings and
                            "			    convert to UTF-8 for all Unicode encodings. Make
                            "			    HTML encoding to Vim encoding detection be
                            "			    case-insensitive for built-in pairs.
                            "		  7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "			    called in restricted mode (Andy Spencer). Use
                            "			    'fencoding' instead of 'encoding' to determine by
                            "			    charset, and make sure the 'fenc' of the generated
                            "			    file matches its indicated charset. Add charsets for
                            "			    all of Vim's natively supported encodings.
                            "   7.3_v6  (0d3f0e3d289b): Really fix bug with 'nowrapscan', 'magic' and other
                            "			    user settings interfering with diff mode generation,
                            "			    trailing whitespace (e.g. line number column) when
                            "			    using html_no_pre, and bugs when using
                            "			    html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "			    folds in diff mode when first line was folded.
                            "   7.3_v4  (7e008c174cc3): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (a29075150aee): Refactor option handling and make html_use_css
                            "			    default to true when not set to anything. Use strict
                            "			    doctypes where possible. Rename use_xhtml option to
                            "			    html_use_xhtml for consistency. Use .xhtml extension
                            "			    when using this option. Add meta tag for settings.
                            "   7.3_v2  (80229a724a11): Fix syntax highlighting in diff mode to use both the
                            "			    diff colors and the normal syntax colors
                            "   7.3_v1  (e7751177126b): Add conceal support and meta tags in output
                            "   Pre-v1 baseline: Mercurial changeset 3c9324c0800e
                            "}}}
                            "}}}
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin was not already loaded
                            " - user commands are available. {{{
                            if !&cp && !exists(":TOhtml") && has("user_commands")
                              command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
                            endif "}}}
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet fdm=marker

SCRIPT  /usr/share/vim/vim74/plugin/vimballPlugin.vim
Sourced 1 time
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
                            " vimballPlugin : construct a file containing both paths and files
                            " Author: Charles E. Campbell, Jr.
                            " Copyright: (c) 2004-2010 by Charles E. Campbell, Jr.
                            "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
                            "            (see |copyright|) except use "Vimball" instead of "Vim".
                            "            No warranty, express or implied.
                            "  *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
                            "      judge. For in that which you judge another, you condemn yourself. For
                            "      you who judge practice the same things.
                            " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
                            
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000027 if &cp || exists("g:loaded_vimballPlugin")
    1              0.000003  finish
                            endif
                            let g:loaded_vimballPlugin = "v35"
                            let s:keepcpo              = &cpo
                            set cpo&vim
                            
                            " ------------------------------------------------------------------------------
                            " Public Interface: {{{1
                            com! -ra   -complete=file -na=+ -bang MkVimball				call vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
                            com! -na=? -complete=dir  UseVimball						call vimball#Vimball(1,<f-args>)
                            com! -na=0                VimballList						call vimball#Vimball(0)
                            com! -na=* -complete=dir  RmVimball							call vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
                            au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz	setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")
                            au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz			if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif
                            au SourceCmd *.vba											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
                            au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz	setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")
                            au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz			if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif
                            au SourceCmd *.vmb											if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
                            
                            " =====================================================================
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
                            let &cpo= s:keepcpo
                            unlet s:keepcpo

SCRIPT  /usr/share/vim/vim74/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Jun 07, 2013
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2013 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000011 if &cp || exists("g:loaded_zipPlugin")
    1              0.000001  finish
                            endif
                            let g:loaded_zipPlugin = "v27"
                            let s:keepcpo          = &cpo
                            set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
                            if !exists("g:zipPlugin_ext")
                             let g:zipPlugin_ext= '*.zip,*.jar,*.xpi,*.ja,*.war,*.ear,*.celzip,*.oxt,*.kmz,*.wsz,*.xap,*.docx,*.docm,*.dotx,*.dotm,*.potx,*.potm,*.ppsx,*.ppsm,*.pptx,*.pptm,*.ppam,*.sldx,*.thmx,*.xlam,*.xlsx,*.xlsm,*.xlsb,*.xltx,*.xltm,*.xlam,*.crtx,*.vdw,*.glox,*.gcsx,*.gqsx'
                            endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            augroup zip
                             au!
                             au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
                             au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
                             au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
                             au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
                             if has("unix")
                              au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
                              au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
                              au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
                              au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
                             endif
                            
                             exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
                            augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
                            let &cpo= s:keepcpo
                            unlet s:keepcpo

SCRIPT  /home/c5262761/configit/vim/modules/vim-snipmate/after/plugin/snipMate.vim
Sourced 1 time
Total time:   0.000415
 Self time:   0.000194

count  total (s)   self (s)
                            " snipMate maps
                            " These maps are created here in order to make sure we can reliably create maps
                            " after SuperTab.
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000006 function! s:map_if_not_mapped(lhs, rhs, mode) abort
                                let l:unique = s:overwrite ? '' : ' <unique>'
                                if !hasmapto(a:rhs, a:mode)
                            	silent! exe a:mode . 'map' . l:unique a:lhs a:rhs
                                endif
                            endfunction
                            
    1              0.000005 if !exists('g:snips_no_mappings') || !g:snips_no_mappings
    1              0.000004 	if exists('g:snips_trigger_key')
                            		echom 'g:snips_trigger_key is deprecated. See :h snipMate-mappings'
                            		exec 'imap <unique>' g:snips_trigger_key '<Plug>snipMateTrigger'
                            		exec 'smap <unique>' g:snips_trigger_key '<Plug>snipMateSNext'
                            		exec 'xmap <unique>' g:snips_trigger_key '<Plug>snipMateVisual'
    1              0.000001 	else
                            		" Remove SuperTab map if it exists
    1              0.000031 		let s:overwrite = maparg('<Tab>', 'i') ==? '<Plug>SuperTabForward'
    1   0.000053   0.000009 		call s:map_if_not_mapped('<Tab>', '<Plug>snipMateNextOrTrigger', 'i')
    1   0.000058   0.000008 		call s:map_if_not_mapped('<Tab>', '<Plug>snipMateNextOrTrigger', 's')
    1              0.000003 		let s:overwrite = 0
    1   0.000045   0.000007 		call s:map_if_not_mapped('<Tab>', '<Plug>snipMateVisual', 'x')
    1              0.000002 	endif
                            
    1              0.000004 	if exists('g:snips_trigger_key_backwards')
                            		echom 'g:snips_trigger_key_backwards is deprecated. See :h snipMate-mappings'
                            		exec 'imap <unique>' g:snips_trigger_key_backwards '<Plug>snipMateIBack'
                            		exec 'smap <unique>' g:snips_trigger_key_backwards '<Plug>snipMateSBack'
    1              0.000001 	else
    1              0.000012 		let s:overwrite = maparg('<S-Tab>', 'i') ==? '<Plug>SuperTabBackward'
    1   0.000043   0.000008 		call s:map_if_not_mapped('<S-Tab>', '<Plug>snipMateBack', 'i')
    1   0.000043   0.000007 		call s:map_if_not_mapped('<S-Tab>', '<Plug>snipMateBack', 's')
    1              0.000003 		let s:overwrite = 0
    1              0.000001 	endif
                            
    1   0.000025   0.000007 	call s:map_if_not_mapped('<C-R><Tab>', '<Plug>snipMateShow', 'i')
    1              0.000002 endif
                            
    1              0.000008 let &cpo = s:save_cpo
                            
                            " vim:noet:

SCRIPT  /home/c5262761/configit/vim/modules/vim-puppet/after/plugin/gutentags.vim
Sourced 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000012 if !exists('g:gutentags_enabled' && g:gutentags_dont_load != 0 )
    1              0.000003     finish
                            endif
                            
                            call add(g:gutentags_project_info, {'type': 'puppet', 'file': 'Puppetfile'})
                            
                            let s:ctags_options = puppet#ctags#OptionFile()
                            call add(g:gutentags_ctags_extra_args, '--options=' . s:ctags_options)
                            unlet s:ctags_options
                            

SCRIPT  /home/c5262761/configit/vim/ftplugin/go.vim
Sourced 2 times
Total time:   0.001910
 Self time:   0.001377

count  total (s)   self (s)
    2              0.000023 setl shiftwidth=0
    2              0.000010 setl noexpandtab
    4              0.000031 for path in split($GOPATH, ':')
    2              0.000024     exec 'setl path+=' . path . '/src'
    4              0.000006 endfor
                            
    2              0.000020 setl ts=4
                            
    2   0.001606   0.001073 compiler go
                            
    2              0.000086 nnoremap <silent> <buffer> <space>gr :GoRun %<cr>
    2              0.000023 nnoremap <silent> <buffer> <space>gcr :GoCoverage<cr>
    2              0.000035 nnoremap <silent> <buffer> <space>gcc :GoCoverageClear<cr>:syntax on<cr>:colorscheme wombat<cr>

SCRIPT  /home/c5262761/configit/vim/compiler/go.vim
Sourced 4 times
Total time:   0.000702
 Self time:   0.000702

count  total (s)   self (s)
                            " Copyright 2013 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " compiler/go.vim: Vim compiler file for Go.
                            
    4              0.000033 if exists("current_compiler")
                                finish
    4              0.000007 endif
    4              0.000031 let current_compiler = "go"
                            
    4              0.000023 if exists(":CompilerSet") != 2
                                command -nargs=* CompilerSet setlocal <args>
    4              0.000005 endif
                            
    4              0.000046 let s:save_cpo = &cpo
    4              0.000044 set cpo-=C
    4              0.000070 if filereadable("makefile") || filereadable("Makefile")
    4              0.000043     CompilerSet makeprg=make
                            else
                                CompilerSet makeprg=go\ build
    4              0.000005 endif
                            
                            " Define the patterns that will be recognized by QuickFix when parsing the
                            " output of Go command that use this errorforamt (when called make, cexpr or
                            " lmake, lexpr). This is the global errorformat, however some command might
                            " use a different output, for those we define them directly and modify the
                            " errorformat ourselves. More information at:
                            " http://vimdoc.sourceforge.net/htmldoc/quickfix.html#errorformat
    4              0.000035 CompilerSet errorformat =%-G#\ %.%#                   " Ignore lines beginning with '#' ('# command-line-arguments' line sometimes appears?)
    4              0.000028 CompilerSet errorformat+=%-G%.%#panic:\ %m            " Ignore lines containing 'panic: message'
    4              0.000024 CompilerSet errorformat+=%Ecan\'t\ load\ package:\ %m " Start of multiline error string is 'can\'t load package'
    4              0.000023 CompilerSet errorformat+=%A%f:%l:%c:\ %m              " Start of multiline unspecified string is 'filename:linenumber:columnnumber:'
    4              0.000022 CompilerSet errorformat+=%A%f:%l:\ %m                 " Start of multiline unspecified string is 'filename:linenumber:'
    4              0.000021 CompilerSet errorformat+=%C%*\\s%m                    " Continuation of multiline error message is indented
    4              0.000022 CompilerSet errorformat+=%-G%.%#                      " All lines not matching any of the above patterns are ignored
                            
    4              0.000036 let &cpo = s:save_cpo
    4              0.000021 unlet s:save_cpo

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/compiler/go.vim
Sourced 4 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
                            " Copyright 2013 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " compiler/go.vim: Vim compiler file for Go.
                            
    4              0.000035 if exists("g:current_compiler")
    4              0.000019   finish
                            endif
                            let g:current_compiler = "go"
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            if exists(":CompilerSet") != 2
                              command -nargs=* CompilerSet setlocal <args>
                            endif
                            
                            let s:save_cpo = &cpo
                            set cpo-=C
                            if filereadable("makefile") || filereadable("Makefile")
                              CompilerSet makeprg=make
                            else
                              CompilerSet makeprg=go\ build
                            endif
                            
                            " Define the patterns that will be recognized by QuickFix when parsing the
                            " output of Go command that use this errorforamt (when called make, cexpr or
                            " lmake, lexpr). This is the global errorformat, however some command might
                            " use a different output, for those we define them directly and modify the
                            " errorformat ourselves. More information at:
                            " http://vimdoc.sourceforge.net/htmldoc/quickfix.html#errorformat
                            CompilerSet errorformat =%-G#\ %.%#                   " Ignore lines beginning with '#' ('# command-line-arguments' line sometimes appears?)
                            CompilerSet errorformat+=%-G%.%#panic:\ %m            " Ignore lines containing 'panic: message'
                            CompilerSet errorformat+=%Ecan\'t\ load\ package:\ %m " Start of multiline error string is 'can\'t load package'
                            CompilerSet errorformat+=%A%f:%l:%c:\ %m              " Start of multiline unspecified string is 'filename:linenumber:columnnumber:'
                            CompilerSet errorformat+=%A%f:%l:\ %m                 " Start of multiline unspecified string is 'filename:linenumber:'
                            CompilerSet errorformat+=%C%*\\s%m                    " Continuation of multiline error message is indented
                            CompilerSet errorformat+=%-G%.%#                      " All lines not matching any of the above patterns are ignored
                            
                            let &cpo = s:save_cpo
                            unlet s:save_cpo
                            
                            " restore Vi compatibility settings
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/local/share/vim/vim81/compiler/go.vim
Sourced 4 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
                            " Vim compiler file
                            " Compiler:	Go
                            " Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
                            " Last Change:	2014 Aug 16
                            
    4              0.000031 if exists('current_compiler')
    4              0.000008   finish
                            endif
                            let current_compiler = 'go'
                            
                            if exists(':CompilerSet') != 2
                              command -nargs=* CompilerSet setlocal <args>
                            endif
                            
                            let s:save_cpo = &cpo
                            set cpo-=C
                            
                            CompilerSet makeprg=go\ build
                            CompilerSet errorformat=
                                \%-G#\ %.%#,
                                \%A%f:%l:%c:\ %m,
                                \%A%f:%l:\ %m,
                                \%C%*\\s%m,
                                \%-G%.%#
                            
                            let &cpo = s:save_cpo
                            unlet s:save_cpo
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/ftplugin/go.vim
Sourced 2 times
Total time:   0.003091
 Self time:   0.002778

count  total (s)   self (s)
                            " Copyright 2013 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " go.vim: Vim filetype plugin for Go.
                            
    2              0.000017 if exists("b:did_ftplugin")
                              finish
    2              0.000002 endif
    2              0.000006 let b:did_ftplugin = 1
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    2              0.000016 let s:cpo_save = &cpo
    2              0.000018 set cpo&vim
                            
    2              0.000010 let b:undo_ftplugin = "setl fo< com< cms<
                                  \ | exe 'au! vim-go-buffer * <buffer>'"
                            
    2              0.000009 setlocal formatoptions-=t
                            
    2              0.000017 setlocal comments=s1:/*,mb:*,ex:*/,://
    2              0.000006 setlocal commentstring=//\ %s
                            
    2              0.000008 setlocal noexpandtab
                            
    2   0.001509   0.001291 compiler go
                            
    2   0.000045   0.000038 if go#config#CodeCompletionEnabled()
                              " Set autocompletion
    2              0.000012   setlocal omnifunc=go#complete#Complete
    2   0.000076   0.000042   if !go#util#has_job()
                                setlocal omnifunc=go#complete#GocodeComplete
    2              0.000002   endif
    2              0.000002 endif
                            
    2              0.000008 if get(g:, "go_doc_keywordprg_enabled", 1)
                              " keywordprg doesn't allow to use vim commands, override it
    2              0.000040   nnoremap <buffer> <silent> K :GoDoc<cr>
    2              0.000004 endif
                            
    2              0.000017 if get(g:, "go_def_mapping_enabled", 1)
                              " these are default Vim mappings, we're overriding them to make them
                              " useful again for Go source code
    2              0.000033   nnoremap <buffer> <silent> gd :GoDef<cr>
    2              0.000029   nnoremap <buffer> <silent> <C-]> :GoDef<cr>
    2              0.000034   nnoremap <buffer> <silent> <C-LeftMouse> <LeftMouse>:GoDef<cr>
    2              0.000026   nnoremap <buffer> <silent> g<LeftMouse> <LeftMouse>:GoDef<cr>
    2              0.000024   nnoremap <buffer> <silent> <C-w><C-]> :<C-u>call go#def#Jump("split", 0)<CR>
    2              0.000023   nnoremap <buffer> <silent> <C-w>] :<C-u>call go#def#Jump("split", 0)<CR>
    2              0.000024   nnoremap <buffer> <silent> <C-t> :<C-U>call go#def#StackPop(v:count1)<cr>
    2              0.000002 endif
                            
    2              0.000010 if get(g:, "go_textobj_enabled", 1)
    2              0.000027   onoremap <buffer> <silent> af :<c-u>call go#textobj#Function('a')<cr>
    2              0.000025   xnoremap <buffer> <silent> af :<c-u>call go#textobj#Function('a')<cr>
                            
    2              0.000023   onoremap <buffer> <silent> if :<c-u>call go#textobj#Function('i')<cr>
    2              0.000021   xnoremap <buffer> <silent> if :<c-u>call go#textobj#Function('i')<cr>
                            
    2              0.000022   onoremap <buffer> <silent> ac :<c-u>call go#textobj#Comment('a')<cr>
    2              0.000021   xnoremap <buffer> <silent> ac :<c-u>call go#textobj#Comment('a')<cr>
                            
    2              0.000021   onoremap <buffer> <silent> ic :<c-u>call go#textobj#Comment('i')<cr>
    2              0.000021   xnoremap <buffer> <silent> ic :<c-u>call go#textobj#Comment('i')<cr>
                            
                              " Remap ]] and [[ to jump betweeen functions as they are useless in Go
    2              0.000032   nnoremap <buffer> <silent> ]] :<c-u>call go#textobj#FunctionJump('n', 'next')<cr>
    2              0.000024   nnoremap <buffer> <silent> [[ :<c-u>call go#textobj#FunctionJump('n', 'prev')<cr>
                            
    2              0.000023   onoremap <buffer> <silent> ]] :<c-u>call go#textobj#FunctionJump('o', 'next')<cr>
    2              0.000024   onoremap <buffer> <silent> [[ :<c-u>call go#textobj#FunctionJump('o', 'prev')<cr>
                            
    2              0.000027   xnoremap <buffer> <silent> ]] :<c-u>call go#textobj#FunctionJump('v', 'next')<cr>
    2              0.000023   xnoremap <buffer> <silent> [[ :<c-u>call go#textobj#FunctionJump('v', 'prev')<cr>
    2              0.000003 endif
                            
    2   0.000045   0.000035 if go#config#AutoTypeInfo() || go#config#AutoSameids()
                              let &l:updatetime= get(g:, "go_updatetime", 800)
    2              0.000003 endif
                            
                            " Autocommands
                            " ============================================================================
                            "
    2              0.000005 augroup vim-go-buffer
    2              0.000193   autocmd! * <buffer>
                            
                              " The file is registered (textDocument/DidOpen) with gopls in plugin/go.vim
                              " on the FileType event.
                              " TODO(bc): handle all the other events that may be of interest to gopls,
                              " too (e.g.  BufFilePost , CursorHold , CursorHoldI, FileReadPost,
                              " StdinReadPre, BufWritePost, TextChange, TextChangedI)
    2   0.000093   0.000049   if go#util#has_job()
    2              0.000021     autocmd BufWritePost <buffer> call go#lsp#DidChange(expand('<afile>:p'))
    2              0.000010     autocmd FileChangedShell <buffer> call go#lsp#DidChange(expand('<afile>:p'))
    2              0.000009     autocmd BufDelete <buffer> call go#lsp#DidClose(expand('<afile>:p'))
    2              0.000003   endif
                            
    2              0.000018   autocmd CursorHold <buffer> call go#auto#auto_type_info()
    2              0.000009   autocmd CursorHold <buffer> call go#auto#auto_sameids()
                            
                              " Echo the identifier information when completion is done. Useful to see
                              " the signature of a function, etc...
    2              0.000008   if exists('##CompleteDone')
    2              0.000008     autocmd CompleteDone <buffer> call go#auto#echo_go_info()
    2              0.000002   endif
                            
    2              0.000008   autocmd BufWritePre <buffer> call go#auto#fmt_autosave()
    2              0.000006   autocmd BufWritePost <buffer> call go#auto#metalinter_autosave()
                            
                              " clear SameIds when the buffer is unloaded so that loading another buffer
                              " in the same window doesn't highlight the most recently matched
                              " identifier's positions.
    2              0.000013   autocmd BufWinEnter <buffer> call go#guru#ClearSameIds()
                            
    2              0.000024   autocmd BufEnter <buffer>
                                    \  if go#config#AutodetectGopath() && !exists('b:old_gopath')
                                    \|   let b:old_gopath = exists('$GOPATH') ? $GOPATH : -1
                                    \|   let $GOPATH = go#path#Detect()
                                    \| endif
    2              0.000020   autocmd BufLeave <buffer>
                                    \  if exists('b:old_gopath')
                                    \|   if b:old_gopath isnot -1
                                    \|     let $GOPATH = b:old_gopath
                                    \|   endif
                                    \|   unlet b:old_gopath
                                    \| endif
    2              0.000006 augroup end
                            
                            " restore Vi compatibility settings
    2              0.000046 let &cpo = s:cpo_save
    2              0.000008 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/ftplugin/go/commands.vim
Sourced 2 times
Total time:   0.001353
 Self time:   0.001353

count  total (s)   self (s)
                            " -- gorename
    2              0.000048 command! -nargs=? -complete=customlist,go#rename#Complete GoRename call go#rename#Rename(<bang>0, <f-args>)
                            
                            " -- guru
    2              0.000035 command! -nargs=* -complete=customlist,go#package#Complete GoGuruScope call go#guru#Scope(<f-args>)
    2              0.000024 command! -range=% GoImplements call go#guru#Implements(<count>)
    2              0.000023 command! -range=% GoPointsTo call go#guru#PointsTo(<count>)
    2              0.000029 command! -range=% GoWhicherrs call go#guru#Whicherrs(<count>)
    2              0.000017 command! -range=% GoCallees call go#guru#Callees(<count>)
    2              0.000016 command! -range=% GoDescribe call go#guru#Describe(<count>)
    2              0.000014 command! -range=% GoCallers call go#guru#Callers(<count>)
    2              0.000017 command! -range=% GoCallstack call go#guru#Callstack(<count>)
    2              0.000016 command! -range=% GoFreevars call go#guru#Freevars(<count>)
    2              0.000015 command! -range=% GoChannelPeers call go#guru#ChannelPeers(<count>)
    2              0.000016 command! -range=% GoReferrers call go#guru#Referrers(<count>)
                            
    2              0.000011 command! -range=0 GoSameIds call go#guru#SameIds(1)
    2              0.000012 command! -range=0 GoSameIdsClear call go#guru#ClearSameIds()
    2              0.000012 command! -range=0 GoSameIdsToggle call go#guru#ToggleSameIds()
    2              0.000012 command! -range=0 GoSameIdsAutoToggle call go#guru#AutoToggleSameIds()
                            
                            " -- tags
    2              0.000032 command! -nargs=* -range GoAddTags call go#tags#Add(<line1>, <line2>, <count>, <f-args>)
    2              0.000031 command! -nargs=* -range GoRemoveTags call go#tags#Remove(<line1>, <line2>, <count>, <f-args>)
                            
                            " -- mod
    2              0.000010 command! -nargs=0 -range GoModFmt call go#mod#Format()
                            
                            " -- tool
    2              0.000013 command! -nargs=* -complete=customlist,go#tool#ValidFiles GoFiles echo go#tool#Files(<f-args>)
    2              0.000010 command! -nargs=0 GoDeps echo go#tool#Deps()
    2              0.000011 command! -nargs=0 GoInfo call go#tool#Info(1)
    2              0.000013 command! -nargs=0 GoAutoTypeInfoToggle call go#complete#ToggleAutoTypeInfo()
                            
                            " -- cmd
    2              0.000017 command! -nargs=* -bang GoBuild call go#cmd#Build(<bang>0,<f-args>)
    2              0.000019 command! -nargs=? -bang GoBuildTags call go#cmd#BuildTags(<bang>0, <f-args>)
    2              0.000018 command! -nargs=* -bang GoGenerate call go#cmd#Generate(<bang>0,<f-args>)
    2              0.000019 command! -nargs=* -bang -complete=file GoRun call go#cmd#Run(<bang>0,<f-args>)
    2              0.000017 command! -nargs=* -bang GoInstall call go#cmd#Install(<bang>0, <f-args>)
                            
                            " -- test
    2              0.000018 command! -nargs=* -bang GoTest call go#test#Test(<bang>0, 0, <f-args>)
    2              0.000018 command! -nargs=* -bang GoTestFunc call go#test#Func(<bang>0, <f-args>)
    2              0.000018 command! -nargs=* -bang GoTestCompile call go#test#Test(<bang>0, 1, <f-args>)
                            
                            " -- cover
    2              0.000018 command! -nargs=* -bang GoCoverage call go#coverage#Buffer(<bang>0, <f-args>)
    2              0.000010 command! -nargs=* -bang GoCoverageClear call go#coverage#Clear()
    2              0.000023 command! -nargs=* -bang GoCoverageToggle call go#coverage#BufferToggle(<bang>0, <f-args>)
    2              0.000025 command! -nargs=* -bang GoCoverageBrowser call go#coverage#Browser(<bang>0, <f-args>)
                            
                            " -- play
    2              0.000033 command! -nargs=0 -range=% GoPlay call go#play#Share(<count>, <line1>, <line2>)
                            
                            " -- def
    2              0.000010 command! -nargs=* -range GoDef :call go#def#Jump('', 0)
    2              0.000012 command! -nargs=* -range GoDefType :call go#def#Jump('', 1)
    2              0.000012 command! -nargs=? GoDefPop :call go#def#StackPop(<f-args>)
    2              0.000013 command! -nargs=? GoDefStack :call go#def#Stack(<f-args>)
    2              0.000012 command! -nargs=? GoDefStackClear :call go#def#StackClear(<f-args>)
                            
                            " -- doc
    2              0.000017 command! -nargs=* -range -complete=customlist,go#package#Complete GoDoc call go#doc#Open('new', 'split', <f-args>)
    2              0.000015 command! -nargs=* -range -complete=customlist,go#package#Complete GoDocBrowser call go#doc#OpenBrowser(<f-args>)
                            
                            " -- fmt
    2              0.000014 command! -nargs=0 GoFmt call go#fmt#Format(-1)
    2              0.000014 command! -nargs=0 GoFmtAutoSaveToggle call go#fmt#ToggleFmtAutoSave()
    2              0.000012 command! -nargs=0 GoImports call go#fmt#Format(1)
                            
                            " -- asmfmt
    2              0.000013 command! -nargs=0 GoAsmFmtAutoSaveToggle call go#asmfmt#ToggleAsmFmtAutoSave()
                            
                            " -- import
    2              0.000018 command! -nargs=? -complete=customlist,go#package#Complete GoDrop call go#import#SwitchImport(0, '', <f-args>, '')
    2              0.000024 command! -nargs=1 -bang -complete=customlist,go#package#Complete GoImport call go#import#SwitchImport(1, '', <f-args>, '<bang>')
    2              0.000023 command! -nargs=* -bang -complete=customlist,go#package#Complete GoImportAs call go#import#SwitchImport(1, <f-args>, '<bang>')
                            
                            " -- linters
    2              0.000019 command! -nargs=* -bang GoMetaLinter call go#lint#Gometa(<bang>0, 0, <f-args>)
    2              0.000020 command! -nargs=0 GoMetaLinterAutoSaveToggle call go#lint#ToggleMetaLinterAutoSave()
    2              0.000019 command! -nargs=* -bang GoLint call go#lint#Golint(<bang>0, <f-args>)
    2              0.000018 command! -nargs=* -bang GoVet call go#lint#Vet(<bang>0, <f-args>)
    2              0.000020 command! -nargs=* -bang -complete=customlist,go#package#Complete GoErrCheck call go#lint#Errcheck(<bang>0, <f-args>)
                            
                            " -- alternate
    2              0.000015 command! -bang GoAlternate call go#alternate#Switch(<bang>0, '')
                            
                            " -- decls
    2              0.000014 command! -nargs=? -complete=file GoDecls call go#decls#Decls(0, <q-args>)
    2              0.000014 command! -nargs=? -complete=dir GoDeclsDir call go#decls#Decls(1, <q-args>)
                            
                            " -- impl
    2              0.000017 command! -nargs=* -complete=customlist,go#impl#Complete GoImpl call go#impl#Impl(<f-args>)
                            
                            " -- template
    2              0.000019 command! -nargs=0 GoTemplateAutoCreateToggle call go#template#ToggleAutoCreate()
                            
                            " -- keyify
    2              0.000016 command! -nargs=0 GoKeyify call go#keyify#Keyify()
                            
                            " -- fillstruct
    2              0.000016 command! -nargs=0 GoFillStruct call go#fillstruct#FillStruct()
                            
                            " -- debug
    2              0.000019 if !exists(':GoDebugStart')
    1              0.000009   command! -nargs=* -complete=customlist,go#package#Complete GoDebugStart call go#debug#Start(0, <f-args>)
    1              0.000009   command! -nargs=* -complete=customlist,go#package#Complete GoDebugTest  call go#debug#Start(1, <f-args>)
    1              0.000017   command! -nargs=? GoDebugBreakpoint call go#debug#Breakpoint(<f-args>)
    2              0.000002 endif
                            
                            " -- issue
    2              0.000012 command! -nargs=0 GoReportGitHubIssue call go#issue#New()
                            
                            " -- iferr
    2              0.000012 command! -nargs=0 GoIfErr call go#iferr#Generate()
                            
                            " -- lsp
    2              0.000016 command! -nargs=+ -complete=dir GoAddWorkspace call go#lsp#AddWorkspaceDirectory(<f-args>)
    2              0.000012 command! -nargs=0 GoLSPDebugBrowser call go#lsp#DebugBrowser()
                            
                            " -- term
    2              0.000014 command! GoToggleTermCloseOnExit call go#term#ToggleCloseOnExit()
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/ftplugin/go/mappings.vim
Sourced 2 times
Total time:   0.001892
 Self time:   0.001892

count  total (s)   self (s)
                            " go_jump_to_error defines whether we should pass the bang attribute to the
                            " command or not. This is only used for mappings, because the user can't pass
                            " the bang attribute to the plug mappings below. So instead of hardcoding it
                            " as 0 (no '!' attribute) or 1 (with '!' attribute) we pass the user setting,
                            " which by default is enabled. For commands the user has the ability to pass
                            " the '!', such as :GoBuild or :GoBuild!
    2              0.000017 if !exists("g:go_jump_to_error")
    1              0.000005   let g:go_jump_to_error = 1
    2              0.000003 endif
                            
                            " Some handy plug mappings
    2              0.000052 nnoremap <silent> <Plug>(go-run) :<C-u>call go#cmd#Run(!g:go_jump_to_error)<CR>
                            
    2              0.000012 if has("nvim")
                              nnoremap <silent> <Plug>(go-run-vertical) :<C-u>call go#cmd#RunTerm(!g:go_jump_to_error, 'vsplit', [])<CR>
                              nnoremap <silent> <Plug>(go-run-split) :<C-u>call go#cmd#RunTerm(!g:go_jump_to_error, 'split', [])<CR>
                              nnoremap <silent> <Plug>(go-run-tab) :<C-u>call go#cmd#RunTerm(!g:go_jump_to_error, 'tabe', [])<CR>
    2              0.000002 endif
                            
    2              0.000037 nnoremap <silent> <Plug>(go-build) :<C-u>call go#cmd#Build(!g:go_jump_to_error)<CR>
    2              0.000033 nnoremap <silent> <Plug>(go-generate) :<C-u>call go#cmd#Generate(!g:go_jump_to_error)<CR>
    2              0.000031 nnoremap <silent> <Plug>(go-install) :<C-u>call go#cmd#Install(!g:go_jump_to_error)<CR>
    2              0.000030 nnoremap <silent> <Plug>(go-test) :<C-u>call go#test#Test(!g:go_jump_to_error, 0)<CR>
    2              0.000031 nnoremap <silent> <Plug>(go-test-func) :<C-u>call go#test#Func(!g:go_jump_to_error)<CR>
    2              0.000032 nnoremap <silent> <Plug>(go-test-compile) :<C-u>call go#test#Test(!g:go_jump_to_error, 1)<CR>
                            
    2              0.000030 nnoremap <silent> <Plug>(go-coverage) :<C-u>call go#coverage#Buffer(!g:go_jump_to_error)<CR>
    2              0.000029 nnoremap <silent> <Plug>(go-coverage-clear) :<C-u>call go#coverage#Clear()<CR>
    2              0.000033 nnoremap <silent> <Plug>(go-coverage-toggle) :<C-u>call go#coverage#BufferToggle(!g:go_jump_to_error)<CR>
    2              0.000033 nnoremap <silent> <Plug>(go-coverage-browser) :<C-u>call go#coverage#Browser(!g:go_jump_to_error)<CR>
                            
    2              0.000028 nnoremap <silent> <Plug>(go-files) :<C-u>call go#tool#Files()<CR>
    2              0.000025 nnoremap <silent> <Plug>(go-deps) :<C-u>call go#tool#Deps()<CR>
    2              0.000034 nnoremap <silent> <Plug>(go-info) :<C-u>call go#tool#Info(1)<CR>
    2              0.000037 nnoremap <silent> <Plug>(go-import) :<C-u>call go#import#SwitchImport(1, '', expand('<cword>'), '')<CR>
    2              0.000026 nnoremap <silent> <Plug>(go-imports) :<C-u>call go#fmt#Format(1)<CR>
                            
    2              0.000029 nnoremap <silent> <Plug>(go-implements) :<C-u>call go#guru#Implements(-1)<CR>
    2              0.000033 nnoremap <silent> <Plug>(go-callees) :<C-u>call go#guru#Callees(-1)<CR>
    2              0.000025 nnoremap <silent> <Plug>(go-callers) :<C-u>call go#guru#Callers(-1)<CR>
    2              0.000026 nnoremap <silent> <Plug>(go-describe) :<C-u>call go#guru#Describe(-1)<CR>
    2              0.000027 nnoremap <silent> <Plug>(go-callstack) :<C-u>call go#guru#Callstack(-1)<CR>
    2              0.000030 xnoremap <silent> <Plug>(go-freevars) :<C-u>call go#guru#Freevars(0)<CR>
    2              0.000029 nnoremap <silent> <Plug>(go-channelpeers) :<C-u>call go#guru#ChannelPeers(-1)<CR>
    2              0.000039 nnoremap <silent> <Plug>(go-referrers) :<C-u>call go#guru#Referrers(-1)<CR>
    2              0.000037 nnoremap <silent> <Plug>(go-sameids) :<C-u>call go#guru#SameIds(1)<CR>
    2              0.000039 nnoremap <silent> <Plug>(go-pointsto) :<C-u>call go#guru#PointsTo(-1)<CR>
    2              0.000039 nnoremap <silent> <Plug>(go-whicherrs) :<C-u>call go#guru#Whicherrs(-1)<CR>
    2              0.000043 nnoremap <silent> <Plug>(go-sameids-toggle) :<C-u>call go#guru#ToggleSameIds()<CR>
                            
    2              0.000039 nnoremap <silent> <Plug>(go-rename) :<C-u>call go#rename#Rename(!g:go_jump_to_error)<CR>
                            
    2              0.000039 nnoremap <silent> <Plug>(go-decls) :<C-u>call go#decls#Decls(0, '')<CR>
    2              0.000037 nnoremap <silent> <Plug>(go-decls-dir) :<C-u>call go#decls#Decls(1, '')<CR>
                            
    2              0.000033 nnoremap <silent> <Plug>(go-def) :<C-u>call go#def#Jump('', 0)<CR>
    2              0.000029 nnoremap <silent> <Plug>(go-def-vertical) :<C-u>call go#def#Jump("vsplit", 0)<CR>
    2              0.000026 nnoremap <silent> <Plug>(go-def-split) :<C-u>call go#def#Jump("split", 0)<CR>
    2              0.000025 nnoremap <silent> <Plug>(go-def-tab) :<C-u>call go#def#Jump("tab", 0)<CR>
                            
    2              0.000025 nnoremap <silent> <Plug>(go-def-type) :<C-u>call go#def#Jump('', 1)<CR>
    2              0.000030 nnoremap <silent> <Plug>(go-def-type-vertical) :<C-u>call go#def#Jump("vsplit", 1)<CR>
    2              0.000035 nnoremap <silent> <Plug>(go-def-type-split) :<C-u>call go#def#Jump("split", 1)<CR>
    2              0.000032 nnoremap <silent> <Plug>(go-def-type-tab) :<C-u>call go#def#Jump("tab", 1)<CR>
                            
    2              0.000034 nnoremap <silent> <Plug>(go-def-pop) :<C-u>call go#def#StackPop()<CR>
    2              0.000026 nnoremap <silent> <Plug>(go-def-stack) :<C-u>call go#def#Stack()<CR>
    2              0.000029 nnoremap <silent> <Plug>(go-def-stack-clear) :<C-u>call go#def#StackClear()<CR>
                            
    2              0.000028 nnoremap <silent> <Plug>(go-doc) :<C-u>call go#doc#Open("new", "split")<CR>
    2              0.000029 nnoremap <silent> <Plug>(go-doc-tab) :<C-u>call go#doc#Open("tabnew", "tabe")<CR>
    2              0.000029 nnoremap <silent> <Plug>(go-doc-vertical) :<C-u>call go#doc#Open("vnew", "vsplit")<CR>
    2              0.000035 nnoremap <silent> <Plug>(go-doc-split) :<C-u>call go#doc#Open("new", "split")<CR>
    2              0.000027 nnoremap <silent> <Plug>(go-doc-browser) :<C-u>call go#doc#OpenBrowser()<CR>
                            
    2              0.000035 nnoremap <silent> <Plug>(go-metalinter) :<C-u>call go#lint#Gometa(!g:go_jump_to_error, 0)<CR>
    2              0.000043 nnoremap <silent> <Plug>(go-lint) :<C-u>call go#lint#Golint(!g:go_jump_to_error)<CR>
    2              0.000039 nnoremap <silent> <Plug>(go-vet) :<C-u>call go#lint#Vet(!g:go_jump_to_error)<CR>
                            
    2              0.000031 nnoremap <silent> <Plug>(go-alternate-edit) :<C-u>call go#alternate#Switch(0, "edit")<CR>
    2              0.000031 nnoremap <silent> <Plug>(go-alternate-vertical) :<C-u>call go#alternate#Switch(0, "vsplit")<CR>
    2              0.000037 nnoremap <silent> <Plug>(go-alternate-split) :<C-u>call go#alternate#Switch(0, "split")<CR>
                            
    2              0.000036 nnoremap <silent> <Plug>(go-iferr) :<C-u>call go#iferr#Generate()<CR>
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/ftplugin/go/snippets.vim
Sourced 2 times
Total time:   0.000326
 Self time:   0.000308

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    2              0.000026 let s:cpo_save = &cpo
    2              0.000020 set cpo&vim
                            
    2              0.000071 if exists("g:go_loaded_gosnippets")
    1              0.000002   finish
    1              0.000001 endif
    1              0.000014 let g:go_loaded_gosnippets = 1
                            
    1              0.000005 function! s:GoUltiSnips() abort
                              if get(g:, 'did_plugin_ultisnips') isnot 1
                                return
                              endif
                            
                              if !exists("g:UltiSnipsSnippetDirectories")
                                let g:UltiSnipsSnippetDirectories = ["gosnippets/UltiSnips"]
                              else
                                let g:UltiSnipsSnippetDirectories += ["gosnippets/UltiSnips"]
                              endif
                            endfunction
                            
    1              0.000004 function! s:GoNeosnippet() abort
                              if get(g:, 'loaded_neosnippet') isnot 1
                                return
                              endif
                            
                              let g:neosnippet#enable_snipmate_compatibility = 1
                            
                              let l:gosnippets_dir = globpath(&rtp, 'gosnippets/snippets')
                              if type(g:neosnippet#snippets_directory) == type([])
                                let g:neosnippet#snippets_directory += [l:gosnippets_dir]
                              elseif type(g:neosnippet#snippets_directory) == type("")
                                if strlen(g:neosnippet#snippets_directory) > 0
                                  let g:neosnippet#snippets_directory = g:neosnippet#snippets_directory . "," . l:gosnippets_dir
                                else
                                  let g:neosnippet#snippets_directory = l:gosnippets_dir
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! s:GoMinisnip() abort
                              if get(g:, 'loaded_minisnip') isnot 1
                                return
                              endif
                            
                              if exists('g:minisnip_dir')
                                let g:minisnip_dir .= go#util#PathListSep() . globpath(&rtp, 'gosnippets/minisnip')
                              else
                                let g:minisnip_dir = globpath(&rtp, 'gosnippets/minisnip')
                              endif
                            endfunction
                            
                            
    1   0.000026   0.000008 let s:engine = go#config#SnippetEngine()
    1              0.000003 if s:engine is? "automatic"
    1              0.000004   if get(g:, 'did_plugin_ultisnips') is 1
                                call s:GoUltiSnips()
    1              0.000004   elseif get(g:, 'loaded_neosnippet') is 1
                                call s:GoNeosnippet()
    1              0.000003   elseif get(g:, 'loaded_minisnip') is 1
                                call s:GoMinisnip()
    1              0.000001   endif
                            elseif s:engine is? "ultisnips"
                              call s:GoUltiSnips()
                            elseif s:engine is? "neosnippet"
                              call s:GoNeosnippet()
                            elseif s:engine is? "minisnip"
                              call s:GoMinisnip()
    1              0.000001 endif
                            
                            " restore Vi compatibility settings
    1              0.000009 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/ftplugin/go/tagbar.vim
Sourced 2 times
Total time:   0.000806
 Self time:   0.000806

count  total (s)   self (s)
                            " Check if tagbar is installed under plugins or is directly under rtp
                            " this covers pathogen + Vundle/Bundle
                            "
                            " Also make sure the ctags command exists
                            "
    2              0.000137 if !executable('ctags')
                              finish
    2              0.000624 elseif globpath(&rtp, 'plugin/tagbar.vim') == ""
    2              0.000008   finish
                            endif
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            if !exists("g:go_gotags_bin")
                              let g:go_gotags_bin = "gotags"
                            endif
                            
                            
                            function! s:SetTagbar()
                              let bin_path = go#path#CheckBinPath(g:go_gotags_bin)
                              if empty(bin_path)
                                return
                              endif
                            
                              if !exists("g:tagbar_type_go")
                                let g:tagbar_type_go = {
                                      \ 'ctagstype' : 'go',
                                      \ 'kinds'     : [
                                      \ 'p:package',
                                      \ 'i:imports',
                                      \ 'c:constants',
                                      \ 'v:variables',
                                      \ 't:types',
                                      \ 'n:interfaces',
                                      \ 'w:fields',
                                      \ 'e:embedded',
                                      \ 'm:methods',
                                      \ 'r:constructor',
                                      \ 'f:functions'
                                      \ ],
                                      \ 'sro' : '.',
                                      \ 'kind2scope' : {
                                      \ 't' : 'ctype',
                                      \ 'n' : 'ntype'
                                      \ },
                                      \ 'scope2kind' : {
                                      \ 'ctype' : 't',
                                      \ 'ntype' : 'n'
                                      \ },
                                      \ 'ctagsbin'  : bin_path,
                                      \ 'ctagsargs' : '-sort -silent'
                                      \ }
                              endif
                            endfunction
                            
                            
                            call s:SetTagbar()
                            
                            " restore Vi compatibility settings
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/local/share/vim/vim81/ftplugin/go.vim
Sourced 2 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	Go
                            " Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
                            " Last Change:	2014 Aug 16
                            
    2              0.000019 if exists('b:did_ftplugin')
    2              0.000005   finish
                            endif
                            let b:did_ftplugin = 1
                            
                            setlocal formatoptions-=t
                            
                            setlocal comments=s1:/*,mb:*,ex:*/,://
                            setlocal commentstring=//\ %s
                            
                            let b:undo_ftplugin = 'setl fo< com< cms<'
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/indent/go.vim
Sourced 2 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
                            " Copyright 2011 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " indent/go.vim: Vim indent file for Go.
                            "
                            " TODO:
                            " - function invocations split across lines
                            " - general line splits (line ends in an operator)
                            
    2              0.000014 if exists("b:did_indent")
                              finish
    2              0.000002 endif
    2              0.000007 let b:did_indent = 1
                            
                            " C indentation is too far off useful, mainly due to Go's := operator.
                            " Let's just define our own.
    2              0.000029 setlocal nolisp
    2              0.000009 setlocal autoindent
    2              0.000008 setlocal indentexpr=GoIndent(v:lnum)
    2              0.000008 setlocal indentkeys+=<:>,0=},0=)
                            
    2              0.000008 if exists("*GoIndent")
    1              0.000002   finish
    1              0.000001 endif
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000016 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000003 function! GoIndent(lnum) abort
                              let prevlnum = prevnonblank(a:lnum-1)
                              if prevlnum == 0
                                " top of file
                                return 0
                              endif
                            
                              " grab the previous and current line, stripping comments.
                              let prevl = substitute(getline(prevlnum), '//.*$', '', '')
                              let thisl = substitute(getline(a:lnum), '//.*$', '', '')
                              let previ = indent(prevlnum)
                            
                              let ind = previ
                            
                              for synid in synstack(a:lnum, 1)
                                if synIDattr(synid, 'name') == 'goRawString'
                                  if prevl =~ '\%(\%(:\?=\)\|(\|,\)\s*`[^`]*$'
                                    " previous line started a multi-line raw string
                                    return 0
                                  endif
                                  " return -1 to keep the current indent.
                                  return -1
                                endif
                              endfor
                            
                              if prevl =~ '[({]\s*$'
                                " previous line opened a block
                                let ind += shiftwidth()
                              endif
                              if prevl =~# '^\s*\(case .*\|default\):$'
                                " previous line is part of a switch statement
                                let ind += shiftwidth()
                              endif
                              " TODO: handle if the previous line is a label.
                            
                              if thisl =~ '^\s*[)}]'
                                " this line closed a block
                                let ind -= shiftwidth()
                              endif
                            
                              " Colons are tricky.
                              " We want to outdent if it's part of a switch ("case foo:" or "default:").
                              " We ignore trying to deal with jump labels because (a) they're rare, and
                              " (b) they're hard to disambiguate from a composite literal key.
                              if thisl =~# '^\s*\(case .*\|default\):$'
                                let ind -= shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000008 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/local/share/vim/vim81/indent/go.vim
Sourced 2 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Go
                            " Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
                            " Last Change:	2017 Jun 13
                            "
                            " TODO:
                            " - function invocations split across lines
                            " - general line splits (line ends in an operator)
                            
    2              0.000014 if exists('b:did_indent')
    2              0.000004   finish
                            endif
                            let b:did_indent = 1
                            
                            " C indentation is too far off useful, mainly due to Go's := operator.
                            " Let's just define our own.
                            setlocal nolisp
                            setlocal autoindent
                            setlocal indentexpr=GoIndent(v:lnum)
                            setlocal indentkeys+=<:>,0=},0=)
                            
                            if exists('*GoIndent')
                              finish
                            endif
                            
                            function! GoIndent(lnum)
                              let l:prevlnum = prevnonblank(a:lnum-1)
                              if l:prevlnum == 0
                                " top of file
                                return 0
                              endif
                            
                              " grab the previous and current line, stripping comments.
                              let l:prevl = substitute(getline(l:prevlnum), '//.*$', '', '')
                              let l:thisl = substitute(getline(a:lnum), '//.*$', '', '')
                              let l:previ = indent(l:prevlnum)
                            
                              let l:ind = l:previ
                            
                              if l:prevl =~ '[({]\s*$'
                                " previous line opened a block
                                let l:ind += shiftwidth()
                              endif
                              if l:prevl =~# '^\s*\(case .*\|default\):$'
                                " previous line is part of a switch statement
                                let l:ind += shiftwidth()
                              endif
                              " TODO: handle if the previous line is a label.
                            
                              if l:thisl =~ '^\s*[)}]'
                                " this line closed a block
                                let l:ind -= shiftwidth()
                              endif
                            
                              " Colons are tricky.
                              " We want to outdent if it's part of a switch ("case foo:" or "default:").
                              " We ignore trying to deal with jump labels because (a) they're rare, and
                              " (b) they're hard to disambiguate from a composite literal key.
                              if l:thisl =~# '^\s*\(case .*\|default\):$'
                                let l:ind -= shiftwidth()
                              endif
                            
                              return l:ind
                            endfunction
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/syntax/go.vim
Sourced 3 times
Total time:   0.005903
 Self time:   0.005000

count  total (s)   self (s)
                            " Copyright 2009 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " go.vim: Vim syntax file for Go.
                            
                            " Quit when a (custom) syntax file was already loaded
    3              0.000025 if exists("b:current_syntax")
                              finish
    3              0.000003 endif
                            
    3              0.000008 syn case match
                            
    3              0.000033 syn keyword     goPackage           package
    3              0.000012 syn keyword     goImport            import    contained
    3              0.000016 syn keyword     goVar               var       contained
    3              0.000010 syn keyword     goConst             const     contained
                            
    3              0.000016 hi def link     goPackage           Statement
    3              0.000010 hi def link     goImport            Statement
    3              0.000009 hi def link     goVar               Keyword
    3              0.000008 hi def link     goConst             Keyword
    3              0.000008 hi def link     goDeclaration       Keyword
                            
                            " Keywords within functions
    3              0.000013 syn keyword     goStatement         defer go goto return break continue fallthrough
    3              0.000012 syn keyword     goConditional       if else switch select
    3              0.000010 syn keyword     goLabel             case default
    3              0.000007 syn keyword     goRepeat            for range
                            
    3              0.000009 hi def link     goStatement         Statement
    3              0.000011 hi def link     goConditional       Conditional
    3              0.000007 hi def link     goLabel             Label
    3              0.000009 hi def link     goRepeat            Repeat
                            
                            " Predefined types
    3              0.000011 syn keyword     goType              chan map bool string error
    3              0.000012 syn keyword     goSignedInts        int int8 int16 int32 int64 rune
    3              0.000011 syn keyword     goUnsignedInts      byte uint uint8 uint16 uint32 uint64 uintptr
    3              0.000008 syn keyword     goFloats            float32 float64
    3              0.000015 syn keyword     goComplexes         complex64 complex128
                            
    3              0.000009 hi def link     goType              Type
    3              0.000008 hi def link     goSignedInts        Type
    3              0.000008 hi def link     goUnsignedInts      Type
    3              0.000009 hi def link     goFloats            Type
    3              0.000008 hi def link     goComplexes         Type
                            
                            " Predefined functions and values
    3              0.000036 syn keyword     goBuiltins                 append cap close complex copy delete imag len
    3              0.000018 syn keyword     goBuiltins                 make new panic print println real recover
    3              0.000009 syn keyword     goBoolean                  true false
    3              0.000007 syn keyword     goPredefinedIdentifiers    nil iota
                            
    3              0.000009 hi def link     goBuiltins                 Identifier
    3              0.000008 hi def link     goBoolean                  Boolean
    3              0.000008 hi def link     goPredefinedIdentifiers    goBoolean
                            
                            " Comments; their contents
    3              0.000011 syn keyword     goTodo              contained TODO FIXME XXX BUG
    3              0.000016 syn cluster     goCommentGroup      contains=goTodo
                            
    3              0.000048 syn region      goComment           start="//" end="$" contains=goGenerate,@goCommentGroup,@Spell
    3   0.000130   0.000036 if go#config#FoldEnable('comment')
                              syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell fold
                              syn match     goComment           "\v(^\s*//.*\n)+" contains=goGenerate,@goCommentGroup,@Spell fold
    3              0.000007 else
    3              0.000029   syn region    goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell
    3              0.000004 endif
                            
    3              0.000012 hi def link     goComment           Comment
    3              0.000008 hi def link     goTodo              Todo
                            
    3   0.000038   0.000018 if go#config#HighlightGenerateTags()
                              syn match       goGenerateVariables contained /\%(\$GOARCH\|\$GOOS\|\$GOFILE\|\$GOLINE\|\$GOPACKAGE\|\$DOLLAR\)\>/
                              syn region      goGenerate          start="^\s*//go:generate" end="$" contains=goGenerateVariables
                              hi def link     goGenerate          PreProc
                              hi def link     goGenerateVariables Special
    3              0.000003 endif
                            
                            " Go escapes
    3              0.000024 syn match       goEscapeOctal       display contained "\\[0-7]\{3}"
    3              0.000021 syn match       goEscapeC           display contained +\\[abfnrtv\\'"]+
    3              0.000016 syn match       goEscapeX           display contained "\\x\x\{2}"
    3              0.000017 syn match       goEscapeU           display contained "\\u\x\{4}"
    3              0.000017 syn match       goEscapeBigU        display contained "\\U\x\{8}"
    3              0.000020 syn match       goEscapeError       display contained +\\[^0-7xuUabfnrtv\\'"]+
                            
    3              0.000011 hi def link     goEscapeOctal       goSpecialString
    3              0.000007 hi def link     goEscapeC           goSpecialString
    3              0.000007 hi def link     goEscapeX           goSpecialString
    3              0.000006 hi def link     goEscapeU           goSpecialString
    3              0.000011 hi def link     goEscapeBigU        goSpecialString
    3              0.000009 hi def link     goSpecialString     Special
    3              0.000007 hi def link     goEscapeError       Error
                            
                            " Strings and their contents
    3              0.000033 syn cluster     goStringGroup       contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU,goEscapeError
    3   0.000040   0.000022 if go#config#HighlightStringSpellcheck()
    3              0.000046   syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup,@Spell
    3              0.000027   syn region      goRawString         start=+`+ end=+`+ contains=@Spell
                            else
                              syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup
                              syn region      goRawString         start=+`+ end=+`+
    3              0.000005 endif
                            
    3   0.000036   0.000022 if go#config#HighlightFormatStrings()
                              " [n] notation is valid for specifying explicit argument indexes
                              " 1. Match a literal % not preceded by a %.
                              " 2. Match any number of -, #, 0, space, or +
                              " 3. Match * or [n]* or any number or nothing before a .
                              " 4. Match * or [n]* or any number or nothing after a .
                              " 5. Match [n] or nothing before a verb
                              " 6. Match a formatting verb
    3              0.000090   syn match       goFormatSpecifier   /\
                                    \%([^%]\%(%%\)*\)\
                                    \@<=%[-#0 +]*\
                                    \%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\
                                    \%(\.\%(\%(\%(\[\d\+\]\)\=\*\)\|\d\+\)\=\)\=\
                                    \%(\[\d\+\]\)\=[vTtbcdoqxXUeEfFgGspw]/ contained containedin=goString,goRawString
    3              0.000012   hi def link     goFormatSpecifier   goSpecialString
    3              0.000003 endif
                            
    3              0.000009 hi def link     goString            String
    3              0.000009 hi def link     goRawString         String
                            
                            " Characters; their contents
    3              0.000026 syn cluster     goCharacterGroup    contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU
    3              0.000035 syn region      goCharacter         start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=@goCharacterGroup
                            
    3              0.000010 hi def link     goCharacter         Character
                            
                            " Regions
    3              0.000028 syn region      goParen             start='(' end=')' transparent
    3   0.000093   0.000024 if go#config#FoldEnable('block')
    3              0.000028   syn region    goBlock             start="{" end="}" transparent fold
                            else
                              syn region    goBlock             start="{" end="}" transparent
    3              0.000006 endif
                            
                            " import
    3   0.000078   0.000018 if go#config#FoldEnable('import')
    3              0.000042   syn region    goImport            start='import (' end=')' transparent fold contains=goImport,goString,goComment
                            else
                              syn region    goImport            start='import (' end=')' transparent contains=goImport,goString,goComment
    3              0.000003 endif
                            
                            " var, const
    3   0.000092   0.000019 if go#config#FoldEnable('varconst')
    3              0.000075   syn region    goVar               start='var ('   end='^\s*)$' transparent fold
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
    3              0.000064   syn region    goConst             start='const (' end='^\s*)$' transparent fold
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                            else
                              syn region    goVar               start='var ('   end='^\s*)$' transparent
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
                              syn region    goConst             start='const (' end='^\s*)$' transparent
                                                    \ contains=ALLBUT,goParen,goBlock,goFunction,goTypeName,goReceiverType,goReceiverVar,goParamName,goParamType,goSimpleParams,goPointerOperator
    3              0.000004 endif
                            
                            " Single-line var, const, and import.
    3              0.000045 syn match       goSingleDecl        /\%(import\|var\|const\) [^(]\@=/ contains=goImport,goVar,goConst
                            
                            " Integers
    3              0.000023 syn match       goDecimalInt        "\<-\=\d\+\%([Ee][-+]\=\d\+\)\=\>"
    3              0.000021 syn match       goHexadecimalInt    "\<-\=0[xX]\x\+\>"
    3              0.000016 syn match       goOctalInt          "\<-\=0\o\+\>"
    3              0.000016 syn match       goOctalError        "\<-\=0\o*[89]\d*\>"
                            
    3              0.000011 hi def link     goDecimalInt        Integer
    3              0.000007 hi def link     goHexadecimalInt    Integer
    3              0.000006 hi def link     goOctalInt          Integer
    3              0.000010 hi def link     goOctalError        Error
    3              0.000006 hi def link     Integer             Number
                            
                            " Floating point
    3              0.000029 syn match       goFloat             "\<-\=\d\+\.\d*\%([Ee][-+]\=\d\+\)\=\>"
    3              0.000019 syn match       goFloat             "\<-\=\.\d\+\%([Ee][-+]\=\d\+\)\=\>"
                            
    3              0.000008 hi def link     goFloat             Float
                            
                            " Imaginary literals
    3              0.000015 syn match       goImaginary         "\<-\=\d\+i\>"
    3              0.000043 syn match       goImaginary         "\<-\=\d\+[Ee][-+]\=\d\+i\>"
    3              0.000022 syn match       goImaginaryFloat    "\<-\=\d\+\.\d*\%([Ee][-+]\=\d\+\)\=i\>"
    3              0.000025 syn match       goImaginaryFloat    "\<-\=\.\d\+\%([Ee][-+]\=\d\+\)\=i\>"
                            
    3              0.000010 hi def link     goImaginary         Number
    3              0.000007 hi def link     goImaginaryFloat    Float
                            
                            " Spaces after "[]"
    3   0.000039   0.000021 if go#config#HighlightArrayWhitespaceError()
                              syn match goSpaceError display "\%(\[\]\)\@<=\s\+"
    3              0.000006 endif
                            
                            " Spacing errors around the 'chan' keyword
    3   0.000032   0.000015 if go#config#HighlightChanWhitespaceError()
                              " receive-only annotation on chan type
                              "
                              " \(\<chan\>\)\@<!<-  (only pick arrow when it doesn't come after a chan)
                              " this prevents picking up 'chan<- chan<-' but not '<- chan'
                              syn match goSpaceError display "\%(\%(\<chan\>\)\@<!<-\)\@<=\s\+\%(\<chan\>\)\@="
                            
                              " send-only annotation on chan type
                              "
                              " \(<-\)\@<!\<chan\>  (only pick chan when it doesn't come after an arrow)
                              " this prevents picking up '<-chan <-chan' but not 'chan <-'
                              syn match goSpaceError display "\%(\%(<-\)\@<!\<chan\>\)\@<=\s\+\%(<-\)\@="
                            
                              " value-ignoring receives in a few contexts
                              syn match goSpaceError display "\%(\%(^\|[={(,;]\)\s*<-\)\@<=\s\+"
    3              0.000007 endif
                            
                            " Extra types commonly seen
    3   0.000048   0.000027 if go#config#HighlightExtraTypes()
                              syn match goExtraType /\<bytes\.\%(Buffer\)\>/
                              syn match goExtraType /\<context\.\%(Context\)\>/
                              syn match goExtraType /\<io\.\%(Reader\|ReadSeeker\|ReadWriter\|ReadCloser\|ReadWriteCloser\|Writer\|WriteCloser\|Seeker\)\>/
                              syn match goExtraType /\<reflect\.\%(Kind\|Type\|Value\)\>/
                              syn match goExtraType /\<unsafe\.Pointer\>/
    3              0.000003 endif
                            
                            " Space-tab error
    3   0.000032   0.000019 if go#config#HighlightSpaceTabError()
                              syn match goSpaceError display " \+\t"me=e-1
    3              0.000005 endif
                            
                            " Trailing white space error
    3   0.000029   0.000015 if go#config#HighlightTrailingWhitespaceError()
                              syn match goSpaceError display excludenl "\s\+$"
    3              0.000004 endif
                            
    3              0.000015 hi def link     goExtraType         Type
    3              0.000029 hi def link     goSpaceError        Error
                            
                            
                            
                            " included from: https://github.com/athom/more-colorful.vim/blob/master/after/syntax/go.vim
                            "
                            " Comments; their contents
    3              0.000011 syn keyword     goTodo              contained NOTE
    3              0.000009 hi def link     goTodo              Todo
                            
    3              0.000016 syn match goVarArgs /\.\.\./
                            
                            " Operators;
    3   0.000031   0.000017 if go#config#HighlightOperators()
                              " match single-char operators:          - + % < > ! & | ^ * =
                              " and corresponding two-char operators: -= += %= <= >= != &= |= ^= *= ==
                              syn match goOperator /[-+%<>!&|^*=]=\?/
                              " match / and /=
                              syn match goOperator /\/\%(=\|\ze[^/*]\)/
                              " match two-char operators:               << >> &^
                              " and corresponding three-char operators: <<= >>= &^=
                              syn match goOperator /\%(<<\|>>\|&^\)=\?/
                              " match remaining two-char operators: := && || <- ++ --
                              syn match goOperator /:=\|||\|<-\|++\|--/
                              " match ...
                            
                              hi def link     goPointerOperator   goOperator
                              hi def link     goVarArgs           goOperator
    3              0.000003 endif
    3              0.000010 hi def link     goOperator          Operator
                            
                            " Functions;
    3   0.000057   0.000023 if go#config#HighlightFunctions() || go#config#HighlightFunctionParameters()
                              syn match goDeclaration       /\<func\>/ nextgroup=goReceiver,goFunction,goSimpleParams skipwhite skipnl
                              syn match goReceiverVar       /\w\+\ze\s\+\%(\w\|\*\)/ nextgroup=goPointerOperator,goReceiverType skipwhite skipnl contained
                              syn match goPointerOperator   /\*/ nextgroup=goReceiverType contained skipwhite skipnl
                              syn match goFunction          /\w\+/ nextgroup=goSimpleParams contained skipwhite skipnl
                              syn match goReceiverType      /\w\+/ contained
                              if go#config#HighlightFunctionParameters()
                                syn match goSimpleParams      /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType nextgroup=goFunctionReturn skipwhite skipnl
                                syn match goFunctionReturn   /(\%(\w\|\_s\|[*\.\[\],\{\}<>-]\)*)/ contained contains=goParamName,goType skipwhite skipnl
                                syn match goParamName        /\w\+\%(\s*,\s*\w\+\)*\ze\s\+\%(\w\|\.\|\*\|\[\)/ contained nextgroup=goParamType skipwhite skipnl
                                syn match goParamType        /\%([^,)]\|\_s\)\+,\?/ contained nextgroup=goParamName skipwhite skipnl
                                                      \ contains=goVarArgs,goType,goSignedInts,goUnsignedInts,goFloats,goComplexes,goDeclType,goBlock
                                hi def link   goReceiverVar    goParamName
                                hi def link   goParamName      Identifier
                              endif
                              syn match goReceiver          /(\s*\w\+\%(\s\+\*\?\s*\w\+\)\?\s*)\ze\s*\w/ contained nextgroup=goFunction contains=goReceiverVar skipwhite skipnl
    3              0.000007 else
    3              0.000010   syn keyword goDeclaration func
    3              0.000003 endif
    3              0.000010 hi def link     goFunction          Function
                            
                            " Function calls;
    3   0.000033   0.000019 if go#config#HighlightFunctionCalls()
                              syn match goFunctionCall      /\w\+\ze(/ contains=goBuiltins,goDeclaration
    3              0.000005 endif
    3              0.000011 hi def link     goFunctionCall      Type
                            
                            " Fields;
    3   0.000027   0.000014 if go#config#HighlightFields()
                              " 1. Match a sequence of word characters coming after a '.'
                              " 2. Require the following but dont match it: ( \@= see :h E59)
                              "    - The symbols: / - + * %   OR
                              "    - The symbols: [] {} <> )  OR
                              "    - The symbols: \n \r space OR
                              "    - The symbols: , : .
                              " 3. Have the start of highlight (hs) be the start of matched
                              "    pattern (s) offsetted one to the right (+1) (see :h E401)
                              syn match       goField   /\.\w\+\
                                    \%(\%([\/\-\+*%]\)\|\
                                    \%([\[\]{}<\>\)]\)\|\
                                    \%([\!=\^|&]\)\|\
                                    \%([\n\r\ ]\)\|\
                                    \%([,\:.]\)\)\@=/hs=s+1
    3              0.000003 endif
    3              0.000013 hi def link    goField              Identifier
                            
                            " Structs & Interfaces;
    3   0.000029   0.000016 if go#config#HighlightTypes()
                              syn match goTypeConstructor      /\<\w\+{\@=/
                              syn match goTypeDecl             /\<type\>/ nextgroup=goTypeName skipwhite skipnl
                              syn match goTypeName             /\w\+/ contained nextgroup=goDeclType skipwhite skipnl
                              syn match goDeclType             /\<\%(interface\|struct\)\>/ skipwhite skipnl
                              hi def link     goReceiverType      Type
    3              0.000013 else
    3              0.000010   syn keyword goDeclType           struct interface
    3              0.000008   syn keyword goDeclaration        type
    3              0.000003 endif
    3              0.000012 hi def link     goTypeConstructor   Type
    3              0.000007 hi def link     goTypeName          Type
    3              0.000010 hi def link     goTypeDecl          Keyword
    3              0.000007 hi def link     goDeclType          Keyword
                            
                            " Variable Assignments
    3   0.000034   0.000020 if go#config#HighlightVariableAssignments()
                              syn match goVarAssign /\v[_.[:alnum:]]+(,\s*[_.[:alnum:]]+)*\ze(\s*([-^+|^\/%&]|\*|\<\<|\>\>|\&\^)?\=[^=])/
                              hi def link   goVarAssign         Special
    3              0.000003 endif
                            
                            " Variable Declarations
    3   0.000027   0.000015 if go#config#HighlightVariableDeclarations()
                              syn match goVarDefs /\v\w+(,\s*\w+)*\ze(\s*:\=)/
                              hi def link   goVarDefs           Special
    3              0.000003 endif
                            
                            " Build Constraints
    3   0.000027   0.000015 if go#config#HighlightBuildConstraints()
                              syn match   goBuildKeyword      display contained "+build"
                              " Highlight the known values of GOOS, GOARCH, and other +build options.
                              syn keyword goBuildDirectives   contained
                                    \ android darwin dragonfly freebsd linux nacl netbsd openbsd plan9
                                    \ solaris windows 386 amd64 amd64p32 arm armbe arm64 arm64be ppc64
                                    \ ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc
                                    \ s390 s390x sparc sparc64 cgo ignore race
                            
                              " Other words in the build directive are build tags not listed above, so
                              " avoid highlighting them as comments by using a matchgroup just for the
                              " start of the comment.
                              " The rs=s+2 option lets the \s*+build portion be part of the inner region
                              " instead of the matchgroup so it will be highlighted as a goBuildKeyword.
                              syn region  goBuildComment      matchgroup=goBuildCommentStart
                                    \ start="//\s*+build\s"rs=s+2 end="$"
                                    \ contains=goBuildKeyword,goBuildDirectives
                              hi def link goBuildCommentStart Comment
                              hi def link goBuildDirectives   Type
                              hi def link goBuildKeyword      PreProc
    3              0.000003 endif
                            
    3   0.000111   0.000033 if go#config#HighlightBuildConstraints() || go#config#FoldEnable('package_comment')
                              " One or more line comments that are followed immediately by a "package"
                              " declaration are treated like package documentation, so these must be
                              " matched as comments to avoid looking like working build constraints.
                              " The he, me, and re options let the "package" itself be highlighted by
                              " the usual rules.
    3   0.000156   0.000098   exe 'syn region  goPackageComment    start=/\v(\/\/.*\n)+\s*package/'
                                    \ . ' end=/\v\n\s*package/he=e-7,me=e-7,re=e-7'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (go#config#FoldEnable('package_comment') ? ' fold' : '')
    3   0.000194   0.000129   exe 'syn region  goPackageComment    start=/\v^\s*\/\*.*\n(.*\n)*\s*\*\/\npackage/'
                                    \ . ' end=/\v\*\/\n\s*package/he=e-7,me=e-7,re=e-7'
                                    \ . ' contains=@goCommentGroup,@Spell'
                                    \ . (go#config#FoldEnable('package_comment') ? ' fold' : '')
    3              0.000015   hi def link goPackageComment    Comment
    3              0.000003 endif
                            
                            " :GoCoverage commands
    3              0.000020 hi def link goCoverageNormalText Comment
                            
    3              0.000013 function! s:hi()
                              hi def link goSameId Search
                            
                              " :GoCoverage commands
                              hi def      goCoverageCovered    ctermfg=green guifg=#A6E22E
                              hi def      goCoverageUncover    ctermfg=red guifg=#F92672
                            
                              " :GoDebug commands
                              if go#config#HighlightDebug()
                                hi GoDebugBreakpoint term=standout ctermbg=117 ctermfg=0 guibg=#BAD4F5  guifg=Black
                                hi GoDebugCurrent term=reverse  ctermbg=12  ctermfg=7 guibg=DarkBlue guifg=White
                              endif
                            endfunction
                            
    3              0.000013 augroup vim-go-hi
    3              0.000277   autocmd!
    3              0.000048   autocmd ColorScheme * call s:hi()
    3              0.000006 augroup end
    3   0.000171   0.000026 call s:hi()
                            
                            " Search backwards for a global declaration to start processing the syntax.
                            "syn sync match goSync grouphere NONE /^\(const\|var\|type\|func\)\>/
                            
                            " There's a bug in the implementation of grouphere. For now, use the
                            " following as a more expensive/less precise workaround.
    3              0.000008 syn sync minlines=500
                            
    3              0.000012 let b:current_syntax = "go"
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/local/share/vim/vim81/syntax/go.vim
Sourced 3 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Go
                            " Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
                            " Last Change:	2014 Aug 16
                            
                            " Options:
                            "   There are some options for customizing the highlighting; the recommended
                            "   settings are the default values, but you can write:
                            "     let OPTION_NAME = 0
                            "   in your ~/.vimrc file to disable particular options. You can also write:
                            "     let OPTION_NAME = 1
                            "   to enable particular options. At present, all options default to on.
                            "
                            "   - g:go_highlight_array_whitespace_error
                            "     Highlights white space after "[]".
                            "   - g:go_highlight_chan_whitespace_error
                            "     Highlights white space around the communications operator that don't
                            "     follow the standard style.
                            "   - g:go_highlight_extra_types
                            "     Highlights commonly used library types (io.Reader, etc.).
                            "   - g:go_highlight_space_tab_error
                            "     Highlights instances of tabs following spaces.
                            "   - g:go_highlight_trailing_whitespace_error
                            "     Highlights trailing white space.
                            
                            " Quit when a (custom) syntax file was already loaded
    3              0.000026 if exists('b:current_syntax')
    3              0.000006   finish
                            endif
                            
                            if !exists('g:go_highlight_array_whitespace_error')
                              let g:go_highlight_array_whitespace_error = 1
                            endif
                            if !exists('g:go_highlight_chan_whitespace_error')
                              let g:go_highlight_chan_whitespace_error = 1
                            endif
                            if !exists('g:go_highlight_extra_types')
                              let g:go_highlight_extra_types = 1
                            endif
                            if !exists('g:go_highlight_space_tab_error')
                              let g:go_highlight_space_tab_error = 1
                            endif
                            if !exists('g:go_highlight_trailing_whitespace_error')
                              let g:go_highlight_trailing_whitespace_error = 1
                            endif
                            
                            syn case match
                            
                            syn keyword     goDirective         package import
                            syn keyword     goDeclaration       var const type
                            syn keyword     goDeclType          struct interface
                            
                            hi def link     goDirective         Statement
                            hi def link     goDeclaration       Keyword
                            hi def link     goDeclType          Keyword
                            
                            " Keywords within functions
                            syn keyword     goStatement         defer go goto return break continue fallthrough
                            syn keyword     goConditional       if else switch select
                            syn keyword     goLabel             case default
                            syn keyword     goRepeat            for range
                            
                            hi def link     goStatement         Statement
                            hi def link     goConditional       Conditional
                            hi def link     goLabel             Label
                            hi def link     goRepeat            Repeat
                            
                            " Predefined types
                            syn keyword     goType              chan map bool string error
                            syn keyword     goSignedInts        int int8 int16 int32 int64 rune
                            syn keyword     goUnsignedInts      byte uint uint8 uint16 uint32 uint64 uintptr
                            syn keyword     goFloats            float32 float64
                            syn keyword     goComplexes         complex64 complex128
                            
                            hi def link     goType              Type
                            hi def link     goSignedInts        Type
                            hi def link     goUnsignedInts      Type
                            hi def link     goFloats            Type
                            hi def link     goComplexes         Type
                            
                            " Treat func specially: it's a declaration at the start of a line, but a type
                            " elsewhere. Order matters here.
                            syn match       goType              /\<func\>/
                            syn match       goDeclaration       /^func\>/
                            
                            " Predefined functions and values
                            syn keyword     goBuiltins          append cap close complex copy delete imag len
                            syn keyword     goBuiltins          make new panic print println real recover
                            syn keyword     goConstants         iota true false nil
                            
                            hi def link     goBuiltins          Keyword
                            hi def link     goConstants         Keyword
                            
                            " Comments; their contents
                            syn keyword     goTodo              contained TODO FIXME XXX BUG
                            syn cluster     goCommentGroup      contains=goTodo
                            syn region      goComment           start="/\*" end="\*/" contains=@goCommentGroup,@Spell
                            syn region      goComment           start="//" end="$" contains=@goCommentGroup,@Spell
                            
                            hi def link     goComment           Comment
                            hi def link     goTodo              Todo
                            
                            " Go escapes
                            syn match       goEscapeOctal       display contained "\\[0-7]\{3}"
                            syn match       goEscapeC           display contained +\\[abfnrtv\\'"]+
                            syn match       goEscapeX           display contained "\\x\x\{2}"
                            syn match       goEscapeU           display contained "\\u\x\{4}"
                            syn match       goEscapeBigU        display contained "\\U\x\{8}"
                            syn match       goEscapeError       display contained +\\[^0-7xuUabfnrtv\\'"]+
                            
                            hi def link     goEscapeOctal       goSpecialString
                            hi def link     goEscapeC           goSpecialString
                            hi def link     goEscapeX           goSpecialString
                            hi def link     goEscapeU           goSpecialString
                            hi def link     goEscapeBigU        goSpecialString
                            hi def link     goSpecialString     Special
                            hi def link     goEscapeError       Error
                            
                            " Strings and their contents
                            syn cluster     goStringGroup       contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU,goEscapeError
                            syn region      goString            start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@goStringGroup
                            syn region      goRawString         start=+`+ end=+`+
                            
                            hi def link     goString            String
                            hi def link     goRawString         String
                            
                            " Characters; their contents
                            syn cluster     goCharacterGroup    contains=goEscapeOctal,goEscapeC,goEscapeX,goEscapeU,goEscapeBigU
                            syn region      goCharacter         start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=@goCharacterGroup
                            
                            hi def link     goCharacter         Character
                            
                            " Regions
                            syn region      goBlock             start="{" end="}" transparent fold
                            syn region      goParen             start='(' end=')' transparent
                            
                            " Integers
                            syn match       goDecimalInt        "\<\d\+\([Ee]\d\+\)\?\>"
                            syn match       goHexadecimalInt    "\<0x\x\+\>"
                            syn match       goOctalInt          "\<0\o\+\>"
                            syn match       goOctalError        "\<0\o*[89]\d*\>"
                            
                            hi def link     goDecimalInt        Integer
                            hi def link     goHexadecimalInt    Integer
                            hi def link     goOctalInt          Integer
                            hi def link     Integer             Number
                            
                            " Floating point
                            syn match       goFloat             "\<\d\+\.\d*\([Ee][-+]\d\+\)\?\>"
                            syn match       goFloat             "\<\.\d\+\([Ee][-+]\d\+\)\?\>"
                            syn match       goFloat             "\<\d\+[Ee][-+]\d\+\>"
                            
                            hi def link     goFloat             Float
                            
                            " Imaginary literals
                            syn match       goImaginary         "\<\d\+i\>"
                            syn match       goImaginary         "\<\d\+\.\d*\([Ee][-+]\d\+\)\?i\>"
                            syn match       goImaginary         "\<\.\d\+\([Ee][-+]\d\+\)\?i\>"
                            syn match       goImaginary         "\<\d\+[Ee][-+]\d\+i\>"
                            
                            hi def link     goImaginary         Number
                            
                            " Spaces after "[]"
                            if go_highlight_array_whitespace_error != 0
                              syn match goSpaceError display "\(\[\]\)\@<=\s\+"
                            endif
                            
                            " Spacing errors around the 'chan' keyword
                            if go_highlight_chan_whitespace_error != 0
                              " receive-only annotation on chan type
                              syn match goSpaceError display "\(<-\)\@<=\s\+\(chan\>\)\@="
                              " send-only annotation on chan type
                              syn match goSpaceError display "\(\<chan\)\@<=\s\+\(<-\)\@="
                              " value-ignoring receives in a few contexts
                              syn match goSpaceError display "\(\(^\|[={(,;]\)\s*<-\)\@<=\s\+"
                            endif
                            
                            " Extra types commonly seen
                            if go_highlight_extra_types != 0
                              syn match goExtraType /\<bytes\.\(Buffer\)\>/
                              syn match goExtraType /\<io\.\(Reader\|Writer\|ReadWriter\|ReadWriteCloser\)\>/
                              syn match goExtraType /\<reflect\.\(Kind\|Type\|Value\)\>/
                              syn match goExtraType /\<unsafe\.Pointer\>/
                            endif
                            
                            " Space-tab error
                            if go_highlight_space_tab_error != 0
                              syn match goSpaceError display " \+\t"me=e-1
                            endif
                            
                            " Trailing white space error
                            if go_highlight_trailing_whitespace_error != 0
                              syn match goSpaceError display excludenl "\s\+$"
                            endif
                            
                            hi def link     goExtraType         Type
                            hi def link     goSpaceError        Error
                            
                            " Search backwards for a global declaration to start processing the syntax.
                            "syn sync match goSync grouphere NONE /^\(const\|var\|type\|func\)\>/
                            
                            " There's a bug in the implementation of grouphere. For now, use the
                            " following as a more expensive/less precise workaround.
                            syn sync minlines=500
                            
                            let b:current_syntax = 'go'
                            
                            " vim: sw=2 sts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/lsp.vim
Sourced 1 time
Total time:   0.001054
 Self time:   0.001054

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000010 let s:cpo_save = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000003 scriptencoding utf-8
                            
    1              0.000004 let s:lspfactory = {}
                            
    1              0.000003 function! s:lspfactory.get() dict abort
                              if empty(get(self, 'current', {})) || empty(get(self.current, 'job', {}))
                                let self.current = s:newlsp()
                              endif
                            
                              return self.current
                            endfunction
                            
    1              0.000002 function! s:lspfactory.reset() dict abort
                              if has_key(self, 'current')
                                call remove(self, 'current')
                              endif
                            endfunction
                            
    1              0.000003 function! s:newlsp() abort
                              if !go#util#has_job()
                                let l:oldshortmess=&shortmess
                                if has('nvim')
                                  set shortmess-=F
                                endif
                                call go#util#EchoWarning('Features that rely on gopls will not work without either Vim 8.0.0087 or newer with +job or Neovim')
                                " Sleep one second to make sure people see the message. Otherwise it is
                                " often immediately overwritten by an async message.
                                sleep 1
                                let &shortmess=l:oldshortmess
                                return {'sendMessage': funcref('s:noop')}
                              endif
                            
                              " job is the job used to talk to the backing instance of gopls.
                              " ready is 0 until the initialize response has been received. 1 afterwards.
                              " queue is messages to send after initialization
                              " last_request_id is id of the most recently sent request.
                              " buf is unprocessed/incomplete responses
                              " handlers is a mapping of request ids to dictionaries of functions.
                              "   request id -> {start, requestComplete, handleResult, error}
                              "   * start is a function that takes no arguments
                              "   * requestComplete is a function that takes 1 argument. The parameter will be 1
                              "     if the call was succesful.
                              "   * handleResult takes a single argument, the result message received from gopls
                              "   * error takes a single argument, the error message received from gopls.
                              "     The error method is optional.
                              let l:lsp = {
                                    \ 'job':  '',
                                    \ 'ready': 0,
                                    \ 'queue': [],
                                    \ 'last_request_id': 0,
                                    \ 'buf': '',
                                    \ 'handlers': {},
                                    \ 'workspaceDirectories': [],
                                    \ 'wd' : '',
                                    \ }
                            
                              function! l:lsp.readMessage(data) dict abort
                                let l:responses = []
                                let l:rest = a:data
                            
                                while 1
                                  " Look for the end of the HTTP headers
                                  let l:body_start_idx = matchend(l:rest, "\r\n\r\n")
                            
                                  if l:body_start_idx < 0
                                    " incomplete header
                                    break
                                  endif
                            
                                  " Parse the Content-Length header.
                                  let l:header = l:rest[:l:body_start_idx - 4]
                                  let l:length_match = matchlist(
                                  \   l:header,
                                  \   '\vContent-Length: *(\d+)'
                                  \)
                            
                                  if empty(l:length_match)
                                    " TODO(bc): shutdown gopls?
                                    throw "invalid JSON-RPC header:\n" . l:header
                                  endif
                            
                                  " get the start of the rest
                                  let l:next_start_idx = l:body_start_idx + str2nr(l:length_match[1])
                            
                                  if len(l:rest) < l:next_start_idx
                                    " incomplete response body
                                    break
                                  endif
                            
                                  call s:debug('received', l:rest[:l:next_start_idx - 1])
                            
                                  let l:body = l:rest[l:body_start_idx : l:next_start_idx - 1]
                                  let l:rest = l:rest[l:next_start_idx :]
                            
                                  try
                                    " add the json body to the list.
                                    call add(l:responses, json_decode(l:body))
                                  catch
                                    " TODO(bc): log the message and/or show an error message.
                                  finally
                                    " intentionally left blank.
                                  endtry
                                endwhile
                            
                                return [l:rest, l:responses]
                              endfunction
                            
                              function! l:lsp.handleMessage(ch, data) dict abort
                                  let self.buf .= a:data
                            
                                  let [self.buf, l:messages] = self.readMessage(self.buf)
                            
                                  for l:message in l:messages
                                    if has_key(l:message, 'method')
                                      if has_key(l:message, 'id')
                                        call self.handleRequest(l:message)
                                      else
                                        call self.handleNotification(l:message)
                                      endif
                                    elseif has_key(l:message, 'result') || has_key(l:message, 'error')
                                      call self.handleResponse(l:message)
                                    endif
                                  endfor
                              endfunction
                            
                              function! l:lsp.handleRequest(req) dict abort
                                if a:req.method == 'workspace/workspaceFolders'
                                  let l:resp = go#lsp#message#WorkspaceFoldersResult(self.workspaceDirectories)
                                elseif a:req.method == 'workspace/configuration' && has_key(a:req, 'params') && has_key(a:req.params, 'items')
                                  let l:resp = go#lsp#message#ConfigurationResult(a:req.params.items)
                                elseif a:req.method == 'client/registerCapability' && has_key(a:req, 'params') && has_key(a:req.params, 'registrations')
                                  let l:resp = v:null
                                else
                                  return
                                endif
                            
                                if get(self, 'exited', 0)
                                  return
                                endif
                            
                                let l:msg = self.newResponse(a:req.id, l:resp)
                                call self.write(l:msg)
                              endfunction
                            
                              function! l:lsp.handleNotification(req) dict abort
                                  " TODO(bc): handle notifications (e.g. window/showMessage).
                              endfunction
                            
                              function! l:lsp.handleResponse(resp) dict abort
                                if has_key(a:resp, 'id') && has_key(self.handlers, a:resp.id)
                                  try
                                    let l:handler = self.handlers[a:resp.id]
                            
                                    let l:winid = win_getid(winnr())
                                    " Always set the active window to the window that was active when
                                    " the request was sent. Among other things, this makes sure that
                                    " the correct window's location list will be populated when the
                                    " list type is 'location' and the user has moved windows since
                                    " sending the request.
                                    call win_gotoid(l:handler.winid)
                            
                                    if has_key(a:resp, 'error')
                                      call l:handler.requestComplete(0)
                                      if has_key(l:handler, 'error')
                                        call call(l:handler.error, [a:resp.error.message])
                                      else
                                        call go#util#EchoError(a:resp.error.message)
                                      endif
                                      call win_gotoid(l:winid)
                                      return
                                    endif
                                    call l:handler.requestComplete(1)
                            
                                    let l:winidBeforeHandler = l:handler.winid
                                    call call(l:handler.handleResult, [a:resp.result])
                            
                                    " change the window back to the window that was active when
                                    " starting to handle the message _only_ if the handler didn't
                                    " update the winid, so that handlers can set the winid if needed
                                    " (e.g. :GoDef).
                                    if l:handler.winid == l:winidBeforeHandler
                                      call win_gotoid(l:winid)
                                    endif
                                  finally
                                    call remove(self.handlers, a:resp.id)
                                  endtry
                                endif
                              endfunction
                            
                              function! l:lsp.handleInitializeResult(result) dict abort
                                if go#config#EchoCommandInfo()
                                  call go#util#EchoProgress("initialized gopls")
                                endif
                                let status = {
                                      \ 'desc': '',
                                      \ 'type': 'gopls',
                                      \ 'state': 'initialized',
                                    \ }
                                call go#statusline#Update(self.wd, status)
                            
                                let self.ready = 1
                                let  l:msg = self.newMessage(go#lsp#message#Initialized())
                                call self.write(l:msg)
                            
                                " send messages queued while waiting for ready.
                                for l:item in self.queue
                                  call self.sendMessage(l:item.data, l:item.handler)
                                endfor
                            
                                " reset the queue
                                let self.queue = []
                              endfunction
                            
                              function! l:lsp.sendMessage(data, handler) dict abort
                                if !self.last_request_id
                                  let l:wd = go#util#ModuleRoot()
                                  if l:wd == -1
                                    call go#util#EchoError('could not determine appropriate working directory for gopls')
                                    return -1
                                  endif
                            
                                  if l:wd == ''
                                    let l:wd = getcwd()
                                  endif
                                  let self.wd = l:wd
                            
                                  if go#config#EchoCommandInfo()
                                    call go#util#EchoProgress("initializing gopls")
                                  endif
                            
                                  let l:status = {
                                        \ 'desc': '',
                                        \ 'type': 'gopls',
                                        \ 'state': 'initializing',
                                      \ }
                                  call go#statusline#Update(l:wd, l:status)
                            
                                  let self.workspaceDirectories = add(self.workspaceDirectories, l:wd)
                                  let l:msg = self.newMessage(go#lsp#message#Initialize(l:wd))
                            
                                  let l:state = s:newHandlerState('')
                                  let l:state.handleResult = funcref('self.handleInitializeResult', [], l:self)
                            
                                  let self.handlers[l:msg.id] = l:state
                            
                                  call l:state.start()
                                  call self.write(l:msg)
                                endif
                            
                                if !self.ready
                                  call add(self.queue, {'data': a:data, 'handler': a:handler})
                                  return
                                endif
                            
                                let l:msg = self.newMessage(a:data)
                                if has_key(l:msg, 'id')
                                  let self.handlers[l:msg.id] = a:handler
                                endif
                            
                                call a:handler.start()
                                call self.write(l:msg)
                              endfunction
                            
                              " newMessage returns a message constructed from data. data should be a dict
                              " with 2 or 3 keys: notification, method, and optionally params.
                              function! l:lsp.newMessage(data) dict abort
                                let l:msg = {
                                      \ 'method': a:data.method,
                                      \ 'jsonrpc': '2.0',
                                    \ }
                            
                                if !a:data.notification
                                  let self.last_request_id += 1
                                  let l:msg.id = self.last_request_id
                                endif
                            
                                if has_key(a:data, 'params')
                                  let l:msg.params = a:data.params
                                endif
                            
                                return l:msg
                              endfunction
                            
                              function l:lsp.newResponse(id, result) dict abort
                                let l:msg = {
                                      \ 'jsonrpc': '2.0',
                                      \ 'id': a:id,
                                      \ 'result': a:result,
                                    \ }
                            
                                return l:msg
                              endfunction
                            
                              function! l:lsp.write(msg) dict abort
                                let l:body = json_encode(a:msg)
                                let l:data = 'Content-Length: ' . strlen(l:body) . "\r\n\r\n" . l:body
                            
                                call s:debug('sent', l:data)
                            
                                if has('nvim')
                                  call chansend(self.job, l:data)
                                  return
                                endif
                            
                                call ch_sendraw(self.job, l:data)
                              endfunction
                            
                              function! l:lsp.exit_cb(job, exit_status) dict
                                let self.exited = 1
                                if !get(self, 'restarting', 0)
                                  return
                                endif
                            
                                let l:queue = self.queue
                            
                                let l:workspaces = self.workspaceDirectories
                            
                                call s:lspfactory.reset()
                                let l:lsp = s:lspfactory.get()
                            
                                " restore workspaces
                                call call('go#lsp#AddWorkspaceDirectory', l:workspaces)
                                " * send DidOpen messages for all buffers that have b:did_lsp_open set
                                " TODO(bc): check modifiable and filetype, too?
                                bufdo if get(b:, 'go_lsp_did_open', 0) | if &modified | call go#lsp#DidOpen(expand('%:p')) | else | call go#lsp#DidChange(expand('%:p')) | endif | endif
                                let l:lsp.queue = extend(l:lsp.queue, l:queue)
                                return
                              endfunction
                            
                              function! l:lsp.close_cb(ch) dict abort
                                " TODO(bc): remove the buffer variables that indicate that gopls has been
                                " informed that the file is open
                              endfunction
                            
                              function! l:lsp.err_cb(ch, msg) dict abort
                                if a:msg =~ '^\tPort = \d\+$' && !get(self, 'debugport', 0)
                                  let self.debugport = substitute(a:msg, '^\tPort = \(\d\+\).*$', '\1', '')
                                endif
                            
                                call s:debug('stderr', a:msg)
                              endfunction
                            
                              " explicitly bind callbacks to l:lsp so that within it, self will always refer
                              " to l:lsp instead of l:opts. See :help Partial for more information.
                              let l:opts = {
                                    \ 'in_mode': 'raw',
                                    \ 'out_mode': 'raw',
                                    \ 'err_mode': 'nl',
                                    \ 'noblock': 1,
                                    \ 'err_cb': funcref('l:lsp.err_cb', [], l:lsp),
                                    \ 'out_cb': funcref('l:lsp.handleMessage', [], l:lsp),
                                    \ 'close_cb': funcref('l:lsp.close_cb', [], l:lsp),
                                    \ 'exit_cb': funcref('l:lsp.exit_cb', [], l:lsp),
                                    \ 'cwd': getcwd(),
                                    \}
                            
                              let l:bin_path = go#path#CheckBinPath("gopls")
                              if empty(l:bin_path)
                                return
                              endif
                            
                              let l:cmd = [l:bin_path]
                              if go#util#HasDebug('lsp')
                                let l:cmd = extend(l:cmd, ['-debug', 'localhost:0'])
                              endif
                            
                              let l:lsp.job = go#job#Start(l:cmd, l:opts)
                            
                              return l:lsp
                            endfunction
                            
    1              0.000004 function! s:noop(...) abort
                            endfunction
                            
    1              0.000003 function! s:newHandlerState(statustype) abort
                              let l:state = {
                                    \ 'winid': win_getid(winnr()),
                                    \ 'statustype': a:statustype,
                                    \ 'jobdir': getcwd(),
                                  \ }
                            
                              " explicitly bind requestComplete to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
                              let l:state.requestComplete = funcref('s:requestComplete', [], l:state)
                            
                              " explicitly bind start to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
                              let l:state.start = funcref('s:start', [], l:state)
                            
                              return l:state
                            endfunction
                            
    1              0.000003 function! s:requestComplete(ok) abort dict
                              if self.statustype == ''
                                return
                              endif
                            
                              if go#config#EchoCommandInfo()
                                let prefix = '[' . self.statustype . '] '
                                if a:ok
                                  call go#util#EchoSuccess(prefix . "SUCCESS")
                                else
                                  call go#util#EchoError(prefix . "FAIL")
                                endif
                              endif
                            
                              let status = {
                                    \ 'desc': 'last status',
                                    \ 'type': self.statustype,
                                    \ 'state': "success",
                                    \ }
                            
                              if !a:ok
                                let status.state = "failed"
                              endif
                            
                              if has_key(self, 'started_at')
                                let elapsed_time = reltimestr(reltime(self.started_at))
                                " strip whitespace
                                let elapsed_time = substitute(elapsed_time, '^\s*\(.\{-}\)\s*$', '\1', '')
                                let status.state .= printf(" (%ss)", elapsed_time)
                              endif
                            
                              call go#statusline#Update(self.jobdir, status)
                            endfunction
                            
    1              0.000003 function! s:start() abort dict
                              let self.started_at = reltime()
                              if self.statustype == ''
                                return
                              endif
                              let status = {
                                    \ 'desc': 'current status',
                                    \ 'type': self.statustype,
                                    \ 'state': "started",
                                    \ }
                            
                              call go#statusline#Update(self.jobdir, status)
                            endfunction
                            
                            " go#lsp#Definition calls gopls to get the definition of the identifier at
                            " line and col in fname. handler should be a dictionary function that takes a
                            " list of strings in the form 'file:line:col: message'. handler will be
                            " attached to a dictionary that manages state (statuslines, sets the winid,
                            " etc.)
    1              0.000004 function! go#lsp#Definition(fname, line, col, handler) abort
                              call go#lsp#DidChange(a:fname)
                            
                              let l:lsp = s:lspfactory.get()
                              let l:state = s:newHandlerState('definition')
                              let l:state.handleResult = funcref('s:definitionHandler', [function(a:handler, [], l:state)], l:state)
                              let l:msg = go#lsp#message#Definition(fnamemodify(a:fname, ':p'), a:line, a:col)
                              return l:lsp.sendMessage(l:msg, l:state)
                            endfunction
                            
    1              0.000003 function! s:definitionHandler(next, msg) abort dict
                              " gopls returns a []Location; just take the first one.
                              let l:msg = a:msg[0]
                              let l:args = [[printf('%s:%d:%d: %s', go#path#FromURI(l:msg.uri), l:msg.range.start.line+1, go#lsp#lsp#PositionOf(getline(l:msg.range.start.line+1), l:msg.range.start.character), 'lsp does not supply a description')]]
                              call call(a:next, l:args)
                            endfunction
                            
                            " go#lsp#Type calls gopls to get the type definition of the identifier at
                            " line and col in fname. handler should be a dictionary function that takes a
                            " list of strings in the form 'file:line:col: message'. handler will be
                            " attached to a dictionary that manages state (statuslines, sets the winid,
                            " etc.)
    1              0.000004 function! go#lsp#TypeDef(fname, line, col, handler) abort
                              call go#lsp#DidChange(a:fname)
                            
                              let l:lsp = s:lspfactory.get()
                              let l:state = s:newHandlerState('type definition')
                              let l:msg = go#lsp#message#TypeDefinition(fnamemodify(a:fname, ':p'), a:line, a:col)
                              let l:state.handleResult = funcref('s:typeDefinitionHandler', [function(a:handler, [], l:state)], l:state)
                              return  l:lsp.sendMessage(l:msg, l:state)
                            endfunction
                            
    1              0.000004 function! s:typeDefinitionHandler(next, msg) abort dict
                              " gopls returns a []Location; just take the first one.
                              let l:msg = a:msg[0]
                              let l:args = [[printf('%s:%d:%d: %s', go#path#FromURI(l:msg.uri), l:msg.range.start.line+1, go#lsp#lsp#PositionOf(getline(l:msg.range.start.line+1), l:msg.range.start.character), 'lsp does not supply a description')]]
                              call call(a:next, l:args)
                            endfunction
                            
    1              0.000002 function! go#lsp#DidOpen(fname) abort
                              if get(b:, 'go_lsp_did_open', 0)
                                return
                              endif
                            
                              if !filereadable(a:fname)
                                return
                              endif
                            
                              let l:lsp = s:lspfactory.get()
                              let l:msg = go#lsp#message#DidOpen(fnamemodify(a:fname, ':p'), join(go#util#GetLines(), "\n") . "\n")
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:noop')
                            
                              " TODO(bc): setting a buffer level variable here assumes that a:fname is the
                              " current buffer. Change to a:fname first before setting it and then change
                              " back to active buffer.
                              let b:go_lsp_did_open = 1
                            
                              return l:lsp.sendMessage(l:msg, l:state)
                            endfunction
                            
    1              0.000003 function! go#lsp#DidChange(fname) abort
                              " DidChange is called even when fname isn't open in a buffer (e.g. via
                              " go#lsp#Info); don't report the file as open or as having changed when it's
                              " not actually a buffer.
                              if bufnr(a:fname) == -1
                                return
                              endif
                            
                              if !filereadable(a:fname)
                                return
                              endif
                            
                              call go#lsp#DidOpen(a:fname)
                            
                              let l:lsp = s:lspfactory.get()
                              let l:msg = go#lsp#message#DidChange(fnamemodify(a:fname, ':p'), join(go#util#GetLines(), "\n") . "\n")
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:noop')
                              return l:lsp.sendMessage(l:msg, l:state)
                            endfunction
                            
    1              0.000002 function! go#lsp#DidClose(fname) abort
                              if !filereadable(a:fname)
                                return
                              endif
                            
                              if !get(b:, 'go_lsp_did_open', 0)
                                return
                              endif
                            
                              let l:lsp = s:lspfactory.get()
                              let l:msg = go#lsp#message#DidClose(fnamemodify(a:fname, ':p'))
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:noop')
                              " TODO(bc): setting a buffer level variable here assumes that a:fname is the
                              " current buffer. Change to a:fname first before setting it and then change
                              " back to active buffer.
                              let b:go_lsp_did_open = 0
                            
                              return l:lsp.sendMessage(l:msg, l:state)
                            endfunction
                            
    1              0.000003 function! go#lsp#Completion(fname, line, col, handler) abort
                              call go#lsp#DidChange(a:fname)
                            
                              let l:lsp = s:lspfactory.get()
                              let l:msg = go#lsp#message#Completion(a:fname, a:line, a:col)
                              let l:state = s:newHandlerState('completion')
                              let l:state.handleResult = funcref('s:completionHandler', [function(a:handler, [], l:state)], l:state)
                              let l:state.error = funcref('s:completionErrorHandler', [function(a:handler, [], l:state)], l:state)
                              return l:lsp.sendMessage(l:msg, l:state)
                            endfunction
                            
    1              0.000004 function! s:completionHandler(next, msg) abort dict
                              " gopls returns a CompletionList.
                              let l:matches = []
                              let l:start = -1
                            
                              for l:item in a:msg.items
                                let l:start = l:item.textEdit.range.start.character
                            
                                let l:match = {'abbr': l:item.label, 'word': l:item.textEdit.newText, 'info': '', 'kind': go#lsp#completionitemkind#Vim(l:item.kind)}
                                if has_key(l:item, 'detail')
                                    let l:match.menu = l:item.detail
                                    if go#lsp#completionitemkind#IsFunction(l:item.kind) || go#lsp#completionitemkind#IsMethod(l:item.kind)
                                      let l:match.info = printf('%s %s', l:item.label, l:item.detail)
                            
                                      " The detail provided by gopls hasn't always provided the the full
                                      " signature including the return value. The label used to be the
                                      " function signature and the detail was the return value. Handle
                                      " that case for backward compatibility. This can be removed in the
                                      " future once it's likely that the majority of users are on a recent
                                      " version of gopls.
                                      if l:item.detail !~ '^func'
                                        let l:match.info = printf('func %s %s', l:item.label, l:item.detail)
                                      endif
                                    endif
                                endif
                            
                                if has_key(l:item, 'documentation')
                                  let l:match.info .= "\n\n" . l:item.documentation
                                endif
                            
                                let l:matches = add(l:matches, l:match)
                              endfor
                              let l:args = [l:start, l:matches]
                              call call(a:next, l:args)
                            endfunction
                            
    1              0.000009 function! s:completionErrorHandler(next, error) abort dict
                              call call(a:next, [-1, []])
                            endfunction
                            
    1              0.000006 function! go#lsp#Hover(fname, line, col, handler) abort
                              call go#lsp#DidChange(a:fname)
                            
                              let l:lsp = s:lspfactory.get()
                              let l:msg = go#lsp#message#Hover(a:fname, a:line, a:col)
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:hoverHandler', [function(a:handler, [], l:state)], l:state)
                              let l:state.error = funcref('s:noop')
                              return l:lsp.sendMessage(l:msg, l:state)
                            endfunction
                            
    1              0.000006 function! s:hoverHandler(next, msg) abort dict
                              let l:content = split(a:msg.contents.value, '; ')
                              if len(l:content) > 1
                                let l:curly = stridx(l:content[0], '{')
                                let l:content = extend([l:content[0][0:l:curly]], map(extend([l:content[0][l:curly+1:]], l:content[1:]), '"\t" . v:val'))
                                let l:content[len(l:content)-1] = '}'
                              endif
                            
                              let l:args = [l:content]
                              call call(a:next, l:args)
                            endfunction
                            
    1              0.000002 function! go#lsp#Info(showstatus)
                              let l:fname = expand('%:p')
                              let [l:line, l:col] = go#lsp#lsp#Position()
                            
                              call go#lsp#DidChange(l:fname)
                            
                              let l:lsp = s:lspfactory.get()
                            
                              if a:showstatus
                                let l:state = s:newHandlerState('info')
                              else
                                let l:state = s:newHandlerState('')
                              endif
                            
                              let l:state.handleResult = funcref('s:infoDefinitionHandler', [function('s:info', [1], l:state), a:showstatus], l:state)
                              let l:state.error = funcref('s:noop')
                              let l:msg = go#lsp#message#Definition(l:fname, l:line, l:col)
                              return l:lsp.sendMessage(l:msg, l:state)
                            endfunction
                            
    1              0.000003 function! go#lsp#GetInfo()
                              let l:fname = expand('%:p')
                              let [l:line, l:col] = go#lsp#lsp#Position()
                            
                              call go#lsp#DidChange(l:fname)
                            
                              let l:lsp = s:lspfactory.get()
                            
                              let l:state = s:newHandlerState('')
                            
                              let l:info = go#promise#New(function('s:info', [0], l:state), 10000, '')
                            
                              let l:state.handleResult = funcref('s:infoDefinitionHandler', [l:info.wrapper, 0], l:state)
                              let l:state.error = funcref('s:noop')
                              let l:msg = go#lsp#message#Definition(l:fname, l:line, l:col)
                              call l:lsp.sendMessage(l:msg, l:state)
                              return l:info.await()
                            endfunction
                            
    1              0.000004 function! s:infoDefinitionHandler(next, showstatus, msg) abort dict
                              " gopls returns a []Location; just take the first one.
                              let l:msg = a:msg[0]
                            
                              let l:fname = go#path#FromURI(l:msg.uri)
                              let l:line = l:msg.range.start.line
                              let l:col = l:msg.range.start.character
                            
                              let l:lsp = s:lspfactory.get()
                              let l:msg = go#lsp#message#Hover(l:fname, l:line, l:col)
                            
                              if a:showstatus
                                let l:state = s:newHandlerState('info')
                              else
                                let l:state = s:newHandlerState('')
                              endif
                            
                              let l:state.handleResult = funcref('s:hoverHandler', [a:next], l:state)
                              let l:state.error = funcref('s:noop')
                              return l:lsp.sendMessage(l:msg, l:state)
                            endfunction
                            
    1              0.000002 function! s:info(show, content) abort dict
                              let l:content = s:infoFromHoverContent(a:content)
                            
                              if a:show
                                call go#util#ShowInfo(l:content)
                              endif
                            
                              return l:content
                            endfunction
                            
    1              0.000004 function! s:infoFromHoverContent(content) abort
                              if len(a:content) < 1
                                return ''
                              endif
                            
                              let l:content = a:content[0]
                            
                              " strip off the method set and fields of structs and interfaces.
                              if l:content =~# '^\(type \)\?[^ ]\+ \(struct\|interface\)'
                                let l:content = substitute(l:content, '{.*', '', '')
                              endif
                            
                              return l:content
                            endfunction
                            
    1              0.000003 function! go#lsp#AddWorkspaceDirectory(...) abort
                              if a:0 == 0
                                return
                              endif
                            
                              call go#lsp#CleanWorkspaces()
                            
                              let l:workspaces = []
                              for l:dir in a:000
                                let l:dir = fnamemodify(l:dir, ':p')
                                if !isdirectory(l:dir)
                                  continue
                                endif
                            
                                let l:workspaces = add(l:workspaces, l:dir)
                              endfor
                            
                              let l:lsp = s:lspfactory.get()
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:noop')
                              let l:lsp.workspaceDirectories = extend(l:lsp.workspaceDirectories, l:workspaces)
                              let l:msg = go#lsp#message#ChangeWorkspaceFolders(l:workspaces, [])
                              call l:lsp.sendMessage(l:msg, l:state)
                            
                              return 0
                            endfunction
                            
    1              0.000002 function! go#lsp#CleanWorkspaces() abort
                              let l:workspaces = []
                            
                              let l:lsp = s:lspfactory.get()
                            
                              let l:i = 0
                              let l:missing = []
                              for l:dir in l:lsp.workspaceDirectories
                                if !isdirectory(l:dir)
                                  let l:dir = add(l:missing, l:dir)
                                  call remove(l:lsp.workspaceDirectories, l:i)
                                  continue
                                endif
                                let l:i += 1
                              endfor
                            
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:noop')
                              let l:msg = go#lsp#message#ChangeWorkspaceFolders([], l:missing)
                              call l:lsp.sendMessage(l:msg, l:state)
                            
                              return 0
                            endfunction
                            
                            " go#lsp#ResetWorkspaceDiretories removes and then re-adds all workspace
                            " folders to cause gopls to send configuration requests for all of them again.
                            " This is useful, for instance, when build tags have been added and gopls
                            " needs to use them.
    1              0.000002 function! go#lsp#ResetWorkspaceDirectories() abort
                              call go#lsp#CleanWorkspaces()
                            
                              let l:lsp = s:lspfactory.get()
                            
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:noop')
                              let l:msg = go#lsp#message#ChangeWorkspaceFolders(l:lsp.workspaceDirectories, l:lsp.workspaceDirectories)
                              call l:lsp.sendMessage(l:msg, l:state)
                            
                              return 0
                            endfunction
                            
    1              0.000002 function! go#lsp#DebugBrowser() abort
                              let l:lsp = s:lspfactory.get()
                              let l:port = get(l:lsp, 'debugport', 0)
                              if !l:port
                                call go#util#EchoError("gopls was not started with debugging enabled. See :help g:go_debug.")
                                return
                              endif
                            
                              call go#util#OpenBrowser(printf('http://localhost:%d', l:port))
                            endfunction
                            
    1              0.000007 function! go#lsp#Restart() abort
                              if !go#util#has_job() || len(s:lspfactory) == 0 || !has_key(s:lspfactory, 'current')
                                return
                              endif
                            
                              let l:lsp = s:lspfactory.get()
                            
                              let l:lsp.restarting = 1
                            
                              let l:state = s:newHandlerState('exit')
                            
                              let l:msg = go#lsp#message#Shutdown()
                              let l:state.handleResult = funcref('s:noop')
                              let l:retval = l:lsp.sendMessage(l:msg, l:state)
                            
                              let l:msg = go#lsp#message#Exit()
                              let l:retval = l:lsp.sendMessage(l:msg, l:state)
                            
                              return l:retval
                            endfunction
                            
    1              0.000007 function! s:debug(event, data) abort
                              if !go#util#HasDebug('lsp')
                                return
                              endif
                            
                              let l:winid = win_getid()
                            
                              let l:name = '__GOLSP_LOG__'
                              let l:log_winid = bufwinid(l:name)
                              if l:log_winid == -1
                                silent keepalt botright 10new
                                silent file `='__GOLSP_LOG__'`
                                setlocal buftype=nofile bufhidden=wipe nomodified nobuflisted noswapfile nowrap nonumber nocursorline
                                setlocal filetype=golsplog
                              else
                                call win_gotoid(l:log_winid)
                              endif
                            
                              try
                                setlocal modifiable
                                if getline(1) == ''
                                  call setline('$', printf('%s: %s', a:event, a:data))
                                else
                                  call append('$', printf('%s: %s', a:event, a:data))
                                endif
                                normal! G
                                setlocal nomodifiable
                              finally
                                call win_gotoid(l:winid)
                              endtry
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000035 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/path.vim
Sourced 1 time
Total time:   0.000322
 Self time:   0.000322

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000010 let s:cpo_save = &cpo
    1              0.000009 set cpo&vim
                            
                            " initial_go_path is used to store the initial GOPATH that was set when Vim
                            " was started. It's used with :GoPathClear to restore the GOPATH when the user
                            " changed it explicitly via :GoPath. Initially it's empty. It's being set when
                            " :GoPath is used
    1              0.000007 let s:initial_go_path = ""
                            
                            " GoPath sets or echos the current GOPATH. If no arguments are passed it
                            " echoes the current GOPATH, if an argument is passed it replaces the current
                            " GOPATH with it. If two double quotes are passed (the empty string in go),
                            " it'll clear the GOPATH and will restore to the initial GOPATH.
    1              0.000005 function! go#path#GoPath(...) abort
                              " no argument, show GOPATH
                              if len(a:000) == 0
                                echo go#path#Default()
                                return
                              endif
                            
                              " we have an argument, replace GOPATH
                              " clears the current manually set GOPATH and restores it to the
                              " initial GOPATH, which was set when Vim was started.
                              if len(a:000) == 1 && a:1 == '""'
                                if !empty(s:initial_go_path)
                                  let $GOPATH = s:initial_go_path
                                  let s:initial_go_path = ""
                                endif
                            
                                echon "vim-go: " | echohl Function | echon "GOPATH restored to ". $GOPATH | echohl None
                                return
                              endif
                            
                              echon "vim-go: " | echohl Function | echon "GOPATH changed to ". a:1 | echohl None
                              let s:initial_go_path = $GOPATH
                              let $GOPATH = a:1
                            endfunction
                            
                            " Default returns the default GOPATH. If GOPATH is not set, it uses the
                            " default GOPATH set starting with Go 1.8. This GOPATH can be retrieved via
                            " 'go env GOPATH'
    1              0.000007 function! go#path#Default() abort
                              if $GOPATH == ""
                                " use default GOPATH via go env
                                return go#util#env("gopath")
                              endif
                            
                              return $GOPATH
                            endfunction
                            
                            " s:HasPath checks whether the given path exists in GOPATH environment variable
                            " or not
    1              0.000006 function! s:HasPath(path) abort
                              let go_paths = split(go#path#Default(), go#util#PathListSep())
                              let last_char = strlen(a:path) - 1
                            
                              " check cases of '/foo/bar/' and '/foo/bar'
                              if a:path[last_char] == go#util#PathSep()
                                let withSep = a:path
                                let noSep = strpart(a:path, 0, last_char)
                              else
                                let withSep = a:path . go#util#PathSep()
                                let noSep = a:path
                              endif
                            
                              let hasA = index(go_paths, withSep) != -1
                              let hasB = index(go_paths, noSep) != -1
                              return hasA || hasB
                            endfunction
                            
                            " Detect returns the current GOPATH. If a package manager is used, such as
                            " Godeps, GB, it will modify the GOPATH so those directories take precedence
                            " over the current GOPATH. It also detects diretories whose are outside
                            " GOPATH.
    1              0.000003 function! go#path#Detect() abort
                              let gopath = go#path#Default()
                            
                              let current_dir = fnameescape(expand('%:p:h'))
                            
                              " TODO(arslan): this should be changed so folders or files should be
                              " fetched from a customizable list. The user should define any new package
                              " management tool by it's own.
                            
                              " src folders outside $GOPATH
                              let src_roots = finddir("src", current_dir .";", -1)
                            
                              " for cases like GOPATH/src/foo/src/bar, pick up GOPATH/src instead of
                              " GOPATH/src/foo/src
                              let src_root = ""
                              if len(src_roots) > 0
                                let src_root = src_roots[-1]
                              endif
                            
                              if !empty(src_root)
                                let src_path = fnamemodify(src_root, ':p:h:h') . go#util#PathSep()
                            
                                " gb vendor plugin
                                " (https://github.com/constabulary/gb/tree/master/cmd/gb-vendor)
                                let gb_vendor_root = src_path . "vendor" . go#util#PathSep()
                                if isdirectory(gb_vendor_root) && !s:HasPath(gb_vendor_root)
                                  let gopath = gb_vendor_root . go#util#PathListSep() . gopath
                                endif
                            
                                if !s:HasPath(src_path)
                                  let gopath =  src_path . go#util#PathListSep() . gopath
                                endif
                              endif
                            
                              " Godeps
                              let godeps_root = finddir("Godeps", current_dir .";")
                              if !empty(godeps_root)
                                let godeps_path = join([fnamemodify(godeps_root, ':p:h:h'), "Godeps", "_workspace" ], go#util#PathSep())
                            
                                if !s:HasPath(godeps_path)
                                  let gopath =  godeps_path . go#util#PathListSep() . gopath
                                endif
                              endif
                            
                              " Fix up the case where initial $GOPATH is empty,
                              " and we end up with a trailing :
                              let gopath = substitute(gopath, ":$", "", "")
                              return gopath
                            endfunction
                            
                            " BinPath returns the binary path of installed go tools.
    1              0.000002 function! go#path#BinPath() abort
                              let bin_path = go#config#BinPath()
                              if bin_path != ""
                                return bin_path
                              endif
                            
                              " check if our global custom path is set, if not check if $GOBIN is set so
                              " we can use it, otherwise use default GOPATH
                              if $GOBIN != ""
                                let bin_path = $GOBIN
                              else
                                let go_paths = split(go#path#Default(), go#util#PathListSep())
                                if len(go_paths) == 0
                                  return "" "nothing found
                                endif
                                let bin_path = expand(go_paths[0] . "/bin/")
                              endif
                            
                              return bin_path
                            endfunction
                            
                            " CheckBinPath checks whether the given binary exists or not and returns the
                            " path of the binary, respecting the go_bin_path and go_search_bin_path_first
                            " settings. It returns an empty string if the binary doesn't exist.
    1              0.000003 function! go#path#CheckBinPath(binpath) abort
                              " remove whitespaces if user applied something like 'goimports   '
                              let binpath = substitute(a:binpath, '^\s*\(.\{-}\)\s*$', '\1', '')
                            
                              " save original path
                              let old_path = $PATH
                            
                              " check if we have an appropriate bin_path
                              let go_bin_path = go#path#BinPath()
                              if !empty(go_bin_path)
                                " append our GOBIN and GOPATH paths and be sure they can be found there...
                                " let us search in our GOBIN and GOPATH paths
                                " respect the ordering specified by go_search_bin_path_first
                                if go#config#SearchBinPathFirst()
                                  let $PATH = go_bin_path . go#util#PathListSep() . $PATH
                                else
                                  let $PATH = $PATH . go#util#PathListSep() . go_bin_path
                                endif
                              endif
                            
                              " if it's in PATH just return it
                              if executable(binpath)
                                if exists('*exepath')
                                  let binpath = exepath(binpath)
                                endif
                                let $PATH = old_path
                            
                                if go#util#IsUsingCygwinShell() == 1
                                  return s:CygwinPath(binpath)
                                endif
                            
                                return binpath
                              endif
                            
                              " just get the basename
                              let basename = fnamemodify(binpath, ":t")
                              if !executable(basename)
                                call go#util#EchoError(printf("could not find '%s'. Run :GoInstallBinaries to fix it", basename))
                            
                                " restore back!
                                let $PATH = old_path
                                return ""
                              endif
                            
                              let $PATH = old_path
                            
                              if go#util#IsUsingCygwinShell() == 1
                                return s:CygwinPath(a:binpath)
                              endif
                            
                              return go_bin_path . go#util#PathSep() . basename
                            endfunction
                            
    1              0.000004 function! s:CygwinPath(path)
                               return substitute(a:path, '\\', '/', "g")
                            endfunction
                            
                            " go#path#ToURI converts path to a file URI. path should be an absolute path.
                            " Relative paths cannot be properly converted to a URI; when path is a
                            " relative path, the file scheme will not be prepended.
    1              0.000002 function! go#path#ToURI(path)
                              let l:absolute = !go#util#IsWin() && a:path[0] is# '/'
                              let l:prefix = ''
                              let l:path = a:path
                            
                              if go#util#IsWin() && l:path[1:2] is# ':\'
                                let l:absolute = 1
                                let l:prefix = '/' . l:path[0:1]
                                let l:path = l:path[2:]
                              endif
                            
                              return substitute(
                              \   (l:absolute ? 'file://' : '') . l:prefix . go#uri#EncodePath(l:path),
                              \   '\\',
                              \   '/',
                              \   'g',
                              \)
                            endfunction
                            
    1              0.000002 function! go#path#FromURI(uri) abort
                                let l:i = len('file://')
                                let l:encoded_path = a:uri[: l:i - 1] is# 'file://' ? a:uri[l:i :] : a:uri
                            
                                let l:path = go#uri#Decode(l:encoded_path)
                            
                                " If the path is like /C:/foo/bar, it should be C:\foo\bar instead.
                                if go#util#IsWin() && l:path =~# '^/[a-zA-Z]:'
                                    let l:path = substitute(l:path[1:], '/', '\\', 'g')
                                endif
                            
                                return l:path
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000011 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/job.vim
Sourced 1 time
Total time:   0.000574
 Self time:   0.000574

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000010 let s:cpo_save = &cpo
    1              0.000008 set cpo&vim
                            
                            " Spawn starts an asynchronous job. See the description of go#job#Options to
                            " understand the args parameter.
                            "
                            " Spawn returns a job.
    1              0.000004 function! go#job#Spawn(cmd, args)
                              let l:options = go#job#Options(a:args)
                              return go#job#Start(a:cmd, l:options)
                            endfunction
                            
                            " Options returns callbacks to be used with job_start. It is abstracted to be
                            " used with various go commands, such as build, test, install, etc.. This
                            " allows us to avoid writing the same callback over and over for some
                            " commands. It's fully customizable so each command can change it to its own
                            " logic.
                            "
                            " args is a dictionary with the these keys:
                            "   'bang':
                            "     Set to 0 to jump to the first error in the error list.
                            "     Defaults to 0.
                            "   'statustype':
                            "     The status type to use when updating the status.
                            "     See statusline.vim.
                            "   'for':
                            "     The g:go_list_type_command key to use to get the error list type to use.
                            "     Errors will not be handled when the value is '_'.
                            "     Defaults to '_job'
                            "   'errorformat':
                            "     The errorformat string to use when parsing errors. Defaults to
                            "     &errorformat.
                            "     See :help 'errorformat'.
                            "   'complete':
                            "     A function to call after the job exits and the channel is closed. The
                            "     function will be passed three arguments: the job, its exit code, and the
                            "     list of messages received from the channel. The default is a no-op. A
                            "     custom value can modify the messages before they are processed by the
                            "     returned exit_cb and close_cb callbacks. When the function is called,
                            "     the current window will be the window that was hosting the buffer when
                            "     the job was started. After it returns, the current window will be
                            "     restored to what it was before the function was called.
                            
                            " The return value is a dictionary with these keys:
                            "   'callback':
                            "     A function suitable to be passed as a job callback handler. See
                            "     job-callback.
                            "   'exit_cb':
                            "     A function suitable to be passed as a job exit_cb handler. See
                            "     job-exit_cb.
                            "   'close_cb':
                            "     A function suitable to be passed as a job close_cb handler. See
                            "     job-close_cb.
                            "   'cwd':
                            "     The path to the directory which contains the current buffer. The
                            "     callbacks are configured to expect this directory is the working
                            "     directory for the job; it should not be modified by callers.
    1              0.000003 function! go#job#Options(args)
                              let cbs = {}
                              let state = {
                                    \ 'winid': win_getid(winnr()),
                                    \ 'dir': getcwd(),
                                    \ 'jobdir': expand("%:p:h"),
                                    \ 'messages': [],
                                    \ 'bang': 0,
                                    \ 'for': "_job",
                                    \ 'exited': 0,
                                    \ 'exit_status': 0,
                                    \ 'closed': 0,
                                    \ 'errorformat': &errorformat,
                                    \ 'statustype' : ''
                                  \ }
                            
                              if has("patch-8.0.0902") || has('nvim')
                                let cbs.cwd = state.jobdir
                              endif
                            
                              if has_key(a:args, 'bang')
                                let state.bang = a:args.bang
                              endif
                            
                              if has_key(a:args, 'for')
                                let state.for = a:args.for
                              endif
                            
                              if has_key(a:args, 'statustype')
                                let state.statustype = a:args.statustype
                              endif
                            
                              if has_key(a:args, 'errorformat')
                                let state.errorformat = a:args.errorformat
                              endif
                            
                              function state.complete(job, exit_status, data)
                                if has_key(self, 'custom_complete')
                                  let l:winid = win_getid(winnr())
                                  " Always set the active window to the window that was active when the job
                                  " was started. Among other things, this makes sure that the correct
                                  " window's location list will be populated when the list type is
                                  " 'location' and the user has moved windows since starting the job.
                                  call win_gotoid(self.winid)
                                  call self.custom_complete(a:job, a:exit_status, a:data)
                                  call win_gotoid(l:winid)
                                endif
                            
                                call self.show_errors(a:job, a:exit_status, a:data)
                              endfunction
                            
                              function state.show_status(job, exit_status) dict
                                if self.statustype == ''
                                  return
                                endif
                            
                                if go#config#EchoCommandInfo()
                                  let prefix = '[' . self.statustype . '] '
                                  if a:exit_status == 0
                                    call go#util#EchoSuccess(prefix . "SUCCESS")
                                  else
                                    call go#util#EchoError(prefix . "FAIL")
                                  endif
                                endif
                            
                                let status = {
                                      \ 'desc': 'last status',
                                      \ 'type': self.statustype,
                                      \ 'state': "success",
                                      \ }
                            
                                if a:exit_status
                                  let status.state = "failed"
                                endif
                            
                                if has_key(self, 'started_at')
                                  let elapsed_time = reltimestr(reltime(self.started_at))
                                  " strip whitespace
                                  let elapsed_time = substitute(elapsed_time, '^\s*\(.\{-}\)\s*$', '\1', '')
                                  let status.state .= printf(" (%ss)", elapsed_time)
                                endif
                            
                                call go#statusline#Update(self.jobdir, status)
                              endfunction
                            
                              if has_key(a:args, 'complete')
                                let state.custom_complete = a:args.complete
                              endif
                            
                              " explicitly bind _start to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
                              "
                              " _start is intended only for internal use and should not be referenced
                              " outside of this file.
                              let cbs._start = function('s:start', [''], state)
                            
                              " explicitly bind callback to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
                              let cbs.callback = function('s:callback', [], state)
                            
                              " explicitly bind exit_cb to state so that within it, self will always refer
                              " to state. See :help Partial for more information.
                              let cbs.exit_cb = function('s:exit_cb', [], state)
                            
                              " explicitly bind close_cb to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
                              let cbs.close_cb = function('s:close_cb', [], state)
                            
                              function state.show_errors(job, exit_status, data)
                                if self.for == '_'
                                  return
                                endif
                            
                                let l:winid = win_getid(winnr())
                                " Always set the active window to the window that was active when the job
                                " was started. Among other things, this makes sure that the correct
                                " window's location list will be populated when the list type is
                                " 'location' and the user has moved windows since starting the job.
                                call win_gotoid(self.winid)
                            
                                let l:listtype = go#list#Type(self.for)
                                if a:exit_status == 0
                                  call go#list#Clean(l:listtype)
                                  call win_gotoid(l:winid)
                                  return
                                endif
                            
                                let l:listtype = go#list#Type(self.for)
                                if len(a:data) == 0
                                  call go#list#Clean(l:listtype)
                                  call win_gotoid(l:winid)
                                  return
                                endif
                            
                                let out = join(self.messages, "\n")
                            
                                let l:cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : 'cd'
                                try
                                  " parse the errors relative to self.jobdir
                                  execute l:cd fnameescape(self.jobdir)
                                  call go#list#ParseFormat(l:listtype, self.errorformat, out, self.for)
                                  let errors = go#list#Get(l:listtype)
                                finally
                                  execute l:cd fnameescape(self.dir)
                                endtry
                            
                            
                                if empty(errors)
                                  " failed to parse errors, output the original content
                                  call go#util#EchoError([self.dir] + self.messages)
                                  call win_gotoid(l:winid)
                                  return
                                endif
                            
                                " only open the error window if user was still in the window from which
                                " the job was started.
                                if self.winid == l:winid
                                  call go#list#Window(l:listtype, len(errors))
                                  if self.bang
                                    call win_gotoid(l:winid)
                                  else
                                    call go#list#JumpToFirst(l:listtype)
                                  endif
                                endif
                              endfunction
                            
                              return cbs
                            endfunction
                            
    1              0.000005 function! s:start(args) dict
                              if go#config#EchoCommandInfo() && self.statustype != ""
                                let prefix = '[' . self.statustype . '] '
                                call go#util#EchoSuccess(prefix . "dispatched")
                              endif
                            
                              if self.statustype != ''
                                let status = {
                                      \ 'desc': 'current status',
                                      \ 'type': self.statustype,
                                      \ 'state': "started",
                                      \ }
                            
                                call go#statusline#Update(self.jobdir, status)
                              endif
                              let self.started_at = reltime()
                            endfunction
                            
    1              0.000004 function! s:callback(chan, msg) dict
                              call add(self.messages, a:msg)
                            endfunction
                            
    1              0.000003 function! s:exit_cb(job, exitval) dict
                              let self.exit_status = a:exitval
                              let self.exited = 1
                            
                              call self.show_status(a:job, a:exitval)
                            
                              if self.closed || has('nvim')
                                call self.complete(a:job, self.exit_status, self.messages)
                              endif
                            endfunction
                            
    1              0.000003 function! s:close_cb(ch) dict
                              let self.closed = 1
                            
                              if self.exited
                                let job = ch_getjob(a:ch)
                                call self.complete(job, self.exit_status, self.messages)
                              endif
                            endfunction
                            
                            " go#job#Start runs a job. The options are expected to be the options
                            " suitable for Vim8 jobs. When called from Neovim, Vim8 options will be
                            " transformed to their Neovim equivalents.
    1              0.000002 function! go#job#Start(cmd, options)
                              let l:cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : 'cd'
                              let l:options = copy(a:options)
                            
                              if has('nvim')
                                let l:options = s:neooptions(l:options)
                              endif
                            
                              " Verify that the working directory for the job actually exists. Return
                              " early if the directory does not exist. This helps avoid errors when
                              " working with plugins that use virtual files that don't actually exist on
                              " the file system.
                              let l:filedir = expand("%:p:h")
                              if has_key(l:options, 'cwd') && !isdirectory(l:options.cwd)
                                  return
                              elseif !isdirectory(l:filedir)
                                return
                              endif
                            
                              let l:manualcd = 0
                              if !has_key(l:options, 'cwd')
                                " pre start
                                let l:manualcd = 1
                                let dir = getcwd()
                                execute l:cd fnameescape(filedir)
                              elseif !(has("patch-8.0.0902") || has('nvim'))
                                let l:manualcd = 1
                                let l:dir = l:options.cwd
                                execute l:cd fnameescape(l:dir)
                                call remove(l:options, 'cwd')
                              endif
                            
                              if has_key(l:options, '_start')
                                call l:options._start()
                                " remove _start to play nicely with vim (when vim encounters an unexpected
                                " job option it reports an "E475: invalid argument" error).
                                unlet l:options._start
                              endif
                            
                              " noblock was added in 8.1.350; remove it if it's not supported.
                              if has_key(l:options, 'noblock') && (has('nvim') || !has("patch-8.1.350"))
                                call remove(l:options, 'noblock')
                              endif
                            
                              if go#util#HasDebug('shell-commands')
                                call go#util#EchoInfo('job command: ' . string(a:cmd))
                              endif
                            
                              if has('nvim')
                                let l:input = []
                                if has_key(a:options, 'in_io') && a:options.in_io ==# 'file' && !empty(a:options.in_name)
                                  let l:input = readfile(a:options.in_name, "b")
                                endif
                            
                                let job = jobstart(a:cmd, l:options)
                            
                                if len(l:input) > 0
                                  call chansend(job, l:input)
                                  " close stdin to signal that no more bytes will be sent.
                                  call chanclose(job, 'stdin')
                                endif
                              else
                                let l:cmd = a:cmd
                                if go#util#IsWin()
                                  let l:cmd = join(map(copy(a:cmd), function('s:winjobarg')), " ")
                                endif
                            
                                let job = job_start(l:cmd, l:options)
                              endif
                            
                              if l:manualcd
                                " post start
                                execute l:cd fnameescape(l:dir)
                              endif
                            
                              return job
                            endfunction
                            
                            " s:neooptions returns a dictionary of job options suitable for use by Neovim
                            " based on a dictionary of job options suitable for Vim8.
    1              0.000003 function! s:neooptions(options)
                              let l:options = {}
                              let l:options['stdout_buf'] = ''
                              let l:options['stderr_buf'] = ''
                            
                              let l:err_mode = get(a:options, 'err_mode', get(a:options, 'mode', ''))
                              let l:out_mode = get(a:options, 'out_mode', get(a:options, 'mode', ''))
                            
                              for key in keys(a:options)
                                  if key == 'cwd'
                                    let l:options['cwd'] = a:options['cwd']
                                    continue
                                  endif
                            
                                  if key == 'callback'
                                    let l:options['callback'] = a:options['callback']
                            
                                    if !has_key(a:options, 'out_cb')
                                      let l:options['on_stdout'] = function('s:callback2on_stdout', [l:out_mode], l:options)
                                    endif
                            
                                    if !has_key(a:options, 'err_cb')
                                      let l:options['on_stderr'] = function('s:callback2on_stderr', [l:err_mode], l:options)
                                    endif
                            
                                    continue
                                  endif
                            
                                  if key == 'out_cb'
                                    let l:options['out_cb'] = a:options['out_cb']
                                    let l:options['on_stdout'] = function('s:on_stdout', [l:out_mode], l:options)
                            
                                    continue
                                  endif
                            
                                  if key == 'err_cb'
                                    let l:options['err_cb'] = a:options['err_cb']
                                    let l:options['on_stderr'] = function('s:on_stderr', [l:err_mode], l:options)
                            
                                    continue
                                  endif
                            
                                  if key == 'exit_cb'
                                    let l:options['exit_cb'] = a:options['exit_cb']
                                    let l:options['on_exit'] = function('s:on_exit', [], l:options)
                            
                                    continue
                                  endif
                            
                                  if key == 'close_cb'
                                    continue
                                  endif
                            
                                  if key == 'stoponexit'
                                    if a:options['stoponexit'] == ''
                                      let l:options['detach'] = 1
                                    endif
                                    continue
                                  endif
                              endfor
                              return l:options
                            endfunction
                            
    1              0.000005 function! s:callback2on_stdout(mode, ch, data, event) dict
                              let self.stdout_buf = s:neocb(a:mode, a:ch, self.stdout_buf, a:data, self.callback)
                            endfunction
                            
    1              0.000003 function! s:callback2on_stderr(mode, ch, data, event) dict
                              let self.stderr_buf = s:neocb(a:mode, a:ch, self.stderr_buf, a:data, self.callback)
                            endfunction
                            
    1              0.000002 function! s:on_stdout(mode, ch, data, event) dict
                              let self.stdout_buf = s:neocb(a:mode, a:ch, self.stdout_buf, a:data, self.out_cb)
                            endfunction
                            
    1              0.000003 function! s:on_stderr(mode, ch, data, event) dict
                              let self.stderr_buf = s:neocb(a:mode, a:ch, self.stderr_buf, a:data, self.err_cb )
                            endfunction
                            
    1              0.000003 function! s:on_exit(jobid, exitval, event) dict
                              call self.exit_cb(a:jobid, a:exitval)
                            endfunction
                            
    1              0.000004 function! go#job#Stop(job) abort
                              if has('nvim')
                                call jobstop(a:job)
                                return
                              endif
                            
                              call job_stop(a:job)
                              call go#job#Wait(a:job)
                              return
                            endfunction
                            
    1              0.000002 function! go#job#Wait(job) abort
                              if has('nvim')
                                call jobwait([a:job])
                                return
                              endif
                            
                              while job_status(a:job) is# 'run'
                                sleep 50m
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:winjobarg(idx, val) abort
                              if empty(a:val)
                                return '""'
                              endif
                              return a:val
                            endfunction
                            
    1              0.000003 function! s:neocb(mode, ch, buf, data, callback)
                              " dealing with the channel lines of Neovim is awful. The docs (:help
                              " channel-lines) say:
                              "     stream event handlers may receive partial (incomplete) lines. For a
                              "     given invocation of on_stdout etc, `a:data` is not guaranteed to end
                              "     with a newline.
                              "       - `abcdefg` may arrive as `['abc']`, `['defg']`.
                              "       - `abc\nefg` may arrive as `['abc', '']`, `['efg']` or `['abc']`,
                              "         `['','efg']`, or even `['ab']`, `['c','efg']`.
                              "
                              " Thankfully, though, this is explained a bit better in an issue:
                              " https://github.com/neovim/neovim/issues/3555. Specifically in these two
                              " comments:
                              "     * https://github.com/neovim/neovim/issues/3555#issuecomment-152290804
                              "     * https://github.com/neovim/neovim/issues/3555#issuecomment-152588749
                              "
                              " The key is
                              "     Every item in the list passed to job control callbacks represents a
                              "     string after a newline(Except the first, of course). If the program
                              "     outputs: "hello\nworld" the corresponding list is ["hello", "world"].
                              "     If the program outputs "hello\nworld\n", the corresponding list is
                              "     ["hello", "world", ""]. In other words, you can always determine if
                              "     the last line received is complete or not.
                              " and
                              "     for every list you receive in a callback, all items except the first
                              "     represent newlines.
                            
                              let l:buf = ''
                            
                              " A single empty string means EOF was reached. The first item will never be
                              " an empty string except for when it's the only item and is signaling that
                              " EOF was reached.
                              if len(a:data) == 1 && a:data[0] == ''
                                " when there's nothing buffered, return early so that an
                                " erroneous message will not be added.
                                if a:buf == ''
                                  return ''
                                endif
                            
                                let l:data = [a:buf]
                              else
                                let l:data = copy(a:data)
                                let l:data[0] = a:buf . l:data[0]
                            
                                " The last element may be a partial line; save it for next time.
                                if a:mode != 'raw'
                                  let l:buf = l:data[-1]
                                  let l:data = l:data[:-2]
                                endif
                              endif
                            
                              let l:i = 0
                              let l:last = len(l:data) - 1
                              while l:i <= l:last
                                let l:msg = l:data[l:i]
                                if a:mode == 'raw' && l:i < l:last
                                  let l:msg = l:msg . "\n"
                                endif
                                call a:callback(a:ch, l:msg)
                            
                                let l:i += 1
                              endwhile
                            
                              return l:buf
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000012 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/lsp/message.vim
Sourced 1 time
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000012 let s:cpo_save = &cpo
    1              0.000012 set cpo&vim
                            
    1              0.000004 function! go#lsp#message#Initialize(wd) abort
                              return {
                                      \ 'notification': 0,
                                      \ 'method': 'initialize',
                                      \ 'params': {
                                        \ 'processId': getpid(),
                                        \ 'rootUri': go#path#ToURI(a:wd),
                                        \ 'capabilities': {
                                          \ 'workspace': {
                                            \ 'workspaceFolders': v:true,
                                            \ 'didChangeConfiguration': {
                                              \ 'dynamicRegistration': v:true,
                                            \ },
                                            \ 'configuration': v:true,
                                          \ },
                                          \ 'textDocument': {
                                            \ 'hover': {
                                              \ 'contentFormat': ['plaintext'],
                                            \ },
                                          \ }
                                        \ },
                                        \ 'workspaceFolders': [s:workspaceFolder(0, a:wd)],
                                      \ }
                                   \ }
                            endfunction
                            
    1              0.000002 function! go#lsp#message#Initialized() abort
                              return {
                                      \ 'notification': 1,
                                      \ 'method': 'initialized',
                                      \ 'params': {},
                                   \ }
                            endfunction
                            
    1              0.000002 function! go#lsp#message#Shutdown() abort
                              return {
                                      \ 'notification': 0,
                                      \ 'method': 'shutdown',
                                   \ }
                            endfunction
                            
    1              0.000002 function! go#lsp#message#Exit() abort
                              return {
                                      \ 'notification': 1,
                                      \ 'method': 'exit',
                                   \ }
                            endfunction
                            
    1              0.000003 function! go#lsp#message#WorkspaceFoldersResult(dirs) abort
                              return map(copy(a:dirs), function('s:workspaceFolder', []))
                            endfunction
                            
    1              0.000003 function! go#lsp#message#Definition(file, line, col) abort
                              return {
                                      \ 'notification': 0,
                                      \ 'method': 'textDocument/definition',
                                      \ 'params': {
                                      \   'textDocument': {
                                      \       'uri': go#path#ToURI(a:file)
                                      \   },
                                      \   'position': s:position(a:line, a:col)
                                      \ }
                                   \ }
                            endfunction
                            
    1              0.000003 function! go#lsp#message#TypeDefinition(file, line, col) abort
                              return {
                                      \ 'notification': 0,
                                      \ 'method': 'textDocument/typeDefinition',
                                      \ 'params': {
                                      \   'textDocument': {
                                      \       'uri': go#path#ToURI(a:file)
                                      \   },
                                      \   'position': s:position(a:line, a:col)
                                      \ }
                                   \ }
                            endfunction
                            
    1              0.000003 function! go#lsp#message#DidOpen(file, content) abort
                              return {
                                      \ 'notification': 1,
                                      \ 'method': 'textDocument/didOpen',
                                      \ 'params': {
                                      \     'textDocument': {
                                      \         'uri': go#path#ToURI(a:file),
                                      \         'languageId': 'go',
                                      \         'text': a:content,
                                      \     }
                                      \ }
                                   \ }
                            endfunction
                            
    1              0.000003 function! go#lsp#message#DidChange(file, content) abort
                              return {
                                      \ 'notification': 1,
                                      \ 'method': 'textDocument/didChange',
                                      \ 'params': {
                                      \     'textDocument': {
                                      \         'uri': go#path#ToURI(a:file),
                                      \     },
                                      \     'contentChanges': [
                                      \       {
                                      \         'text': a:content,
                                      \       }
                                      \     ]
                                      \ }
                                   \ }
                            endfunction
                            
    1              0.000002 function! go#lsp#message#DidClose(file) abort
                              return {
                                      \ 'notification': 1,
                                      \ 'method': 'textDocument/didClose',
                                      \ 'params': {
                                      \     'textDocument': {
                                      \         'uri': go#path#ToURI(a:file),
                                      \     }
                                      \ }
                                   \ }
                            endfunction
                            
    1              0.000003 function! go#lsp#message#Completion(file, line, col) abort
                              return {
                                      \ 'notification': 0,
                                      \ 'method': 'textDocument/completion',
                                      \ 'params': {
                                      \   'textDocument': {
                                      \       'uri': go#path#ToURI(a:file)
                                      \   },
                                      \   'position': s:position(a:line, a:col),
                                      \ }
                                   \ }
                            endfunction
                            
    1              0.000003 function! go#lsp#message#Hover(file, line, col) abort
                              return {
                                      \ 'notification': 0,
                                      \ 'method': 'textDocument/hover',
                                      \ 'params': {
                                      \   'textDocument': {
                                      \       'uri': go#path#ToURI(a:file)
                                      \   },
                                      \   'position': s:position(a:line, a:col),
                                      \ }
                                   \ }
                            endfunction
                            
    1              0.000003 function! go#lsp#message#ChangeWorkspaceFolders(add, remove) abort
                              let l:addDirs = map(copy(a:add), function('s:workspaceFolder', []))
                              let l:removeDirs = map(copy(a:add), function('s:workspaceFolder', []))
                            
                              return {
                                      \ 'notification': 1,
                                      \ 'method': 'workspace/didChangeWorkspaceFolders',
                                      \ 'params': {
                                      \   'event': {
                                      \     'removed': l:removeDirs,
                                      \     'added': l:addDirs,
                                      \     },
                                      \ }
                                   \ }
                            
                            endfunction
                            
    1              0.000003 function! go#lsp#message#ConfigurationResult(items) abort
                              let l:result = []
                            
                              " results must be in the same order as the items
                              for l:item in a:items
                                let l:config = {
                                      \ 'buildFlags': [],
                                      \ 'hoverKind': 'NoDocumentation',
                                      \ }
                                let l:buildtags = go#config#BuildTags()
                                if buildtags isnot ''
                                  let l:config.buildFlags = extend(l:config.buildFlags, ['-tags', go#config#BuildTags()])
                                endif
                            
                                let l:result = add(l:result, l:config)
                              endfor
                            
                              return l:result
                            endfunction
                            
    1              0.000006 function s:workspaceFolder(key, val) abort
                              return {'uri': go#path#ToURI(a:val), 'name': a:val}
                            endfunction
                            
    1              0.000003 function! s:position(line, col) abort
                              return {'line': a:line, 'character': a:col}
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000009 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/uri.vim
Sourced 1 time
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000011 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000004 function! go#uri#Encode(value) abort
                                return s:encode(a:value, '[^A-Za-z0-9_.~-]')
                            endfunction
                            
    1              0.000002 function! go#uri#EncodePath(value) abort
                                let l:separator = '/'
                                if go#util#IsWin()
                                  let l:separator = '\\'
                                endif
                                return s:encode(a:value, '[^' . l:separator . 'A-Za-z0-9_.~-]')
                            endfunction
                            
    1              0.000004 function! s:encode(value, unreserved)
                                return substitute(
                                \   a:value,
                                \   a:unreserved,
                                \   '\="%".printf(''%02X'', char2nr(submatch(0)))',
                                \   'g'
                                \)
                            endfunction
                            
    1              0.000002 function! go#uri#Decode(value) abort
                                return substitute(
                                \   a:value,
                                \   '%\(\x\x\)',
                                \   '\=nr2char(''0X'' . submatch(1))',
                                \   'g'
                                \)
                            endfunction
                            " restore Vi compatibility settings
    1              0.000008 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/statusline.vim
Sourced 1 time
Total time:   0.000259
 Self time:   0.000259

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000012 let s:cpo_save = &cpo
    1              0.000009 set cpo&vim
                            
                            " Statusline
                            """"""""""""""""""""""""""""""""
                            
                            " s:statuses is a global reference to all statuses. It stores the statuses per
                            " import paths (map[string]status), where each status is unique per its
                            " type. Current status dict is in form:
                            " {
                            "   'desc'        : 'Job description',
                            "   'state'       : 'Job state, such as success, failure, etc..',
                            "   'type'        : 'Job type, such as build, test, etc..'
                            "   'created_at'  : 'Time it was created as seconds since 1st Jan 1970'
                            " }
    1              0.000007 let s:statuses = {}
                            
                            " timer_id for cleaner
    1              0.000004 let s:timer_id = 0
                            
                            " last_status stores the last generated text per status
    1              0.000008 let s:last_status = ""
                            
                            " Show returns the current status of the job for 20 seconds (configurable). It
                            " displays it in form of 'desc: [type|state]' if there is any state available,
                            " if not it returns an empty string. This function should be plugged directly
                            " into the statusline.
    1              0.000006 function! go#statusline#Show() abort
                              " lazy initialization of the cleaner
                              if !s:timer_id
                                let interval = go#config#StatuslineDuration()
                                let s:timer_id = timer_start(interval, function('go#statusline#Clear'), {'repeat': -1})
                              endif
                            
                              " nothing to show
                              if empty(s:statuses)
                                return ''
                              endif
                            
                              let status_dir =  expand('%:p:h')
                            
                              if !has_key(s:statuses, status_dir)
                                return ''
                              endif
                            
                              let status = s:statuses[status_dir]
                              if !has_key(status, 'desc') || !has_key(status, 'state') || !has_key(status, 'type')
                                return ''
                              endif
                            
                              let status_text = printf("[%s|%s]", status.type, status.state)
                              if empty(status_text)
                                return ''
                              endif
                            
                              " only update highlight if status has changed.
                              if status_text != s:last_status
                                if status.state =~ "success" || status.state =~ "finished" || status.state =~ "pass" || status.state =~ 'initialized'
                                  hi goStatusLineColor cterm=bold ctermbg=76 ctermfg=22 guibg=#5fd700 guifg=#005f00
                                elseif status.state =~ "started" || status.state =~ "analysing" || status.state =~ "compiling" || status.state =~ 'initializing'
                                  hi goStatusLineColor cterm=bold ctermbg=208 ctermfg=88 guibg=#ff8700 guifg=#870000
                                elseif status.state =~ "failed"
                                  hi goStatusLineColor cterm=bold ctermbg=196 ctermfg=52 guibg=#ff0000 guifg=#5f0000
                                endif
                              endif
                            
                              let s:last_status = status_text
                              return status_text
                            endfunction
                            
                            " Update updates (adds) the statusline for the given status_dir with the
                            " given status dict. It overrides any previously set status.
    1              0.000004 function! go#statusline#Update(status_dir, status) abort
                              let a:status.created_at = reltime()
                              let s:statuses[a:status_dir] = a:status
                            
                              " force to update the statusline, otherwise the user needs to move the
                              " cursor
                              exe 'let &ro = &ro'
                            
                              " before we stop the timer, check if we have any previous jobs to be cleaned
                              " up. Otherwise every job will reset the timer when this function is called
                              " and thus old jobs will never be cleaned
                              call s:clear()
                            
                              " also reset the timer, so the user has time to see it in the statusline.
                              " Setting the timer_id to 0 will cause a new timer to be created the next
                              " time the go#statusline#Show() is called.
                              call timer_stop(s:timer_id)
                              let s:timer_id = 0
                            endfunction
                            
                            " Clear clears all currently stored statusline data. The timer_id argument is
                            " just a placeholder so we can pass it to a timer_start() function if needed.
    1              0.000003 function! go#statusline#Clear(timer_id) abort
                              call s:clear()
                            endfunction
                            
    1              0.000003 function! s:clear()
                              for [status_dir, status] in items(s:statuses)
                                let elapsed_time = reltimestr(reltime(status.created_at))
                                " strip whitespace
                                let elapsed_time = substitute(elapsed_time, '^\s*\(.\{-}\)\s*$', '\1', '')
                            
                                if str2nr(elapsed_time) > 10
                                  call remove(s:statuses, status_dir)
                                endif
                              endfor
                            
                              if len(s:statuses) == 0
                                let s:statuses = {}
                              endif
                            
                              " force to update the statusline, otherwise the user needs to move the
                              " cursor
                              exe 'let &ro = &ro'
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000011 let &cpo = s:cpo_save
    1              0.000006 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-signify/autoload/sy.vim
Sourced 1 time
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
                            " vim: et sw=2 sts=2
                            
    1              0.000004 scriptencoding utf-8
                            
                            " Function: #start {{{1
    1              0.000003 function! sy#start() abort
                              if g:signify_locked
                                call sy#verbose('Locked.')
                                return
                              endif
                            
                              let sy_path = resolve(expand('%:p'))
                              if has('win32')
                                let sy_path = substitute(sy_path, '\v^(\w):\\\\', '\1:\\', '')
                              endif
                            
                              if s:skip(sy_path)
                                call sy#verbose('Skip file: '. sy_path)
                                if exists('b:sy')
                                  call sy#sign#remove_all_signs(bufnr(''))
                                  unlet! b:sy
                                endif
                                return
                              endif
                            
                              if !exists('b:sy') || b:sy.path != sy_path
                                call sy#verbose('Register new file: '. sy_path)
                                let b:sy = {
                                      \ 'path':       sy_path,
                                      \ 'buffer':     bufnr(''),
                                      \ 'active':     0,
                                      \ 'detecting':  0,
                                      \ 'vcs':        [],
                                      \ 'hunks':      [],
                                      \ 'signid':     0x100,
                                      \ 'updated_by': '',
                                      \ 'stats':      [-1, -1, -1],
                                      \ 'info':       {
                                      \    'dir':  fnamemodify(sy_path, ':p:h'),
                                      \    'path': sy#util#escape(sy_path),
                                      \    'file': sy#util#escape(fnamemodify(sy_path, ':t'))
                                      \ }}
                                if get(g:, 'signify_disable_by_default')
                                  call sy#verbose('Disabled by default.')
                                  return
                                endif
                                let b:sy.active = 1
                                call sy#repo#detect()
                              elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
                              elseif !b:sy.active
                                call sy#verbose('Inactive buffer.')
                                return
                              elseif empty(b:sy.vcs)
                                if get(b:sy, 'retry')
                                  let b:sy.retry = 0
                                  call sy#verbose('Redetecting VCS.')
                                  call sy#repo#detect()
                                else
                                  if get(b:sy, 'detecting')
                                    call sy#verbose('Detection is already in progress.')
                                  else
                                    call sy#verbose('No VCS found. Disabling.')
                                    call sy#disable()
                                  endif
                                endif
                              else
                                for vcs in b:sy.vcs
                                  let job_id = get(b:, 'sy_job_id_'. vcs)
                                  if type(job_id) != type(0) || job_id > 0
                                    call sy#verbose('Update is already in progress.', vcs)
                                  else
                                    call sy#verbose('Updating signs.', vcs)
                                    call sy#repo#get_diff(vcs, function('sy#sign#set_signs'))
                                  endif
                                endfor
                              endif
                            endfunction
                            
                            " Function: #stop {{{1
    1              0.000003 function! sy#stop(bufnr) abort
                              let sy = getbufvar(a:bufnr, 'sy')
                              if empty(sy)
                                return
                              endif
                            
                              call sy#sign#remove_all_signs(a:bufnr)
                            endfunction
                            
                            " Function: #enable {{{1
    1              0.000002 function! sy#enable() abort
                              if !exists('b:sy')
                                call sy#start()
                                return
                              endif
                            
                              if !b:sy.active
                                let b:sy.active = 1
                                let b:sy.retry  = 1
                                call sy#start()
                              endif
                            endfunction
                            
                            " Function: #disable {{{1
    1              0.000002 function! sy#disable() abort
                              if exists('b:sy') && b:sy.active
                                call sy#stop(b:sy.buffer)
                                let b:sy.active = 0
                                let b:sy.stats = [-1, -1, -1]
                              endif
                            endfunction
                            
                            " Function: #toggle {{{1
    1              0.000002 function! sy#toggle() abort
                              if !exists('b:sy') || !b:sy.active
                                call sy#enable()
                              else
                                call sy#disable()
                              endif
                            endfunction
                            
                            " Function: #buffer_is_active {{{1
    1              0.000002 function! sy#buffer_is_active()
                              return exists('b:sy') && b:sy.active
                            endfunction
                            
                            " Function: #verbose {{{1
    1              0.000002 function! sy#verbose(msg, ...) abort
                              if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
                              endif
                            endfunction
                            
                            " Function: s:skip {{{1
    1              0.000004 function! s:skip(path)
                              if &diff || !filereadable(a:path)
                                return 1
                              endif
                            
                              if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, &filetype)
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help') && (&buftype == 'help')
                                  return 1
                                endif
                              endif
                            
                              if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
                              endif
                            
                              if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
                              endif
                            
                              return 0
                            endfunction

SCRIPT  /home/c5262761/configit/vim/modules/vim-signify/autoload/sy/util.vim
Sourced 1 time
Total time:   0.000220
 Self time:   0.000220

count  total (s)   self (s)
                            " vim: et sw=2 sts=2
                            
    1              0.000004 scriptencoding utf-8
                            
                            " Function: #escape {{{1
    1              0.000004 function! sy#util#escape(path) abort
                              if exists('+shellslash')
                                let old_ssl = &shellslash
                                if fnamemodify(&shell, ':t') == 'cmd.exe'
                                  set noshellslash
                                else
                                  set shellslash
                                endif
                              endif
                            
                              let path = shellescape(a:path)
                            
                              if exists('old_ssl')
                                let &shellslash = old_ssl
                              endif
                            
                              return path
                            endfunction
                            
                            " Function: #refresh_windows {{{1
    1              0.000002 function! sy#util#refresh_windows() abort
                              if exists('*win_getid')
                                let winid = win_getid()
                              else
                                let winnr = winnr()
                              endif
                            
                              if !get(g:, 'signify_cmdwin_active')
                                keepjumps windo if exists('b:sy') | call sy#start() | endif
                              endif
                            
                              if exists('winid')
                                call win_gotoid(winid)
                              else
                                execute winnr .'wincmd w'
                              endif
                            endfunction
                            
                            " Function: #hunk_text_object {{{1
    1              0.000003 function! sy#util#hunk_text_object(emptylines) abort
                              execute sy#util#return_if_no_changes()
                            
                              let lnum  = line('.')
                              let hunks = filter(copy(b:sy.hunks), 'v:val.start <= lnum && v:val.end >= lnum')
                            
                              if empty(hunks)
                                echomsg 'signify: Here is no hunk.'
                                return
                              endif
                            
                              execute hunks[0].start
                              normal! V
                            
                              if a:emptylines
                                let lnum = hunks[0].end
                                while getline(lnum+1) =~ '^$'
                                  let lnum += 1
                                endwhile
                                execute lnum
                              else
                                execute hunks[0].end
                              endif
                            endfunction
                            
                            " Function: #shell_redirect {{{1
    1              0.000003 function! sy#util#shell_redirect(path) abort
                              " if shellredir contains a %s it is replaced with the path
                              " otherwise, just append it (from :help shellredir:
                              "   The name of the temporary file can be represented by '%s' if necessary
                              "   (the file name is appended automatically if no %s appears in the value
                              "   of this option)
                              if &shellredir =~# '%s'
                                return substitute(&shellredir, '\C%s', a:path, 'g')
                              else
                                return &shellredir .' '. a:path
                              endif
                            endfunction
                            
                            " Function: #chdir {{{1
    1              0.000002 function! sy#util#chdir() abort
                              let chdir = haslocaldir()
                                    \ ? 'lcd'
                                    \ : (exists(':tcd') && haslocaldir(-1, 0)) ? 'tcd' : 'cd'
                              return [getcwd(), chdir]
                            endfunction
                            
                            " Function: #has_changes {{{1
    1              0.000003 function! sy#util#return_if_no_changes() abort
                              if !exists('b:sy') || empty(b:sy.hunks)
                                echomsg 'signify: There are no changes.'
                                return 'return'
                              endif
                              return ''
                            endfunction
                            
                            " Function: #execute {{{1
    1              0.000002 function! sy#util#execute(cmd) abort
                              let lang = v:lang
                              redir => output
                                silent! execute a:cmd
                              redir END
                              silent! execute 'language message' lang
                              return output
                            endfunction
                            
    1              0.000004 let s:popup_window = 0
                            
                            " Function: #popup_close {{{1
    1              0.000002 function! sy#util#popup_close() abort
                              if s:popup_window
                                call nvim_win_close(s:popup_window, 1)
                                let s:popup_window = 0
                              endif
                            endfunction
                            
                            " Function: #popup_create {{{1
    1              0.000012 function! sy#util#popup_create(hunkdiff) abort
                              let offset      = s:offset()
                              let winline     = winline()
                              let min_height  = 6
                              let max_height  = winheight('%') - winline
                              let diff_height = len(a:hunkdiff)
                              let height      = min([diff_height, max_height])
                            
                              if diff_height > max_height && max_height < min_height
                                let max_scroll = min_height - max_height
                                let scroll     = min([max_scroll, diff_height - max_height])
                                " Old versions don't have feedkeys(..., 'x')
                                execute 'normal!' scroll.''
                                let winline -= scroll
                                let height  += scroll
                              endif
                            
                              if exists('*nvim_open_win')
                                call sy#util#popup_close()
                                let buf = nvim_create_buf(0, 1)
                                call nvim_buf_set_option(buf, 'syntax', 'diff')
                                call nvim_buf_set_lines(buf, 0, -1, 0, a:hunkdiff)
                                let s:popup_window = nvim_open_win(buf, v:false, {
                                      \ 'relative': 'win',
                                      \ 'row': winline,
                                      \ 'col': offset - 1,
                                      \ 'width': winwidth('%') - offset + 1,
                                      \ 'height': height,
                                      \ })
                                call nvim_win_set_option(s:popup_window, 'cursorline', v:false)
                                call nvim_win_set_option(s:popup_window, 'foldcolumn', 0)
                                call nvim_win_set_option(s:popup_window, 'foldenable', v:false)
                                call nvim_win_set_option(s:popup_window, 'number', v:false)
                                call nvim_win_set_option(s:popup_window, 'relativenumber', v:false)
                                call nvim_win_set_option(s:popup_window, 'wrap', v:true)
                                autocmd CursorMoved * ++once call sy#util#popup_close()
                              elseif exists('*popup_create')
                                let s:popup_window = popup_create(a:hunkdiff, {
                                      \ 'line': 'cursor+1',
                                      \ 'col': offset,
                                      \ 'minwidth': winwidth('%'),
                                      \ 'maxheight': height,
                                      \ 'moved': 'any',
                                      \ 'zindex': 1000,
                                      \ })
                                call setbufvar(winbufnr(s:popup_window), '&syntax', 'diff')
                              else
                                return 0
                              endif
                            
                              return 1
                            endfunction
                            
                            " Function: s:offset {{{1
    1              0.000003 function! s:offset() abort
                              let offset = &foldcolumn
                              let offset += 2  " FIXME: Find better way to calculate the sign column width.
                              if &number
                                let l = len(line('$')) + 1
                                let offset += (&numberwidth > l) ? &numberwidth : l
                              elseif &relativenumber
                                let l = len(winheight('%')) + 1
                                let offset += (&numberwidth > l) ? &numberwidth : l
                              endif
                              return offset
                            endfunction

SCRIPT  /home/c5262761/configit/vim/modules/vim-signify/autoload/sy/repo.vim
Sourced 1 time
Total time:   0.000876
 Self time:   0.000820

count  total (s)   self (s)
                            " vim: et sw=2 sts=2
                            
    1              0.000004 scriptencoding utf-8
                            
                            " Function: #detect {{{1
    1              0.000003 function! sy#repo#detect() abort
                              for vcs in s:vcs_list
                                let b:sy.detecting += 1
                                call sy#repo#get_diff(vcs, function('sy#sign#set_signs'))
                              endfor
                            endfunction
                            
                            " Function: s:callback_nvim_stdout{{{1
    1              0.000004 function! s:callback_nvim_stdout(_job_id, data, _event) dict abort
                              let self.stdoutbuf[-1] .= a:data[0]
                              call extend(self.stdoutbuf, a:data[1:])
                            endfunction
                            
                            " Function: s:callback_nvim_exit {{{1
    1              0.000004 function! s:callback_nvim_exit(_job_id, exitval, _event) dict abort
                              return s:handle_diff(self, a:exitval)
                            endfunction
                            
                            " Function: s:callback_vim_stdout {{{1
    1              0.000013 function! s:callback_vim_stdout(_job_id, data) dict abort
                              let self.stdoutbuf += [a:data]
                            endfunction
                            
                            " Function: s:callback_vim_close {{{1
    1              0.000004 function! s:callback_vim_close(channel) dict abort
                              let job = ch_getjob(a:channel)
                              while 1
                                if job_status(job) == 'dead'
                                  let exitval = job_info(job).exitval
                                  break
                                endif
                                sleep 10m
                              endwhile
                              return s:handle_diff(self, exitval)
                            endfunction
                            
                            " Function: sy#get_diff {{{1
    1              0.000003 function! sy#repo#get_diff(vcs, func) abort
                              call sy#verbose('sy#repo#get_diff()', a:vcs)
                              let job_id = get(b:, 'sy_job_id_'.a:vcs)
                              let [cmd, options] = s:initialize_job(a:vcs)
                              let options.func = a:func
                            
                              " Neovim
                              if has('nvim')
                                if job_id
                                  silent! call jobstop(job_id)
                                endif
                            
                                let [cwd, chdir] = sy#util#chdir()
                                call sy#verbose(['CMD: '. string(cmd), 'CMD DIR:  '. b:sy.info.dir, 'ORIG DIR: '. cwd], a:vcs)
                            
                                try
                                  execute chdir fnameescape(b:sy.info.dir)
                                catch
                                  echohl ErrorMsg
                                  echomsg 'signify: Changing directory failed: '. b:sy.info.dir
                                  echohl NONE
                                  return
                                endtry
                                let b:sy_job_id_{a:vcs} = jobstart(cmd, extend(options, {
                                      \ 'on_stdout': function('s:callback_nvim_stdout'),
                                      \ 'on_exit':   function('s:callback_nvim_exit'),
                                      \ }))
                                execute chdir fnameescape(cwd)
                            
                              " Newer Vim
                              elseif has('patch-7.4.1967')
                                if type(job_id) != type(0)
                                  silent! call job_stop(job_id)
                                endif
                            
                                let [cwd, chdir] = sy#util#chdir()
                                call sy#verbose(['CMD: '. string(cmd), 'CMD DIR:  '. b:sy.info.dir, 'ORIG DIR: '. cwd], a:vcs)
                            
                                try
                                  execute chdir fnameescape(b:sy.info.dir)
                                catch
                                  echohl ErrorMsg
                                  echomsg 'signify: Changing directory failed: '. b:sy.info.dir
                                  echohl NONE
                                  return
                                endtry
                                let opts = {
                                      \ 'in_io':    'null',
                                      \ 'out_cb':   function('s:callback_vim_stdout', options),
                                      \ 'close_cb': function('s:callback_vim_close', options),
                                      \ }
                                let b:sy_job_id_{a:vcs} = job_start(cmd, opts)
                                execute chdir fnameescape(cwd)
                            
                              " Older Vim
                              else
                                let options.stdoutbuf = split(s:run(a:vcs), '\n')
                                call s:handle_diff(options, v:shell_error)
                              endif
                            endfunction
                            
                            " Function: s:handle_diff {{{1
    1              0.000003 function! s:handle_diff(options, exitval) abort
                              call sy#verbose('s:handle_diff()', a:options.vcs)
                            
                              let sy = getbufvar(a:options.bufnr, 'sy')
                              if empty(sy)
                                call sy#verbose(printf('No b:sy found for %s', bufname(a:options.bufnr)), a:options.vcs)
                                return
                              elseif !empty(sy.updated_by) && sy.updated_by != a:options.vcs
                                call sy#verbose(printf('Signs already got updated by %s.', sy.updated_by), a:options.vcs)
                                return
                              elseif empty(sy.vcs) && sy.active
                                let sy.detecting -= 1
                              endif
                            
                              if (&fenc != &enc) && has('iconv')
                                call map(a:options.stdoutbuf, 'iconv(v:val, &fenc, &enc)')
                              endif
                            
                              let [found_diff, diff] = s:check_diff_{a:options.vcs}(a:exitval, a:options.stdoutbuf)
                              if found_diff
                                if index(sy.vcs, a:options.vcs) == -1
                                  let sy.vcs += [a:options.vcs]
                                endif
                                call a:options.func(sy, a:options.vcs, diff)
                              else
                                call sy#verbose('No valid diff found. Disabling this VCS.', a:options.vcs)
                              endif
                            
                              call setbufvar(a:options.bufnr, 'sy_job_id_'.a:options.vcs, 0)
                            endfunction
                            
                            " Function: s:check_diff_git {{{1
    1              0.000003 function! s:check_diff_git(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " Function: s:check_diff_yadm {{{1
    1              0.000003 function! s:check_diff_yadm(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " Function: s:check_diff_hg {{{1
    1              0.000003 function! s:check_diff_hg(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " Function: s:check_diff_svn {{{1
    1              0.000002 function! s:check_diff_svn(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " Function: s:check_diff_bzr {{{1
    1              0.000005 function! s:check_diff_bzr(exitval, diff) abort
                              return (a:exitval =~ '[012]') ? [1, a:diff] : [0, []]
                            endfunction
                            
                            " Function: s:check_diff_darcs {{{1
    1              0.000003 function! s:check_diff_darcs(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " Function: s:check_diff_fossil {{{1
    1              0.000005 function! s:check_diff_fossil(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " Function: s:check_diff_cvs {{{1
    1              0.000006 function! s:check_diff_cvs(exitval, diff) abort
                              let [found_diff, diff] = [0, []]
                              if a:exitval == 1
                                for diffline in a:diff
                                  if diffline =~ '^+++'
                                    let [found_diff, diff] = [1, a:diff]
                                    break
                                  endif
                                endfor
                              elseif a:exitval == 0 && len(a:diff) == 0
                                let found_diff = 1
                              endif
                              return [found_diff, diff]
                            endfunction
                            
                            " Function: s:check_diff_rcs {{{1
    1              0.000004 function! s:check_diff_rcs(exitval, diff) abort
                              return (a:exitval == 2) ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " Function: s:check_diff_accurev {{{1
    1              0.000004 function! s:check_diff_accurev(exitval, diff) abort
                              return (a:exitval >= 2) ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " Function: s:check_diff_perforce {{{1
    1              0.000005 function! s:check_diff_perforce(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, a:diff]
                            endfunction
                            
                            " Function: s:check_diff_tfs {{{1
    1              0.000006 function! s:check_diff_tfs(exitval, diff) abort
                              return a:exitval ? [0, []] : [1, s:strip_context(a:diff)]
                            endfunction
                            
                            " Function: #get_stats {{{1
    1              0.000004 function! sy#repo#get_stats() abort
                              return exists('b:sy') ? b:sy.stats : [-1, -1, -1]
                            endfunction
                            
                            " Function: #debug_detection {{{1
    1              0.000004 function! sy#repo#debug_detection()
                              if !exists('b:sy')
                                echomsg 'signify: I cannot detect any changes!'
                                return
                              endif
                            
                              for vcs in s:vcs_list
                                let cmd = s:expand_cmd(vcs, g:signify_vcs_cmds)
                                echohl Statement
                                echo cmd
                                echo repeat('=', len(cmd))
                                echohl NONE
                            
                                let diff = s:run(vcs)
                                if v:shell_error
                                  echohl ErrorMsg
                                  echo diff
                                  echohl NONE
                                else
                                  echo empty(diff) ? "<none>" : diff
                                endif
                                echo "\n"
                              endfor
                            endfunction
                            
                            " Function: #diffmode {{{1
    1              0.000002 function! sy#repo#diffmode(do_tab) abort
                              execute sy#util#return_if_no_changes()
                            
                              let vcs = b:sy.updated_by
                              if !has_key(g:signify_vcs_cmds_diffmode, vcs)
                                echomsg 'SignifyDiff has no support for: '. vcs
                                echomsg 'Open an issue for it at: https://github.com/mhinz/vim-signify/issues'
                                return
                              endif
                              let cmd = s:expand_cmd(vcs, g:signify_vcs_cmds_diffmode)
                              call sy#verbose('SignifyDiff: '. cmd, vcs)
                              let ft = &filetype
                              let fenc = &fenc
                              if a:do_tab
                                tabedit %
                              endif
                              diffthis
                              let [cwd, chdir] = sy#util#chdir()
                              try
                                execute chdir fnameescape(b:sy.info.dir)
                                leftabove vnew
                                if (fenc != &enc) && has('iconv')
                                  silent put =iconv(system(cmd), fenc, &enc)
                                else
                                  silent put =system(cmd)
                                endif
                              finally
                                execute chdir fnameescape(cwd)
                              endtry
                              silent 1delete
                              set buftype=nofile bufhidden=wipe nomodified
                              let &filetype = ft
                              diffthis
                              wincmd p
                              normal! ]czt
                            endfunction
                            
                            " Function: #preview_hunk {{{1
    1              0.000002 function! sy#repo#preview_hunk() abort
                              if exists('b:sy') && !empty(b:sy.updated_by)
                                call sy#repo#get_diff(b:sy.updated_by, function('s:preview_hunk'))
                              endif
                            endfunction
                            
    1              0.000004 function! s:preview_hunk(_sy, vcs, diff) abort
                              call sy#verbose('s:preview_hunk()', a:vcs)
                            
                              let in_hunk = 0
                              let hunk = []
                            
                              for line in a:diff
                                if in_hunk
                                  if line[:2] == '@@ ' || empty(line)
                                    break
                                  endif
                                  call add(hunk, line)
                                elseif line[:2] == '@@ ' && s:is_cur_line_in_hunk(line)
                                  let in_hunk = 1
                                endif
                              endfor
                            
                              if !in_hunk
                                return
                              endif
                            
                              if sy#util#popup_create(hunk)
                                return
                              endif
                            
                              silent! wincmd P
                              if !&previewwindow
                                noautocmd botright new
                              endif
                              call setline(1, hunk)
                              silent! %foldopen!
                              setlocal previewwindow filetype=diff buftype=nofile bufhidden=delete
                              " With :noautocmd wincmd p, the first line of the preview window would show
                              " the 'cursorline', although it's not focused. Use feedkeys() instead.
                              noautocmd call feedkeys("\<c-w>p", 'nt')
                            endfunction
                            
    1              0.000004 function! s:is_cur_line_in_hunk(hunkline) abort
                              let cur_line = line('.')
                              let [_old_line, new_line, old_count, new_count] = sy#sign#parse_hunk(a:hunkline)
                            
                              if cur_line == 1 && new_line == 0
                                " deleted first line
                                return 1
                              endif
                            
                              if cur_line == new_line && new_count < old_count
                                " deleted lines
                                return 1
                              endif
                            
                              if cur_line >= new_line && cur_line < (new_line + new_count)
                                " added/changed lines
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            " Function: s:initialize_job {{{1
    1              0.000003 function! s:initialize_job(vcs) abort
                              let vcs_cmd = s:expand_cmd(a:vcs, g:signify_vcs_cmds)
                              if has('win32')
                                if has('nvim')
                                  let cmd = &shell =~ '\v%(cmd|powershell)' ? vcs_cmd : ['sh', '-c', vcs_cmd]
                                else
                                  if &shell =~ 'cmd'
                                    let cmd = join([&shell, &shellcmdflag, '(', vcs_cmd, ')'])
                                  elseif empty(&shellxquote)
                                    let cmd = join([&shell, &shellcmdflag, &shellquote, vcs_cmd, &shellquote])
                                  else
                                    let cmd = join([&shell, &shellcmdflag, &shellxquote, vcs_cmd, &shellxquote])
                                  endif
                                endif
                              else
                                let cmd = ['sh', '-c', vcs_cmd]
                              endif
                              let options = {
                                    \ 'stdoutbuf':   [''],
                                    \ 'vcs':         a:vcs,
                                    \ 'bufnr':       bufnr('%'),
                                    \ }
                              return [cmd, options]
                            endfunction
                            
                            " Function: s:get_vcs_path {{{1
    1              0.000002 function! s:get_vcs_path(vcs) abort
                              return (a:vcs =~# '\v(git|cvs|accurev|tfs|yadm)') ? b:sy.info.file : b:sy.info.path
                            endfunction
                            
                            " Function: s:expand_cmd {{{1
    1              0.000002 function! s:expand_cmd(vcs, vcs_cmds) abort
                              let cmd = a:vcs_cmds[a:vcs]
                              let cmd = s:replace(cmd, '%f', s:get_vcs_path(a:vcs))
                              let cmd = s:replace(cmd, '%d', s:difftool)
                              let cmd = s:replace(cmd, '%n', s:devnull)
                              return cmd
                            endfunction
                            
                            " Function: s:run {{{1
    1              0.000002 function! s:run(vcs)
                              let [cwd, chdir] = sy#util#chdir()
                              try
                                execute chdir fnameescape(b:sy.info.dir)
                                let ret = system(s:expand_cmd(a:vcs, g:signify_vcs_cmds))
                              catch
                                " This exception message can be seen via :SignifyDebugUnknown.
                                " E.g. unquoted VCS programs in vcd_cmds can lead to E484.
                                let ret = v:exception .' at '. v:throwpoint
                              finally
                                execute chdir fnameescape(cwd)
                                return ret
                              endtry
                            endfunction
                            
                            " Function: s:replace {{{1
    1              0.000003 function! s:replace(cmd, pat, sub)
                              let parts = split(a:cmd, a:pat, 1)
                              return join(parts, a:sub)
                            endfunction
                            
                            " Function: s:strip_context {{{1
    1              0.000003 function! s:strip_context(context)
                              let diff = []
                              let hunk = []
                              let state = 0
                              let lines = a:context
                              let linenr = 0
                            
                              while linenr < len(lines)
                                let line = lines[linenr]
                            
                                if state == 0
                                  if line =~ "^@@ "
                                    let [old_line, new_line, old_count, new_count] = sy#sign#parse_hunk(line)
                                    let hunk = []
                                    let state = 1
                                  else
                                    call add(diff,line)
                                  endif
                                  let linenr += 1
                                elseif index([1,2,3],state) >= 0 && index(['\','/'],line[0]) >= 0
                                  let linenr += 1
                                  call add(hunk,line)
                                elseif state == 1
                                  if line[0] == ' '
                                    let old_line += 1
                                    let new_line += 1
                                    let old_count -= 1
                                    let new_count -= 1
                                    let linenr += 1
                                  else
                                    let old_count_part = 0
                                    let new_count_part = 0
                                    let state = 2
                                  endif
                                elseif state == 2
                                  if line[0] == '-'
                                    call add(hunk,line)
                                    let old_count_part += 1
                                    let linenr += 1
                                  else
                                    let state = 3
                                  endif
                                elseif state == 3
                                  if line[0] == '+'
                                    call add(hunk,line)
                                    let new_count_part += 1
                                    let linenr += 1
                                  else
                                    call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                    let diff += hunk
                                    let hunk = []
                                    let old_count -= old_count_part
                                    let new_count -= new_count_part
                                    let old_line += old_count_part
                                    let new_line += new_count_part
                                    let state = 1
                                  endif
                                endif
                            
                                if state > 0 && new_count <= 0 && old_count <= 0
                                  if len(hunk) > 0
                                    call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                    let diff = diff + hunk
                                    let hunk = []
                                  endif
                                  let state = 0
                                endif
                              endwhile
                              if len(hunk) > 0
                                call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                let diff = diff + hunk
                                let hunk = []
                              endif
                              return diff
                            endfunction
                            
                            " Variables {{{1
    1              0.000009 let s:difftool = get(g:, 'signify_difftool', 'diff')
    1              0.000062 if executable(s:difftool)
    1              0.000015   let s:vcs_dict = {
                                    \ 'git':      'git',
                                    \ 'yadm':     'yadm',
                                    \ 'hg':       'hg',
                                    \ 'svn':      'svn',
                                    \ 'darcs':    'darcs',
                                    \ 'bzr':      'bzr',
                                    \ 'fossil':   'fossil',
                                    \ 'cvs':      'cvs',
                                    \ 'rcs':      'rcsdiff',
                                    \ 'accurev':  'accurev',
                                    \ 'perforce': 'p4',
                                    \ 'tfs':      'tf'
                                    \ }
                            else
                              call sy#verbose('No "diff" executable found. Disable support for svn, darcs, bzr.')
                              let s:vcs_dict = {
                                    \ 'git':      'git',
                                    \ 'yadm':     'yadm',
                                    \ 'hg':       'hg',
                                    \ 'fossil':   'fossil',
                                    \ 'cvs':      'cvs',
                                    \ 'rcs':      'rcsdiff',
                                    \ 'accurev':  'accurev',
                                    \ 'perforce': 'p4',
                                    \ 'tfs':      'tf'
                                    \ }
    1              0.000001 endif
                            
    1              0.000008 let s:vcs_list = get(g:, 'signify_vcs_list', [])
    1              0.000004 if empty(s:vcs_list)
                              let s:vcs_list = keys(filter(s:vcs_dict, 'executable(v:val)'))
    1              0.000001 endif
                            
    1   0.000065   0.000033 let s:default_vcs_cmds = {
                                  \ 'git':      'git diff --no-color --no-ext-diff -U0 -- %f',
                                  \ 'yadm':     'yadm diff --no-color --no-ext-diff -U0 -- %f',
                                  \ 'hg':       'hg diff --color=never --config aliases.diff= --nodates -U0 -- %f',
                                  \ 'svn':      'svn diff --diff-cmd %d -x -U0 -- %f',
                                  \ 'bzr':      'bzr diff --using %d --diff-options=-U0 -- %f',
                                  \ 'darcs':    'darcs diff --no-pause-for-gui --no-unified --diff-opts=-U0 -- %f',
                                  \ 'fossil':   'fossil diff --unified -c 0 -- %f',
                                  \ 'cvs':      'cvs diff -U0 -- %f',
                                  \ 'rcs':      'rcsdiff -U0 %f 2>%n',
                                  \ 'accurev':  'accurev diff %f -- -U0',
                                  \ 'perforce': 'p4 info '. sy#util#shell_redirect('%n') . (has('win32') ? ' &&' : ' && env P4DIFF= P4COLORS=') .' p4 diff -du0 %f',
                                  \ 'tfs':      'tf diff -version:W -noprompt -format:Unified %f'
                                  \ }
                            
    1              0.000015 let s:default_vcs_cmds_diffmode = {
                                  \ 'git':      'git show HEAD:./%f',
                                  \ 'yadm':     'yadm show HEAD:./%f',
                                  \ 'hg':       'hg cat %f',
                                  \ 'svn':      'svn cat %f',
                                  \ 'bzr':      'bzr cat %f',
                                  \ 'darcs':    'darcs show contents -- %f',
                                  \ 'fossil':   'fossil cat %f',
                                  \ 'cvs':      'cvs up -p -- %f 2>%n',
                                  \ 'perforce': 'p4 print %f',
                                  \ }
                            
    1              0.000004 if exists('g:signify_vcs_cmds')
                              call extend(g:signify_vcs_cmds, s:default_vcs_cmds, 'keep')
    1              0.000002 else
    1              0.000003   let g:signify_vcs_cmds = s:default_vcs_cmds
    1              0.000001 endif
    1              0.000003 if exists('g:signify_vcs_cmds_diffmode')
                              call extend(g:signify_vcs_cmds_diffmode, s:default_vcs_cmds_diffmode, 'keep')
    1              0.000001 else
    1              0.000003   let g:signify_vcs_cmds_diffmode = s:default_vcs_cmds_diffmode
    1              0.000001 endif
                            
    1   0.000030   0.000006 let s:difftool = sy#util#escape(s:difftool)
    1              0.000010 let s:devnull  = has('win32') || has ('win64') ? 'NUL' : '/dev/null'

SCRIPT  /home/c5262761/configit/vim/modules/vim-gutentags/autoload/gutentags.vim
Sourced 1 time
Total time:   0.000909
 Self time:   0.000909

count  total (s)   self (s)
                            " gutentags.vim - Automatic ctags management for Vim
                            
                            " Utilities {{{
                            
    1              0.000015 function! gutentags#chdir(path)
                                if has('nvim')
                                    let chdir = haslocaldir() ? 'lcd' : haslocaldir(-1, 0) ? 'tcd' : 'cd'
                                else
                                    let chdir = haslocaldir() ? 'lcd' : 'cd'
                                endif
                                execute chdir a:path
                            endfunction
                            
                            " Throw an exception message.
    1              0.000003 function! gutentags#throw(message)
                                throw "gutentags: " . a:message
                            endfunction
                            
                            " Show an error message.
    1              0.000002 function! gutentags#error(message)
                                let v:errmsg = "gutentags: " . a:message
                                echoerr v:errmsg
                            endfunction
                            
                            " Show a warning message.
    1              0.000003 function! gutentags#warning(message)
                                echohl WarningMsg
                                echom "gutentags: " . a:message
                                echohl None
                            endfunction
                            
                            " Prints a message if debug tracing is enabled.
    1              0.000002 function! gutentags#trace(message, ...)
                                if g:gutentags_trace || (a:0 && a:1)
                                    let l:message = "gutentags: " . a:message
                                    echom l:message
                                endif
                            endfunction
                            
                            " Strips the ending slash in a path.
    1              0.000003 function! gutentags#stripslash(path)
                                return fnamemodify(a:path, ':s?[/\\]$??')
                            endfunction
                            
                            " Normalizes the slashes in a path.
    1              0.000002 function! gutentags#normalizepath(path)
                                if exists('+shellslash') && &shellslash
                                    return substitute(a:path, '\v/', '\\', 'g')
                                elseif has('win32')
                                    return substitute(a:path, '\v/', '\\', 'g')
                                else
                                    return a:path
                                endif
                            endfunction
                            
                            " Shell-slashes the path (opposite of `normalizepath`).
    1              0.000002 function! gutentags#shellslash(path)
                                if exists('+shellslash') && !&shellslash
                                    return substitute(a:path, '\v\\', '/', 'g')
                                else
                                    return a:path
                                endif
                            endfunction
                            
                            " Gets a file path in the correct `plat` folder.
    1              0.000002 function! gutentags#get_plat_file(filename) abort
                                return g:gutentags_plat_dir . a:filename . g:gutentags_script_ext
                            endfunction
                            
                            " Gets a file path in the resource folder.
    1              0.000002 function! gutentags#get_res_file(filename) abort
                                return g:gutentags_res_dir . a:filename
                            endfunction
                            
                            " Generate a path for a given filename in the cache directory.
    1              0.000003 function! gutentags#get_cachefile(root_dir, filename) abort
                                if gutentags#is_path_rooted(a:filename)
                                    return a:filename
                                endif
                                let l:tag_path = gutentags#stripslash(a:root_dir) . '/' . a:filename
                                if g:gutentags_cache_dir != ""
                                    " Put the tag file in the cache dir instead of inside the
                                    " project root.
                                    let l:tag_path = g:gutentags_cache_dir . '/' .
                                                \tr(l:tag_path, '\/: ', '---_')
                                    let l:tag_path = substitute(l:tag_path, '/\-', '/', '')
                                    let l:tag_path = substitute(l:tag_path, '[\-_]*$', '', '')
                                endif
                                let l:tag_path = gutentags#normalizepath(l:tag_path)
                                return l:tag_path
                            endfunction
                            
                            " Makes sure a given command starts with an executable that's in the PATH.
    1              0.000002 function! gutentags#validate_cmd(cmd) abort
                                if !empty(a:cmd) && executable(split(a:cmd)[0])
                                    return a:cmd
                                endif
                                return ""
                            endfunction
                            
                            " Makes an appropriate command line for use with `job_start` by converting
                            " a list of possibly quoted arguments into a single string on Windows, or
                            " into a list of unquoted arguments on Unix/Mac.
    1              0.000010 if has('win32') || has('win64')
                                function! gutentags#make_args(cmd) abort
                                    return join(a:cmd, ' ')
                                endfunction
    1              0.000001 else
    1              0.000002     function! gutentags#make_args(cmd) abort
                                    let l:outcmd = []
                                    for cmdarg in a:cmd
                                        " Thanks Vimscript... you can use negative integers for strings
                                        " in the slice notation, but not for indexing characters :(
                                        let l:arglen = strlen(cmdarg)
                                        if (cmdarg[0] == '"' && cmdarg[l:arglen - 1] == '"') || 
                                                    \(cmdarg[0] == "'" && cmdarg[l:arglen - 1] == "'")
                                            call add(l:outcmd, cmdarg[1:-2])
                                        else
                                            call add(l:outcmd, cmdarg)
                                        endif
                                    endfor
                                    return l:outcmd
                                endfunction
    1              0.000001 endif
                            
                            " Returns whether a path is rooted.
    1              0.000007 if has('win32') || has('win64')
                                function! gutentags#is_path_rooted(path) abort
                                    return len(a:path) >= 2 && (
                                                \a:path[0] == '/' || a:path[0] == '\' || a:path[1] == ':')
                                endfunction
    1              0.000001 else
    1              0.000003     function! gutentags#is_path_rooted(path) abort
                                    return !empty(a:path) && a:path[0] == '/'
                                endfunction
    1              0.000001 endif
                            
                            " }}}
                            
                            " Gutentags Setup {{{
                            
    1              0.000004 let s:known_files = []
    1              0.000003 let s:known_projects = {}
                            
    1              0.000006 function! s:cache_project_root(path) abort
                                let l:result = {}
                            
                                for proj_info in g:gutentags_project_info
                                    let l:filematch = get(proj_info, 'file', '')
                                    if l:filematch != '' && filereadable(a:path . '/'. l:filematch)
                                        let l:result = copy(proj_info)
                                        break
                                    endif
                            
                                    let l:globmatch = get(proj_info, 'glob', '')
                                    if l:globmatch != '' && glob(a:path . '/' . l:globmatch) != ''
                                        let l:result = copy(proj_info)
                                        break
                                    endif
                                endfor
                            
                                let s:known_projects[a:path] = l:result
                            endfunction
                            
    1              0.000003 function! gutentags#get_project_file_list_cmd(path) abort
                                if type(g:gutentags_file_list_command) == type("")
                                    return gutentags#validate_cmd(g:gutentags_file_list_command)
                                elseif type(g:gutentags_file_list_command) == type({})
                                    let l:markers = get(g:gutentags_file_list_command, 'markers', [])
                                    if type(l:markers) == type({})
                                        for [marker, file_list_cmd] in items(l:markers)
                                            if !empty(globpath(a:path, marker, 1))
                                                return gutentags#validate_cmd(file_list_cmd)
                                            endif
                                        endfor
                                    endif
                                    return get(g:gutentags_file_list_command, 'default', "")
                                endif
                                return ""
                            endfunction
                            
                            " Finds the first directory with a project marker by walking up from the given
                            " file path.
    1              0.000002 function! gutentags#get_project_root(path) abort
                                if g:gutentags_project_root_finder != ''
                                    return call(g:gutentags_project_root_finder, [a:path])
                                endif
                                return gutentags#default_get_project_root(a:path)
                            endfunction
                            
                            " Default implementation for finding project markers... useful when a custom
                            " finder (`g:gutentags_project_root_finder`) wants to fallback to the default
                            " behaviour.
    1              0.000003 function! gutentags#default_get_project_root(path) abort
                                let l:path = gutentags#stripslash(a:path)
                                let l:previous_path = ""
                                let l:markers = g:gutentags_project_root[:]
                                if g:gutentags_add_ctrlp_root_markers && exists('g:ctrlp_root_markers')
                                    for crm in g:ctrlp_root_markers
                                        if index(l:markers, crm) < 0
                                            call add(l:markers, crm)
                                        endif
                                    endfor
                                endif
                                while l:path != l:previous_path
                                    for root in l:markers
                                        if !empty(globpath(l:path, root, 1))
                                            let l:proj_dir = simplify(fnamemodify(l:path, ':p'))
                                            let l:proj_dir = gutentags#stripslash(l:proj_dir)
                                            if l:proj_dir == ''
                                                call gutentags#trace("Found project marker '" . root .
                                                            \"' at the root of your file-system! " .
                                                            \" That's probably wrong, disabling " .
                                                            \"gutentags for this file...",
                                                            \1)
                                                call gutentags#throw("Marker found at root, aborting.")
                                            endif
                                            for ign in g:gutentags_exclude_project_root
                                                if l:proj_dir == ign
                                                    call gutentags#trace(
                                                                \"Ignoring project root '" . l:proj_dir .
                                                                \"' because it is in the list of ignored" .
                                                                \" projects.")
                                                    call gutentags#throw("Ignore project: " . l:proj_dir)
                                                endif
                                            endfor
                                            return l:proj_dir
                                        endif
                                    endfor
                                    let l:previous_path = l:path
                                    let l:path = fnamemodify(l:path, ':h')
                                endwhile
                                call gutentags#throw("Can't figure out what tag file to use for: " . a:path)
                            endfunction
                            
                            " Get info on the project we're inside of.
    1              0.000002 function! gutentags#get_project_info(path) abort
                                return get(s:known_projects, a:path, {})
                            endfunction
                            
                            " Setup gutentags for the current buffer.
    1              0.000005 function! gutentags#setup_gutentags() abort
                                if exists('b:gutentags_files') && !g:gutentags_debug
                                    " This buffer already has gutentags support.
                                    return
                                endif
                            
                                " Don't setup gutentags for anything that's not a normal buffer
                                " (so don't do anything for help buffers and quickfix windows and
                                "  other such things)
                                " Also don't do anything for the default `[No Name]` buffer you get
                                " after starting Vim.
                                if &buftype != '' || 
                                      \(bufname('%') == '' && !g:gutentags_generate_on_empty_buffer)
                                    return
                                endif
                            
                                " Don't setup gutentags for things that don't need it, or that could
                                " cause problems.
                                if index(g:gutentags_exclude_filetypes, &filetype) >= 0
                                    return
                                endif
                            
                                " Let the user specify custom ways to disable Gutentags.
                                if g:gutentags_init_user_func != '' &&
                                            \!call(g:gutentags_init_user_func, [expand('%:p')])
                                    call gutentags#trace("Ignoring '" . bufname('%') . "' because of " .
                                                \"custom user function.")
                                    return
                                endif
                            
                                " Try and find what tags file we should manage.
                                call gutentags#trace("Scanning buffer '" . bufname('%') . "' for gutentags setup...")
                                try
                                    let l:buf_dir = expand('%:p:h', 1)
                                    if g:gutentags_resolve_symlinks
                                        let l:buf_dir = fnamemodify(resolve(expand('%:p', 1)), ':p:h')
                                    endif
                                    if !exists('b:gutentags_root')
                                        let b:gutentags_root = gutentags#get_project_root(l:buf_dir)
                                    endif
                                    if !len(b:gutentags_root)
                                        call gutentags#trace("no valid project root.. no gutentags support.")
                                        return
                                    endif
                                    if filereadable(b:gutentags_root . '/.notags')
                                        call gutentags#trace("'.notags' file found... no gutentags support.")
                                        return
                                    endif
                            
                                    if !has_key(s:known_projects, b:gutentags_root)
                                        call s:cache_project_root(b:gutentags_root)
                                    endif
                                    if g:gutentags_trace
                                        let l:projnfo = gutentags#get_project_info(b:gutentags_root)
                                        if l:projnfo != {}
                                            call gutentags#trace("Setting project type to ".l:projnfo['type'])
                                        else
                                            call gutentags#trace("No specific project type.")
                                        endif
                                    endif
                            
                                    let b:gutentags_files = {}
                                    for module in g:gutentags_modules
                                        call call("gutentags#".module."#init", [b:gutentags_root])
                                    endfor
                                catch /^gutentags\:/
                                    call gutentags#trace("No gutentags support for this buffer.")
                                    return
                                endtry
                            
                                " We know what tags file to manage! Now set things up.
                                call gutentags#trace("Setting gutentags for buffer '".bufname('%')."'")
                            
                                " Autocommands for updating the tags on save.
                                " We need to pass the buffer number to the callback function in the rare
                                " case that the current buffer is changed by another `BufWritePost`
                                " callback. This will let us get that buffer's variables without causing
                                " errors.
                                let l:bn = bufnr('%')
                                execute 'augroup gutentags_buffer_' . l:bn
                                execute '  autocmd!'
                                execute '  autocmd BufWritePost <buffer=' . l:bn . '> call s:write_triggered_update_tags(' . l:bn . ')'
                                execute 'augroup end'
                            
                                " Miscellaneous commands.
                                command! -buffer -bang GutentagsUpdate :call s:manual_update_tags(<bang>0)
                            
                                " Add these tags files to the known tags files.
                                for module in keys(b:gutentags_files)
                                    let l:tagfile = b:gutentags_files[module]
                                    let l:found = index(s:known_files, l:tagfile)
                                    if l:found < 0
                                        call add(s:known_files, l:tagfile)
                            
                                        " Generate this new file depending on settings and stuff.
                                        if g:gutentags_enabled
                                            if g:gutentags_generate_on_missing && !filereadable(l:tagfile)
                                                call gutentags#trace("Generating missing tags file: " . l:tagfile)
                                                call s:update_tags(l:bn, module, 1, 1)
                                            elseif g:gutentags_generate_on_new
                                                call gutentags#trace("Generating tags file: " . l:tagfile)
                                                call s:update_tags(l:bn, module, 1, 1)
                                            endif
                                        endif
                                    endif
                                endfor
                            endfunction
                            
                            " }}}
                            
                            "  Job Management {{{
                            
                            " List of queued-up jobs, and in-progress jobs, per module.
    1              0.000004 let s:update_queue = {}
    1              0.000003 let s:update_in_progress = {}
    2              0.000007 for module in g:gutentags_modules
    1              0.000005     let s:update_queue[module] = []
    1              0.000003     let s:update_in_progress[module] = []
    2              0.000003 endfor
                            
    1              0.000004 function! gutentags#add_job(module, tags_file, data) abort
                                call add(s:update_in_progress[a:module], [a:tags_file, a:data])
                            endfunction
                            
    1              0.000003 function! gutentags#find_job_index_by_tags_file(module, tags_file) abort
                                let l:idx = -1
                                for upd_info in s:update_in_progress[a:module]
                                    let l:idx += 1
                                    if upd_info[0] == a:tags_file
                                        return l:idx
                                    endif
                                endfor
                                return -1
                            endfunction
                            
    1              0.000003 function! gutentags#find_job_index_by_data(module, data) abort
                                let l:idx = -1
                                for upd_info in s:update_in_progress[a:module]
                                    let l:idx += 1
                                    if upd_info[1] == a:data
                                        return l:idx
                                    endif
                                endfor
                                return -1
                            endfunction
                            
    1              0.000003 function! gutentags#get_job_tags_file(module, job_idx) abort
                                return s:update_in_progress[a:module][a:job_idx][0]
                            endfunction
                            
    1              0.000003 function! gutentags#get_job_data(module, job_idx) abort
                                return s:update_in_progress[a:module][a:job_idx][1]
                            endfunction
                            
    1              0.000003 function! gutentags#remove_job(module, job_idx) abort
                                let l:tags_file = s:update_in_progress[a:module][a:job_idx][0]
                                call remove(s:update_in_progress[a:module], a:job_idx)
                            
                                " Run the user callback for finished jobs.
                                silent doautocmd User GutentagsUpdated
                            
                                " See if we had any more updates queued up for this.
                                let l:qu_idx = -1
                                for qu_info in s:update_queue[a:module]
                                    let l:qu_idx += 1
                                    if qu_info[0] == l:tags_file
                                        break
                                    endif
                                endfor
                                if l:qu_idx >= 0
                                    let l:qu_info = s:update_queue[a:module][l:qu_idx]
                                    call remove(s:update_queue[a:module], l:qu_idx)
                            
                                    if bufexists(l:qu_info[1])
                                        call gutentags#trace("Finished ".a:module." job, ".
                                                    \"running queued update for '".l:tags_file."'.")
                                        call s:update_tags(l:qu_info[1], a:module, l:qu_info[2], 2)
                                    else
                                        call gutentags#trace("Finished ".a:module." job, ".
                                                    \"but skipping queued update for '".l:tags_file."' ".
                                                    \"because originating buffer doesn't exist anymore.")
                                    endif
                                else
                                    call gutentags#trace("Finished ".a:module." job.")
                                endif
                            endfunction
                            
    1              0.000006 function! gutentags#remove_job_by_data(module, data) abort
                                let l:idx = gutentags#find_job_index_by_data(a:module, a:data)
                                call gutentags#remove_job(a:module, l:idx)
                            endfunction
                            
                            " }}}
                            
                            "  Tags File Management {{{
                            
                            " (Re)Generate the tags file for the current buffer's file.
    1              0.000006 function! s:manual_update_tags(bang) abort
                                let l:restore_prev_trace = 0
                                let l:prev_trace = g:gutentags_trace
                                if &verbose > 0
                                    let g:gutentags_trace = 1
                                    let l:restore_prev_trace = 1
                                endif
                            
                                try
                                    let l:bn = bufnr('%')
                                    for module in g:gutentags_modules
                                        call s:update_tags(l:bn, module, a:bang, 0)
                                    endfor
                                    silent doautocmd User GutentagsUpdating
                                finally
                                    if l:restore_prev_trace
                                        let g:gutentags_trace = l:prev_trace
                                    endif
                                endtry
                            endfunction
                            
                            " (Re)Generate the tags file for a buffer that just go saved.
    1              0.000006 function! s:write_triggered_update_tags(bufno) abort
                                if g:gutentags_enabled && g:gutentags_generate_on_write
                                    for module in g:gutentags_modules
                                        call s:update_tags(a:bufno, module, 0, 2)
                                    endfor
                                endif
                                silent doautocmd User GutentagsUpdating
                            endfunction
                            
                            " Update the tags file for the current buffer's file.
                            " write_mode:
                            "   0: update the tags file if it exists, generate it otherwise.
                            "   1: always generate (overwrite) the tags file.
                            "
                            " queue_mode:
                            "   0: if an update is already in progress, report it and abort.
                            "   1: if an update is already in progress, abort silently.
                            "   2: if an update is already in progress, queue another one.
    1              0.000005 function! s:update_tags(bufno, module, write_mode, queue_mode) abort
                                " Figure out where to save.
                                let l:buf_gutentags_files = getbufvar(a:bufno, 'gutentags_files')
                                let l:tags_file = l:buf_gutentags_files[a:module]
                                let l:proj_dir = getbufvar(a:bufno, 'gutentags_root')
                            
                                " Check that there's not already an update in progress.
                                let l:in_progress_idx = gutentags#find_job_index_by_tags_file(
                                            \a:module, l:tags_file)
                                if l:in_progress_idx >= 0
                                    if a:queue_mode == 2
                                        let l:needs_queuing = 1
                                        for qu_info in s:update_queue[a:module]
                                            if qu_info[0] == l:tags_file
                                                let l:needs_queuing = 0
                                                break
                                            endif
                                        endfor
                                        if l:needs_queuing
                                            call add(s:update_queue[a:module], 
                                                        \[l:tags_file, a:bufno, a:write_mode])
                                        endif
                                        call gutentags#trace("Tag file '" . l:tags_file . 
                                                    \"' is already being updated. Queuing it up...")
                                    elseif a:queue_mode == 1
                                        call gutentags#trace("Tag file '" . l:tags_file .
                                                    \"' is already being updated. Skipping...")
                                    elseif a:queue_mode == 0
                                        echom "gutentags: The tags file is already being updated, " .
                                                    \"please try again later."
                                    else
                                        call gutentags#throw("Unknown queue mode: " . a:queue_mode)
                                    endif
                            
                                    " Don't update the tags right now.
                                    return
                                endif
                            
                                " Switch to the project root to make the command line smaller, and make
                                " it possible to get the relative path of the filename to parse if we're
                                " doing an incremental update.
                                let l:prev_cwd = getcwd()
                                call gutentags#chdir(fnameescape(l:proj_dir))
                                try
                                    call call("gutentags#".a:module."#generate",
                                                \[l:proj_dir, l:tags_file,
                                                \ {
                                                \   'write_mode': a:write_mode,
                                                \ }])
                                catch /^gutentags\:/
                                    echom "Error while generating ".a:module." file:"
                                    echom v:exception
                                finally
                                    " Restore the current directory...
                                    call gutentags#chdir(fnameescape(l:prev_cwd))
                                endtry
                            endfunction
                            
                            " }}}
                            
                            " Utility Functions {{{
                            
    1              0.000003 function! gutentags#rescan(...)
                                if exists('b:gutentags_files')
                                    unlet b:gutentags_files
                                endif
                                if a:0 && a:1
                                    let l:trace_backup = g:gutentags_trace
                                    let l:gutentags_trace = 1
                                endif
                                call gutentags#setup_gutentags()
                                if a:0 && a:1
                                    let g:gutentags_trace = l:trace_backup
                                endif
                            endfunction
                            
    1              0.000002 function! gutentags#toggletrace(...)
                                let g:gutentags_trace = !g:gutentags_trace
                                if a:0 > 0
                                    let g:gutentags_trace = a:1
                                endif
                                if g:gutentags_trace
                                    echom "gutentags: Tracing is enabled."
                                else
                                    echom "gutentags: Tracing is disabled."
                                endif
                                echom ""
                            endfunction
                            
    1              0.000002 function! gutentags#fake(...)
                                let g:gutentags_fake = !g:gutentags_fake
                                if a:0 > 0
                                    let g:gutentags_fake = a:1
                                endif
                                if g:gutentags_fake
                                    echom "gutentags: Now faking gutentags."
                                else
                                    echom "gutentags: Now running gutentags for real."
                                endif
                                echom ""
                            endfunction
                            
    1              0.000002 function! gutentags#default_io_cb(chan, msg) abort
                                call gutentags#trace('[job output]: '.string(a:msg))
                            endfunction
                            
    1              0.000006 if has('nvim')
                                " Neovim job API.
                                function! s:nvim_job_exit_wrapper(real_cb, job, exit_code, event_type) abort
                                    call call(a:real_cb, [a:job, a:exit_code])
                                endfunction
                            
                                function! s:nvim_job_out_wrapper(real_cb, job, lines, event_type) abort
                                    call call(a:real_cb, [a:job, a:lines])
                                endfunction
                            
                                function! gutentags#build_default_job_options(module) abort
                                   " Neovim kills jobs on exit, which is what we want.
                                   let l:job_opts = {
                                            \'on_exit': function(
                                            \    '<SID>nvim_job_exit_wrapper',
                                            \    ['gutentags#'.a:module.'#on_job_exit']),
                                            \'on_stdout': function(
                                            \    '<SID>nvim_job_out_wrapper',
                                            \    ['gutentags#default_io_cb']),
                                            \'on_stderr': function(
                                            \    '<SID>nvim_job_out_wrapper',
                                            \    ['gutentags#default_io_cb'])
                                            \}
                                   return l:job_opts
                                endfunction
                            
                                function! gutentags#start_job(cmd, opts) abort
                                    return jobstart(a:cmd, a:opts)
                                endfunction
    1              0.000001 else
                                " Vim8 job API.
    1              0.000003     function! gutentags#build_default_job_options(module) abort
                                    let l:job_opts = {
                                             \'exit_cb': 'gutentags#'.a:module.'#on_job_exit',
                                             \'out_cb': 'gutentags#default_io_cb',
                                             \'err_cb': 'gutentags#default_io_cb',
                                             \'stoponexit': 'term'
                                             \}
                                    return l:job_opts
                                endfunction
                            
    1              0.000003     function! gutentags#start_job(cmd, opts) abort
                                    return job_start(a:cmd, a:opts)
                                endfunction
    1              0.000001 endif
                            
                            " Returns which modules are currently generating something for the
                            " current buffer.
    1              0.000002 function! gutentags#inprogress()
                                " Does this buffer have gutentags enabled?
                                if !exists('b:gutentags_files')
                                    return []
                                endif
                            
                                " Find any module that has a job in progress for any of this buffer's
                                " tags files.
                                let l:modules_in_progress = []
                                for [module, tags_file] in items(b:gutentags_files)
                                    let l:jobidx = gutentags#find_job_index_by_tags_file(module, tags_file)
                                    if l:jobidx >= 0
                                        call add(l:modules_in_progress, module)
                                    endif
                                endfor
                                return l:modules_in_progress
                            endfunction
                            
                            " }}}
                            
                            " Statusline Functions {{{
                            
                            " Prints whether a tag file is being generated right now for the current
                            " buffer in the status line.
                            "
                            " Arguments can be passed:
                            " - args 1 and 2 are the prefix and suffix, respectively, of whatever output,
                            "   if any, is going to be produced.
                            "   (defaults to empty strings)
                            " - arg 3 is the text to be shown if tags are currently being generated.
                            "   (defaults to the name(s) of the modules currently generating).
                            
    1              0.000003 function! gutentags#statusline(...) abort
                                let l:modules_in_progress = gutentags#inprogress()
                                if empty(l:modules_in_progress)
                                   return ''
                                endif
                            
                                let l:prefix = ''
                                let l:suffix = ''
                                if a:0 > 0
                                   let l:prefix = a:1
                                endif
                                if a:0 > 1
                                   let l:suffix = a:2
                                endif
                            
                                if a:0 > 2
                                   let l:genmsg = a:3
                                else
                                   let l:genmsg = join(l:modules_in_progress, ',')
                                endif
                            
                                return l:prefix.l:genmsg.l:suffix
                            endfunction
                            
                            " Same as `gutentags#statusline`, but the only parameter is a `Funcref` or
                            " function name that will get passed the list of modules currently generating
                            " something. This formatter function should return the string to display in
                            " the status line.
                            
    1              0.000003 function! gutentags#statusline_cb(fmt_cb, ...) abort
                                let l:modules_in_progress = gutentags#inprogress()
                            
                                if (a:0 == 0 || !a:1) && empty(l:modules_in_progress)
                                   return ''
                                endif
                            
                                return call(a:fmt_cb, [l:modules_in_progress])
                            endfunction
                            
                            " }}}
                            

SCRIPT  /home/c5262761/configit/vim/modules/vim-gutentags/autoload/gutentags/ctags.vim
Sourced 1 time
Total time:   0.000442
 Self time:   0.000378

count  total (s)   self (s)
                            " Ctags module for Gutentags
                            
                            " Global Options {{{
                            
    1              0.000012 let g:gutentags_ctags_executable = get(g:, 'gutentags_ctags_executable', 'ctags')
    1              0.000005 let g:gutentags_ctags_tagfile = get(g:, 'gutentags_ctags_tagfile', 'tags')
    1              0.000005 let g:gutentags_ctags_auto_set_tags = get(g:, 'gutentags_ctags_auto_set_tags', 1)
                            
    1              0.000004 let g:gutentags_ctags_options_file = get(g:, 'gutentags_ctags_options_file', '.gutctags')
    1              0.000005 let g:gutentags_ctags_check_tagfile = get(g:, 'gutentags_ctags_check_tagfile', 0)
    1              0.000005 let g:gutentags_ctags_extra_args = get(g:, 'gutentags_ctags_extra_args', [])
    1              0.000005 let g:gutentags_ctags_post_process_cmd = get(g:, 'gutentags_ctags_post_process_cmd', '')
                            
    1              0.000005 let g:gutentags_ctags_exclude = get(g:, 'gutentags_ctags_exclude', [])
    1              0.000004 let g:gutentags_ctags_exclude_wildignore = get(g:, 'gutentags_ctags_exclude_wildignore', 1)
                            
                            " Backwards compatibility.
    1              0.000005 function! s:_handleOldOptions() abort
                                let l:renamed_options = {
                                            \'gutentags_exclude': 'gutentags_ctags_exclude',
                                            \'gutentags_tagfile': 'gutentags_ctags_tagfile',
                                            \'gutentags_auto_set_tags': 'gutentags_ctags_auto_set_tags'
                                            \}
                                for key in keys(l:renamed_options)
                                    if exists('g:'.key)
                                        let newname = l:renamed_options[key]
                                        echom "gutentags: Option 'g:'".key." has been renamed to ".
                                                    \"'g:'".newname." Please update your vimrc."
                                        let g:[newname] = g:[key]
                                    endif
                                endfor
                            endfunction
    1   0.000065   0.000007 call s:_handleOldOptions()
                            " }}}
                            
                            " Gutentags Module Interface {{{
                            
    1              0.000003 let s:did_check_exe = 0
    1   0.000013   0.000007 let s:runner_exe = gutentags#get_plat_file('update_tags')
    1              0.000018 let s:unix_redir = (&shellredir =~# '%s') ? &shellredir : &shellredir . ' %s'
    1              0.000003 let s:wildignores_options_path = ''
    1              0.000002 let s:last_wildignores = ''
                            
    1              0.000003 function! gutentags#ctags#init(project_root) abort
                                " Figure out the path to the tags file.
                                " Check the old name for this option, too, before falling back to the
                                " globally defined name.
                                let l:tagfile = getbufvar("", 'gutentags_ctags_tagfile',
                                            \getbufvar("", 'gutentags_tagfile', 
                                            \g:gutentags_ctags_tagfile))
                                let b:gutentags_files['ctags'] = gutentags#get_cachefile(
                                            \a:project_root, l:tagfile)
                            
                                " Set the tags file for Vim to use.
                                if g:gutentags_ctags_auto_set_tags
                                    execute 'setlocal tags^=' . fnameescape(b:gutentags_files['ctags'])
                                endif
                            
                                " Check if the ctags executable exists.
                                if s:did_check_exe == 0
                                    if g:gutentags_enabled && executable(expand(g:gutentags_ctags_executable, 1)) == 0
                                        let g:gutentags_enabled = 0
                                        echoerr "Executable '".g:gutentags_ctags_executable."' can't be found. "
                                                    \."Gutentags will be disabled. You can re-enable it by "
                                                    \."setting g:gutentags_enabled back to 1."
                                    endif
                                    let s:did_check_exe = 1
                                endif
                            endfunction
                            
    1              0.000004 function! gutentags#ctags#generate(proj_dir, tags_file, gen_opts) abort
                                let l:write_mode = a:gen_opts['write_mode']
                            
                                let l:tags_file_exists = filereadable(a:tags_file)
                                let l:tags_file_relative = fnamemodify(a:tags_file, ':.')
                                let l:tags_file_is_local = len(l:tags_file_relative) < len(a:tags_file)
                            
                                if l:tags_file_exists && g:gutentags_ctags_check_tagfile
                                    let l:first_lines = readfile(a:tags_file, '', 1)
                                    if len(l:first_lines) == 0 || stridx(l:first_lines[0], '!_TAG_') != 0
                                        call gutentags#throw(
                                                    \"File ".a:tags_file." doesn't appear to be ".
                                                    \"a ctags file. Please delete it and run ".
                                                    \":GutentagsUpdate!.")
                                        return
                                    endif
                                endif
                            
                                if empty(g:gutentags_cache_dir) && l:tags_file_is_local
                                    " If we don't use the cache directory, we can pass relative paths
                                    " around.
                                    "
                                    " Note that if we don't do this and pass a full path for the project
                                    " root, some `ctags` implementations like Exhuberant Ctags can get
                                    " confused if the paths have spaces -- but not if you're *in* the root 
                                    " directory, for some reason... (which we are, our caller in
                                    " `autoload/gutentags.vim` changed it).
                                    let l:actual_proj_dir = '.'
                                    let l:actual_tags_file = l:tags_file_relative
                                else
                                    " else: the tags file goes in a cache directory, so we need to specify
                                    " all the paths absolutely for `ctags` to do its job correctly.
                                    let l:actual_proj_dir = a:proj_dir
                                    let l:actual_tags_file = a:tags_file
                                endif
                            
                                " Build the command line.
                                let l:cmd = [s:runner_exe]
                                let l:cmd += ['-e', '"' . s:get_ctags_executable(a:proj_dir) . '"']
                                let l:cmd += ['-t', '"' . l:actual_tags_file . '"']
                                let l:cmd += ['-p', '"' . l:actual_proj_dir . '"']
                                if l:write_mode == 0 && l:tags_file_exists
                                    let l:cur_file_path = expand('%:p')
                                    if empty(g:gutentags_cache_dir) && l:tags_file_is_local
                                        let l:cur_file_path = fnamemodify(l:cur_file_path, ':.')
                                    endif
                                    let l:cmd += ['-s', '"' . l:cur_file_path . '"']
                                else
                                    let l:file_list_cmd = gutentags#get_project_file_list_cmd(l:actual_proj_dir)
                                    if !empty(l:file_list_cmd)
                                        if match(l:file_list_cmd, '///') > 0
                                            let l:suffopts = split(l:file_list_cmd, '///')
                                            let l:suffoptstr = l:suffopts[1]
                                            let l:file_list_cmd = l:suffopts[0]
                                            if l:suffoptstr == 'absolute'
                                                let l:cmd += ['-A']
                                            endif
                                        endif
                                        let l:cmd += ['-L', '"' . l:file_list_cmd. '"']
                                    endif
                                endif
                                if empty(get(l:, 'file_list_cmd', ''))
                                    " Pass the Gutentags recursive options file before the project
                                    " options file, so that users can override --recursive.
                                    " Omit --recursive if this project uses a file list command.
                                    let l:cmd += ['-o', '"' . gutentags#get_res_file('ctags_recursive.options') . '"']
                                endif
                                if !empty(g:gutentags_ctags_extra_args)
                                    let l:cmd += ['-O', shellescape(join(g:gutentags_ctags_extra_args))]
                                endif
                                if !empty(g:gutentags_ctags_post_process_cmd)
                                    let l:cmd += ['-P', shellescape(g:gutentags_ctags_post_process_cmd)]
                                endif
                                let l:proj_options_file = a:proj_dir . '/' .
                                            \g:gutentags_ctags_options_file
                                if filereadable(l:proj_options_file)
                                    let l:proj_options_file = s:process_options_file(
                                                \a:proj_dir, l:proj_options_file)
                                    let l:cmd += ['-o', '"' . l:proj_options_file . '"']
                                endif
                                if g:gutentags_ctags_exclude_wildignore
                                    call s:generate_wildignore_options()
                                    if !empty(s:wildignores_options_path)
                                        let l:cmd += ['-x', shellescape('@'.s:wildignores_options_path, 1)]
                                    endif
                                endif
                                for exc in g:gutentags_ctags_exclude
                                    let l:cmd += ['-x', '"' . exc . '"']
                                endfor
                                if g:gutentags_pause_after_update
                                    let l:cmd += ['-c']
                                endif
                                if g:gutentags_trace
                                    let l:cmd += ['-l', '"' . l:actual_tags_file . '.log"']
                                endif
                                let l:cmd = gutentags#make_args(l:cmd)
                            
                                call gutentags#trace("Running: " . string(l:cmd))
                                call gutentags#trace("In:      " . getcwd())
                                if !g:gutentags_fake
                                    let l:job_opts = gutentags#build_default_job_options('ctags')
                                    let l:job = gutentags#start_job(l:cmd, l:job_opts)
                                    call gutentags#add_job('ctags', a:tags_file, l:job)
                                else
                                    call gutentags#trace("(fake... not actually running)")
                                endif
                            endfunction
                            
    1              0.000003 function! gutentags#ctags#on_job_exit(job, exit_val) abort
                                call gutentags#remove_job_by_data('ctags', a:job)
                            
                                if a:exit_val != 0
                                    call gutentags#warning("ctags job failed, returned: ".
                                                \string(a:exit_val))
                                endif
                            endfunction
                            
                            " }}}
                            
                            " Utilities {{{
                            
                            " Get final ctags executable depending whether a filetype one is defined
    1              0.000004 function! s:get_ctags_executable(proj_dir) abort
                                "Only consider the main filetype in cases like 'python.django'
                                let l:ftype = get(split(&filetype, '\.'), 0, '')
                                let l:proj_info = gutentags#get_project_info(a:proj_dir)
                                let l:type = get(l:proj_info, 'type', l:ftype)
                                let exepath = exists('g:gutentags_ctags_executable_{l:type}')
                                    \ ? g:gutentags_ctags_executable_{l:type} : g:gutentags_ctags_executable
                                return expand(exepath, 1)
                            endfunction
                            
    1              0.000003 function! s:generate_wildignore_options() abort
                                if s:last_wildignores == &wildignore
                                    " The 'wildignore' setting didn't change since last time we did this.
                                    call gutentags#trace("Wildignore options file is up to date.")
                                    return
                                endif
                            
                                if s:wildignores_options_path == ''
                                    if empty(g:gutentags_cache_dir)
                                        let s:wildignores_options_path = tempname()
                                    else
                                        let s:wildignores_options_path = 
                                                    \gutentags#stripslash(g:gutentags_cache_dir).
                                                    \'/_wildignore.options'
                                    endif
                                endif
                            
                                call gutentags#trace("Generating wildignore options: ".s:wildignores_options_path)
                                let l:opt_lines = []
                                for ign in split(&wildignore, ',')
                                    call add(l:opt_lines, ign)
                                endfor
                                call writefile(l:opt_lines, s:wildignores_options_path)
                                let s:last_wildignores = &wildignore
                            endfunction
                            
    1              0.000004 function! s:process_options_file(proj_dir, path) abort
                                if empty(g:gutentags_cache_dir)
                                    " If we're not using a cache directory to store tag files, we can
                                    " use the options file straight away.
                                    return a:path
                                endif
                            
                                " See if we need to process the options file.
                                let l:do_process = 0
                                let l:proj_dir = gutentags#stripslash(a:proj_dir)
                                let l:out_path = gutentags#get_cachefile(l:proj_dir, 'options')
                                if !filereadable(l:out_path)
                                    call gutentags#trace("Processing options file '".a:path."' because ".
                                                \"it hasn't been processed yet.")
                                    let l:do_process = 1
                                elseif getftime(a:path) > getftime(l:out_path)
                                    call gutentags#trace("Processing options file '".a:path."' because ".
                                                \"it has changed.")
                                    let l:do_process = 1
                                endif
                                if l:do_process == 0
                                    " Nothing's changed, return the existing processed version of the
                                    " options file.
                                    return l:out_path
                                endif
                            
                                " We have to process the options file. Right now this only means capturing
                                " all the 'exclude' rules, and rewrite them to make them absolute.
                                "
                                " This is because since `ctags` is run with absolute paths (because we
                                " want the tag file to be in a cache directory), it will do its path
                                " matching with absolute paths too, so the exclude rules need to be
                                " absolute.
                                let l:lines = readfile(a:path)
                                let l:outlines = []
                                for line in l:lines
                                    let l:exarg_idx = matchend(line, '\v^\-\-exclude=')
                                    if l:exarg_idx < 0
                                        call add(l:outlines, line)
                                        continue
                                    endif
                            
                                    " Don't convert things that don't look like paths.
                                    let l:exarg = strpart(line, l:exarg_idx + 1)
                                    let l:do_convert = 1
                                    if l:exarg[0] == '@'   " Manifest file path
                                        let l:do_convert = 0
                                    endif
                                    if stridx(l:exarg, '/') < 0 && stridx(l:exarg, '\\') < 0   " Filename
                                        let l:do_convert = 0
                                    endif
                                    if l:do_convert == 0
                                        call add(l:outlines, line)
                                        continue
                                    endif
                            
                                    let l:fullp = l:proj_dir . gutentags#normalizepath('/'.l:exarg)
                                    let l:ol = '--exclude='.l:fullp
                                    call add(l:outlines, l:ol)
                                endfor
                            
                                call writefile(l:outlines, l:out_path)
                                return l:out_path
                            endfunction
                            
                            " }}}

SCRIPT  /home/c5262761/configit/vim/modules/vim-fugitive/autoload/fugitive.vim
Sourced 1 time
Total time:   0.011833
 Self time:   0.010741

count  total (s)   self (s)
                            " Location:     autoload/fugitive.vim
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            
    1              0.000008 if exists('g:autoloaded_fugitive')
                              finish
    1              0.000002 endif
    1              0.000006 let g:autoloaded_fugitive = 1
                            
    1              0.000007 if !exists('g:fugitive_git_executable')
    1              0.000007   let g:fugitive_git_executable = 'git'
                            elseif g:fugitive_git_executable =~# '^\w\+='
                              let g:fugitive_git_executable = 'env ' . g:fugitive_git_executable
    1              0.000002 endif
                            
                            " Section: Utility
                            
    1              0.000007 function! s:function(name) abort
                              return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
                            endfunction
                            
    1              0.000005 function! s:sub(str,pat,rep) abort
                              return substitute(a:str,'\v\C'.a:pat,a:rep,'')
                            endfunction
                            
    1              0.000005 function! s:gsub(str,pat,rep) abort
                              return substitute(a:str,'\v\C'.a:pat,a:rep,'g')
                            endfunction
                            
    1              0.000011 function! s:Uniq(list) abort
                              let i = 0
                              let seen = {}
                              while i < len(a:list)
                                let str = string(a:list[i])
                                if has_key(seen, str)
                                  call remove(a:list, i)
                                else
                                  let seen[str] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:list
                            endfunction
                            
    1              0.000012 function! s:winshell() abort
                              return has('win32') && &shellcmdflag !~# '^-'
                            endfunction
                            
    1              0.000002 function! s:shellesc(arg) abort
                              if type(a:arg) == type([])
                                return join(map(copy(a:arg), 's:shellesc(v:val)'))
                              elseif a:arg =~ '^[A-Za-z0-9_/:.-]\+$'
                                return a:arg
                              elseif s:winshell()
                                return '"'.s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"').'"'
                              else
                                return shellescape(a:arg)
                              endif
                            endfunction
                            
    1              0.000005 let s:fnameescape = " \t\n*?[{`$\\%#'\"|!<"
    1              0.000005 function! s:fnameescape(file) abort
                              if type(a:file) == type([])
                                return join(map(copy(a:file), 's:fnameescape(v:val)'))
                              elseif exists('*fnameescape')
                                return fnameescape(a:file)
                              else
                                return escape(a:file, s:fnameescape)
                              endif
                            endfunction
                            
    1              0.000003 function! s:throw(string) abort
                              throw 'fugitive: '.a:string
                            endfunction
                            
    1              0.000002 function! s:DirCheck(...) abort
                              if !empty(a:0 ? s:Dir(a:1) : s:Dir())
                                return ''
                              elseif empty(bufname(''))
                                return 'return ' . string('echoerr "fugitive: blank buffer unsupported (edit a file from a repository)"')
                              else
                                return 'return ' . string('echoerr "fugitive: file does not belong to a Git repository"')
                              endif
                            endfunction
                            
    1              0.000002 function! s:Mods(mods, ...) abort
                              let mods = substitute(a:mods, '\C<mods>', '', '')
                              let mods = mods =~# '\S$' ? mods . ' ' : mods
                              if a:0 && mods !~# '\<\%(aboveleft\|belowright\|leftabove\|rightbelow\|topleft\|botright\|tab\)\>'
                                let mods = a:1 . ' ' . mods
                              endif
                              return substitute(mods, '\s\+', ' ', 'g')
                            endfunction
                            
    1              0.000003 function! s:Slash(path) abort
                              if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
                                return a:path
                              endif
                            endfunction
                            
    1              0.000003 function! s:Resolve(path) abort
                              let path = resolve(a:path)
                              if has('win32')
                                let path = FugitiveVimPath(fnamemodify(fnamemodify(path, ':h'), ':p') . fnamemodify(path, ':t'))
                              endif
                              return path
                            endfunction
                            
    1              0.000003 function! s:cpath(path, ...) abort
                              if exists('+fileignorecase') && &fileignorecase
                                let path = FugitiveVimPath(tolower(a:path))
                              else
                                let path = FugitiveVimPath(a:path)
                              endif
                              return a:0 ? path ==# s:cpath(a:1) : path
                            endfunction
                            
    1              0.000002 function! s:Cd(...) abort
                              let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'
                              if !a:0
                                return cd
                              endif
                              let cwd = getcwd()
                              if s:cpath(cwd, a:1)
                                return ''
                              endif
                              exe cd s:fnameescape(a:1)
                              return cd . ' ' . s:fnameescape(cwd)
                            endfunction
                            
    1              0.000003 let s:executables = {}
                            
    1              0.000002 function! s:executable(binary) abort
                              if !has_key(s:executables, a:binary)
                                let s:executables[a:binary] = executable(a:binary)
                              endif
                              return s:executables[a:binary]
                            endfunction
                            
    1              0.000005 let s:nowait = v:version >= 704 ? '<nowait>' : ''
                            
    1              0.000002 function! s:Map(mode, lhs, rhs, ...) abort
                              for mode in split(a:mode, '\zs')
                                let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')
                                let head = a:lhs
                                let tail = ''
                                let keys = get(g:, mode.'remap', {})
                                if type(keys) == type([])
                                  return
                                endif
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
                                if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))
                                  exe mode.'map <buffer>' s:nowait flags head.tail a:rhs
                                  if a:0 > 1
                                    let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') .
                                          \ '|sil! exe "' . mode . 'unmap <buffer> ' . head.tail . '"'
                                  endif
                                endif
                              endfor
                            endfunction
                            
                            " Section: Quickfix
                            
    1              0.000003 function! s:QuickfixGet(nr, ...) abort
                              if a:nr < 0
                                return call('getqflist', a:000)
                              else
                                return call('getloclist', [a:nr] + a:000)
                              endif
                            endfunction
                            
    1              0.000002 function! s:QuickfixSet(nr, ...) abort
                              if a:nr < 0
                                return call('setqflist', a:000)
                              else
                                return call('setloclist', [a:nr] + a:000)
                              endif
                            endfunction
                            
    1              0.000003 function! s:QuickfixCreate(nr, opts) abort
                              if has('patch-7.4.2200')
                                call s:QuickfixSet(a:nr, [], ' ', a:opts)
                              else
                                call s:QuickfixSet(a:nr, [], ' ')
                              endif
                            endfunction
                            
    1              0.000003 function! s:QuickfixStream(nr, title, cmd, first, callback, ...) abort
                              call s:QuickfixCreate(a:nr, {'title': a:title})
                              let winnr = winnr()
                              exe a:nr < 0 ? 'copen' : 'lopen'
                              if winnr != winnr()
                                wincmd p
                              endif
                            
                              let buffer = []
                              let lines = split(s:SystemError(s:shellesc(a:cmd))[0], "\n")
                              for line in lines
                                call extend(buffer, call(a:callback, a:000 + [line]))
                                if len(buffer) >= 20
                                  call s:QuickfixSet(a:nr, remove(buffer, 0, -1), 'a')
                                  redraw
                                endif
                              endfor
                              call s:QuickfixSet(a:nr, extend(buffer, call(a:callback, a:000 + [0])), 'a')
                            
                              if a:first && len(s:QuickfixGet(a:nr))
                                call s:BlurStatus()
                                return a:nr < 0 ? 'cfirst' : 'lfirst'
                              else
                                return 'exe'
                              endif
                            endfunction
                            
                            " Section: Git
                            
    1              0.000003 function! s:UserCommandList(...) abort
                              let git = split(get(g:, 'fugitive_git_command', g:fugitive_git_executable), '\s\+')
                              let dir = a:0 ? s:Dir(a:1) : ''
                              if len(dir)
                                let tree = s:Tree(dir)
                                if empty(tree)
                                  call add(git, '--git-dir=' . FugitiveGitPath(dir))
                                elseif len(tree) && s:cpath(tree) !=# s:cpath(getcwd())
                                  if fugitive#GitVersion(1, 8, 5)
                                    call extend(git, ['-C', FugitiveGitPath(tree)])
                                  else
                                    throw 'fugitive: Git 1.8.5 or higher required to change directory'
                                  endif
                                endif
                              endif
                              return git
                            endfunction
                            
    1              0.000003 function! s:UserCommand(...) abort
                              return s:shellesc(call('s:UserCommandList', a:0 ? [a:1] : []) + (a:0 ? a:2 : []))
                            endfunction
                            
    1              0.000003 let s:git_versions = {}
    1              0.000003 function! fugitive#GitVersion(...) abort
                              if !has_key(s:git_versions, g:fugitive_git_executable)
                                let s:git_versions[g:fugitive_git_executable] = matchstr(system(g:fugitive_git_executable.' --version'), '\d[^[:space:]]\+')
                              endif
                              if !a:0
                                return s:git_versions[g:fugitive_git_executable]
                              endif
                              let components = split(s:git_versions[g:fugitive_git_executable], '\D\+')
                              if empty(components)
                                return -1
                              endif
                              for i in range(len(a:000))
                                if a:000[i] > +get(components, i)
                                  return 0
                                elseif a:000[i] < +get(components, i)
                                  return 1
                                endif
                              endfor
                              return a:000[i] ==# get(components, i)
                            endfunction
                            
    1              0.000002 let s:commondirs = {}
    1              0.000003 function! fugitive#CommonDir(dir) abort
                              if empty(a:dir)
                                return ''
                              endif
                              if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
                              endif
                              return s:commondirs[a:dir]
                            endfunction
                            
    1              0.000003 function! s:Dir(...) abort
                              return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()
                            endfunction
                            
    1              0.000002 function! s:Tree(...) abort
                              return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()
                            endfunction
                            
    1              0.000003 function! s:HasOpt(args, ...) abort
                              let args = a:args[0 : index(a:args, '--')]
                              let opts = copy(a:000)
                              if type(opts[0]) == type([])
                                if empty(args) || index(opts[0], args[0]) == -1
                                  return 0
                                endif
                                call remove(opts, 0)
                              endif
                              for opt in opts
                                if index(args, opt) != -1
                                  return 1
                                endif
                              endfor
                            endfunction
                            
    1              0.000004 function! s:PreparePathArgs(cmd, dir, literal) abort
                              let literal_supported = fugitive#GitVersion(1, 9)
                              if a:literal && literal_supported
                                call insert(a:cmd, '--literal-pathspecs')
                              endif
                              let split = index(a:cmd, '--')
                              for i in range(split < 0 ? len(a:cmd) : split)
                                if type(a:cmd[i]) == type(0)
                                  let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                endif
                              endfor
                              if split < 0
                                return a:cmd
                              endif
                              for i in range(split + 1, len(a:cmd) - 1)
                                if type(a:cmd[i]) == type(0)
                                  let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                elseif a:literal
                                  let a:cmd[i] = fugitive#Path(a:cmd[i], './', a:dir)
                                elseif !literal_supported
                                  let a:cmd[i] = substitute(a:cmd[i], '^:\%(/\|([^)]*)\)\=:\=', './', '')
                                endif
                              endfor
                              return a:cmd
                            endfunction
                            
    1              0.000008 let s:prepare_env = {
                                  \ 'sequence.editor': 'GIT_SEQUENCE_EDITOR',
                                  \ 'core.editor': 'GIT_EDITOR',
                                  \ 'core.askpass': 'GIT_ASKPASS',
                                  \ }
    1              0.000004 function! fugitive#PrepareDirEnvArgv(...) abort
                              if a:0 && type(a:1) ==# type([])
                                let cmd = a:000[1:-1] + a:1
                              else
                                let cmd = copy(a:000)
                              endif
                              let env = {}
                              let i = 0
                              while i < len(cmd)
                                if cmd[i] =~# '^$\|[\/.]' && cmd[i] !~# '^-'
                                  let dir = remove(cmd, 0)
                                elseif cmd[i] =~# '^--git-dir='
                                  let dir = remove(cmd, 0)[10:-1]
                                elseif type(cmd[i]) ==# type(0)
                                  let dir = s:Dir(remove(cmd, i))
                                elseif cmd[i] ==# '-c' && len(cmd) > i + 1
                                  let key = matchstr(cmd[i+1], '^[^=]*')
                                  if has_key(s:prepare_env, tolower(key)) || key !~# '\.'
                                    let var = get(s:prepare_env, tolower(key), key)
                                    let val = matchstr(cmd[i+1], '=\zs.*')
                                    let env[var] = val
                                  endif
                                  if fugitive#GitVersion(1, 8) && cmd[i+1] =~# '\.'
                                    let i += 2
                                  else
                                    call remove(cmd, i, i + 1)
                                  endif
                                elseif cmd[i] =~# '^--.*pathspecs$'
                                  let explicit_pathspec_option = 1
                                  if fugitive#GitVersion(1, 9)
                                    let i += 1
                                  else
                                    call remove(cmd, i)
                                  endif
                                elseif cmd[i] !~# '^-'
                                  break
                                else
                                  let i += 1
                                endif
                              endwhile
                              if !exists('dir')
                                let dir = s:Dir()
                              endif
                              call s:PreparePathArgs(cmd, dir, !exists('explicit_pathspec_option'))
                              return [dir, env, cmd]
                            endfunction
                            
    1              0.000004 function! s:BuildShell(dir, env, args) abort
                              let cmd = copy(a:args)
                              let tree = s:Tree(a:dir)
                              let pre = ''
                              for [var, val] in items(a:env)
                                if s:winshell()
                                  let pre .= 'set ' . var . '=' . s:shellesc(val) . '& '
                                else
                                  let pre = (len(pre) ? pre : 'env ') . var . '=' . s:shellesc(val) . ' '
                                endif
                              endfor
                              if empty(tree) || index(cmd, '--') == len(cmd) - 1
                                call insert(cmd, '--git-dir=' . FugitiveGitPath(a:dir))
                              elseif fugitive#GitVersion(1, 8, 5)
                                call extend(cmd, ['-C', FugitiveGitPath(tree)], 'keep')
                              else
                                let pre = 'cd ' . s:shellesc(tree) . (s:winshell() ? '& ' : '; ') . pre
                              endif
                              return pre . g:fugitive_git_executable . ' ' . join(map(cmd, 's:shellesc(v:val)'))
                            endfunction
                            
    1              0.000002 function! fugitive#Prepare(...) abort
                              let [dir, env, argv] = call('fugitive#PrepareDirEnvArgv', a:000)
                              return s:BuildShell(dir, env, argv)
                            endfunction
                            
    1              0.000003 function! s:SystemError(cmd, ...) abort
                              try
                                if &shellredir ==# '>' && &shell =~# 'sh\|cmd'
                                  let shellredir = &shellredir
                                  if &shell =~# 'csh'
                                    set shellredir=>&
                                  else
                                    set shellredir=>%s\ 2>&1
                                  endif
                                endif
                                let out = call('system', [type(a:cmd) ==# type([]) ? fugitive#Prepare(a:cmd) : a:cmd] + a:000)
                                return [out, v:shell_error]
                              catch /^Vim\%((\a\+)\)\=:E484:/
                                let opts = ['shell', 'shellcmdflag', 'shellredir', 'shellquote', 'shellxquote', 'shellxescape', 'shellslash']
                                call filter(opts, 'exists("+".v:val) && !empty(eval("&".v:val))')
                                call map(opts, 'v:val."=".eval("&".v:val)')
                                call s:throw('failed to run `' . a:cmd . '` with ' . join(opts, ' '))
                              finally
                                if exists('shellredir')
                                  let &shellredir = shellredir
                                endif
                              endtry
                            endfunction
                            
    1              0.000002 function! s:ChompError(...) abort
                              let [out, exec_error] = s:SystemError(call('fugitive#Prepare', a:000))
                              return [s:sub(out, '\n$', ''), exec_error]
                            endfunction
                            
    1              0.000003 function! s:ChompDefault(default, ...) abort
                              let [out, exec_error] = call('s:ChompError', a:000)
                              return exec_error ? a:default : out
                            endfunction
                            
    1              0.000002 function! s:LinesError(...) abort
                              let [out, exec_error] = call('s:ChompError', a:000)
                              return [len(out) && !exec_error ? split(out, "\n", 1) : [], exec_error]
                            endfunction
                            
    1              0.000002 function! s:NullError(...) abort
                              let [out, exec_error] = s:SystemError(call('fugitive#Prepare', a:000))
                              return [exec_error ? [] : split(out, "\1"), exec_error ? substitute(out, "\n$", "", "") : '', exec_error]
                            endfunction
                            
    1              0.000002 function! s:TreeChomp(...) abort
                              let cmd = call('fugitive#Prepare', a:000)
                              let [out, exec_error] = s:SystemError(cmd)
                              let out = s:sub(out, '\n$', '')
                              if !exec_error
                                return out
                              endif
                              throw 'fugitive: error running `' . cmd . '`: ' . out
                            endfunction
                            
    1              0.000003 function! s:EchoExec(...) abort
                              echo call('s:ChompError', a:000)[0]
                              call fugitive#ReloadStatus(-1, 1)
                              return 'checktime'
                            endfunction
                            
    1              0.000002 function! fugitive#Head(...) abort
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              if empty(dir) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                return ''
                              endif
                              let head = readfile(fugitive#Find('.git/HEAD', dir))[0]
                              if head =~# '^ref: '
                                return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000003 function! fugitive#RevParse(rev, ...) abort
                              let [hash, exec_error] = s:ChompError([a:0 ? a:1 : s:Dir(), 'rev-parse', '--verify', a:rev, '--'])
                              if !exec_error && hash =~# '^\x\{40,\}$'
                                return hash
                              endif
                              throw 'fugitive: rev-parse '.a:rev.': '.hash
                            endfunction
                            
    1              0.000013 function! s:ConfigTimestamps(dir, dict) abort
                              let files = ['/etc/gitconfig', '~/.gitconfig',
                                    \ len($XDG_CONFIG_HOME) ? $XDG_CONFIG_HOME . '/git/config' : '~/.config/git/config']
                              if len(a:dir)
                                call add(files, fugitive#Find('.git/config', a:dir))
                              endif
                              call extend(files, get(a:dict, 'include.path', []))
                              return join(map(files, 'getftime(expand(v:val))'), ',')
                            endfunction
                            
    1              0.000003 let s:config = {}
    1              0.000002 function! fugitive#Config(...) abort
                              let dir = s:Dir()
                              let name = ''
                              if a:0 >= 2 && type(a:2) == type({})
                                let name = substitute(a:1, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                                return len(a:1) ? get(get(a:2, name, []), 0, '') : a:2
                              elseif a:0 >= 2
                                let dir = a:2
                                let name = a:1
                              elseif a:0 == 1 && type(a:1) == type({})
                                return a:1
                              elseif a:0 == 1 && a:1 =~# '^[[:alnum:]-]\+\.'
                                let name = a:1
                              elseif a:0 == 1
                                let dir = a:1
                              endif
                              let name = substitute(name, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                              let key = len(dir) ? dir : '_'
                              if has_key(s:config, key) && s:config[key][0] ==# s:ConfigTimestamps(dir, s:config[key][1])
                                let dict = s:config[key][1]
                              else
                                let dict = {}
                                let [lines, message, exec_error] = s:NullError([dir, 'config', '--list', '-z'])
                                if exec_error
                                  return {}
                                endif
                                for line in lines
                                  let key = matchstr(line, "^[^\n]*")
                                  if !has_key(dict, key)
                                    let dict[key] = []
                                  endif
                                  call add(dict[key], strpart(line, len(key) + 1))
                                endfor
                                let s:config[dir] = [s:ConfigTimestamps(dir, dict), dict]
                                lockvar! dict
                              endif
                              return len(name) ? get(get(dict, name, []), 0, '') : dict
                            endfunction
                            
    1              0.000002 function! s:Remote(dir) abort
                              let head = FugitiveHead(0, a:dir)
                              let remote = len(head) ? fugitive#Config('branch.' . head . '.remote') : ''
                              let i = 10
                              while remote ==# '.' && i > 0
                                let head = matchstr(fugitive#Config('branch.' . head . '.merge'), 'refs/heads/\zs.*')
                                let remote = len(head) ? fugitive#Config('branch.' . head . '.remote') : ''
                                let i -= 1
                              endwhile
                              return remote =~# '^\.\=$' ? 'origin' : remote
                            endfunction
                            
    1              0.000002 function! fugitive#RemoteUrl(...) abort
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let remote = !a:0 || a:1 =~# '^\.\=$' ? s:Remote(dir) : a:1
                              if !fugitive#GitVersion(2, 7)
                                return fugitive#Config('remote.' . remote . '.url')
                              endif
                              return s:ChompDefault('', [dir, 'remote', 'get-url', remote, '--'])
                            endfunction
                            
                            " Section: Repository Object
                            
    1              0.000003 function! s:add_methods(namespace, method_names) abort
                              for name in a:method_names
                                let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
                              endfor
                            endfunction
                            
    1              0.000004 function! s:Command(command, line1, line2, range, bang, mods, arg, args) abort
                              try
                                if a:command =~# '^\l[[:alnum:]-]\+$'
                                  return fugitive#Command(a:line1, a:line2, a:range, a:bang, s:Mods(a:mods), a:command . ' ' . a:arg)
                                endif
                                return s:{a:command}Command(a:line1, a:line2, a:range, a:line2, a:bang, s:Mods(a:mods), '', a:arg, a:args)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 let s:commands = []
    1              0.000002 function! s:command(definition, ...) abort
                              let def = a:definition
                              if !has('patch-7.4.542')
                                let def = substitute(def, '-addr=\S\+ ', '', '')
                              endif
                              if !has('patch-8.1.560')
                                let def = substitute(def, '-addr=other ', '', '')
                              endif
                              if a:0
                                call add(s:commands, def . ' execute s:Command(' . string(a:1) . ", <line1>, <count>, +'<range>', <bang>0, '<mods>', <q-args>, [<f-args>])")
                              else
                                call add(s:commands, def)
                              endif
                            endfunction
                            
    1              0.000003 function! s:define_commands() abort
                              for command in s:commands
                                exe 'command! -buffer '.command
                              endfor
                            endfunction
                            
    1              0.000003 let s:repo_prototype = {}
    1              0.000002 let s:repos = {}
                            
    1              0.000002 function! fugitive#repo(...) abort
                              let dir = a:0 ? s:Dir(a:1) : (len(s:Dir()) ? s:Dir() : FugitiveExtractGitDir(expand('%:p')))
                              if dir !=# ''
                                if has_key(s:repos, dir)
                                  let repo = get(s:repos, dir)
                                else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
                                return extend(repo, s:repo_prototype, 'keep')
                              endif
                              call s:throw('not a Git repository')
                            endfunction
                            
    1              0.000004 function! s:repo_dir(...) dict abort
                              return join([self.git_dir]+a:000,'/')
                            endfunction
                            
    1              0.000005 function! s:repo_tree(...) dict abort
                              let dir = s:Tree(self.git_dir)
                              if dir ==# ''
                                call s:throw('no work tree')
                              else
                                return join([dir]+a:000,'/')
                              endif
                            endfunction
                            
    1              0.000004 function! s:repo_bare() dict abort
                              if self.dir() =~# '/\.git$'
                                return 0
                              else
                                return s:Tree(self.git_dir) ==# ''
                              endif
                            endfunction
                            
    1              0.000004 function! s:repo_find(object) dict abort
                              return fugitive#Find(a:object, self.git_dir)
                            endfunction
                            
    1              0.000004 function! s:repo_translate(rev) dict abort
                              return s:Slash(fugitive#Find(substitute(a:rev, '^/', ':(top)', ''), self.git_dir))
                            endfunction
                            
    1              0.000004 function! s:repo_head(...) dict abort
                              return fugitive#Head(a:0 ? a:1 : 0, self.git_dir)
                            endfunction
                            
    1   0.000320   0.000028 call s:add_methods('repo',['dir','tree','bare','find','translate','head'])
                            
    1              0.000004 function! s:repo_prepare(...) dict abort
                              return call('fugitive#Prepare', [self.git_dir] + a:000)
                            endfunction
                            
    1              0.000003 function! s:repo_git_command(...) dict abort
                              let git = s:UserCommand() . ' --git-dir='.s:shellesc(self.git_dir)
                              return git.join(map(copy(a:000),'" ".s:shellesc(v:val)'),'')
                            endfunction
                            
    1              0.000003 function! s:repo_git_chomp(...) dict abort
                              let git = g:fugitive_git_executable . ' --git-dir='.s:shellesc(self.git_dir)
                              let output = git . join(map(copy(a:000),'" ".s:shellesc(v:val)'),'')
                              return s:sub(system(output), '\n$', '')
                            endfunction
                            
    1              0.000003 function! s:repo_git_chomp_in_tree(...) dict abort
                              let cdback = s:Cd(self.tree())
                              try
                                return call(self.git_chomp, a:000, self)
                              finally
                                execute cdback
                              endtry
                            endfunction
                            
    1              0.000003 function! s:repo_rev_parse(rev) dict abort
                              return fugitive#RevParse(a:rev, self.git_dir)
                            endfunction
                            
    1   0.000199   0.000008 call s:add_methods('repo',['prepare','git_command','git_chomp','git_chomp_in_tree','rev_parse'])
                            
    1              0.000004 function! s:repo_superglob(base) dict abort
                              return map(fugitive#CompleteObject(a:base, self.git_dir), 'substitute(v:val, ''\\\(.\)'', ''\1'', "g")')
                            endfunction
                            
    1   0.000058   0.000008 call s:add_methods('repo',['superglob'])
                            
    1              0.000004 function! s:repo_config(name) dict abort
                              return fugitive#Config(a:name, self.git_dir)
                            endfunction
                            
    1              0.000002 function! s:repo_user() dict abort
                              let username = self.config('user.name')
                              let useremail = self.config('user.email')
                              return username.' <'.useremail.'>'
                            endfunction
                            
    1   0.000094   0.000017 call s:add_methods('repo',['config', 'user'])
                            
                            " Section: File API
                            
    1              0.000003 function! s:DirCommitFile(path) abort
                              let vals = matchlist(s:Slash(a:path), '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if empty(vals)
                                return ['', '', '']
                              endif
                              return vals[1:3]
                            endfunction
                            
    1              0.000003 function! s:DirRev(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              return [dir, (commit =~# '^.$' ? ':' : '') . commit . substitute(file, '^/', ':', '')]
                            endfunction
                            
    1              0.000005 function! s:Owner(path, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              if empty(dir)
                                return ''
                              endif
                              let actualdir = fugitive#Find('.git/', dir)
                              let [pdir, commit, file] = s:DirCommitFile(a:path)
                              if s:cpath(dir, pdir)
                                if commit =~# '^\x\{40,\}$'
                                  return commit
                                elseif commit ==# '2'
                                  return 'HEAD^{}'
                                endif
                                if filereadable(actualdir . 'MERGE_HEAD')
                                  let merge_head = 'MERGE_HEAD'
                                elseif filereadable(actualdir . 'REBASE_HEAD')
                                  let merge_head = 'REBASE_HEAD'
                                else
                                  return ''
                                endif
                                if commit ==# '3'
                                  return merge_head . '^{}'
                                elseif commit ==# '1'
                                  return s:TreeChomp('merge-base', 'HEAD', merge_head, '--')
                                endif
                              endif
                              let path = fnamemodify(a:path, ':p')
                              if s:cpath(actualdir, strpart(path, 0, len(actualdir))) && a:path =~# 'HEAD$'
                                return strpart(path, len(actualdir))
                              endif
                              let refs = fugitive#Find('.git/refs', dir)
                              if s:cpath(refs . '/', path[0 : len(refs)]) && path !~# '[\/]$'
                                return strpart(path, len(refs) - 4)
                              endif
                              return ''
                            endfunction
                            
    1              0.000003 function! fugitive#Real(url) abort
                              if empty(a:url)
                                return ''
                              endif
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if len(dir)
                                let tree = s:Tree(dir)
                                return FugitiveVimPath((len(tree) ? tree : dir) . file)
                              endif
                              let pre = substitute(matchstr(a:url, '^\a\a\+\ze:'), '^.', '\u&', '')
                              if len(pre) && pre !=? 'fugitive' && exists('*' . pre . 'Real')
                                let url = {pre}Real(a:url)
                              else
                                let url = fnamemodify(a:url, ':p' . (a:url =~# '[\/]$' ? '' : ':s?[\/]$??'))
                              endif
                              return FugitiveVimPath(empty(url) ? a:url : url)
                            endfunction
                            
    1              0.000002 function! fugitive#Path(url, ...) abort
                              if empty(a:url)
                                return ''
                              endif
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let tree = s:Tree(dir)
                              if !a:0
                                return fugitive#Real(a:url)
                              elseif a:1 =~# '\.$'
                                let path = s:Slash(fugitive#Real(a:url))
                                let cwd = getcwd()
                                let lead = ''
                                while s:cpath(tree . '/', (cwd . '/')[0 : len(tree)])
                                  if s:cpath(cwd . '/', path[0 : len(cwd)])
                                    if strpart(path, len(cwd) + 1) =~# '^\.git\%(/\|$\)'
                                      break
                                    endif
                                    return a:1[0:-2] . (empty(lead) ? './' : lead) . strpart(path, len(cwd) + 1)
                                  endif
                                  let cwd = fnamemodify(cwd, ':h')
                                  let lead .= '../'
                                endwhile
                                return a:1[0:-2] . path
                              endif
                              let url = a:url
                              let temp_state = s:TempState(url)
                              if has_key(temp_state, 'bufnr')
                                let url = bufname(temp_state.bufnr)
                              endif
                              let url = s:Slash(fnamemodify(url, ':p'))
                              if url =~# '/$' && s:Slash(a:url) !~# '/$'
                                let url = url[0:-2]
                              endif
                              let [argdir, commit, file] = s:DirCommitFile(a:url)
                              if len(argdir) && s:cpath(argdir) !=# s:cpath(dir)
                                let file = ''
                              elseif len(dir) && s:cpath(url[0 : len(dir)]) ==# s:cpath(dir . '/')
                                let file = '/.git'.url[strlen(dir) : -1]
                              elseif len(tree) && s:cpath(url[0 : len(tree)]) ==# s:cpath(tree . '/')
                                let file = url[len(tree) : -1]
                              elseif s:cpath(url) ==# s:cpath(tree)
                                let file = '/'
                              endif
                              if empty(file) && a:1 =~# '^$\|^[.:]/$'
                                return FugitiveGitPath(fugitive#Real(a:url))
                              endif
                              return substitute(file, '^/', a:1, '')
                            endfunction
                            
    1              0.000002 function! s:Relative(...) abort
                              return fugitive#Path(@%, a:0 ? a:1 : ':(top)', a:0 > 1 ? a:2 : s:Dir())
                            endfunction
                            
    1              0.000002 function! fugitive#Find(object, ...) abort
                              if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
                              elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
                              elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
                              elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
                              endif
                              let dir = a:0 ? a:1 : s:Dir()
                              if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
                              endif
                              let rev = s:Slash(a:object)
                              let tree = s:Tree(dir)
                              let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
                              if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
                              elseif rev =~# '^\.git/'
                                let f = substitute(rev, '^\.git', '', '')
                                let cdir = fugitive#CommonDir(dir)
                                if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
                                elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
                                elseif cdir !=# dir && (
                                      \ f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' ||
                                      \ f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' &&
                                      \ getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
                                else
                                  let f = simplify(dir . f)
                                endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^[^:.-][^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^[^:.-][^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit, '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
                              endif
                              return FugitiveVimPath(f)
                            endfunction
                            
    1              0.000004 function! s:Generate(rev, ...) abort
                              return fugitive#Find(a:rev, a:0 ? a:1 : s:Dir())
                            endfunction
                            
    1              0.000005 function! s:DotRelative(path, ...) abort
                              let cwd = a:0 ? a:1 : getcwd()
                              let path = substitute(a:path, '^[~$]\i*', '\=expand(submatch(0))', '')
                              if len(cwd) && s:cpath(cwd . '/', (path . '/')[0 : len(cwd)])
                                return '.' . strpart(path, len(cwd))
                              endif
                              return a:path
                            endfunction
                            
    1              0.000002 function! fugitive#Object(...) abort
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let [fdir, rev] = s:DirRev(a:0 ? a:1 : @%)
                              if s:cpath(dir) !=# s:cpath(fdir)
                                let rev = ''
                              endif
                              let tree = s:Tree(dir)
                              let full = a:0 ? a:1 : @%
                              let full = fnamemodify(full, ':p' . (s:Slash(full) =~# '/$' ? '' : ':s?/$??'))
                              if empty(rev) && empty(tree)
                                return FugitiveGitPath(full)
                              elseif empty(rev)
                                let rev = fugitive#Path(full, './', dir)
                                if rev =~# '^\./.git\%(/\|$\)'
                                  return FugitiveGitPath(full)
                                endif
                              endif
                              if rev !~# '^\.\%(/\|$\)' || s:cpath(getcwd(), tree)
                                return rev
                              else
                                return FugitiveGitPath(tree . rev[1:-1])
                              endif
                            endfunction
                            
    1              0.000014 let s:var = '\%(%\|#<\=\d\+\|##\=\)'
    1              0.000003 let s:flag = '\%(:[p8~.htre]\|:g\=s\(.\).\{-\}\1.\{-\}\1\)'
    1              0.000005 let s:expand = '\%(\(' . s:var . '\)\(' . s:flag . '*\)\(:S\)\=\)'
                            
    1              0.000003 function! s:BufName(var) abort
                              if a:var ==# '%'
                                return bufname(get(s:TempState(), 'bufnr', ''))
                              elseif a:var =~# '^#\d*$'
                                let nr = get(s:TempState(bufname(+a:var[1:-1])), 'bufnr', '')
                                return bufname(nr ? nr : +a:var[1:-1])
                              else
                                return expand(a:var)
                              endif
                            endfunction
                            
    1              0.000004 function! s:ExpandVarLegacy(str) abort
                              if get(g:, 'fugitive_legacy_quoting', 1)
                                return substitute(a:str, '\\\ze[%#!]', '', 'g')
                              else
                                return a:str
                              endif
                            endfunction
                            
    1              0.000004 function! s:ExpandVar(other, var, flags, esc, ...) abort
                              let cwd = a:0 ? a:1 : getcwd()
                              if a:other =~# '^\'
                                return a:other[1:-1]
                              elseif a:other =~# '^'''
                                return s:ExpandVarLegacy(substitute(a:other[1:-2], "''", "'", "g"))
                              elseif a:other =~# '^"'
                                return s:ExpandVarLegacy(substitute(a:other[1:-2], '""', '"', "g"))
                              elseif a:other =~# '^!'
                                let buffer = s:BufName(len(a:other) > 1 ? '#'. a:other[1:-1] : '%')
                                let owner = s:Owner(buffer)
                                return len(owner) ? owner : '@'
                              endif
                              let flags = a:flags
                              let file = s:DotRelative(fugitive#Real(s:BufName(a:var)), cwd)
                              while len(flags)
                                let flag = matchstr(flags, s:flag)
                                let flags = strpart(flags, len(flag))
                                if flag ==# ':.'
                                  let file = s:DotRelative(file, cwd)
                                else
                                  let file = fnamemodify(file, flag)
                                endif
                              endwhile
                              let file = s:Slash(file)
                              return (len(a:esc) ? shellescape(file) : file)
                            endfunction
                            
    1              0.000002 function! s:Expand(rev, ...) abort
                              if a:rev =~# '^:[0-3]$'
                                let file = len(expand('%')) ? a:rev . ':%' : '%'
                              elseif a:rev ==# '>'
                                let file = '%'
                              elseif a:rev =~# '^>[~^]'
                                let file = len(expand('%')) ? '!' . a:rev[1:-1] . ':%' : '%'
                              elseif a:rev =~# '^>[> ]\@!'
                                let file = len(expand('%')) ? a:rev[1:-1] . ':%' : '%'
                              else
                                let file = a:rev
                              endif
                              return substitute(file,
                                    \ '\(\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                    \ '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),"", a:0 ? a:1 : getcwd())', 'g')
                            endfunction
                            
    1              0.000002 function! fugitive#Expand(object) abort
                              return substitute(a:object,
                                    \ '\(\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                    \ '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5))', 'g')
                            endfunction
                            
    1              0.000003 function! s:ExpandSplit(string, ...) abort
                              let list = []
                              let string = a:string
                              let handle_bar = a:0 && a:1
                              let dquote = handle_bar ? '"\%([^"]\|""\|\\"\)*"\|' : ''
                              let cwd = a:0 > 1 ? a:2 : getcwd()
                              while string =~# '\S'
                                if handle_bar && string =~# '^\s*|'
                                  return [list, substitute(string, '^\s*', '', '')]
                                endif
                                let arg = matchstr(string, '^\s*\%(' . dquote . '''[^'']*''\|\\.\|[^[:space:] ' . (handle_bar ? '|' : '') . ']\)\+')
                                let string = strpart(string, len(arg))
                                let arg = substitute(arg, '^\s\+', '', '')
                                if !exists('seen_separator')
                                  let arg = substitute(arg, '^\%([^:.][^:]*:\|^:\|^:[0-3]:\)\=\zs\.\.\=\%(/.*\)\=$',
                                        \ '\=s:DotRelative(s:Slash(simplify(getcwd() . "/" . submatch(0))), cwd)', '')
                                endif
                                let arg = substitute(arg,
                                      \ '\(' . dquote . '''\%(''''\|[^'']\)*''\|\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                      \ '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5), cwd)', 'g')
                                call add(list, arg)
                                if arg ==# '--'
                                  let seen_separator = 1
                                endif
                              endwhile
                              return handle_bar ? [list, ''] : list
                            endfunction
                            
    1              0.000003 function! s:SplitExpand(string, ...) abort
                              return s:ExpandSplit(a:string, 0, a:0 ? a:1 : getcwd())
                            endfunction
                            
    1              0.000002 function! s:SplitExpandChain(string, ...) abort
                              return s:ExpandSplit(a:string, 1, a:0 ? a:1 : getcwd())
                            endfunction
                            
    1              0.000003 let s:trees = {}
    1              0.000003 let s:indexes = {}
    1              0.000003 function! s:TreeInfo(dir, commit) abort
                              if a:commit =~# '^:\=[0-3]$'
                                let index = get(s:indexes, a:dir, [])
                                let newftime = getftime(fugitive#Find('.git/index', a:dir))
                                if get(index, 0, -1) < newftime
                                  let [lines, exec_error] = s:LinesError([a:dir, 'ls-files', '--stage', '--'])
                                  let s:indexes[a:dir] = [newftime, {'0': {}, '1': {}, '2': {}, '3': {}}]
                                  if exec_error
                                    return [{}, -1]
                                  endif
                                  for line in lines
                                    let [info, filename] = split(line, "\t")
                                    let [mode, sha, stage] = split(info, '\s\+')
                                    let s:indexes[a:dir][1][stage][filename] = [newftime, mode, 'blob', sha, -2]
                                    while filename =~# '/'
                                      let filename = substitute(filename, '/[^/]*$', '', '')
                                      let s:indexes[a:dir][1][stage][filename] = [newftime, '040000', 'tree', '', 0]
                                    endwhile
                                  endfor
                                endif
                                return [get(s:indexes[a:dir][1], a:commit[-1:-1], {}), newftime]
                              elseif a:commit =~# '^\x\{40,\}$'
                                if !has_key(s:trees, a:dir)
                                  let s:trees[a:dir] = {}
                                endif
                                if !has_key(s:trees[a:dir], a:commit)
                                  let [ftime, exec_error] = s:ChompError([a:dir, 'log', '-1', '--pretty=format:%ct', a:commit, '--'])
                                  if exec_error
                                    let s:trees[a:dir][a:commit] = [{}, -1]
                                    return s:trees[a:dir][a:commit]
                                  endif
                                  let s:trees[a:dir][a:commit] = [{}, +ftime]
                                  let [lines, exec_error] = s:LinesError([a:dir, 'ls-tree', '-rtl', '--full-name', a:commit, '--'])
                                  if exec_error
                                    return s:trees[a:dir][a:commit]
                                  endif
                                  for line in lines
                                    let [info, filename] = split(line, "\t")
                                    let [mode, type, sha, size] = split(info, '\s\+')
                                    let s:trees[a:dir][a:commit][0][filename] = [+ftime, mode, type, sha, +size, filename]
                                  endfor
                                endif
                                return s:trees[a:dir][a:commit]
                              endif
                              return [{}, -1]
                            endfunction
                            
    1              0.000004 function! s:PathInfo(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(dir) || !get(g:, 'fugitive_file_api', 1)
                                return [-1, '000000', '', '', -1]
                              endif
                              let path = substitute(file[1:-1], '/*$', '', '')
                              let [tree, ftime] = s:TreeInfo(dir, commit)
                              let entry = empty(path) ? [ftime, '040000', 'tree', '', -1] : get(tree, path, [])
                              if empty(entry) || file =~# '/$' && entry[2] !=# 'tree'
                                return [-1, '000000', '', '', -1]
                              else
                                return entry
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#simplify(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(dir)
                                return ''
                              endif
                              if file =~# '/\.\.\%(/\|$\)'
                                let tree = s:Tree(dir)
                                if len(tree)
                                  let path = simplify(tree . file)
                                  if strpart(path . '/', 0, len(tree) + 1) !=# tree . '/'
                                    return FugitiveVimPath(path)
                                  endif
                                endif
                              endif
                              return FugitiveVimPath('fugitive://' . simplify(dir) . '//' . commit . simplify(file))
                            endfunction
                            
    1              0.000013 function! fugitive#resolve(url) abort
                              let url = fugitive#simplify(a:url)
                              if url =~? '^fugitive:'
                                return url
                              else
                                return resolve(url)
                              endif
                            endfunction
                            
    1              0.000003 function! fugitive#getftime(url) abort
                              return s:PathInfo(a:url)[0]
                            endfunction
                            
    1              0.000002 function! fugitive#getfsize(url) abort
                              let entry = s:PathInfo(a:url)
                              if entry[4] == -2 && entry[2] ==# 'blob' && len(entry[3])
                                let dir = s:DirCommitFile(a:url)[0]
                                let entry[4] = +s:ChompDefault(-1, [dir, 'cat-file', '-s', entry[3]])
                              endif
                              return entry[4]
                            endfunction
                            
    1              0.000003 function! fugitive#getftype(url) abort
                              return get({'tree': 'dir', 'blob': 'file'}, s:PathInfo(a:url)[2], '')
                            endfunction
                            
    1              0.000002 function! fugitive#filereadable(url) abort
                              return s:PathInfo(a:url)[2] ==# 'blob'
                            endfunction
                            
    1              0.000002 function! fugitive#filewritable(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if commit !~# '^\d$' || !filewritable(fugitive#Find('.git/index', dir))
                                return 0
                              endif
                              return s:PathInfo(a:url)[2] ==# 'blob' ? 1 : 2
                            endfunction
                            
    1              0.000002 function! fugitive#isdirectory(url) abort
                              return s:PathInfo(a:url)[2] ==# 'tree'
                            endfunction
                            
    1              0.000002 function! fugitive#getfperm(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              let perm = getfperm(dir)
                              let fperm = s:PathInfo(a:url)[1]
                              if fperm ==# '040000'
                                let fperm = '000755'
                              endif
                              if fperm !~# '[15]'
                                let perm = tr(perm, 'x', '-')
                              endif
                              if fperm !~# '[45]$'
                                let perm = tr(perm, 'rw', '--')
                              endif
                              if commit !~# '^\d$'
                                let perm = tr(perm, 'w', '-')
                              endif
                              return perm ==# '---------' ? '' : perm
                            endfunction
                            
    1              0.000002 function! fugitive#setfperm(url, perm) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              let entry = s:PathInfo(a:url)
                              let perm = fugitive#getfperm(a:url)
                              if commit !~# '^\d$' || entry[2] !=# 'blob' ||
                                  \ substitute(perm, 'x', '-', 'g') !=# substitute(a:perm, 'x', '-', 'g')
                                return -2
                              endif
                              let exec_error = s:SystemError([dir, 'update-index', '--index-info'],
                                    \ (a:perm =~# 'x' ? '000755 ' : '000644 ') . entry[3] . ' ' . commit . "\t" . file[1:-1])[1]
                              return exec_error ? -1 : 0
                            endfunction
                            
    1              0.000003 function! s:TempCmd(out, cmd) abort
                              let prefix = ''
                              try
                                let cmd = (type(a:cmd) == type([]) ? fugitive#Prepare(a:cmd) : a:cmd)
                                let redir = ' > ' . a:out
                                if s:winshell()
                                  let cmd_escape_char = &shellxquote == '(' ?  '^' : '^^^'
                                  return s:SystemError('cmd /c "' . prefix . s:gsub(cmd, '[<>]', cmd_escape_char . '&') . redir . '"')
                                elseif &shell =~# 'fish'
                                  return s:SystemError(' begin;' . prefix . cmd . redir . ';end ')
                                else
                                  return s:SystemError(' (' . prefix . cmd . redir . ') ')
                                endif
                              endtry
                            endfunction
                            
    1              0.000004 if !exists('s:blobdirs')
    1              0.000003   let s:blobdirs = {}
    1              0.000002 endif
    1              0.000002 function! s:BlobTemp(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(file)
                                return ''
                              endif
                              if !has_key(s:blobdirs, dir)
                                let s:blobdirs[dir] = tempname()
                              endif
                              let tempfile = s:blobdirs[dir] . '/' . commit . file
                              let tempparent = fnamemodify(tempfile, ':h')
                              if !isdirectory(tempparent)
                                call mkdir(tempparent, 'p')
                              endif
                              if commit =~# '^\d$' || !filereadable(tempfile)
                                let rev = s:DirRev(a:url)[1]
                                let exec_error = s:TempCmd(tempfile, [dir, 'cat-file', 'blob', rev])[1]
                                if exec_error
                                  call delete(tempfile)
                                  return ''
                                endif
                              endif
                              return s:Resolve(tempfile)
                            endfunction
                            
    1              0.000003 function! fugitive#readfile(url, ...) abort
                              let entry = s:PathInfo(a:url)
                              if entry[2] !=# 'blob'
                                return []
                              endif
                              let temp = s:BlobTemp(a:url)
                              if empty(temp)
                                return []
                              endif
                              return call('readfile', [temp] + a:000)
                            endfunction
                            
    1              0.000003 function! fugitive#writefile(lines, url, ...) abort
                              let url = type(a:url) ==# type('') ? a:url : ''
                              let [dir, commit, file] = s:DirCommitFile(url)
                              let entry = s:PathInfo(url)
                              if commit =~# '^\d$' && entry[2] !=# 'tree'
                                let temp = tempname()
                                if a:0 && a:1 =~# 'a' && entry[2] ==# 'blob'
                                  call writefile(fugitive#readfile(url, 'b'), temp, 'b')
                                endif
                                call call('writefile', [a:lines, temp] + a:000)
                                let [hash, exec_error] = s:ChompError([dir, 'hash-object', '-w', temp])
                                let mode = len(entry[1]) ? entry[1] : '100644'
                                if !exec_error && hash =~# '^\x\{40,\}$'
                                  let exec_error = s:SystemError([dir, 'update-index', '--index-info'],
                                        \ mode . ' ' . hash . ' ' . commit . "\t" . file[1:-1])[1]
                                  if !exec_error
                                    return 0
                                  endif
                                endif
                              endif
                              return call('writefile', [a:lines, a:url] + a:000)
                            endfunction
                            
    1              0.000010 let s:globsubs = {
                                  \ '/**/': '/\%([^./][^/]*/\)*',
                                  \ '/**': '/\%([^./][^/]\+/\)*[^./][^/]*',
                                  \ '**/': '[^/]*\%(/[^./][^/]*\)*',
                                  \ '**': '.*',
                                  \ '/*': '/[^/.][^/]*',
                                  \ '*': '[^/]*',
                                  \ '?': '[^/]'}
    1              0.000005 function! fugitive#glob(url, ...) abort
                              let [dirglob, commit, glob] = s:DirCommitFile(a:url)
                              let append = matchstr(glob, '/*$')
                              let glob = substitute(glob, '/*$', '', '')
                              let pattern = '^' . substitute(glob, '/\=\*\*/\=\|/\=\*\|[.?\$]\|^^', '\=get(s:globsubs, submatch(0), "\\" . submatch(0))', 'g')[1:-1] . '$'
                              let results = []
                              for dir in dirglob =~# '[*?]' ? split(glob(dirglob), "\n") : [dirglob]
                                if empty(dir) || !get(g:, 'fugitive_file_api', 1) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                  continue
                                endif
                                let files = items(s:TreeInfo(dir, commit)[0])
                                if len(append)
                                  call filter(files, 'v:val[1][2] ==# "tree"')
                                endif
                                call map(files, 'v:val[0]')
                                call filter(files, 'v:val =~# pattern')
                                let prepend = 'fugitive://' . dir . '//' . substitute(commit, '^:', '', '') . '/'
                                call sort(files)
                                call map(files, 'FugitiveVimPath(prepend . v:val . append)')
                                call extend(results, files)
                              endfor
                              if a:0 > 1 && a:2
                                return results
                              else
                                return join(results, "\n")
                              endif
                            endfunction
                            
    1              0.000003 function! fugitive#delete(url, ...) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if a:0 && len(a:1) || commit !~# '^\d$'
                                return -1
                              endif
                              let entry = s:PathInfo(a:url)
                              if entry[2] !=# 'blob'
                                return -1
                              endif
                              let exec_error = s:SystemError([dir, 'update-index', '--index-info'],
                                    \ '000000 0000000000000000000000000000000000000000 ' . commit . "\t" . file[1:-1])[1]
                              return exec_error ? -1 : 0
                            endfunction
                            
                            " Section: Buffer Object
                            
    1              0.000003 let s:buffer_prototype = {}
                            
    1              0.000002 function! fugitive#buffer(...) abort
                              let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
                              call extend(buffer, s:buffer_prototype, 'keep')
                              return buffer
                            endfunction
                            
    1              0.000002 function! s:buffer_repo() dict abort
                              return fugitive#repo(self['#'])
                            endfunction
                            
    1              0.000002 function! s:buffer_type(...) dict abort
                              return 'see b:fugitive_type'
                            endfunction
                            
    1   0.000106   0.000010 call s:add_methods('buffer', ['repo', 'type'])
                            
                            " Section: Completion
                            
    1              0.000006 function! s:FilterEscape(items, ...) abort
                              let items = copy(a:items)
                              if a:0 && type(a:1) == type('')
                                call filter(items, 'strpart(v:val, 0, strlen(a:1)) ==# a:1')
                              endif
                              return map(items, 's:fnameescape(v:val)')
                            endfunction
                            
    1              0.000002 function! s:GlobComplete(lead, pattern) abort
                              if a:lead ==# '/'
                                return []
                              elseif v:version >= 704
                                let results = glob(a:lead . a:pattern, 0, 1)
                              else
                                let results = split(glob(a:lead . a:pattern), "\n")
                              endif
                              call map(results, 'v:val !~# "/$" && isdirectory(v:val) ? v:val."/" : v:val')
                              call map(results, 'v:val[ strlen(a:lead) : -1 ]')
                              return results
                            endfunction
                            
    1              0.000003 function! fugitive#CompletePath(base, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 == 3 ? a:3 : s:Dir()
                              let tree = s:Tree(dir) . '/'
                              let strip = '^\%(:/:\=\|:(top)\|:(top,literal)\|:(literal,top)\|:(literal)\)'
                              let base = substitute(a:base, strip, '', '')
                              if base =~# '^\.git/'
                                let pattern = s:gsub(base[5:-1], '/', '*&').'*'
                                let matches = s:GlobComplete(dir . '/', pattern)
                                let cdir = fugitive#CommonDir(dir)
                                if len(cdir) && s:cpath(dir) !=# s:cpath(cdir)
                                  call extend(matches, s:GlobComplete(cdir . '/', pattern))
                                endif
                                call s:Uniq(matches)
                                call map(matches, "'.git/' . v:val")
                              elseif base =~# '^\~/'
                                let matches = map(s:GlobComplete(expand('~/'), base[2:-1] . '*'), '"~/" . v:val')
                              elseif a:base =~# '^/\|^\a\+:\|^\.\.\=/\|^:(literal)'
                                let matches = s:GlobComplete('', base . '*')
                              elseif len(tree) > 1
                                let matches = s:GlobComplete(tree, s:gsub(base, '/', '*&').'*')
                              else
                                let matches = []
                              endif
                              call map(matches, 's:fnameescape(s:Slash(matchstr(a:base, strip) . v:val))')
                              return matches
                            endfunction
                            
    1              0.000002 function! fugitive#PathComplete(...) abort
                              return call('fugitive#CompletePath', a:000)
                            endfunction
                            
    1              0.000002 function! fugitive#CompleteObject(base, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 == 3 ? a:3 : s:Dir()
                              let cwd = getcwd()
                              let tree = s:Tree(dir) . '/'
                              let subdir = ''
                              if len(tree) > 1 && s:cpath(tree, cwd[0 : len(tree) - 1])
                                let subdir = strpart(cwd, len(tree)) . '/'
                              endif
                            
                              if a:base =~# '^\.\=/\|^:(' || a:base !~# ':'
                                let results = []
                                if a:base =~# '^refs/'
                                  let results += map(s:GlobComplete(fugitive#CommonDir(dir) . '/', a:base . '*'), 's:Slash(v:val)')
                                elseif a:base !~# '^\.\=/\|^:('
                                  let heads = ['HEAD', 'ORIG_HEAD', 'FETCH_HEAD', 'MERGE_HEAD', 'refs/']
                                  let heads += sort(s:LinesError(["rev-parse","--symbolic","--branches","--tags","--remotes"], dir)[0])
                                  if filereadable(fugitive#Find('.git/refs/stash', dir))
                                    let heads += ["stash"]
                                    let heads += sort(s:LinesError(["stash","list","--pretty=format:%gd"], dir)[0])
                                  endif
                                  call filter(heads,'v:val[ 0 : strlen(a:base)-1 ] ==# a:base')
                                  let results += heads
                                endif
                                call map(results, 's:fnameescape(v:val)')
                                if !empty(tree)
                                  let results += a:0 == 1 ? fugitive#CompletePath(a:base, dir) : fugitive#CompletePath(a:base)
                                endif
                                return results
                            
                              elseif a:base =~# '^:'
                                let entries = s:LinesError(['ls-files','--stage'], dir)[0]
                                if a:base =~# ':\./'
                                  call map(entries, 'substitute(v:val, "\\M\t\\zs" . subdir, "./", "")')
                                endif
                                call map(entries,'s:sub(v:val,".*(\\d)\\t(.*)",":\\1:\\2")')
                                if a:base !~# '^:[0-3]\%(:\|$\)'
                                  call filter(entries,'v:val[1] == "0"')
                                  call map(entries,'v:val[2:-1]')
                                endif
                            
                              else
                                let tree = matchstr(a:base, '.*[:/]')
                                let entries = s:LinesError(['ls-tree', substitute(tree,  ':\zs\./', '\=subdir', '')], dir)[0]
                                call map(entries,'s:sub(v:val,"^04.*\\zs$","/")')
                                call map(entries,'tree.s:sub(v:val,".*\t","")')
                            
                              endif
                              return s:FilterEscape(entries, a:base)
                            endfunction
                            
    1              0.000004 function! s:CompleteSub(subcommand, A, L, P, ...) abort
                              let pre = strpart(a:L, 0, a:P)
                              if pre =~# ' -- '
                                return fugitive#CompletePath(a:A)
                              elseif a:A =~# '^-' || a:A is# 0
                                return s:FilterEscape(split(s:ChompDefault('', a:subcommand, '--git-completion-helper'), ' '), a:A)
                              elseif !a:0
                                return fugitive#CompleteObject(a:A, s:Dir())
                              elseif type(a:1) == type(function('tr'))
                                return call(a:1, [a:A, a:L, a:P])
                              else
                                return s:FilterEscape(a:1, a:A)
                              endif
                            endfunction
                            
    1              0.000003 function! s:CompleteRevision(A, L, P) abort
                              return s:FilterEscape(['HEAD', 'FETCH_HEAD', 'MERGE_HEAD', 'ORIG_HEAD'] +
                                    \ s:LinesError('rev-parse', '--symbolic', '--branches', '--tags', '--remotes')[0], a:A)
                            endfunction
                            
    1              0.000003 function! s:CompleteRemote(A, L, P) abort
                              let remote = matchstr(a:L, '\u\w*[! ] *\zs\S\+\ze ')
                              if !empty(remote)
                                let matches = s:LinesError('ls-remote', remote)[0]
                                call filter(matches, 'v:val =~# "\t" && v:val !~# "{"')
                                call map(matches, 's:sub(v:val, "^.*\t%(refs/%(heads/|tags/)=)=", "")')
                              else
                                let matches = s:LinesError('remote')[0]
                              endif
                              return s:FilterEscape(matches, a:A)
                            endfunction
                            
                            " Section: Buffer auto-commands
                            
    1              0.000003 function! s:ReplaceCmd(cmd) abort
                              let temp = tempname()
                              let [err, exec_error] = s:TempCmd(temp, a:cmd)
                              if exec_error
                                call s:throw((len(err) ? err : filereadable(temp) ? join(readfile(temp), ' ') : 'unknown error running ' . a:cmd))
                              endif
                              let temp = s:Resolve(temp)
                              let fn = expand('%:p')
                              silent exe 'keepalt file '.temp
                              let modelines = &modelines
                              try
                                set modelines=0
                                silent keepjumps noautocmd edit!
                              finally
                                let &modelines = modelines
                                try
                                  silent exe 'keepalt file '.s:fnameescape(fn)
                                catch /^Vim\%((\a\+)\)\=:E302:/
                                endtry
                                call delete(temp)
                                if s:cpath(fnamemodify(bufname('$'), ':p'), temp)
                                  silent execute 'bwipeout '.bufnr('$')
                                endif
                              endtry
                            endfunction
                            
    1              0.000003 function! s:QueryLog(refspec) abort
                              let lines = s:LinesError(['log', '-n', '256', '--format=%h%x09%s', a:refspec, '--'])[0]
                              call map(lines, 'split(v:val, "\t")')
                              call map(lines, '{"type": "Log", "commit": v:val[0], "subject": v:val[-1]}')
                              return lines
                            endfunction
                            
    1              0.000002 function! s:FormatLog(dict) abort
                              return a:dict.commit . ' ' . a:dict.subject
                            endfunction
                            
    1              0.000003 function! s:FormatRebase(dict) abort
                              return a:dict.status . ' ' . a:dict.commit . ' ' . a:dict.subject
                            endfunction
                            
    1              0.000003 function! s:FormatFile(dict) abort
                              return a:dict.status . ' ' . a:dict.filename
                            endfunction
                            
    1              0.000002 function! s:Format(val) abort
                              if type(a:val) == type({})
                                return s:Format{a:val.type}(a:val)
                              elseif type(a:val) == type([])
                                return map(copy(a:val), 's:Format(v:val)')
                              else
                                return '' . a:val
                              endif
                            endfunction
                            
    1              0.000003 function! s:AddHeader(key, value) abort
                              if empty(a:value)
                                return
                              endif
                              let before = 1
                              while !empty(getline(before))
                                let before += 1
                              endwhile
                              call append(before - 1, [a:key . ':' . (len(a:value) ? ' ' . a:value : '')])
                              if before == 1 && line('$') == 2
                                silent 2delete _
                              endif
                            endfunction
                            
    1              0.000003 function! s:AddSection(label, lines, ...) abort
                              let note = a:0 ? a:1 : ''
                              if empty(a:lines) && empty(note)
                                return
                              endif
                              call append(line('$'), ['', a:label . (len(note) ? ': ' . note : ' (' . len(a:lines) . ')')] + s:Format(a:lines))
                            endfunction
                            
    1              0.000002 function! fugitive#BufReadStatus() abort
                              let amatch = s:Slash(expand('%:p'))
                              let b:fugitive_type = 'index'
                              unlet! b:fugitive_reltime
                              try
                                silent doautocmd BufReadPre
                                let cmd = [fnamemodify(amatch, ':h')]
                                setlocal noro ma nomodeline buftype=nowrite
                                if s:cpath(fnamemodify($GIT_INDEX_FILE !=# '' ? $GIT_INDEX_FILE : fugitive#Find('.git/index'), ':p')) !=# s:cpath(amatch)
                                  let cmd += ['-c', 'GIT_INDEX_FILE=' . amatch]
                                endif
                                let cmd += ['status', '--porcelain', '-bz']
                                let [output, message, exec_error] = s:NullError(cmd)
                                if exec_error
                                  throw 'fugitive: ' . message
                                endif
                            
                                let head = matchstr(output[0], '^## \zs\S\+\ze\%($\| \[\)')
                                let pull = ''
                                if head =~# '\.\.\.'
                                  let [head, pull] = split(head, '\.\.\.')
                                  let branch = head
                                elseif head ==# 'HEAD' || empty(head)
                                  let head = FugitiveHead(11)
                                  let branch = ''
                                else
                                  let branch = head
                                endif
                            
                                let b:fugitive_status = {'Staged': {}, 'Unstaged': {}}
                                let [staged, unstaged, untracked] = [[], [], []]
                                let i = 0
                                while i < len(output)
                                  let line = output[i]
                                  let file = line[3:-1]
                                  let files = file
                                  let i += 1
                                  if line[2] !=# ' '
                                    continue
                                  endif
                                  if line[0:1] =~# '[RC]'
                                    let files = output[i] . ' -> ' . file
                                    let i += 1
                                  endif
                                  if line[0] !~# '[ ?!#]'
                                    call add(staged, {'type': 'File', 'status': line[0], 'filename': files})
                                  endif
                                  if line[0:1] ==# '??'
                                    call add(untracked, {'type': 'File', 'status': line[1], 'filename': files})
                                  elseif line[1] !~# '[ !#]'
                                    call add(unstaged, {'type': 'File', 'status': line[1], 'filename': files})
                                  endif
                                endwhile
                            
                                for dict in staged
                                  let b:fugitive_status['Staged'][dict.filename] = dict.status
                                endfor
                                for dict in unstaged
                                  let b:fugitive_status['Unstaged'][dict.filename] = dict.status
                                endfor
                            
                                let config = fugitive#Config()
                            
                                let pull_type = 'Pull'
                                if len(pull)
                                  let rebase = fugitive#Config('branch.' . branch . '.rebase', config)
                                  if empty(rebase)
                                    let rebase = fugitive#Config('pull.rebase', config)
                                  endif
                                  if rebase =~# '^\%(true\|yes\|on\|1\|interactive\)$'
                                    let pull_type = 'Rebase'
                                  elseif rebase =~# '^\%(false\|no|off\|0\|\)$'
                                    let pull_type = 'Merge'
                                  endif
                                endif
                            
                                let push_remote = fugitive#Config('branch.' . branch . '.pushRemote', config)
                                if empty(push_remote)
                                  let push_remote = fugitive#Config('remote.pushDefault', config)
                                endif
                                let push = len(push_remote) && len(branch) ? push_remote . '/' . branch : ''
                                if empty(push)
                                  let push = pull
                                endif
                            
                                if len(pull)
                                  let unpulled = s:QueryLog(head . '..' . pull)
                                else
                                  let unpulled = []
                                endif
                                if len(push)
                                  let unpushed = s:QueryLog(push . '..' . head)
                                else
                                  let unpushed = []
                                endif
                            
                                if isdirectory(fugitive#Find('.git/rebase-merge/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-merge/')
                                elseif isdirectory(fugitive#Find('.git/rebase-apply/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-apply/')
                                endif
                            
                                let rebasing = []
                                let rebasing_head = 'detached HEAD'
                                if exists('rebasing_dir') && filereadable(rebasing_dir . 'git-rebase-todo')
                                  let rebasing_head = substitute(readfile(rebasing_dir . 'head-name')[0], '\C^refs/heads/', '', '')
                                  let len = 11
                                  let lines = readfile(rebasing_dir . 'git-rebase-todo')
                                  for line in lines
                                    let hash = matchstr(line, '^[^a-z].*\s\zs[0-9a-f]\{4,\}\ze\.\.')
                                    if len(hash)
                                      let len = len(hash)
                                      break
                                    endif
                                  endfor
                                  if getfsize(rebasing_dir . 'done') > 0
                                    let done = readfile(rebasing_dir . 'done')
                                    call map(done, 'substitute(v:val, ''^\l\+\>'', "done", "")')
                                    let done[-1] = substitute(done[-1], '^\l\+\>', 'stop', '')
                                    let lines = done + lines
                                  endif
                                  call reverse(lines)
                                  for line in lines
                                    let match = matchlist(line, '^\(\l\+\)\s\+\(\x\{4,\}\)\s\+\(.*\)')
                                    if len(match) && match[1] !~# 'exec\|merge\|label'
                                      call add(rebasing, {'type': 'Rebase', 'status': get(s:rebase_abbrevs, match[1], match[1]), 'commit': strpart(match[2], 0, len), 'subject': match[3]})
                                    endif
                                  endfor
                                endif
                            
                                let diff = {'Staged': [], 'Unstaged': []}
                                if len(staged)
                                  let diff['Staged'] =
                                      \ s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix', '--cached'])[0]
                                endif
                                if len(unstaged)
                                  let diff['Unstaged'] =
                                      \ s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix'])[0]
                                endif
                                let b:fugitive_diff = diff
                                let expanded = get(b:, 'fugitive_expanded', {'Staged': {}, 'Unstaged': {}})
                                let b:fugitive_expanded = {'Staged': {}, 'Unstaged': {}}
                            
                                silent keepjumps %delete_
                            
                                call s:AddHeader('Head', head)
                                call s:AddHeader(pull_type, pull)
                                if push !=# pull
                                  call s:AddHeader('Push', push)
                                endif
                                call s:AddSection('Rebasing ' . rebasing_head, rebasing)
                                call s:AddSection('Untracked', untracked)
                                call s:AddSection('Unstaged', unstaged)
                                let unstaged_end = len(unstaged) ? line('$') : 0
                                call s:AddSection('Staged', staged)
                                let staged_end = len(staged) ? line('$') : 0
                                call s:AddSection('Unpushed to ' . push, unpushed)
                                call s:AddSection('Unpulled from ' . pull, unpulled)
                            
                                setlocal nomodified readonly noswapfile
                                silent doautocmd BufReadPost
                                setlocal nomodifiable
                                if &bufhidden ==# ''
                                  setlocal bufhidden=delete
                                endif
                                let b:dispatch = ':Gfetch --all'
                                call fugitive#MapJumps()
                                call s:Map('n', '-', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
                                call s:Map('x', '-', ":<C-U>execute <SID>Do('Toggle',1)<CR>", '<silent>')
                                call s:Map('n', 's', ":<C-U>execute <SID>Do('Stage',0)<CR>", '<silent>')
                                call s:Map('x', 's', ":<C-U>execute <SID>Do('Stage',1)<CR>", '<silent>')
                                call s:Map('n', 'u', ":<C-U>execute <SID>Do('Unstage',0)<CR>", '<silent>')
                                call s:Map('x', 'u', ":<C-U>execute <SID>Do('Unstage',1)<CR>", '<silent>')
                                call s:Map('n', 'U', ":exe <SID>EchoExec('reset', '-q')<CR>", '<silent>')
                                call s:MapMotion('gu', "exe <SID>StageJump(v:count, 'Untracked', 'Unstaged')")
                                call s:MapMotion('gU', "exe <SID>StageJump(v:count, 'Unstaged', 'Untracked')")
                                call s:MapMotion('gs', "exe <SID>StageJump(v:count, 'Staged')")
                                call s:MapMotion('gp', "exe <SID>StageJump(v:count, 'Unpushed')")
                                call s:MapMotion('gP', "exe <SID>StageJump(v:count, 'Unpulled')")
                                call s:MapMotion('gr', "exe <SID>StageJump(v:count, 'Rebasing')")
                                call s:Map('n', 'C', ":<C-U>Gcommit<CR>:echohl WarningMsg<Bar>echo ':Gstatus C is deprecated in favor of cc'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'a', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
                                call s:Map('n', 'i', ":<C-U>execute <SID>NextExpandedHunk(v:count1)<CR>", '<silent>')
                                call s:Map('n', "=", ":<C-U>execute <SID>StageInline('toggle',line('.'),v:count)<CR>", '<silent>')
                                call s:Map('n', "<", ":<C-U>execute <SID>StageInline('hide',  line('.'),v:count)<CR>", '<silent>')
                                call s:Map('n', ">", ":<C-U>execute <SID>StageInline('show',  line('.'),v:count)<CR>", '<silent>')
                                call s:Map('x', "=", ":<C-U>execute <SID>StageInline('toggle',line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('x', "<", ":<C-U>execute <SID>StageInline('hide',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('x', ">", ":<C-U>execute <SID>StageInline('show',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('n', 'D', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'dd', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'dh', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'ds', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'dp', ":<C-U>execute <SID>StageDiffEdit()<CR>", '<silent>')
                                call s:Map('n', 'dv', ":<C-U>execute <SID>StageDiff('Gvdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
                                call s:Map('n', 'P', ":<C-U>execute <SID>StagePatch(line('.'),line('.')+v:count1-1)<CR>", '<silent>')
                                call s:Map('x', 'P', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                call s:Map('n', 'p', ":<C-U>if v:count<Bar>silent exe <SID>GF('pedit')<Bar>else<Bar>echoerr 'Use = for inline diff, P for :Git add/reset --patch, 1p for :pedit'<Bar>endif<CR>", '<silent>')
                                call s:Map('x', 'p', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                call s:Map('n', 'I', ":<C-U>execute <SID>StagePatch(line('.'),line('.'))<CR>", '<silent>')
                                call s:Map('x', 'I', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q :<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<Bar>echohl WarningMsg<Bar>echo ':Gstatus q is deprecated in favor of gq or the built-in <Lt>C-W>q'<Bar>echohl NONE<CR>
                                endif
                                call s:Map('n', 'gq', ":<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<CR>", '<silent>')
                                call s:Map('n', 'R', ":echohl WarningMsg<Bar>echo 'Reloading is automatic.  Use :e to force'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent>')
                                call s:Map('x', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent>')
                                call s:Map('n', 'X', ":<C-U>execute <SID>StageDelete(line('.'), 0, v:count)<CR>", '<silent>')
                                call s:Map('x', 'X', ":<C-U>execute <SID>StageDelete(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
                                call s:Map('n', 'gI', ":<C-U>execute <SID>StageIgnore(line('.'), line('.'), v:count)<CR>", '<silent>')
                                call s:Map('x', 'gI', ":<C-U>execute <SID>StageIgnore(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
                                call s:Map('n', '.', ':<C-U> <C-R>=<SID>StageArgs(0)<CR><Home>')
                                call s:Map('x', '.', ':<C-U> <C-R>=<SID>StageArgs(1)<CR><Home>')
                                setlocal filetype=fugitive
                            
                                for [lnum, section] in [[staged_end, 'Staged'], [unstaged_end, 'Unstaged']]
                                  while len(getline(lnum))
                                    let filename = matchstr(getline(lnum), '^[A-Z?] \zs.*')
                                    if has_key(expanded[section], filename)
                                      call s:StageInline('show', lnum)
                                    endif
                                    let lnum -= 1
                                  endwhile
                                endfor
                            
                                let b:fugitive_reltime = reltime()
                                return ''
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000003 function! fugitive#FileReadCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let [dir, rev] = s:DirRev(amatch)
                              let line = a:0 > 1 ? a:2 : line("'[")
                              if empty(dir)
                                return 'noautocmd ' . line . 'read ' . s:fnameescape(amatch)
                              endif
                              if rev !~# ':' && s:ChompDefault('', [dir, 'cat-file', '-t', rev]) =~# '^\%(commit\|tag\)$'
                                let cmd = fugitive#Prepare(dir, 'log', '--pretty=format:%B', '-1', rev, '--')
                              else
                                let cmd = fugitive#Prepare(dir, 'cat-file', '-p', rev)
                              endif
                              return line . 'read !' . escape(cmd, '!#%')
                            endfunction
                            
    1              0.000003 function! fugitive#FileWriteCmd(...) abort
                              let tmp = tempname()
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let autype = a:0 > 1 ? 'Buf' : 'File'
                              if exists('#' . autype . 'WritePre')
                                execute 'doautocmd ' . autype . 'WritePre ' . s:fnameescape(amatch)
                              endif
                              try
                                let [dir, commit, file] = s:DirCommitFile(amatch)
                                if commit !~# '^[0-3]$' || !v:cmdbang && (line("'[") != 1 || line("']") != line('$'))
                                  return "noautocmd '[,']write" . (v:cmdbang ? '!' : '') . ' ' . s:fnameescape(amatch)
                                endif
                                silent execute "'[,']write !".fugitive#Prepare(dir, 'hash-object', '-w', '--stdin', '--').' > '.tmp
                                let sha1 = readfile(tmp)[0]
                                let old_mode = matchstr(s:SystemError([dir, 'ls-files', '--stage', '.' . file])[0], '^\d\+')
                                if empty(old_mode)
                                  let old_mode = executable(s:Tree(dir) . file) ? '100755' : '100644'
                                endif
                                let info = old_mode.' '.sha1.' '.commit."\t".file[1:-1]
                                let [error, exec_error] = s:SystemError([dir, 'update-index', '--index-info'], info . "\n")
                                if !exec_error
                                  setlocal nomodified
                                  if exists('#' . autype . 'WritePost')
                                    execute 'doautocmd ' . autype . 'WritePost ' . s:fnameescape(amatch)
                                  endif
                                  return ''
                                else
                                  return 'echoerr '.string('fugitive: '.error)
                                endif
                              finally
                                call delete(tmp)
                              endtry
                            endfunction
                            
    1              0.000006 let s:nomodeline = (v:version >= 704 ? '<nomodeline>' : '')
                            
    1              0.000002 function! fugitive#BufReadCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              try
                                let [dir, rev] = s:DirRev(amatch)
                                if empty(dir)
                                  return 'echo "Invalid Fugitive URL"'
                                endif
                                if rev =~# '^:\d$'
                                  let b:fugitive_type = 'stage'
                                else
                                  let [b:fugitive_type, exec_error] = s:ChompError([dir, 'cat-file', '-t', rev])
                                  if exec_error && rev =~# '^:0'
                                    let sha = s:ChompDefault('', dir, 'write-tree', '--prefix=' . rev[3:-1])
                                    let exec_error = empty(sha)
                                    let b:fugitive_type = exec_error ? '' : 'tree'
                                  endif
                                  if exec_error
                                    let error = b:fugitive_type
                                    unlet b:fugitive_type
                                    setlocal noswapfile
                                    if empty(&bufhidden)
                                      setlocal bufhidden=delete
                                    endif
                                    if rev =~# '^:\d:'
                                      let &l:readonly = !filewritable(fugitive#Find('.git/index', dir))
                                      return 'silent doautocmd BufNewFile'
                                    else
                                      setlocal readonly nomodifiable
                                      return 'silent doautocmd BufNewFile|echo ' . string(error)
                                    endif
                                  elseif b:fugitive_type !~# '^\%(tag\|commit\|tree\|blob\)$'
                                    return "echoerr ".string("fugitive: unrecognized git type '".b:fugitive_type."'")
                                  endif
                                  if !exists('b:fugitive_display_format') && b:fugitive_type != 'blob'
                                    let b:fugitive_display_format = +getbufvar('#','fugitive_display_format')
                                  endif
                                endif
                            
                                if b:fugitive_type !=# 'blob'
                                  setlocal nomodeline
                                endif
                            
                                setlocal noreadonly modifiable
                                let pos = getpos('.')
                                silent keepjumps %delete_
                                setlocal endofline
                            
                                try
                                  silent doautocmd BufReadPre
                                  if b:fugitive_type ==# 'tree'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'ls-tree', exists('sha') ? sha : rev])
                                    else
                                      if !exists('sha')
                                        let sha = s:TreeChomp(dir, 'rev-parse', '--verify', rev, '--')
                                      endif
                                      call s:ReplaceCmd([dir, 'show', '--no-color', sha])
                                    endif
                                  elseif b:fugitive_type ==# 'tag'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                    else
                                      call s:ReplaceCmd([dir, 'cat-file', '-p', rev])
                                    endif
                                  elseif b:fugitive_type ==# 'commit'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                    else
                                      call s:ReplaceCmd([dir, 'show', '--no-color', '--pretty=format:tree%x20%T%nparent%x20%P%nauthor%x20%an%x20<%ae>%x20%ad%ncommitter%x20%cn%x20<%ce>%x20%cd%nencoding%x20%e%n%n%s%n%n%b', rev])
                                      keepjumps call search('^parent ')
                                      if getline('.') ==# 'parent '
                                        silent keepjumps delete_
                                      else
                                        silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps s/\m\C\%(^parent\)\@<! /\rparent /e' . (&gdefault ? '' : 'g')
                                      endif
                                      keepjumps let lnum = search('^encoding \%(<unknown>\)\=$','W',line('.')+3)
                                      if lnum
                                        silent keepjumps delete_
                                      end
                                      silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps 1,/^diff --git\|\%$/s/\r$//e'
                                      keepjumps 1
                                    endif
                                  elseif b:fugitive_type ==# 'stage'
                                    call s:ReplaceCmd([dir, 'ls-files', '--stage'])
                                  elseif b:fugitive_type ==# 'blob'
                                    call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                  endif
                                finally
                                  keepjumps call setpos('.',pos)
                                  setlocal nomodified noswapfile
                                  let modifiable = rev =~# '^:.:' && b:fugitive_type !=# 'tree'
                                  let &l:readonly = !modifiable || !filewritable(fugitive#Find('.git/index', dir))
                                  if empty(&bufhidden)
                                    setlocal bufhidden=delete
                                  endif
                                  let &l:modifiable = modifiable
                                  if b:fugitive_type !=# 'blob'
                                    setlocal filetype=git foldmethod=syntax
                                    call s:Map('n', 'a', ":<C-U>let b:fugitive_display_format += v:count1<Bar>exe fugitive#BufReadCmd(@%)<CR>", '<silent>')
                                    call s:Map('n', 'i', ":<C-U>let b:fugitive_display_format -= v:count1<Bar>exe fugitive#BufReadCmd(@%)<CR>", '<silent>')
                                  endif
                                  call fugitive#MapJumps()
                                endtry
                            
                                setlocal modifiable
                                return 'silent doautocmd' . s:nomodeline .
                                      \ ' BufReadPost' . (modifiable ? '' : '|setl nomodifiable')
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000014 function! fugitive#BufWriteCmd(...) abort
                              return fugitive#FileWriteCmd(a:0 ? a:1 : expand('<amatch>'), 1)
                            endfunction
                            
    1              0.000002 function! fugitive#SourceCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let temp = s:BlobTemp(amatch)
                              if empty(temp)
                                return 'noautocmd source ' . s:fnameescape(amatch)
                              endif
                              if !exists('g:virtual_scriptnames')
                                let g:virtual_scriptnames = {}
                              endif
                              let g:virtual_scriptnames[temp] = amatch
                              return 'source ' . s:fnameescape(temp)
                            endfunction
                            
                            " Section: Temp files
                            
    1              0.000005 if !exists('s:temp_files')
    1              0.000004   let s:temp_files = {}
    1              0.000001 endif
                            
    1              0.000003 function! s:TempState(...) abort
                              return get(s:temp_files, s:cpath(fnamemodify(a:0 ? a:1 : @%, ':p')), {})
                            endfunction
                            
    1              0.000005 function! s:TempReadPre(file) abort
                              if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nomodeline
                                setlocal bufhidden=delete nobuflisted
                                setlocal buftype=nowrite
                                if has_key(dict, 'modifiable')
                                  let &l:modifiable = dict.modifiable
                                endif
                                if len(dict.dir)
                                  let b:git_dir = dict.dir
                                  call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! s:TempReadPost(file) abort
                              if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                if has_key(dict, 'filetype') && dict.filetype !=# &l:filetype
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<,>>>>>>>
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q    :<C-U>bdelete<Bar>echohl WarningMsg<Bar>echo "Temp file q is deprecated in favor of the built-in <Lt>C-W>q"<Bar>echohl NONE<CR>
                                endif
                                if !&modifiable
                                  call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000006 augroup fugitive_temp
    1              0.000206   autocmd!
    1              0.000018   autocmd BufReadPre  * exe s:TempReadPre( expand('<amatch>:p'))
    1              0.000017   autocmd BufReadPost * exe s:TempReadPost(expand('<amatch>:p'))
    1              0.000002 augroup END
                            
                            " Section: :Git
                            
    1              0.000005 function! fugitive#Command(line1, line2, range, bang, mods, arg) abort
                              let dir = s:Dir()
                              let [args, after] = s:SplitExpandChain(a:arg, s:Tree(dir))
                              if empty(args)
                                let cmd = s:StatusCommand(a:line1, a:line2, a:range, a:line2, a:bang, a:mods, '', '', [])
                                return (empty(cmd) ? 'exe' : cmd) . after
                              endif
                              let alias = get(s:Aliases(dir), args[0], '!')
                              if get(args, 1, '') !=# '--help' && alias !~# '^!\|[\"'']' && !filereadable(s:ExecPath() . '/git-' . args[0])
                                    \ && !(has('win32') && filereadable(s:ExecPath() . '/git-' . args[0] . '.exe'))
                                call remove(args, 0)
                                call extend(args, split(alias, '\s\+'), 'keep')
                              endif
                              let name = substitute(args[0], '\%(^\|-\)\(\l\)', '\u\1', 'g')
                              if exists('*s:' . name . 'Subcommand') && get(args, 1, '') !=# '--help'
                                try
                                  exe s:DirCheck(dir)
                                  return 'exe ' . string(s:{name}Subcommand(a:line1, a:line2, a:range, a:bang, a:mods, args[1:-1])) . after
                                catch /^fugitive:/
                                  return 'echoerr ' . string(v:exception)
                                endtry
                              endif
                              if a:bang || args[0] =~# '^-P$\|^--no-pager$\|diff\%(tool\)\@!\|log\|^show$' ||
                                    \ (args[0] ==# 'stash' && get(args, 1, '') ==# 'show') ||
                                    \ (args[0] ==# 'help' || get(args, 1, '') ==# '--help') && !s:HasOpt(args, '--web')
                                return s:OpenExec((a:line2 > 0 ? a:line2 : '') . (a:line2 ? 'split' : 'edit'), a:mods, args, dir) . after
                              endif
                              if s:HasOpt(args, ['add', 'checkout', 'commit', 'stage', 'stash', 'reset'], '-p', '--patch') ||
                                    \ s:HasOpt(args, ['add', 'clean', 'stage'], '-i', '--interactive') ||
                                    \ index(['--paginate', '-p'], args[0]) >= 0
                                let mods = substitute(s:Mods(a:mods), '\<tab\>', '-tab', 'g')
                                let assign = len(dir) ? '|let b:git_dir = ' . string(dir) : ''
                                if has('nvim')
                                  if &autowrite || &autowriteall | silent! wall | endif
                                  return mods . (a:line2 ? 'split' : 'edit') . ' term://' . s:fnameescape(s:UserCommand(dir, args)) . assign . '|startinsert' . after
                                elseif has('terminal')
                                  if &autowrite || &autowriteall | silent! wall | endif
                                  return 'exe ' . string(mods . 'terminal ' . (a:line2 ? '' : '++curwin ') . join(map(s:UserCommandList(dir) + args, 's:fnameescape(v:val)'))) . assign . after
                                endif
                              endif
                              if has('gui_running') && !has('win32')
                                call insert(args, '--no-pager')
                              endif
                              let pre = ''
                              if has('nvim') && executable('env')
                                let pre .= 'env GIT_TERMINAL_PROMPT=0 '
                              endif
                              return 'exe ' . string('!' . escape(pre . s:UserCommand(dir, args), '!#%')) . after
                            endfunction
                            
    1              0.000004 let s:exec_paths = {}
    1              0.000003 function! s:ExecPath() abort
                              if !has_key(s:exec_paths, g:fugitive_git_executable)
                                let s:exec_paths[g:fugitive_git_executable] = s:sub(system(g:fugitive_git_executable.' --exec-path'),'\n$','')
                              endif
                              return s:exec_paths[g:fugitive_git_executable]
                            endfunction
                            
    1              0.000003 function! s:Subcommands() abort
                              let exec_path = s:ExecPath()
                              return map(split(glob(exec_path.'/git-*'),"\n"),'s:sub(v:val[strlen(exec_path)+5 : -1],"\\.exe$","")')
                            endfunction
                            
    1              0.000003 let s:aliases = {}
    1              0.000002 function! s:Aliases(dir) abort
                              if !has_key(s:aliases, a:dir)
                                let s:aliases[a:dir] = {}
                                let lines = s:NullError([a:dir, 'config', '-z', '--get-regexp', '^alias[.]'])[0]
                                for line in lines
                                  let s:aliases[a:dir][matchstr(line, '\.\zs.\{-}\ze\n')] = matchstr(line, '\n\zs.*')
                                endfor
                              endif
                              return s:aliases[a:dir]
                            endfunction
                            
    1              0.000002 function! fugitive#Complete(lead, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 == 3 ? a:3 : s:Dir()
                              let pre = a:0 > 1 ? strpart(a:1, 0, a:2) : ''
                              let subcmd = matchstr(pre, '\u\w*[! ] *\zs[[:alnum:]-]\+\ze ')
                              if empty(subcmd)
                                let results = sort(s:Subcommands() + keys(s:Aliases(dir)))
                              elseif pre =~# ' -- '
                                return fugitive#CompletePath(a:lead, dir)
                              elseif a:lead =~# '^-'
                                let results = split(s:ChompDefault('', dir, subcmd, '--git-completion-helper'), ' ')
                              else
                                return fugitive#CompleteObject(a:lead, dir)
                              endif
                              return filter(results, 'strpart(v:val, 0, strlen(a:lead)) ==# a:lead')
                            endfunction
                            
                            " Section: :Gcd, :Glcd
                            
    1              0.000015 function! fugitive#CdComplete(A, L, P) abort
                              return filter(fugitive#CompletePath(a:A), 'v:val =~# "/$"')
                            endfunction
                            
    1              0.000002 function! fugitive#Cd(path, ...) abort
                              let path = substitute(a:path, '^:/:\=\|^:(\%(top\|top,literal\|literal,top\|literal\))', '', '')
                              if path !~# '^/\|^\a\+:\|^\.\.\=\%(/\|$\)'
                                let dir = s:Dir()
                                exe s:DirCheck(dir)
                                let path = (empty(s:Tree(dir)) ? dir : s:Tree(dir)) . '/' . path
                              endif
                              return (a:0 && a:1 ? 'lcd ' : 'cd ') . s:fnameescape(FugitiveVimPath(path))
                            endfunction
                            
                            " Section: :Gstatus
                            
    1   0.000065   0.000008 call s:command("-bar -bang -range=-1 -addr=other Gstatus", "Status")
                            
    1              0.000005 function! s:StatusCommand(line1, line2, range, count, bang, mods, reg, arg, args, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              exe s:DirCheck(dir)
                              try
                                let mods = s:Mods(a:mods, &splitbelow ? 'botright' : 'topleft')
                                let file = fugitive#Find(':', dir)
                                let arg = ' +setl\ foldmethod=syntax\ foldlevel=1\|let\ w:fugitive_status=FugitiveGitDir() ' .
                                      \ s:fnameescape(file)
                                for winnr in range(1, winnr('$'))
                                  if s:cpath(file, fnamemodify(bufname(winbufnr(winnr)), ':p'))
                                    if winnr == winnr()
                                      call s:ReloadStatus()
                                    else
                                      call s:ExpireStatus(dir)
                                      exe winnr . 'wincmd w'
                                    endif
                                    let w:fugitive_status = dir
                                    1
                                    return ''
                                  endif
                                endfor
                                if a:count ==# 0
                                  return mods . 'edit' . (a:bang ? '!' : '') . arg
                                elseif a:bang
                                  return mods . 'pedit' . arg . '|wincmd P'
                                else
                                  return mods . (a:count > 0 ? a:count : '') . 'split' . arg
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              return ''
                            endfunction
                            
    1              0.000004 function! s:StageJump(offset, section, ...) abort
                              let line = search('^\%(' . a:section . '\)', 'nw')
                              if !line && a:0
                                let line = search('^\%(' . a:1 . '\)', 'nw')
                              endif
                              if line
                                exe line
                                if a:offset
                                  for i in range(a:offset)
                                    call search(s:file_commit_pattern . '\|^$', 'W')
                                    if empty(getline('.')) && a:0 && getline(line('.') + 1) =~# '^\%(' . a:1 . '\)'
                                      call search(s:file_commit_pattern . '\|^$', 'W')
                                    endif
                                    if empty(getline('.'))
                                      return ''
                                    endif
                                  endfor
                                  call s:StageReveal()
                                else
                                  call s:StageReveal()
                                  +
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000013 function! s:StageSeek(info, fallback) abort
                              let info = a:info
                              if empty(info.section)
                                return a:fallback
                              endif
                              let line = search('^' . info.section, 'wn')
                              if !line
                                for section in get({'Staged': ['Unstaged', 'Untracked'], 'Unstaged': ['Untracked', 'Staged'], 'Untracked': ['Unstaged', 'Staged']}, info.section, [])
                                  let line = search('^' . section, 'wn')
                                  if line
                                    return line + (info.index > 0 ? 1 : 0)
                                  endif
                                endfor
                                return 1
                              endif
                              let i = 0
                              while len(getline(line))
                                let filename = matchstr(getline(line), '^[A-Z?] \zs.*')
                                if len(filename) &&
                                      \ ((info.filename[-1:-1] ==# '/' && filename[0 : len(info.filename) - 1] ==# info.filename) ||
                                      \ (filename[-1:-1] ==# '/' && filename ==# info.filename[0 : len(filename) - 1]) ||
                                      \ filename ==# info.filename)
                                  if info.offset < 0
                                    return line
                                  else
                                    if getline(line+1) !~# '^@'
                                      exe s:StageInline('show', line)
                                    endif
                                    if getline(line+1) !~# '^@'
                                      return line
                                    endif
                                    let type = info.sigil ==# '-' ? '-' : '+'
                                    let offset = -1
                                    while offset < info.offset
                                      let line += 1
                                      if getline(line) =~# '^@'
                                        let offset = +matchstr(getline(line), type . '\zs\d\+') - 1
                                      elseif getline(line) =~# '^[ ' . type . ']'
                                        let offset += 1
                                      elseif getline(line) !~# '^[ @\+-]'
                                        return line - 1
                                      endif
                                    endwhile
                                    return line
                                  endif
                                endif
                                let commit = matchstr(getline(line), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\+')
                                if len(commit) && commit ==# info.commit
                                  return line
                                endif
                                if i ==# info.index
                                  let backup = line
                                endif
                                let i += getline(line) !~# '^[ @\+-]'
                                let line += 1
                              endwhile
                              return exists('backup') ? backup : line - 1
                            endfunction
                            
    1              0.000002 function! s:ReloadStatus(...) abort
                              call s:ExpireStatus(-1)
                              if get(b:, 'fugitive_type', '') !=# 'index'
                                return ''
                              endif
                              let original_lnum = a:0 ? a:1 : line('.')
                              let info = s:StageInfo(original_lnum)
                              call fugitive#BufReadStatus()
                              exe s:StageSeek(info, original_lnum)
                              normal! 0
                              return ''
                            endfunction
                            
    1              0.000006 let s:last_time = reltime()
    1              0.000003 if !exists('s:last_times')
    1              0.000002   let s:last_times = {}
    1              0.000004 endif
                            
    1              0.000003 function! s:ExpireStatus(bufnr) abort
                              if a:bufnr == -2
                                let s:last_time = reltime()
                                return ''
                              endif
                              let dir = s:Dir(a:bufnr)
                              if len(dir)
                                let s:last_times[s:cpath(dir)] = reltime()
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! FugitiveReloadCheck() abort
                              let t = b:fugitive_reltime
                              return [t, reltimestr(reltime(s:last_time, t)),
                                    \ reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t))]
                            endfunction
                            
    1              0.000002 function! s:ReloadWinStatus(...) abort
                              if get(b:, 'fugitive_type', '') !=# 'index' || &modified
                                return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatus()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' ||
                                    \ reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatus()
                              endif
                            endfunction
                            
    1              0.000003 function! s:ReloadTabStatus(...) abort
                              let mytab = tabpagenr()
                              let tab = a:0 ? a:1 : mytab
                              for winnr in range(1, tabpagewinnr(tab, '$'))
                                if getbufvar(tabpagebuflist(tab)[winnr-1], 'fugitive_type') ==# 'index'
                                  execute 'tabnext '.tab
                                  if winnr != winnr()
                                    execute winnr.'wincmd w'
                                    let restorewinnr = 1
                                  endif
                                  try
                                    call s:ReloadWinStatus()
                                  finally
                                    if exists('restorewinnr')
                                      unlet restorewinnr
                                      wincmd p
                                    endif
                                    execute 'tabnext '.mytab
                                  endtry
                                endif
                              endfor
                              unlet! t:fugitive_reload_status
                            endfunction
                            
    1              0.000002 function! fugitive#ReloadStatus(...) abort
                              call s:ExpireStatus(a:0 ? a:1 : -2)
                              if a:0 > 1 ? a:2 : s:CanAutoReloadStatus()
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
                              else
                                call s:ReloadWinStatus()
                              endif
                            endfunction
                            
    1              0.000003 function! s:CanAutoReloadStatus() abort
                              return get(g:, 'fugitive_autoreload_status', !has('win32'))
                            endfunction
                            
    1              0.000003 augroup fugitive_status
    1              0.000094   autocmd!
    1              0.000014   autocmd BufWritePost         * call fugitive#ReloadStatus(-1, 0)
    1              0.000008   autocmd ShellCmdPost     * nested call fugitive#ReloadStatus()
    1              0.000018   autocmd BufDelete term://* nested call fugitive#ReloadStatus()
    1              0.000007   if !has('win32')
    1              0.000006     autocmd FocusGained        * call fugitive#ReloadStatus(-2, 0)
    1              0.000002   endif
    1              0.000009   autocmd BufEnter index,index.lock
                                    \ call s:ReloadWinStatus()
    1              0.000008   autocmd TabEnter *
                                    \ if exists('t:fugitive_reload_status') |
                                    \    call s:ReloadTabStatus() |
                                    \ endif
    1              0.000002 augroup END
                            
    1              0.000004 function! s:StageInfo(...) abort
                              let lnum = a:0 ? a:1 : line('.')
                              let sigil = matchstr(getline(lnum), '^[ @\+-]')
                              let offset = -1
                              if len(sigil)
                                let type = sigil ==# '-' ? '-' : '+'
                                while lnum > 0 && getline(lnum) !~# '^@'
                                  if getline(lnum) =~# '^[ '.type.']'
                                    let offset += 1
                                  endif
                                  let lnum -= 1
                                endwhile
                                let offset += matchstr(getline(lnum), type.'\zs\d\+')
                                while getline(lnum) =~# '^[ @\+-]'
                                  let lnum -= 1
                                endwhile
                              endif
                              let slnum = lnum + 1
                              let section = ''
                              let index = 0
                              while len(getline(slnum - 1)) && empty(section)
                                let slnum -= 1
                                let section = matchstr(getline(slnum), '^\u\l\+\ze.* (\d\+)$')
                                if empty(section) && getline(slnum) !~# '^[ @\+-]'
                                  let index += 1
                                endif
                              endwhile
                              let text = matchstr(getline(lnum), '^[A-Z?] \zs.*')
                              return {'section': section,
                                    \ 'heading': getline(slnum),
                                    \ 'sigil': sigil,
                                    \ 'offset': offset,
                                    \ 'filename': text,
                                    \ 'relative': reverse(split(text, ' -> ')),
                                    \ 'paths': map(reverse(split(text, ' -> ')), 's:Tree() . "/" . v:val'),
                                    \ 'commit': matchstr(getline(lnum), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\{4,\}\ze '),
                                    \ 'status': matchstr(getline(lnum), '^[A-Z?]\ze \|^\%(\x\x\x\)\@!\l\+\ze [0-9a-f]'),
                                    \ 'index': index}
                            endfunction
                            
    1              0.000003 function! s:Selection(arg1, ...) abort
                              if a:arg1 ==# 'n'
                                let arg1 = line('.')
                                let arg2 = -v:count
                              elseif a:arg1 ==# 'v'
                                let arg1 = line("'<")
                                let arg2 = line("'>")
                              else
                                let arg1 = a:arg1
                                let arg2 = a:0 ? a:1 : 0
                              endif
                              let first = arg1
                              if arg2 < 0
                                let last = first - arg2 + 1
                              elseif arg2 > 0
                                let last = arg2
                              else
                                let last = first
                              endif
                              while getline(first) =~# '^$\|^[A-Z][a-z]'
                                let first += 1
                              endwhile
                              if first > last || &filetype !=# 'fugitive'
                                return []
                              endif
                              let flnum = first
                              while getline(flnum) =~# '^[ @\+-]'
                                let flnum -= 1
                              endwhile
                              let slnum = flnum + 1
                              let section = ''
                              let index = 0
                              while len(getline(slnum - 1)) && empty(section)
                                let slnum -= 1
                                let heading = matchstr(getline(slnum), '^\u\l\+.* (\d\+)$')
                                if empty(heading) && getline(slnum) !~# '^[ @\+-]'
                                  let index += 1
                                endif
                              endwhile
                              let results = []
                              let template = {
                                    \ 'heading': heading,
                                    \ 'section': matchstr(heading, '^\u\l\+\ze.* (\d\+)$'),
                                    \ 'filename': '',
                                    \ 'relative': [],
                                    \ 'paths': [],
                                    \ 'commit': '',
                                    \ 'status': '',
                                    \ 'patch': 0,
                                    \ 'index': index}
                              let line = getline(flnum)
                              let lnum = first - (arg1 == flnum ? 0 : 1)
                              let root = s:Tree() . '/'
                              while lnum <= last
                                if line =~# '^\u\l\+\ze.* (\d\+)$'
                                  let template.heading = getline(lnum)
                                  let template.section = matchstr(template.heading, '^\u\l\+\ze.* (\d\+)$')
                                  let template.index = 0
                                elseif line =~# '^[ @\+-]'
                                  let template.index -= 1
                                  if !results[-1].patch
                                    let results[-1].patch = lnum
                                  endif
                                  let results[-1].lnum = lnum
                                elseif line =~# '^[A-Z?] '
                                  let filename = matchstr(line, '^[A-Z?] \zs.*')
                                  call add(results, extend(deepcopy(template), {
                                        \ 'lnum': lnum,
                                        \ 'filename': filename,
                                        \ 'relative': reverse(split(filename, ' -> ')),
                                        \ 'paths': map(reverse(split(filename, ' -> ')), 'root . v:val'),
                                        \ 'status': matchstr(line, '^[A-Z?]'),
                                        \ }))
                                elseif line =~# '^\x\x\x\+ '
                                  call add(results, extend({
                                        \ 'lnum': lnum,
                                        \ 'commit': matchstr(line, '^\x\x\x\+'),
                                        \ }, template, 'keep'))
                                elseif line =~# '^\l\+ \x\x\x\+ '
                                  call add(results, extend({
                                        \ 'lnum': lnum,
                                        \ 'commit': matchstr(line, '^\l\+ \zs\x\x\x\+'),
                                        \ 'status': matchstr(line, '^\l\+'),
                                        \ }, template, 'keep'))
                                endif
                                let lnum += 1
                                let template.index += 1
                                let line = getline(lnum)
                              endwhile
                              if len(results) && results[0].patch && arg2 == 0
                                while getline(results[0].patch) =~# '^[ \+-]'
                                  let results[0].patch -= 1
                                endwhile
                                while getline(results[0].lnum + 1) =~# '^[ \+-]'
                                  let results[0].lnum += 1
                                endwhile
                              endif
                              return results
                            endfunction
                            
    1              0.000017 function! s:StageArgs(visual) abort
                              let commits = []
                              let paths = []
                              for record in s:Selection(a:visual ? 'v' : 'n')
                                if len(record.commit)
                                  call add(commits, record.commit)
                                endif
                                call extend(paths, record.paths)
                              endfor
                              if s:cpath(s:Tree(), getcwd())
                                call map(paths, 'fugitive#Path(v:val, "./")')
                              endif
                              return join(map(commits + paths, 's:fnameescape(v:val)'), ' ')
                            endfunction
                            
    1              0.000003 function! s:Do(action, visual) abort
                              let line = getline('.')
                              let reload = 0
                              if !a:0 && !v:count && line =~# '^[A-Z][a-z]'
                                let header = matchstr(line, '^\S\+\ze:')
                                if len(header) && exists('*s:Do' . a:action . header . 'Header')
                                  let reload = s:Do{a:action}{header}Header(matchstr(line, ': \zs.*')) > 0
                                else
                                  let section = matchstr(line, '^\S\+')
                                  if exists('*s:Do' . a:action . section . 'Heading')
                                    let reload = s:Do{a:action}{section}Heading(line) > 0
                                  endif
                                endif
                                return reload ? s:ReloadStatus() : ''
                              endif
                              let selection = s:Selection(a:visual ? 'v' : 'n')
                              if empty(selection)
                                return ''
                              endif
                              call filter(selection, 'v:val.section ==# selection[0].section')
                              let status = 0
                              let err = ''
                              try
                                for record in selection
                                  if exists('*s:Do' . a:action . record.section)
                                    let status = s:Do{a:action}{record.section}(record)
                                  else
                                    continue
                                  endif
                                  if !status
                                    return ''
                                  endif
                                  let reload = reload || (status > 0)
                                endfor
                                if status < 0
                                  execute record.lnum + 1
                                endif
                                let success = 1
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                if reload
                                  execute s:ReloadStatus()
                                endif
                                if exists('success')
                                  call s:StageReveal()
                                endif
                              endtry
                              return ''
                            endfunction
                            
    1              0.000003 function! s:StageReveal(...) abort
                              let begin = a:0 ? a:1 : line('.')
                              if getline(begin) =~# '^@'
                                let end = begin + 1
                                while getline(end) =~# '^[ \+-]'
                                  let end += 1
                                endwhile
                              elseif getline(begin) =~# '^commit '
                                let end = begin
                                while end < line('$') && getline(end + 1) !~# '^commit '
                                  let end += 1
                                endwhile
                              elseif getline(begin) =~# s:section_pattern
                                let end = begin
                                while len(getline(end + 1))
                                  let end += 1
                                endwhile
                              endif
                              if exists('end')
                                while line('.') > line('w0') + &scrolloff && end > line('w$')
                                  execute "normal! \<C-E>"
                                endwhile
                              endif
                            endfunction
                            
    1              0.000005 let s:file_pattern = '^[A-Z?] .\|^diff --'
    1              0.000005 let s:file_commit_pattern = s:file_pattern . '\|^\%(\l\{3,\} \)\=[0-9a-f]\{4,\} '
    1              0.000004 let s:item_pattern = s:file_commit_pattern . '\|^@@'
                            
    1              0.000002 function! s:NextHunk(count) abort
                              if &filetype ==# 'fugitive' && getline('.') =~# s:file_pattern
                                exe s:StageInline('show')
                              endif
                              for i in range(a:count)
                                if &filetype ==# 'fugitive'
                                  call search(s:file_pattern . '\|^@', 'W')
                                  if getline('.') =~# s:file_pattern
                                    exe s:StageInline('show')
                                    if getline(line('.') + 1) =~# '^@'
                                      +
                                    endif
                                  endif
                                else
                                  call search('^@@', 'W')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000003 function! s:PreviousHunk(count) abort
                              for i in range(a:count)
                                if &filetype ==# 'fugitive'
                                  let lnum = search(s:file_pattern . '\|^@','Wbn')
                                  call s:StageInline('show', lnum)
                                  call search('^? .\|^@','Wb')
                                else
                                  call search('^@@', 'Wb')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000002 function! s:NextFile(count) abort
                              for i in range(a:count)
                                exe s:StageInline('hide')
                                if !search(s:file_pattern, 'W')
                                  break
                                endif
                              endfor
                              exe s:StageInline('hide')
                              return '.'
                            endfunction
                            
    1              0.000003 function! s:PreviousFile(count) abort
                              exe s:StageInline('hide')
                              for i in range(a:count)
                                if !search(s:file_pattern, 'Wb')
                                  break
                                endif
                                exe s:StageInline('hide')
                              endfor
                              return '.'
                            endfunction
                            
    1              0.000003 function! s:NextItem(count) abort
                              for i in range(a:count)
                                if !search(s:item_pattern, 'W') && getline('.') !~# s:item_pattern
                                  call search('^commit ', 'W')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000003 function! s:PreviousItem(count) abort
                              for i in range(a:count)
                                if !search(s:item_pattern, 'Wbe') && getline('.') !~# s:item_pattern
                                  call search('^commit ', 'Wbe')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000004 let s:section_pattern = '^[A-Z][a-z][^:]*$'
    1              0.000004 let s:section_commit_pattern = s:section_pattern . '\|^commit '
                            
    1              0.000003 function! s:NextSection(count) abort
                              let orig = line('.')
                              if getline('.') !~# '^commit '
                                -
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern, 'W')
                                  break
                                endif
                              endfor
                              if getline('.') =~# s:section_commit_pattern
                                call s:StageReveal()
                                return getline('.') =~# s:section_pattern ? '+' : ':'
                              else
                                return orig
                              endif
                            endfunction
                            
    1              0.000003 function! s:PreviousSection(count) abort
                              let orig = line('.')
                              if getline('.') !~# '^commit '
                                -
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern . '\|\%^', 'bW')
                                  break
                                endif
                              endfor
                              if getline('.') =~# s:section_commit_pattern || line('.') == 1
                                call s:StageReveal()
                                return getline('.') =~# s:section_pattern ? '+' : ':'
                              else
                                return orig
                              endif
                            endfunction
                            
    1              0.000002 function! s:NextSectionEnd(count) abort
                              +
                              if empty(getline('.'))
                                +
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern, 'W')
                                  return '$'
                                endif
                              endfor
                              return search('^.', 'Wb')
                            endfunction
                            
    1              0.000003 function! s:PreviousSectionEnd(count) abort
                              let old = line('.')
                              for i in range(a:count)
                                if search(s:section_commit_pattern, 'Wb') <= 1
                                  exe old
                                  if i
                                    break
                                  else
                                    return ''
                                  endif
                                endif
                                let old = line('.')
                              endfor
                              return search('^.', 'Wb')
                            endfunction
                            
    1              0.000005 function! s:PatchSearchExpr(reverse) abort
                              let line = getline('.')
                              if col('.') ==# 1 && line =~# '^[+-]'
                                if line =~# '^[+-]\{3\} '
                                  let pattern = '^[+-]\{3\} ' . substitute(escape(strpart(line, 4), '^$.*[]~\'), '^\w/', '\\w/', '') . '$'
                                else
                                  let pattern = '^[+-]\s*' . escape(substitute(strpart(line, 1), '^\s*\|\s*$', '', ''), '^$.*[]~\') . '\s*$'
                                endif
                                if a:reverse
                                  return '?' . escape(pattern, '/') . "\<CR>"
                                else
                                  return '/' . escape(pattern, '/?') . "\<CR>"
                                endif
                              endif
                              return a:reverse ? '#' : '*'
                            endfunction
                            
    1              0.000003 function! s:StageInline(mode, ...) abort
                              if &filetype !=# 'fugitive'
                                return ''
                              endif
                              let lnum1 = a:0 ? a:1 : line('.')
                              let lnum = lnum1 + 1
                              if a:0 > 1 && a:2 == 0
                                let info = s:StageInfo(lnum - 1)
                                if empty(info.paths) && len(info.section)
                                  while len(getline(lnum))
                                    let lnum += 1
                                  endwhile
                                endif
                              elseif a:0 > 1
                                let lnum += a:2 - 1
                              endif
                              while lnum > lnum1
                                let lnum -= 1
                                while lnum > 0 && getline(lnum) =~# '^[ @\+-]'
                                  let lnum -= 1
                                endwhile
                                let info = s:StageInfo(lnum)
                                if !has_key(b:fugitive_diff, info.section)
                                  continue
                                endif
                                if getline(lnum + 1) =~# '^[ @\+-]'
                                  let lnum2 = lnum + 1
                                  while getline(lnum2 + 1) =~# '^[ @\+-]'
                                    let lnum2 += 1
                                  endwhile
                                  if a:mode !=# 'show'
                                    setlocal modifiable noreadonly
                                    exe 'silent keepjumps ' . (lnum + 1) . ',' . lnum2 . 'delete _'
                                    call remove(b:fugitive_expanded[info.section], info.filename)
                                    setlocal nomodifiable readonly nomodified
                                  endif
                                  continue
                                endif
                                if !has_key(b:fugitive_diff, info.section) || info.status !~# '^[ADMRU]$' || a:mode ==# 'hide'
                                  continue
                                endif
                                let mode = ''
                                let diff = []
                                let index = 0
                                let start = -1
                                for line in b:fugitive_diff[info.section]
                                  if mode ==# 'await' && line[0] ==# '@'
                                    let mode = 'capture'
                                  endif
                                  if mode !=# 'head' && line !~# '^[ @\+-]'
                                    if len(diff)
                                      break
                                    endif
                                    let start = index
                                    let mode = 'head'
                                  elseif mode ==# 'head' && substitute(line, "\t$", '', '') ==# '--- ' . info.relative[-1]
                                    let mode = 'await'
                                  elseif mode ==# 'head' && substitute(line, "\t$", '', '') ==# '+++ ' . info.relative[0]
                                    let mode = 'await'
                                  elseif mode ==# 'capture'
                                    call add(diff, line)
                                  elseif line[0] ==# '@'
                                    let mode = ''
                                  endif
                                  let index += 1
                                endfor
                                if len(diff)
                                  setlocal modifiable noreadonly
                                  silent call append(lnum, diff)
                                  let b:fugitive_expanded[info.section][info.filename] = [start, len(diff)]
                                  setlocal nomodifiable readonly nomodified
                                endif
                              endwhile
                              return lnum
                            endfunction
                            
    1              0.000004 function! s:NextExpandedHunk(count) abort
                              for i in range(a:count)
                                call s:StageInline('show', line('.'), 1)
                                call search(s:file_pattern . '\|^@','W')
                              endfor
                              return '.'
                            endfunction
                            
    1              0.000005 function! s:StageDiff(diff) abort
                              let lnum = line('.')
                              let info = s:StageInfo(lnum)
                              let prefix = info.offset > 0 ? '+' . info.offset : ''
                              if empty(info.paths) && info.section ==# 'Staged'
                                return 'Git! diff --no-ext-diff --cached'
                              elseif empty(info.paths)
                                return 'Git! diff --no-ext-diff'
                              elseif len(info.paths) > 1
                                execute 'Gedit' . prefix s:fnameescape(':0:' . info.paths[0])
                                return a:diff . '! HEAD:'.s:fnameescape(info.paths[1])
                              elseif info.section ==# 'Staged' && info.sigil ==# '-'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! :0:%'
                              elseif info.section ==# 'Staged'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! @:%'
                              elseif info.sigil ==# '-'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! :(top)%'
                              else
                                execute 'Gedit' prefix s:fnameescape(':(top)'.info.paths[0])
                                return a:diff . '!'
                              endif
                            endfunction
                            
    1              0.000003 function! s:StageDiffEdit() abort
                              let info = s:StageInfo(line('.'))
                              let arg = (empty(info.paths) ? s:Tree() : info.paths[0])
                              if info.section ==# 'Staged'
                                return 'Git! diff --no-ext-diff --cached '.s:fnameescape(arg)
                              elseif info.status ==# '?'
                                call s:TreeChomp('add', '--intent-to-add', '--', arg)
                                return s:ReloadStatus()
                              else
                                return 'Git! diff --no-ext-diff '.s:fnameescape(arg)
                              endif
                            endfunction
                            
    1              0.000004 function! s:StageApply(info, reverse, extra) abort
                              if a:info.status ==# 'R'
                                call s:throw('fugitive: patching renamed file not yet supported')
                              endif
                              let cmd = ['apply', '-p0', '--recount'] + a:extra
                              let info = a:info
                              let start = info.patch
                              let end = info.lnum
                              let lines = getline(start, end)
                              if empty(filter(copy(lines), 'v:val =~# "^[+-]"'))
                                return -1
                              endif
                              while getline(end) =~# '^[-+ ]'
                                let end += 1
                                if getline(end) =~# '^[' . (a:reverse ? '+' : '-') . ' ]'
                                  call add(lines, ' ' . getline(end)[1:-1])
                                endif
                              endwhile
                              while start > 0 && getline(start) !~# '^@'
                                let start -= 1
                                if getline(start) =~# '^[' . (a:reverse ? '+' : '-') . ' ]'
                                  call insert(lines, ' ' . getline(start)[1:-1])
                                elseif getline(start) =~# '^@'
                                  call insert(lines, getline(start))
                                endif
                              endwhile
                              if start == 0
                                throw 'fugitive: cold not find hunk'
                              elseif getline(start) !~# '^@@ '
                                throw 'fugitive: cannot apply conflict hunk'
                              endif
                              let i = b:fugitive_expanded[info.section][info.filename][0]
                              let head = []
                              while get(b:fugitive_diff[info.section], i, '@') !~# '^@'
                                call add(head, b:fugitive_diff[info.section][i])
                                let i += 1
                              endwhile
                              call extend(lines, head, 'keep')
                              let temp = tempname()
                              call writefile(lines, temp)
                              if a:reverse
                                call add(cmd, '--reverse')
                              endif
                              call extend(cmd, ['--', temp])
                              let [output, exec_error] = s:ChompError(cmd)
                              if !exec_error
                                return 1
                              endif
                              call s:throw(output)
                            endfunction
                            
    1              0.000004 function! s:StageDelete(lnum1, lnum2, count) abort
                              let restore = []
                              let err = ''
                              try
                                for info in s:Selection(a:lnum1, a:lnum2)
                                  if empty(info.paths)
                                    continue
                                  endif
                                  let hash = s:TreeChomp('hash-object', '-w', '--', info.paths[0])
                                  if empty(hash)
                                    continue
                                  endif
                                  if info.patch
                                    call s:StageApply(info, 1, info.section ==# 'Staged' ? ['--index'] : [])
                                  elseif info.status ==# '?'
                                    call s:TreeChomp('clean', '-f', '--', info.paths[0])
                                  elseif a:count == 2
                                    call s:TreeChomp('checkout', '--ours', '--', info.paths[0])
                                  elseif a:count == 3
                                    call s:TreeChomp('checkout', '--theirs', '--', info.paths[0])
                                  elseif info.status =~# '[ADU]' &&
                                        \ get(b:fugitive_status[info.section ==# 'Staged' ? 'Unstaged' : 'Staged'], info.filename, '') =~# '[AU]'
                                    call s:TreeChomp('checkout', info.section ==# 'Staged' ? '--ours' : '--theirs', '--', info.paths[0])
                                  elseif info.status ==# 'U'
                                    call s:TreeChomp('rm', '--', info.paths[0])
                                  elseif info.status ==# 'A'
                                    call s:TreeChomp('rm', '-f', '--', info.paths[0])
                                  elseif info.section ==# 'Unstaged'
                                    call s:TreeChomp('checkout', '--', info.paths[0])
                                  else
                                    call s:TreeChomp('checkout', 'HEAD^{}', '--', info.paths[0])
                                  endif
                                  call add(restore, ':Gsplit ' . s:fnameescape(info.relative[0]) . '|Gread ' . hash[0:6])
                                endfor
                              catch /^fugitive:/
                                let err = '|echoerr ' . string(v:exception)
                              endtry
                              if empty(restore)
                                return err[1:-1]
                              endif
                              exe s:ReloadStatus()
                              call s:StageReveal()
                              return 'checktime|redraw|echomsg ' . string('To restore, ' . join(restore, '|')) . err
                            endfunction
                            
    1              0.000004 function! s:StageIgnore(lnum1, lnum2, count) abort
                              let paths = []
                              for info in s:Selection(a:lnum1, a:lnum2)
                                call extend(paths, info.relative)
                              endfor
                              call map(paths, '"/" . v:val')
                              exe 'Gsplit' (a:count ? '.gitignore' : '.git/info/exclude')
                              let last = line('$')
                              if last == 1 && empty(getline(1))
                                call setline(last, paths)
                              else
                                call append(last, paths)
                                exe last + 1
                              endif
                              return ''
                            endfunction
                            
    1              0.000003 function! s:DoToggleHeadHeader(value) abort
                              exe 'edit' s:fnameescape(s:Dir())
                              call search('\C^index$', 'wc')
                            endfunction
                            
    1              0.000003 function! s:DoStageUnpushedHeading(heading) abort
                              let remote = matchstr(a:heading, 'to \zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:heading, 'to \%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Gpush ' . remote . ' ' . 'HEAD:' . branch)
                            endfunction
                            
    1              0.000003 function! s:DoToggleUnpushedHeading(heading) abort
                              return s:DoStageUnpushedHeading(a:heading)
                            endfunction
                            
    1              0.000002 function! s:DoStageUnpushed(record) abort
                              let remote = matchstr(a:record.heading, 'to \zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:record.heading, 'to \%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Gpush ' . remote . ' ' . a:record.commit . ':' . branch)
                            endfunction
                            
    1              0.000003 function! s:DoToggleUnpushed(record) abort
                              return s:DoStageUnpushed(a:record)
                            endfunction
                            
    1              0.000003 function! s:DoUnstageUnpulledHeading(heading) abort
                              call feedkeys(':Grebase')
                            endfunction
                            
    1              0.000003 function! s:DoToggleUnpulledHeading(heading) abort
                              call s:DoUnstageUnpulledHeading(a:heading)
                            endfunction
                            
    1              0.000003 function! s:DoUnstageUnpulled(record) abort
                              call feedkeys(':Grebase ' . a:record.commit)
                            endfunction
                            
    1              0.000004 function! s:DoToggleUnpulled(record) abort
                              call s:DoUnstageUnpulled(a:record)
                            endfunction
                            
    1              0.000003 function! s:DoUnstageUnpushed(record) abort
                              call feedkeys(':Grebase --autosquash ' . a:record.commit . '^')
                            endfunction
                            
    1              0.000003 function! s:DoToggleStagedHeading(...) abort
                              call s:TreeChomp('reset', '-q')
                              return 1
                            endfunction
                            
    1              0.000003 function! s:DoUnstageStagedHeading(heading) abort
                              return s:DoToggleStagedHeading(a:heading)
                            endfunction
                            
    1              0.000003 function! s:DoToggleUnstagedHeading(...) abort
                              call s:TreeChomp('add', '-u')
                              return 1
                            endfunction
                            
    1              0.000003 function! s:DoStageUnstagedHeading(heading) abort
                              return s:DoToggleUnstagedHeading(a:heading)
                            endfunction
                            
    1              0.000003 function! s:DoToggleUntrackedHeading(...) abort
                              call s:TreeChomp('add', '.')
                              return 1
                            endfunction
                            
    1              0.000006 function! s:DoStageUntrackedHeading(heading) abort
                              return s:DoToggleUntrackedHeading(a:heading)
                            endfunction
                            
    1              0.000002 function! s:DoToggleStaged(record) abort
                              if a:record.patch
                                return s:StageApply(a:record, 1, ['--cached'])
                              else
                                call s:TreeChomp(['reset', '-q', '--'] + a:record.paths)
                                return 1
                              endif
                            endfunction
                            
    1              0.000003 function! s:DoUnstageStaged(record) abort
                              return s:DoToggleStaged(a:record)
                            endfunction
                            
    1              0.000003 function! s:DoToggleUnstaged(record) abort
                              if a:record.patch && a:record.status !=# 'A'
                                return s:StageApply(a:record, 0, ['--cached'])
                              else
                                call s:TreeChomp(['add', '-A', '--'] + a:record.paths)
                                return 1
                              endif
                            endfunction
                            
    1              0.000003 function! s:DoStageUnstaged(record) abort
                              return s:DoToggleUnstaged(a:record)
                            endfunction
                            
    1              0.000003 function! s:DoUnstageUnstaged(record) abort
                              if a:record.status ==# 'A'
                                call s:TreeChomp(['reset', '-q', '--'] + a:record.paths)
                                return 1
                              else
                                return -1
                              endif
                            endfunction
                            
    1              0.000003 function! s:DoToggleUntracked(record) abort
                              call s:TreeChomp(['add', '--'] + a:record.paths)
                              return 1
                            endfunction
                            
    1              0.000003 function! s:DoStageUntracked(record) abort
                              return s:DoToggleUntracked(a:record)
                            endfunction
                            
    1              0.000003 function! s:StagePatch(lnum1,lnum2) abort
                              let add = []
                              let reset = []
                              let intend = []
                            
                              for lnum in range(a:lnum1,a:lnum2)
                                let info = s:StageInfo(lnum)
                                if empty(info.paths) && info.section ==# 'Staged'
                                  return 'Git reset --patch'
                                elseif empty(info.paths) && info.section ==# 'Unstaged'
                                  return 'Git add --patch'
                                elseif empty(info.paths) && info.section ==# 'Untracked'
                                  return 'Git add --interactive'
                                elseif empty(info.paths)
                                  continue
                                endif
                                execute lnum
                                if info.section ==# 'Staged'
                                  let reset += info.relative
                                elseif info.section ==# 'Untracked'
                                  let intend += info.paths
                                elseif info.status !~# '^D'
                                  let add += info.relative
                                endif
                              endfor
                              try
                                if !empty(intend)
                                  call s:TreeChomp(['add', '--intent-to-add', '--'] + intend)
                                endif
                                if !empty(add)
                                  execute "Git add --patch -- ".join(map(add,'s:fnameescape(v:val)'))
                                endif
                                if !empty(reset)
                                  execute "Git reset --patch -- ".join(map(reset,'s:fnameescape(v:val)'))
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              return s:ReloadStatus()
                            endfunction
                            
                            " Section: :Gcommit, :Grevert
                            
    1              0.000017 function! s:CommitInteractive(line1, line2, range, bang, mods, args, patch) abort
                              let status = s:StatusCommand(a:line1, a:line2, a:range, a:line2, a:bang, a:mods, '', '', [])
                              let status = len(status) ? status . '|' : ''
                              if a:patch
                                return status . 'if search("^Unstaged")|exe "normal >"|exe "+"|endif'
                              else
                                return status . 'if search("^Untracked\\|^Unstaged")|exe "+"|endif'
                              endif
                            endfunction
                            
    1              0.000009 function! s:CommitSubcommand(line1, line2, range, bang, mods, args, ...) abort
                              let mods = substitute(s:Mods(a:mods), '\C\<tab\>', '-tab', 'g')
                              let dir = a:0 ? a:1 : s:Dir()
                              let tree = s:Tree(dir)
                              let msgfile = fugitive#Find('.git/COMMIT_EDITMSG', dir)
                              let outfile = tempname()
                              try
                                if s:winshell()
                                  let command = 'set GIT_EDITOR=false& '
                                else
                                  let command = 'env GIT_EDITOR=false '
                                endif
                                let argv = a:args
                                let i = 0
                                while get(argv, i, '--') !=# '--'
                                  if argv[i] =~# '^-[apzsneiovq].'
                                    call insert(argv, argv[i][0:1])
                                    let argv[i+1] = '-' . argv[i+1][2:-1]
                                  else
                                    let i += 1
                                  endif
                                endwhile
                                let command .= s:UserCommand(dir, ['commit'] + argv)
                                if (&autowrite || &autowriteall) && !a:0
                                  silent! wall
                                endif
                                if s:HasOpt(argv, '-i', '--interactive')
                                  return s:CommitInteractive(a:line1, a:line2, a:range, a:bang, a:mods, argv, 0)
                                elseif s:HasOpt(argv, '-p', '--patch')
                                  return s:CommitInteractive(a:line1, a:line2, a:range, a:bang, a:mods, argv, 1)
                                else
                                  let [error_string, exec_error] = s:TempCmd(outfile, command)
                                  let errors = split(error_string, "\n")
                                endif
                                if !has('gui_running')
                                  redraw!
                                endif
                                if !exec_error
                                  echo join(errors, "\n")
                                  if filereadable(outfile)
                                    echo join(readfile(outfile), "\n")
                                  endif
                                  call fugitive#ReloadStatus(dir, 1)
                                  return ''
                                else
                                  let error = get(errors,-2,get(errors,-1,'!'))
                                  if error =~# 'false''\=\.$'
                                    let i = 0
                                    while get(argv, i, '--') !=# '--'
                                      if argv[i] =~# '^\%(-[eips]\|-[CcFm].\+\|--edit\|--interactive\|--patch\|--signoff\|--reedit-message=.*\|--reuse-message=.*\|--file=.*\|--message=.*\)$'
                                        call remove(argv, i)
                                      elseif argv[i] =~# '^\%(-[CcFm]\|--reedit-message\|--reuse-message\|--file\|--message\)$'
                                        call remove(argv, i, i + 1)
                                      else
                                        if argv[i] =~# '^--cleanup\>'
                                          let cleanup = 1
                                        endif
                                        let i += 1
                                      endif
                                    endwhile
                                    call insert(argv, '--no-signoff', i)
                                    call insert(argv, '--no-interactive', i)
                                    call insert(argv, '--no-edit', i)
                                    if !exists('cleanup')
                                      call insert(argv, '--cleanup=strip')
                                    endif
                                    call extend(argv, ['-F', msgfile], 'keep')
                                    if (bufname('%') == '' && line('$') == 1 && getline(1) == '' && !&modified) || a:line2 == 0
                                      execute mods . 'keepalt edit' s:fnameescape(msgfile)
                                    elseif s:HasOpt(argv, '-v') || mods =~# '\<tab\>'
                                      execute mods . 'keepalt -tabedit' s:fnameescape(msgfile)
                                    else
                                      execute mods . 'keepalt split' s:fnameescape(msgfile)
                                    endif
                                    let b:fugitive_commit_arguments = argv
                                    setlocal bufhidden=wipe filetype=gitcommit
                                    return '1'
                                  elseif empty(errors)
                                    let out = readfile(outfile)
                                    echo get(out, -1, '') =~# 'stash\|\d' ? get(out, -2, '') : get(out, -1, '')
                                    return ''
                                  else
                                    echo join(errors, "\n")
                                    return ''
                                  endif
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                call delete(outfile)
                              endtry
                            endfunction
                            
    1              0.000007 function! s:RevertSubcommand(line1, line2, range, bang, mods, args) abort
                              let dir = s:Dir()
                              let no_commit = s:HasOpt(a:args, '-n', '--no-commit', '--no-edit', '--abort', '--continue', '--quit')
                              let cmd = s:UserCommand(dir, ['revert'] + (no_commit ? [] : ['-n']) + a:args)
                              let [out, exec_error] = s:SystemError(cmd)
                              call fugitive#ReloadStatus(-1, 1)
                              if no_commit || exec_error
                                return 'echo ' . string(substitute(out, "\n$", '', ''))
                              endif
                              return s:CommitSubcommand(a:line1, a:line2, a:range, a:bang, a:mods, [], dir)
                            endfunction
                            
    1              0.000008 function! s:CommitComplete(A, L, P) abort
                              if a:A =~# '^--fixup=\|^--squash='
                                let commits = s:LinesError(['log', '--pretty=format:%s', '@{upstream}..'])[0]
                                let pre = matchstr(a:A, '^--\w*=''\=') . ':/^'
                                if pre =~# "'"
                                  call map(commits, 'pre . string(tr(v:val, "|\"^$*[]", "......."))[1:-1]')
                                  call filter(commits, 'strpart(v:val, 0, strlen(a:A)) ==# a:A')
                                  return commits
                                else
                                  return s:FilterEscape(map(commits, 'pre . tr(v:val, "\\ !^$*?[]()''\"`&;<>|#", "....................")'), a:A)
                                endif
                              else
                                return s:CompleteSub('commit', a:A, a:L, a:P, function('fugitive#CompletePath'))
                              endif
                              return []
                            endfunction
                            
    1              0.000009 function! s:RevertComplete(A, L, P) abort
                              return s:CompleteSub('revert', a:A, a:L, a:P, function('s:CompleteRevision'))
                            endfunction
                            
    1              0.000004 function! s:FinishCommit() abort
                              let buf = +expand('<abuf>')
                              let args = getbufvar(buf, 'fugitive_commit_arguments')
                              if !empty(args)
                                call setbufvar(buf, 'fugitive_commit_arguments', [])
                                if getbufvar(buf, 'fugitive_commit_rebase')
                                  call setbufvar(buf, 'fugitive_commit_rebase', 0)
                                  let s:rebase_continue = s:Dir(buf)
                                endif
                                return s:CommitSubcommand(-1, -1, 0, 0, '', args, s:Dir(buf))
                              endif
                              return ''
                            endfunction
                            
    1   0.000069   0.000020 call s:command("-nargs=? -range=-1 -complete=customlist,s:CommitComplete Gcommit", "commit")
    1   0.000054   0.000017 call s:command("-nargs=? -range=-1 -complete=customlist,s:RevertComplete Grevert", "revert")
                            
                            " Section: :Gmerge, :Grebase, :Gpull
                            
    1              0.000003 function! s:MergeComplete(A, L, P) abort
                              return s:CompleteSub('merge', a:A, a:L, a:P, function('s:CompleteRevision'))
                            endfunction
                            
    1              0.000014 function! s:RebaseComplete(A, L, P) abort
                              return s:CompleteSub('rebase', a:A, a:L, a:P, function('s:CompleteRevision'))
                            endfunction
                            
    1              0.000007 function! s:PullComplete(A, L, P) abort
                              return s:CompleteSub('pull', a:A, a:L, a:P, function('s:CompleteRemote'))
                            endfunction
                            
    1              0.000003 function! s:RebaseSequenceAborter() abort
                              if !exists('s:rebase_sequence_aborter')
                                let temp = tempname() . '.sh'
                                call writefile(
                                      \ ['#!/bin/sh',
                                      \ 'echo exec false | cat - "$1" > "$1.fugitive"',
                                      \ 'mv "$1.fugitive" "$1"'],
                                      \ temp)
                                let s:rebase_sequence_aborter = temp
                              endif
                              return s:rebase_sequence_aborter
                            endfunction
                            
    1              0.000003 function! fugitive#Cwindow() abort
                              if &buftype == 'quickfix'
                                cwindow
                              else
                                botright cwindow
                                if &buftype == 'quickfix'
                                  wincmd p
                                endif
                              endif
                            endfunction
                            
    1              0.000012 let s:common_efm = ''
                                  \ . '%+Egit:%.%#,'
                                  \ . '%+Eusage:%.%#,'
                                  \ . '%+Eerror:%.%#,'
                                  \ . '%+Efatal:%.%#,'
                                  \ . '%-G%.%#%\e[K%.%#,'
                                  \ . '%-G%.%#%\r%.%\+'
                            
    1              0.000011 let s:rebase_abbrevs = {
                                  \ 'p': 'pick',
                                  \ 'r': 'reword',
                                  \ 'e': 'edit',
                                  \ 's': 'squash',
                                  \ 'f': 'fixup',
                                  \ 'x': 'exec',
                                  \ 'd': 'drop',
                                  \ 'l': 'label',
                                  \ 't': 'reset',
                                  \ 'm': 'merge',
                                  \ 'b': 'break',
                                  \ }
                            
    1              0.000004 function! s:RebaseEdit(cmd, dir) abort
                              let rebase_todo = s:fnameescape(fugitive#Find('.git/rebase-merge/git-rebase-todo', a:dir))
                            
                              if filereadable(rebase_todo)
                                let new = readfile(rebase_todo)
                                let sha_length = 0
                                let shas = {}
                            
                                for i in range(len(new))
                                  if new[i] =~# '^\l\+\s\+[0-9a-f]\{5,\}\>'
                                    let sha = matchstr(new[i], '\C\<[a-f0-9]\{5,\}\>')
                                    if !sha_length
                                      let sha_length = len(s:TreeChomp(a:dir, 'rev-parse', '--short', sha))
                                    endif
                                    let shortened_sha = strpart(sha, 0, sha_length)
                                    let shas[shortened_sha] = sha
                                    let new[i] = substitute(new[i], sha, shortened_sha, '')
                                  endif
                                endfor
                                call writefile(new, rebase_todo)
                              endif
                              return a:cmd . ' +setlocal\ bufhidden=wipe\|' . escape('let b:fugitive_rebase_shas = ' . string(shas), ' ') . ' ' . rebase_todo
                            endfunction
                            
    1              0.000004 function! s:MergeRebase(cmd, bang, mods, args, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              let args = a:args
                              let mods = s:Mods(a:mods)
                              if a:cmd =~# '^rebase' && s:HasOpt(args, '-i', '--interactive')
                                let cmd = fugitive#Prepare(dir, '-c', 'sequence.editor=sh ' . s:RebaseSequenceAborter(), 'rebase') . ' ' . s:shellesc(args)
                                let out = system(cmd)[0:-2]
                                for file in ['end', 'msgnum']
                                  let file = fugitive#Find('.git/rebase-merge/' . file, dir)
                                  if !filereadable(file)
                                    return 'echoerr ' . string("fugitive: " . out)
                                  endif
                                  call writefile([readfile(file)[0] - 1], file)
                                endfor
                                call writefile([], fugitive#Find('.git/rebase-merge/done', dir))
                                if a:bang
                                  return 'exe'
                                endif
                                return s:RebaseEdit(mods . 'split', dir)
                              elseif a:cmd =~# '^rebase' && s:HasOpt(args, '--edit-todo') && filereadable(fugitive#Find('.git/rebase-merge/git-rebase-todo', dir))
                                return s:RebaseEdit(mods . 'split', dir)
                              elseif a:cmd =~# '^rebase' && s:HasOpt(args, '--continue') && !a:0
                                let rdir = fugitive#Find('.git/rebase-merge', dir)
                                let exec_error = s:ChompError([dir, 'diff-index', '--cached', '--quiet', 'HEAD', '--'])[1]
                                if exec_error && isdirectory(rdir)
                                  if getfsize(rdir . '/amend') <= 0
                                    return 'exe ' . string(mods . 'Gcommit -n -F ' . s:fnameescape(rdir .'/message') . ' -e') . '|let b:fugitive_commit_rebase = 1'
                                  elseif readfile(rdir . '/amend')[0] ==# fugitive#Head(-1, dir)
                                    return 'exe ' . string(mods . 'Gcommit --amend -n -F ' . s:fnameescape(rdir . '/message') . ' -e') . '|let b:fugitive_commit_rebase = 1'
                                  endif
                                endif
                              endif
                              let had_merge_msg = filereadable(fugitive#Find('.git/MERGE_MSG', dir))
                              let argv = []
                              if a:cmd ==# 'pull'
                                let argv += s:AskPassArgs(dir) + ['pull', '--progress']
                              else
                                call add(argv, a:cmd)
                              endif
                              if !s:HasOpt(args, '--no-edit', '--abort', '-m') && a:cmd !=# 'rebase'
                                call add(argv, '--edit')
                              endif
                              if a:cmd ==# 'rebase' && s:HasOpt(args, '--autosquash') && !s:HasOpt(args, '--interactive', '-i')
                                call add(argv, '--interactive')
                              endif
                              call extend(argv, args)
                            
                              let [mp, efm] = [&l:mp, &l:efm]
                              try
                                let cdback = s:Cd(s:Tree(dir))
                                let &l:errorformat = ''
                                      \ . '%-Gerror:%.%#false''.,'
                                      \ . '%-G%.%# ''git commit'' %.%#,'
                                      \ . '%+Emerge:%.%#,'
                                      \ . s:common_efm . ','
                                      \ . '%+ECannot %.%#: You have unstaged changes.,'
                                      \ . '%+ECannot %.%#: Your index contains uncommitted changes.,'
                                      \ . '%+EThere is no tracking information for the current branch.,'
                                      \ . '%+EYou are not currently on a branch. Please specify which,'
                                      \ . '%+I %#git rebase --continue,'
                                      \ . 'CONFLICT (%m): %f deleted in %.%#,'
                                      \ . 'CONFLICT (%m): Merge conflict in %f,'
                                      \ . 'CONFLICT (%m): Rename \"%f\"->%.%#,'
                                      \ . 'CONFLICT (%m): Rename %.%#->%f %.%#,'
                                      \ . 'CONFLICT (%m): There is a directory with name %f in %.%#,'
                                      \ . '%+ECONFLICT %.%#,'
                                      \ . '%+EKONFLIKT %.%#,'
                                      \ . '%+ECONFLIT %.%#,'
                                      \ . "%+EXUNG \u0110\u1ed8T %.%#,"
                                      \ . "%+E\u51b2\u7a81 %.%#,"
                                      \ . 'U%\t%f'
                                if a:cmd =~# '^merge' && empty(args) &&
                                      \ (had_merge_msg || isdirectory(fugitive#Find('.git/rebase-apply', dir)) ||
                                      \  !empty(s:TreeChomp(dir, 'diff-files', '--diff-filter=U')))
                                  let cmd = g:fugitive_git_executable.' diff-files --name-status --diff-filter=U'
                                else
                                  let cmd = s:UserCommand(dir, argv)
                                endif
                                if !empty($GIT_SEQUENCE_EDITOR) || has('win32')
                                  let old_sequence_editor = $GIT_SEQUENCE_EDITOR
                                  let $GIT_SEQUENCE_EDITOR = 'true'
                                else
                                  let cmd = 'env GIT_SEQUENCE_EDITOR=true ' . cmd
                                endif
                                if !empty($GIT_EDITOR) || has('win32')
                                  let old_editor = $GIT_EDITOR
                                  let $GIT_EDITOR = 'false'
                                else
                                  let cmd = 'env GIT_EDITOR=false ' . substitute(cmd, '^env ', '', '')
                                endif
                                if !has('patch-8.1.0334') && has('terminal') && &autowrite
                                  let autowrite_was_set = 1
                                  set noautowrite
                                  silent! wall
                                endif
                                let &l:makeprg = cmd
                                silent noautocmd make!
                              catch /^Vim\%((\a\+)\)\=:E211/
                                let err = v:exception
                              finally
                                if exists('autowrite_was_set')
                                  set autowrite
                                endif
                                redraw!
                                let [&l:mp, &l:efm] = [mp, efm]
                                if exists('old_editor')
                                  let $GIT_EDITOR = old_editor
                                endif
                                if exists('old_sequence_editor')
                                  let $GIT_SEQUENCE_EDITOR = old_sequence_editor
                                endif
                                execute cdback
                              endtry
                              call fugitive#ReloadStatus(dir, 1)
                              if empty(filter(getqflist(),'v:val.valid && v:val.type !=# "I"'))
                                if a:cmd =~# '^rebase' &&
                                      \ filereadable(fugitive#Find('.git/rebase-merge/amend', dir)) &&
                                      \ filereadable(fugitive#Find('.git/rebase-merge/done', dir)) &&
                                      \ get(readfile(fugitive#Find('.git/rebase-merge/done', dir)), -1, '') =~# '^[^e]'
                                  cclose
                                  return 'exe ' . string(mods . 'Gcommit --amend -n -F ' . s:fnameescape(fugitive#Find('.git/rebase-merge/message', dir)) . ' -e') . '|let b:fugitive_commit_rebase = 1'
                                elseif !had_merge_msg && filereadable(fugitive#Find('.git/MERGE_MSG', dir))
                                  cclose
                                  return mods . 'Gcommit --no-status -n -t '.s:fnameescape(fugitive#Find('.git/MERGE_MSG', dir))
                                endif
                              endif
                              let qflist = getqflist()
                              let found = 0
                              for e in qflist
                                if !empty(e.bufnr)
                                  let found = 1
                                  let e.pattern = '^<<<<<<<'
                                endif
                              endfor
                              call fugitive#Cwindow()
                              if found
                                call setqflist(qflist, 'r')
                                if !a:bang
                                  call s:BlurStatus()
                                  return 'cfirst'
                                endif
                              endif
                              return exists('err') ? 'echoerr '.string(err) : 'exe'
                            endfunction
                            
    1              0.000005 function! s:RebaseClean(file) abort
                              if !filereadable(a:file)
                                return ''
                              endif
                              let old = readfile(a:file)
                              let new = copy(old)
                              for i in range(len(new))
                                let new[i] = substitute(new[i], '^\l\>', '\=get(s:rebase_abbrevs,submatch(0),submatch(0))', '')
                            
                                let sha = matchstr(new[i], '\C\<[a-f0-9]\{5,\}\>')
                                let rebase_shas = getbufvar(a:file, 'fugitive_rebase_shas')
                                if len(sha) && type(rebase_shas) == type({}) && has_key(rebase_shas, sha)
                                  let new[i] = substitute(new[i], '\C\<' . sha . '\>', rebase_shas[sha], '')
                                endif
                              endfor
                              if new !=# old
                                call writefile(new, a:file)
                              endif
                              return ''
                            endfunction
                            
    1              0.000004 function! s:MergeSubcommand(line1, line2, range, bang, mods, args) abort
                              return s:MergeRebase('merge', a:bang, a:mods, a:args)
                            endfunction
                            
    1              0.000004 function! s:RebaseSubcommand(line1, line2, range, bang, mods, args) abort
                              return s:MergeRebase('rebase', a:bang, a:mods, a:args)
                            endfunction
                            
    1              0.000004 function! s:PullSubcommand(line1, line2, range, bang, mods, args) abort
                              return s:MergeRebase('pull', a:bang, a:mods, a:args)
                            endfunction
                            
    1              0.000004 augroup fugitive_merge
    1              0.000081   autocmd!
    1              0.000028   autocmd VimLeavePre,BufDelete git-rebase-todo
                                    \ if getbufvar(+expand('<abuf>'), '&bufhidden') ==# 'wipe' |
                                    \   call s:RebaseClean(expand('<afile>')) |
                                    \   if getfsize(FugitiveFind('.git/rebase-merge/done', +expand('<abuf>'))) == 0 |
                                    \     let s:rebase_continue = FugitiveGitDir(+expand('<abuf>')) |
                                    \   endif |
                                    \ endif
    1              0.000013   autocmd BufEnter * nested
                                    \ if exists('s:rebase_continue') |
                                    \   exe s:MergeRebase('rebase', 0, '', [getfsize(fugitive#Find('.git/rebase-merge/git-rebase-todo', s:rebase_continue)) > 0 ? '--continue' : '--abort'], remove(s:, 'rebase_continue')) |
                                    \ endif
    1              0.000002 augroup END
                            
    1   0.000053   0.000011 call s:command("-nargs=? -bang -complete=customlist,s:MergeComplete Gmerge", "merge")
    1   0.000050   0.000013 call s:command("-nargs=? -bang -complete=customlist,s:RebaseComplete Grebase", "rebase")
    1   0.000051   0.000017 call s:command("-nargs=? -bang -complete=customlist,s:PullComplete Gpull", "pull")
                            
                            " Section: :Ggrep, :Glog
                            
    1              0.000004 if !exists('g:fugitive_summary_format')
    1              0.000003   let g:fugitive_summary_format = '%s'
    1              0.000001 endif
                            
    1              0.000003 function! fugitive#GrepComplete(A, L, P) abort
                              return s:CompleteSub('grep', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000004 function! fugitive#LogComplete(A, L, P) abort
                              return s:CompleteSub('log', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000010 function! s:GrepParseLine(prefix, name_only, dir, line) abort
                              let entry = {'valid': 1}
                              let match = matchlist(a:line, '^\(.\{-\}\):\(\d\+\):\(\d\+:\)\=\(.*\)$')
                              if len(match)
                                let entry.module = match[1]
                                let entry.lnum = +match[2]
                                let entry.col = +match[3]
                                let entry.text = match[4]
                              elseif a:line =~# '^git: \|^usage: \|^error: \|^fatal: '
                                return {'text': a:line}
                              else
                                let entry.module = matchstr(a:line, '\CBinary file \zs.*\ze matches$')
                                if len(entry.module)
                                  let entry.text = 'Binary file'
                                  let entry.valid = 0
                                endif
                              endif
                              if empty(entry.module) && a:name_only
                                let entry.module = a:line
                              endif
                              if empty(entry.module)
                                return {'text': a:line}
                              endif
                              if entry.module !~# ':'
                                let entry.filename = a:prefix . entry.module
                              else
                                let entry.filename = fugitive#Find(entry.module, a:dir)
                              endif
                              return entry
                            endfunction
                            
    1              0.000005 function! s:GrepSubcommand(line1, line2, range, bang, mods, args) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              let listnr = a:line1 == 0 ? a:line1 : a:line2
                              let cmd = ['--no-pager', 'grep', '-n', '--no-color', '--full-name']
                              if fugitive#GitVersion(2, 19)
                                call add(cmd, '--column')
                              endif
                              let tree = s:Tree(dir)
                              if type(a:args) == type([])
                                let [args, after] = [a:args, '']
                              else
                                let [args, after] = s:SplitExpandChain(a:args, tree)
                              endif
                              let prefix = FugitiveVimPath(s:HasOpt(args, '--cached') || empty(tree) ? 'fugitive://' . dir . '//0/' : tree . '/')
                              let name_only = s:HasOpt(args, '-l', '--files-with-matches', '--name-only', '-L', '--files-without-match')
                              let title = [listnr < 0 ? ':Ggrep' : ':Glgrep'] + args
                              if listnr > 0
                                exe listnr 'wincmd w'
                              else
                                call s:BlurStatus()
                              endif
                              redraw
                              call s:QuickfixCreate(listnr, {'title': (listnr < 0 ? ':Ggrep ' : ':Glgrep ') . s:fnameescape(args)})
                              let tempfile = tempname()
                              if v:version >= 704 | exe 'silent doautocmd <nomodeline> QuickFixCmdPre ' (listnr < 0 ? 'Ggrep' : 'Glgrep') | endif
                              exe '!' . escape(s:UserCommand(dir, cmd + args), '%#!')
                                    \ printf(&shellpipe . (&shellpipe =~# '%s' ? '' : ' %s'), s:shellesc(tempfile))
                              let list = map(readfile(tempfile), 's:GrepParseLine(prefix, name_only, dir, v:val)')
                              call s:QuickfixSet(listnr, list, 'a')
                              if v:version >= 704 | exe 'silent doautocmd <nomodeline> QuickFixCmdPost ' (listnr < 0 ? 'Ggrep' : 'Glgrep') | endif
                              if !has('gui_running')
                                redraw
                              endif
                              if !a:bang && !empty(list)
                                return (listnr < 0 ? 'c' : 'l').'first' . after
                              else
                                return after[1:-1]
                              endif
                            endfunction
                            
    1              0.000004 function! s:LogFlushQueue(state) abort
                              let queue = remove(a:state, 'queue')
                              if a:state.child_found
                                call remove(queue, 0)
                              endif
                              if len(queue) && queue[-1] ==# {'text': ''}
                                call remove(queue, -1)
                              endif
                              return queue
                            endfunction
                            
    1              0.000003 function! s:LogParse(state, dir, line) abort
                              if a:state.context ==# 'hunk' && a:line =~# '^[-+ ]'
                                return []
                              endif
                              let list = matchlist(a:line, '^\%(fugitive \(.\{-\}\)\t\|commit \|From \)\=\(\x\{40,\}\)\%( \(.*\)\)\=$')
                              if len(list)
                                let a:state.context = 'commit'
                                let a:state.base = 'fugitive://' . a:dir . '//' . list[2]
                                let a:state.base_module = len(list[1]) ? list[1] : list[2]
                                let a:state.message = list[3]
                                if has_key(a:state, 'diffing')
                                  call remove(a:state, 'diffing')
                                endif
                                let queue = s:LogFlushQueue(a:state)
                                let a:state.queue = [{
                                      \ 'valid': 1,
                                      \ 'filename': a:state.base . a:state.target,
                                      \ 'module': a:state.base_module . substitute(a:state.target, '^/', ':', ''),
                                      \ 'text': a:state.message}]
                                let a:state.child_found = 0
                                return queue
                              elseif type(a:line) == type(0)
                                return s:LogFlushQueue(a:state)
                              elseif a:line =~# '^diff'
                                let a:state.context = 'diffhead'
                              elseif a:line =~# '^[+-]\{3\} \w/' && a:state.context ==# 'diffhead'
                                let a:state.diffing = a:line[5:-1]
                              elseif a:line =~# '^@@[^@]*+\d' && has_key(a:state, 'diffing') && has_key(a:state, 'base')
                                let a:state.context = 'hunk'
                                if empty(a:state.target) || a:state.target ==# a:state.diffing
                                  let a:state.child_found = 1
                                  call add(a:state.queue, {
                                        \ 'valid': 1,
                                        \ 'filename': a:state.base . a:state.diffing,
                                        \ 'module': a:state.base_module . substitute(a:state.diffing, '^/', ':', ''),
                                        \ 'lnum': +matchstr(a:line, '+\zs\d\+'),
                                        \ 'text': a:state.message . matchstr(a:line, ' @@\+ .\+')})
                                endif
                              elseif a:state.follow &&
                                    \ a:line =~# '^ \%(mode change \d\|\%(create\|delete\) mode \d\|\%(rename\|copy\|rewrite\) .* (\d\+%)$\)'
                                let rename = matchstr(a:line, '^ rename \zs.* => .*\ze (\d\+%)$')
                                if len(rename)
                                  let rename = rename =~# '{.* => .*}' ? rename : '{' . rename . '}'
                                  if a:state.target ==# simplify('/' . substitute(rename, '{.* => \(.*\)}', '\1', ''))
                                    let a:state.target = simplify('/' . substitute(rename, '{\(.*\) => .*}', '\1', ''))
                                  endif
                                endif
                                if !get(a:state, 'ignore_summary')
                                  call add(a:state.queue, {'text': a:line})
                                endif
                              elseif a:state.context ==# 'commit' || a:state.context ==# 'init'
                                call add(a:state.queue, {'text': a:line})
                              endif
                              return []
                            endfunction
                            
    1              0.000008 function! fugitive#LogCommand(line1, count, range, bang, mods, args, type) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              let listnr = a:type =~# '^l' ? 0 : -1
                              let [args, after] = s:SplitExpandChain(a:args, s:Tree(dir))
                              let split = index(args, '--')
                              if split > 0
                                let paths = args[split : -1]
                                let args = args[0 : split - 1]
                              elseif split == 0
                                let paths = args
                                let args = []
                              else
                                let paths = []
                              endif
                              if a:line1 == 0 && a:count
                                let path = fugitive#Path(bufname(a:count), '/', dir)
                              elseif a:count >= 0
                                let path = fugitive#Path(@%, '/', dir)
                              else
                                 let path = ''
                              endif
                              let range = ''
                              let extra = []
                              let state = {'context': 'init', 'child_found': 0, 'queue': [], 'follow': 0}
                              if path =~# '^/\.git\%(/\|$\)\|^$'
                                let path = ''
                              elseif a:line1 == 0
                                let range = "0," . (a:count ? a:count : bufnr(''))
                                let extra = ['.' . path]
                                if (empty(paths) || paths ==# ['--']) && !s:HasOpt(args, '--no-follow')
                                  let state.follow = 1
                                  if !s:HasOpt(args, '--follow')
                                    call insert(args, '--follow')
                                  endif
                                  if !s:HasOpt(args, '--summary')
                                    call insert(args, '--summary')
                                    let state.ignore_summary = 1
                                  endif
                                endif
                              elseif a:count > 0
                                if !s:HasOpt(args, '--merges', '--no-merges')
                                  call insert(args, '--no-merges')
                                endif
                                call add(args, '-L' . a:line1 . ',' . a:count . ':' . path[1:-1])
                              endif
                              if len(path) && empty(filter(copy(args), 'v:val =~# "^[^-]"'))
                                let owner = s:Owner(@%, dir)
                                if len(owner)
                                  call add(args, owner)
                                endif
                              endif
                              if empty(extra)
                                let path = ''
                              endif
                              if s:HasOpt(args, '-g', '--walk-reflogs')
                                let format = "%gd\t%H %gs"
                              else
                                let format = "%h\t%H " . g:fugitive_summary_format
                              endif
                              let cmd = ['--no-pager']
                              if fugitive#GitVersion(1, 9)
                                call extend(cmd, ['-c', 'diff.context=0', '-c', 'diff.noprefix=false', 'log'])
                              else
                                call extend(cmd, ['log', '-U0', '--no-patch'])
                              endif
                              call extend(cmd,
                                    \ ['--no-color', '--no-ext-diff', '--pretty=format:fugitive ' . format] +
                                    \ args + paths + extra)
                              let state.target = path
                              let title = (listnr < 0 ? ':Gclog ' : ':Gllog ') . s:fnameescape(args + paths)
                              if empty(paths + extra) && empty(a:type) && len(s:Relative('/'))
                                let after = '|echohl WarningMsg|echo ' . string('Use :0Glog or :0Gclog for old behavior of targeting current file') . '|echohl NONE' . after
                              endif
                              return s:QuickfixStream(listnr, title, s:UserCommandList(dir) + cmd, !a:bang, s:function('s:LogParse'), state, dir) . after
                            endfunction
                            
                            " Section: :Gedit, :Gpedit, :Gsplit, :Gvsplit, :Gtabedit, :Gread
                            
    1              0.000007 function! s:UsableWin(nr) abort
                              return a:nr && !getwinvar(a:nr, '&previewwindow') && !getwinvar(a:nr, '&winfixwidth') &&
                                    \ (empty(getwinvar(a:nr, 'fugitive_status')) || getbufvar(winbufnr(a:nr), 'fugitive_type') !=# 'index') &&
                                    \ index(['gitrebase', 'gitcommit'], getbufvar(winbufnr(a:nr), '&filetype')) < 0 &&
                                    \ index(['nofile','help','quickfix'], getbufvar(winbufnr(a:nr), '&buftype')) < 0
                            endfunction
                            
    1              0.000004 function! s:OpenParse(args) abort
                              let pre = []
                              let args = copy(a:args)
                              while !empty(args) && args[0] =~# '^+'
                                call add(pre, ' ' . escape(remove(args, 0), ' |"'))
                              endwhile
                              if len(args)
                                let file = join(args)
                              elseif empty(expand('%'))
                                let file = ''
                              elseif empty(s:DirCommitFile(@%)[1]) && s:Relative('./') !~# '^\./\.git\>'
                                let file = '>:0'
                              else
                                let file = '>'
                              endif
                              return [s:Expand(file), join(pre)]
                            endfunction
                            
    1              0.000003 function! s:DiffClose() abort
                              let mywinnr = winnr()
                              for winnr in [winnr('#')] + range(winnr('$'),1,-1)
                                if winnr != mywinnr && getwinvar(winnr,'&diff')
                                  execute winnr.'wincmd w'
                                  close
                                  if winnr('$') > 1
                                    wincmd p
                                  endif
                                endif
                              endfor
                              diffoff!
                            endfunction
                            
    1              0.000004 function! s:BlurStatus() abort
                              if (&previewwindow || exists('w:fugitive_status')) && get(b:,'fugitive_type', '') ==# 'index'
                                let winnrs = filter([winnr('#')] + range(1, winnr('$')), 's:UsableWin(v:val)')
                                if len(winnrs)
                                  exe winnrs[0].'wincmd w'
                                else
                                  belowright new
                                endif
                                if &diff
                                  call s:DiffClose()
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! s:OpenExec(cmd, mods, args, ...) abort
                              let dir = a:0 ? s:Dir(a:1) : s:Dir()
                              let temp = tempname()
                              let columns = get(g:, 'fugitive_columns', 80)
                              if columns <= 0
                                let env = ''
                              elseif s:winshell()
                                let env = 'set COLUMNS=' . columns . '& '
                              else
                                let env = 'env COLUMNS=' . columns . ' '
                              endif
                              silent! execute '!' . escape(env . s:UserCommand(dir, ['--no-pager'] + a:args), '!#%') .
                                    \ (&shell =~# 'csh' ? ' >& ' . temp : ' > ' . temp . ' 2>&1')
                              redraw!
                              let temp = s:Resolve(temp)
                              let first = join(readfile(temp, '', 2), "\n")
                              if first =~# '\<\([[:upper:][:digit:]_-]\+(\d\+)\).*\1'
                                let filetype = 'man'
                              else
                                let filetype = 'git'
                              endif
                              let s:temp_files[s:cpath(temp)] = { 'dir': dir, 'filetype': filetype, 'modifiable': first =~# '^diff ' }
                              if a:cmd ==# 'edit'
                                call s:BlurStatus()
                              endif
                              silent execute s:Mods(a:mods) . a:cmd temp
                              call fugitive#ReloadStatus(dir, 1)
                              return 'echo ' . string(':!' . s:UserCommand(dir, a:args))
                            endfunction
                            
    1              0.000004 function! fugitive#Open(cmd, bang, mods, arg, args) abort
                              if a:bang
                                return s:OpenExec(a:cmd, a:mods, s:SplitExpand(a:arg, s:Tree()))
                              endif
                            
                              let mods = s:Mods(a:mods)
                              try
                                let [file, pre] = s:OpenParse(a:args)
                                let file = s:Generate(file)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if file !~# '^\a\a\+:'
                                let file = s:sub(file, '/$', '')
                              endif
                              if a:cmd ==# 'edit'
                                call s:BlurStatus()
                              endif
                              return mods . a:cmd . pre . ' ' . s:fnameescape(file)
                            endfunction
                            
    1              0.000004 function! fugitive#ReadCommand(line1, count, range, bang, mods, arg, args) abort
                              let mods = s:Mods(a:mods)
                              let after = a:count
                              if a:count < 0
                                let delete = 'silent 1,' . line('$') . 'delete_|'
                                let after = line('$')
                              elseif a:range == 2
                                let delete = 'silent ' . a:line1 . ',' . a:count . 'delete_|'
                              else
                                let delete = ''
                              endif
                              if a:bang
                                let dir = s:Dir()
                                let args = s:SplitExpand(a:arg, s:Tree(dir))
                                silent execute mods . after . 'read!' escape(s:UserCommand(dir, ['--no-pager'] + args), '!#%')
                                execute delete . 'diffupdate'
                                call fugitive#ReloadStatus()
                                return 'redraw|echo '.string(':!'.s:UserCommand(dir, args))
                              endif
                              try
                                let [file, pre] = s:OpenParse(a:args)
                                let file = s:Generate(file)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if file =~# '^fugitive:' && after is# 0
                                return 'exe ' .string(mods . fugitive#FileReadCmd(file, 0, pre)) . '|diffupdate'
                              endif
                              if foldlevel(after)
                                exe after . 'foldopen!'
                              endif
                              return mods . after . 'read' . pre . ' ' . s:fnameescape(file) . '|' . delete . 'diffupdate' . (a:count < 0 ? '|' . line('.') : '')
                            endfunction
                            
    1              0.000004 function! fugitive#ReadComplete(A, L, P) abort
                              if a:L =~# '^\w\+!'
                                return fugitive#Complete(a:A, a:L, a:P)
                              else
                                return fugitive#CompleteObject(a:A, a:L, a:P)
                              endif
                            endfunction
                            
                            " Section: :Gwrite, :Gwq
                            
    1              0.000004 function! fugitive#WriteCommand(line1, line2, range, bang, mods, arg, args) abort
                              if exists('b:fugitive_commit_arguments')
                                return 'write|bdelete'
                              elseif expand('%:t') == 'COMMIT_EDITMSG' && $GIT_INDEX_FILE != ''
                                return 'wq'
                              elseif get(b:, 'fugitive_type', '') ==# 'index'
                                return 'Gcommit'
                              elseif &buftype ==# 'nowrite' && getline(4) =~# '^+++ '
                                let filename = getline(4)[6:-1]
                                setlocal buftype=
                                silent write
                                setlocal buftype=nowrite
                                if matchstr(getline(2),'index [[:xdigit:]]\+\.\.\zs[[:xdigit:]]\{7\}') ==# fugitive#RevParse(':0:'.filename)[0:6]
                                  let [message, exec_error] = s:ChompError(['apply', '--cached', '--reverse', '--', expand('%:p')])
                                else
                                  let [message, exec_error] = s:ChompError(['apply', '--cached', '--', expand('%:p')])
                                endif
                                if exec_error
                                  echohl ErrorMsg
                                  echo message
                                  echohl NONE
                                  return ''
                                elseif a:bang
                                  return 'bdelete'
                                else
                                  return 'Gedit '.fnameescape(filename)
                                endif
                              endif
                              let mytab = tabpagenr()
                              let mybufnr = bufnr('')
                              try
                                let file = len(a:args) ? s:Generate(s:Expand(join(a:args, ' '))) : fugitive#Real(@%)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if empty(file)
                                return 'echoerr '.string('fugitive: cannot determine file path')
                              endif
                              if file =~# '^fugitive:'
                                return 'write' . (a:bang ? '! ' : ' ') . s:fnameescape(file)
                              endif
                              exe s:DirCheck()
                              let always_permitted = s:cpath(fugitive#Real(@%), file) && empty(s:DirCommitFile(@%)[1])
                              if !always_permitted && !a:bang && (len(s:TreeChomp('diff', '--name-status', 'HEAD', '--', file)) || len(s:TreeChomp('ls-files', '--others', '--', file)))
                                let v:errmsg = 'fugitive: file has uncommitted changes (use ! to override)'
                                return 'echoerr v:errmsg'
                              endif
                              let treebufnr = 0
                              for nr in range(1,bufnr('$'))
                                if fnamemodify(bufname(nr),':p') ==# file
                                  let treebufnr = nr
                                endif
                              endfor
                            
                              if treebufnr > 0 && treebufnr != bufnr('')
                                let temp = tempname()
                                silent execute 'keepalt %write '.temp
                                for tab in [mytab] + range(1,tabpagenr('$'))
                                  for winnr in range(1,tabpagewinnr(tab,'$'))
                                    if tabpagebuflist(tab)[winnr-1] == treebufnr
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        let lnum = line('.')
                                        let last = line('$')
                                        silent execute '$read '.temp
                                        silent execute '1,'.last.'delete_'
                                        silent write!
                                        silent execute lnum
                                        diffupdate
                                        let did = 1
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                      break
                                    endif
                                  endfor
                                endfor
                                if !exists('did')
                                  call writefile(readfile(temp,'b'),file,'b')
                                endif
                              else
                                execute 'write! '.s:fnameescape(file)
                              endif
                            
                              if a:bang
                                let [error, exec_error] = s:ChompError(['add', '--force', '--', file])
                              else
                                let [error, exec_error] = s:ChompError(['add', '--', file])
                              endif
                              if exec_error
                                let v:errmsg = 'fugitive: '.error
                                return 'echoerr v:errmsg'
                              endif
                              if s:cpath(fugitive#Real(@%), file) && s:DirCommitFile(@%)[1] =~# '^\d$'
                                setlocal nomodified
                              endif
                            
                              let one = s:Generate(':1:'.file)
                              let two = s:Generate(':2:'.file)
                              let three = s:Generate(':3:'.file)
                              for nr in range(1,bufnr('$'))
                                let name = fnamemodify(bufname(nr), ':p')
                                if bufloaded(nr) && !getbufvar(nr,'&modified') && (name ==# one || name ==# two || name ==# three)
                                  execute nr.'bdelete'
                                endif
                              endfor
                            
                              unlet! restorewinnr
                              let zero = s:Generate(':0:'.file)
                              silent execute 'doautocmd' s:nomodeline 'BufWritePost' s:fnameescape(zero)
                              for tab in range(1,tabpagenr('$'))
                                for winnr in range(1,tabpagewinnr(tab,'$'))
                                  let bufnr = tabpagebuflist(tab)[winnr-1]
                                  let bufname = fnamemodify(bufname(bufnr), ':p')
                                  if bufname ==# zero && bufnr != mybufnr
                                    execute 'tabnext '.tab
                                    if winnr != winnr()
                                      execute winnr.'wincmd w'
                                      let restorewinnr = 1
                                    endif
                                    try
                                      let lnum = line('.')
                                      let last = line('$')
                                      silent execute '$read '.s:fnameescape(file)
                                      silent execute '1,'.last.'delete_'
                                      silent execute lnum
                                      setlocal nomodified
                                      diffupdate
                                    finally
                                      if exists('restorewinnr')
                                        wincmd p
                                      endif
                                      execute 'tabnext '.mytab
                                    endtry
                                    break
                                  endif
                                endfor
                              endfor
                              call fugitive#ReloadStatus()
                              return 'checktime'
                            endfunction
                            
    1              0.000003 function! fugitive#WqCommand(...) abort
                              let bang = a:4 ? '!' : ''
                              if exists('b:fugitive_commit_arguments')
                                return 'wq'.bang
                              endif
                              let result = call('fugitive#WriteCommand', a:000)
                              if result =~# '^\%(write\|wq\|echoerr\)'
                                return s:sub(result,'^write','wq')
                              else
                                return result.'|quit'.bang
                              endif
                            endfunction
                            
    1              0.000003 augroup fugitive_commit
    1              0.000071   autocmd!
    1              0.000041   autocmd VimLeavePre,BufDelete COMMIT_EDITMSG execute substitute(s:FinishCommit(), '\C^echoerr \(''[^'']*''\)*', 'redraw|echohl ErrorMsg|echo \1|echohl NONE', '')
    1              0.000003 augroup END
                            
                            " Section: :Gpush, :Gfetch
                            
    1              0.000005 function! s:PushComplete(A, L, P) abort
                              return s:CompleteSub('push', a:A, a:L, a:P, function('s:CompleteRemote'))
                            endfunction
                            
    1              0.000004 function! s:FetchComplete(A, L, P) abort
                              return s:CompleteSub('fetch', a:A, a:L, a:P, function('s:CompleteRemote'))
                            endfunction
                            
    1              0.000003 function! s:AskPassArgs(dir) abort
                              if (len($DISPLAY) || len($TERM_PROGRAM) || has('gui_running')) && fugitive#GitVersion(1, 8) &&
                                    \ empty($GIT_ASKPASS) && empty($SSH_ASKPASS) && empty(fugitive#Config('core.askPass', a:dir))
                                if s:executable(s:ExecPath() . '/git-gui--askpass')
                                  return ['-c', 'core.askPass=' . s:ExecPath() . '/git-gui--askpass']
                                elseif s:executable('ssh-askpass')
                                  return ['-c', 'core.askPass=ssh-askpass']
                                endif
                              endif
                              return []
                            endfunction
                            
    1              0.000008 function! s:Dispatch(bang, cmd, args) abort
                              let dir = s:Dir()
                              let [mp, efm, cc] = [&l:mp, &l:efm, get(b:, 'current_compiler', '')]
                              try
                                let b:current_compiler = 'git'
                                let &l:errorformat = s:common_efm
                                let &l:makeprg = s:UserCommand(dir, s:AskPassArgs(dir) + [a:cmd] + a:args)
                                if exists(':Make') == 2
                                  Make
                                  return ''
                                else
                                  if !has('patch-8.1.0334') && has('terminal') && &autowrite
                                    let autowrite_was_set = 1
                                    set noautowrite
                                    silent! wall
                                  endif
                                  silent noautocmd make!
                                  redraw!
                                  return 'call fugitive#Cwindow()|call fugitive#ReloadStatus()'
                                endif
                              finally
                                let [&l:mp, &l:efm, b:current_compiler] = [mp, efm, cc]
                                if empty(cc) | unlet! b:current_compiler | endif
                                if exists('autowrite_was_set')
                                  set autowrite
                                endif
                              endtry
                            endfunction
                            
    1              0.000008 function! s:PushSubcommand(line1, line2, range, bang, mods, args) abort
                              return s:Dispatch(a:bang ? '!' : '', 'push', a:args)
                            endfunction
                            
    1              0.000004 function! s:FetchSubcommand(line1, line2, range, bang, mods, args) abort
                              return s:Dispatch(a:bang ? '!' : '', 'fetch', a:args)
                            endfunction
                            
    1   0.000058   0.000011 call s:command("-nargs=? -bang -complete=customlist,s:PushComplete Gpush", "push")
    1   0.000045   0.000008 call s:command("-nargs=? -bang -complete=customlist,s:FetchComplete Gfetch", "fetch")
                            
                            " Section: :Gdiff
                            
    1              0.000004 augroup fugitive_diff
    1              0.000070   autocmd!
    1              0.000013   autocmd BufWinLeave *
                                    \ if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |
                                    \   call s:diffoff_all(s:Dir(+expand('<abuf>'))) |
                                    \ endif
    1              0.000014   autocmd BufWinEnter *
                                    \ if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |
                                    \   call s:diffoff() |
                                    \ endif
    1              0.000002 augroup END
                            
    1              0.000004 function! s:can_diffoff(buf) abort
                              return getwinvar(bufwinnr(a:buf), '&diff') &&
                                    \ !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
                            endfunction
                            
    1              0.000004 function! fugitive#CanDiffoff(buf) abort
                              return s:can_diffoff(bufnr(a:buf))
                            endfunction
                            
    1              0.000003 function! s:diff_modifier(count) abort
                              let fdc = matchstr(&diffopt, 'foldcolumn:\zs\d\+')
                              if &diffopt =~# 'horizontal' && &diffopt !~# 'vertical'
                                return ''
                              elseif &diffopt =~# 'vertical'
                                return 'vertical '
                              elseif winwidth(0) <= a:count * ((&tw ? &tw : 80) + (empty(fdc) ? 2 : fdc))
                                return ''
                              else
                                return 'vertical '
                              endif
                            endfunction
                            
    1              0.000004 function! s:diff_window_count() abort
                              let c = 0
                              for nr in range(1,winnr('$'))
                                let c += getwinvar(nr,'&diff')
                              endfor
                              return c
                            endfunction
                            
    1              0.000003 function! s:diff_restore() abort
                              let restore = 'setlocal nodiff noscrollbind'
                                    \ . ' scrollopt=' . &l:scrollopt
                                    \ . (&l:wrap ? ' wrap' : ' nowrap')
                                    \ . ' foldlevel=999'
                                    \ . ' foldmethod=' . &l:foldmethod
                                    \ . ' foldcolumn=' . &l:foldcolumn
                                    \ . ' foldlevel=' . &l:foldlevel
                                    \ . (&l:foldenable ? ' foldenable' : ' nofoldenable')
                              if has('cursorbind')
                                let restore .= (&l:cursorbind ? ' ' : ' no') . 'cursorbind'
                              endif
                              return restore
                            endfunction
                            
    1              0.000002 function! s:diffthis() abort
                              if !&diff
                                let w:fugitive_diff_restore = s:diff_restore()
                                diffthis
                              endif
                            endfunction
                            
    1              0.000002 function! s:diffoff() abort
                              if exists('w:fugitive_diff_restore')
                                execute w:fugitive_diff_restore
                                unlet w:fugitive_diff_restore
                              else
                                diffoff
                              endif
                            endfunction
                            
    1              0.000006 function! s:diffoff_all(dir) abort
                              let curwin = winnr()
                              for nr in range(1,winnr('$'))
                                if getwinvar(nr,'&diff')
                                  if nr != winnr()
                                    execute nr.'wincmd w'
                                    let restorewinnr = 1
                                  endif
                                  if s:Dir() ==# a:dir
                                    call s:diffoff()
                                  endif
                                endif
                              endfor
                              execute curwin.'wincmd w'
                            endfunction
                            
    1              0.000003 function! s:CompareAge(mine, theirs) abort
                              let scores = {':0': 1, ':1': 2, ':2': 3, ':': 4, ':3': 5}
                              let mine = substitute(a:mine, '^:', '', '')
                              let theirs = substitute(a:theirs, '^:', '', '')
                              let my_score    = get(scores, ':'.mine, 0)
                              let their_score = get(scores, ':'.theirs, 0)
                              if my_score || their_score
                                return my_score < their_score ? -1 : my_score != their_score
                              elseif mine ==# theirs
                                return 0
                              endif
                              let base = s:TreeChomp('merge-base', mine, theirs)
                              if base ==# mine
                                return -1
                              elseif base ==# theirs
                                return 1
                              endif
                              let my_time    = +s:TreeChomp('log', '--max-count=1', '--pretty=format:%at', a:mine, '--')
                              let their_time = +s:TreeChomp('log', '--max-count=1', '--pretty=format:%at', a:theirs, '--')
                              return my_time < their_time ? -1 : my_time != their_time
                            endfunction
                            
    1              0.000003 function! s:IsConflicted() abort
                              return len(@%) && !empty(s:ChompDefault('', 'ls-files', '--unmerged', '--', expand('%:p')))
                            endfunction
                            
    1              0.000003 function! fugitive#Diffsplit(autodir, keepfocus, mods, arg, args) abort
                              let args = copy(a:args)
                              let post = ''
                              if get(args, 0) =~# '^+'
                                let post = remove(args, 0)[1:-1]
                              endif
                              if exists(':DiffGitCached') && empty(args)
                                return s:Mods(a:mods) . 'DiffGitCached' . (len(post) ? '|' . post : '')
                              endif
                              let commit = s:DirCommitFile(@%)[1]
                              if a:mods =~# '\<tab\>'
                                let mods = substitute(a:mods, '\<tab\>', '', 'g')
                                let pre = 'tab split'
                              else
                                let mods = 'keepalt ' . a:mods
                                let pre = ''
                              endif
                              let back = exists('*win_getid') ? 'call win_gotoid(' . win_getid() . ')' : 'wincmd p'
                              if (empty(args) || args[0] ==# ':') && a:keepfocus
                                exe s:DirCheck()
                                if empty(commit) && s:IsConflicted()
                                  let parents = [s:Relative(':2:'), s:Relative(':3:')]
                                elseif empty(commit)
                                  let parents = [s:Relative(':0:')]
                                elseif commit =~# '^\d\=$'
                                  let parents = [s:Relative('HEAD:')]
                                elseif commit =~# '^\x\x\+$'
                                  let parents = s:LinesError(['rev-parse', commit . '^@'])[0]
                                  call map(parents, 's:Relative(v:val . ":")')
                                endif
                              endif
                              try
                                if exists('parents') && len(parents) > 1
                                  exe pre
                                  let mods = (a:autodir ? s:diff_modifier(len(parents) + 1) : '') . s:Mods(mods, 'leftabove')
                                  let nr = bufnr('')
                                  execute mods 'split' s:fnameescape(s:Generate(parents[0]))
                                  call s:Map('n', 'dp', ':diffput '.nr.'<Bar>diffupdate<CR>', '<silent>')
                                  let nr2 = bufnr('')
                                  call s:diffthis()
                                  exe back
                                  call s:Map('n', 'd2o', ':diffget '.nr2.'<Bar>diffupdate<CR>', '<silent>')
                                  let mods = substitute(mods, '\Cleftabove\|rightbelow\|aboveleft\|belowright', '\=submatch(0) =~# "f" ? "rightbelow" : "leftabove"', '')
                                  for i in range(len(parents)-1, 1, -1)
                                    execute mods 'split' s:fnameescape(s:Generate(parents[i]))
                                    call s:Map('n', 'dp', ':diffput '.nr.'<Bar>diffupdate<CR>', '<silent>')
                                    let nrx = bufnr('')
                                    call s:diffthis()
                                    exe back
                                    call s:Map('n', 'd' . (i + 2) . 'o', ':diffget '.nrx.'<Bar>diffupdate<CR>', '<silent>')
                                  endfor
                                  call s:diffthis()
                                  if len(parents) > 1
                                    wincmd =
                                  endif
                                  return post
                                elseif len(args)
                                  let arg = join(args, ' ')
                                  if arg ==# ''
                                    return post
                                  elseif arg ==# ':/'
                                    exe s:DirCheck()
                                    let file = s:Relative()
                                  elseif arg ==# ':'
                                    exe s:DirCheck()
                                    let file = s:Relative(':0:')
                                  elseif arg =~# '^:\d$'
                                    exe s:DirCheck()
                                    let file = s:Relative(arg . ':')
                                  else
                                    try
                                      let file = arg =~# '^:/.' ? fugitive#RevParse(arg) . s:Relative(':') : s:Expand(arg)
                                    catch /^fugitive:/
                                      return 'echoerr ' . string(v:exception)
                                    endtry
                                  endif
                                elseif exists('parents') && len(parents)
                                  let file = parents[-1]
                                elseif len(commit)
                                  let file = s:Relative()
                                elseif s:IsConflicted()
                                  let file = s:Relative(':1:')
                                  let post = 'echohl WarningMsg|echo "Use :Gdiffsplit! for 3 way diff"|echohl NONE|' . post
                                else
                                  exe s:DirCheck()
                                  let file = s:Relative(':0:')
                                endif
                                let spec = s:Generate(file)
                                if spec =~# '^fugitive:' && empty(s:DirCommitFile(spec)[2])
                                  let spec = FugitiveVimPath(spec . s:Relative('/'))
                                endif
                                exe pre
                                let restore = s:diff_restore()
                                let w:fugitive_diff_restore = restore
                                if s:CompareAge(commit, s:DirCommitFile(spec)[1]) < 0
                                  let mods = s:Mods(mods, 'rightbelow')
                                else
                                  let mods = s:Mods(mods, 'leftabove')
                                endif
                                let mods = (a:autodir ? s:diff_modifier(2) : '') . mods
                                if &diffopt =~# 'vertical'
                                  let diffopt = &diffopt
                                  set diffopt-=vertical
                                endif
                                execute mods 'diffsplit' s:fnameescape(spec)
                                let &l:readonly = &l:readonly
                                redraw
                                let w:fugitive_diff_restore = restore
                                let winnr = winnr()
                                if getwinvar('#', '&diff')
                                  if a:keepfocus
                                    exe back
                                  endif
                                endif
                                return post
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                if exists('diffopt')
                                  let &diffopt = diffopt
                                endif
                              endtry
                            endfunction
                            
                            " Section: :Gmove, :Gremove
                            
    1              0.000005 function! s:Move(force, rename, destination) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              if s:DirCommitFile(@%)[1] !~# '^0\=$' || empty(@%)
                                return 'echoerr ' . string('fugitive: mv not supported for this buffer')
                              endif
                              if a:destination =~# '^\.\.\=\%(/\|$\)'
                                let destination = simplify(getcwd() . '/' . a:destination)
                              elseif a:destination =~# '^\a\+:\|^/'
                                let destination = a:destination
                              elseif a:destination =~# '^:/:\='
                                let destination = s:Tree(dir) . substitute(a:destination, '^:/:\=', '', '')
                              elseif a:destination =~# '^:(\%(top\|top,literal\|literal,top\))'
                                let destination = s:Tree(dir) . matchstr(a:destination, ')\zs.*')
                              elseif a:destination =~# '^:(literal)'
                                let destination = simplify(getcwd() . '/' . matchstr(a:destination, ')\zs.*'))
                              elseif a:rename
                                let destination = expand('%:p:s?[\/]$??:h') . '/' . a:destination
                              else
                                let destination = s:Tree(dir) . '/' . a:destination
                              endif
                              let destination = s:Slash(destination)
                              if isdirectory(@%)
                                setlocal noswapfile
                              endif
                              let [message, exec_error] = s:ChompError(['mv'] + (a:force ? ['-f'] : []) + ['--', expand('%:p'), destination], dir)
                              if exec_error
                                let v:errmsg = 'fugitive: '.message
                                return 'echoerr v:errmsg'
                              endif
                              if isdirectory(destination)
                                let destination = fnamemodify(s:sub(destination,'/$','').'/'.expand('%:t'),':.')
                              endif
                              call fugitive#ReloadStatus(dir)
                              if empty(s:DirCommitFile(@%)[1])
                                if isdirectory(destination)
                                  return 'keepalt edit '.s:fnameescape(destination)
                                else
                                  return 'keepalt saveas! '.s:fnameescape(destination)
                                endif
                              else
                                return 'file '.s:fnameescape(fugitive#Find(':0:'.destination, dir))
                              endif
                            endfunction
                            
    1              0.000004 function! fugitive#RenameComplete(A,L,P) abort
                              if a:A =~# '^[.:]\=/'
                                return fugitive#CompletePath(a:A)
                              else
                                let pre = s:Slash(fnamemodify(expand('%:p:s?[\/]$??'), ':h')) . '/'
                                return map(fugitive#CompletePath(pre.a:A), 'strpart(v:val, len(pre))')
                              endif
                            endfunction
                            
    1              0.000004 function! fugitive#MoveCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Move(a:bang, 0, a:arg)
                            endfunction
                            
    1              0.000004 function! fugitive#RenameCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Move(a:bang, 1, a:arg)
                            endfunction
                            
    1              0.000004 function! s:Remove(after, force) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              if len(@%) && s:DirCommitFile(@%)[1] ==# ''
                                let cmd = ['rm']
                              elseif s:DirCommitFile(@%)[1] ==# '0'
                                let cmd = ['rm','--cached']
                              else
                                return 'echoerr ' . string('fugitive: rm not supported for this buffer')
                              endif
                              if a:force
                                let cmd += ['--force']
                              endif
                              let [message, exec_error] = s:ChompError(cmd + ['--', expand('%:p')], dir)
                              if exec_error
                                let v:errmsg = 'fugitive: '.s:sub(message,'error:.*\zs\n\(.*-f.*',' (add ! to force)')
                                return 'echoerr '.string(v:errmsg)
                              else
                                call fugitive#ReloadStatus(dir)
                                return a:after . (a:force ? '!' : '')
                              endif
                            endfunction
                            
    1              0.000006 function! fugitive#RemoveCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Remove('edit', a:bang)
                            endfunction
                            
    1              0.000005 function! fugitive#DeleteCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Remove('bdelete', a:bang)
                            endfunction
                            
                            " Section: :Gblame
                            
    1              0.000005 function! s:Keywordprg() abort
                              let args = ' --git-dir='.escape(s:Dir(),"\\\"' ")
                              if has('gui_running') && !has('win32')
                                return s:UserCommand() . ' --no-pager' . args . ' log -1'
                              else
                                return s:UserCommand() . args . ' show'
                              endif
                            endfunction
                            
    1              0.000003 function! s:linechars(pattern) abort
                              let chars = strlen(s:gsub(matchstr(getline('.'), a:pattern), '.', '.'))
                              if exists('*synconcealed') && &conceallevel > 1
                                for col in range(1, chars)
                                  let chars -= synconcealed(line('.'), col)[0]
                                endfor
                              endif
                              return chars
                            endfunction
                            
    1              0.000003 function! s:BlameBufnr(...) abort
                              let state = s:TempState(bufname(a:0 ? a:1 : ''))
                              if get(state, 'filetype', '') ==# 'fugitiveblame'
                                return get(state, 'bufnr', -1)
                              else
                                return -1
                              endif
                            endfunction
                            
    1              0.000004 function! s:BlameCommitFileLnum(...) abort
                              let line = a:0 ? a:1 : getline('.')
                              let state = a:0 ? a:2 : s:TempState()
                              let commit = matchstr(line, '^\^\=\zs\x\+')
                              if commit =~# '^0\+$'
                                let commit = ''
                              elseif line !~# '^\^' && has_key(state, 'blame_reverse_end')
                                let commit = get(s:LinesError('rev-list', '--ancestry-path', '--reverse', commit . '..' . state.blame_reverse_end)[0], 0, '')
                              endif
                              let lnum = +matchstr(line, ' \zs\d\+\ze \%((\| *\d\+)\)')
                              let path = matchstr(line, '^\^\=[?*]*\x* \+\%(\d\+ \+\d\+ \+\)\=\zs.\{-\}\ze\s\+\%(\%( \d\+ \)\@<!([^()]*\w \d\+)\|\d\+ \)')
                              if empty(path) && lnum
                                let path = get(state, 'blame_file', '')
                              endif
                              return [commit, path, lnum]
                            endfunction
                            
    1              0.000002 function! s:BlameLeave() abort
                              let bufwinnr = bufwinnr(s:BlameBufnr())
                              if bufwinnr > 0
                                let bufnr = bufnr('')
                                exe bufwinnr . 'wincmd w'
                                return bufnr . 'bdelete'
                              endif
                              return ''
                            endfunction
                            
    1              0.000003 function! s:BlameQuit() abort
                              let cmd = s:BlameLeave()
                              if empty(cmd)
                                return 'bdelete'
                              elseif len(s:DirCommitFile(@%)[1])
                                return cmd . '|Gedit'
                              else
                                return cmd
                              endif
                            endfunction
                            
    1              0.000004 function! s:BlameComplete(A, L, P) abort
                              return s:CompleteSub('blame', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000004 function! s:BlameSubcommand(line1, count, range, bang, mods, args) abort
                              exe s:DirCheck()
                              let flags = copy(a:args)
                              let i = 0
                              let raw = 0
                              let commits = []
                              let files = []
                              let ranges = []
                              if a:line1 > 0 && a:count > 0 && a:range != 1
                                call extend(ranges, ['-L', a:line1 . ',' . a:count])
                              endif
                              while i < len(flags)
                                let match = matchlist(flags[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(flags, match[1])
                                  let flags[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = flags[i]
                                if arg =~# '^-p$\|^--\%(help\|porcelain\|line-porcelain\|incremental\)$'
                                  let raw = 1
                                elseif arg ==# '--contents' && i + 1 < len(flags)
                                  call extend(commits, remove(flags, i, i+1))
                                  continue
                                elseif arg ==# '-L' && i + 1 < len(flags)
                                  call extend(ranges, remove(flags, i, i+1))
                                  continue
                                elseif arg =~# '^--contents='
                                  call add(commits, remove(flags, i))
                                  continue
                                elseif arg =~# '^-L.'
                                  call add(ranges, remove(flags, i))
                                  continue
                                elseif arg =~# '^-[GLS]$\|^--\%(date\|encoding\|contents\|ignore-rev\|ignore-revs-file\)$'
                                  let i += 1
                                  if i == len(flags)
                                    echohl ErrorMsg
                                    echo s:ChompError(['blame', arg])[0]
                                    echohl NONE
                                    return ''
                                  endif
                                elseif arg ==# '--'
                                  if i + 1 < len(flags)
                                    call extend(files, remove(flags, i + 1, -1))
                                  endif
                                  call remove(flags, i)
                                  break
                                elseif arg !~# '^-' && (s:HasOpt(flags, '--not') || arg !~# '^\^')
                                  if index(flags, '--') >= 0
                                    call add(commits, remove(flags, i))
                                    continue
                                  endif
                                  if arg =~# '\.\.' && arg !~# '^\.\.\=\%(/\|$\)' && empty(commits)
                                    call add(commits, remove(flags, i))
                                    continue
                                  endif
                                  try
                                    let dcf = s:DirCommitFile(fugitive#Find(arg))
                                    if len(dcf[1]) && empty(dcf[2])
                                      call add(commits, remove(flags, i))
                                      continue
                                    endif
                                  catch /^fugitive:/
                                  endtry
                                  call add(files, remove(flags, i))
                                  continue
                                endif
                                let i += 1
                              endwhile
                              let file = substitute(get(files, 0, get(s:TempState(), 'blame_file', s:Relative('./'))), '^\.\%(/\|$\)', '', '')
                              if empty(commits) && len(files) > 1
                                call add(commits, remove(files, 1))
                              endif
                              exe s:BlameLeave()
                              try
                                let cmd = ['--no-pager', '-c', 'blame.coloring=none', '-c', 'blame.blankBoundary=false', 'blame', '--show-number']
                                call extend(cmd, filter(copy(flags), 'v:val !~# "\\v^%(-b|--%(no-)=color-.*|--progress)$"'))
                                if a:count > 0 && empty(ranges)
                                  let cmd += ['-L', (a:line1 ? a:line1 : line('.')) . ',' . (a:line1 ? a:line1 : line('.'))]
                                endif
                                call extend(cmd, ranges)
                                if len(commits)
                                  let cmd += commits
                                elseif empty(files) && len(matchstr(s:DirCommitFile(@%)[1], '^\x\x\+$'))
                                  let cmd += [matchstr(s:DirCommitFile(@%)[1], '^\x\x\+$')]
                                elseif empty(files) && !s:HasOpt(flags, '--reverse')
                                  let cmd += ['--contents', '-']
                                endif
                                let basecmd = escape(fugitive#Prepare(cmd) . ' -- ' . s:shellesc(len(files) ? files : file), '!#%')
                                let tempname = tempname()
                                let error = tempname . '.err'
                                let temp = tempname . (raw ? '' : '.fugitiveblame')
                                if &shell =~# 'csh'
                                  silent! execute '%write !('.basecmd.' > '.temp.') >& '.error
                                else
                                  silent! execute '%write !'.basecmd.' > '.temp.' 2> '.error
                                endif
                                redraw
                                try
                                  if v:shell_error
                                    let lines = readfile(error)
                                    if empty(lines)
                                      let lines = readfile(temp)
                                    endif
                                    for i in range(len(lines))
                                      if lines[i] =~# '^error: \|^fatal: '
                                        echohl ErrorMsg
                                        echon lines[i]
                                        echohl NONE
                                        break
                                      else
                                        echon lines[i]
                                      endif
                                      if i != len(lines) - 1
                                        echon "\n"
                                      endif
                                    endfor
                                    return ''
                                  endif
                                  let temp_state = {'dir': s:Dir(), 'filetype': (raw ? '' : 'fugitiveblame'), 'blame_flags': flags, 'blame_file': file, 'modifiable': 0}
                                  if s:HasOpt(flags, '--reverse')
                                    let temp_state.blame_reverse_end = matchstr(get(commits, 0, ''), '\.\.\zs.*')
                                  endif
                                  if (a:line1 == 0 || a:range == 1) && a:count > 0
                                    let edit = s:Mods(a:mods) . get(['edit', 'split', 'pedit', 'vsplit', 'tabedit'], a:count - (a:line1 ? a:line1 : 1), 'split')
                                    return s:BlameCommit(edit, get(readfile(temp), 0, ''), temp_state)
                                  else
                                    let temp = s:Resolve(temp)
                                    let s:temp_files[s:cpath(temp)] = temp_state
                                    if len(ranges + commits + files) || raw
                                      let mods = s:Mods(a:mods)
                                      if a:count != 0
                                        exe 'silent keepalt' mods 'split' s:fnameescape(temp)
                                      elseif !&modified || a:bang || &bufhidden ==# 'hide' || (empty(&bufhidden) && &hidden)
                                        exe 'silent' mods 'edit' . (a:bang ? '! ' : ' ') . s:fnameescape(temp)
                                      else
                                        return mods . 'edit ' . s:fnameescape(temp)
                                      endif
                                      return ''
                                    endif
                                    if a:mods =~# '\<tab\>'
                                      silent tabedit %
                                    endif
                                    let mods = substitute(a:mods, '\<tab\>', '', 'g')
                                    for winnr in range(winnr('$'),1,-1)
                                      if getwinvar(winnr, '&scrollbind')
                                        call setwinvar(winnr, '&scrollbind', 0)
                                      endif
                                      if exists('+cursorbind') && getwinvar(winnr, '&cursorbind')
                                        call setwinvar(winnr, '&cursorbind', 0)
                                      endif
                                      if s:BlameBufnr(winbufnr(winnr)) > 0
                                        execute winbufnr(winnr).'bdelete'
                                      endif
                                    endfor
                                    let bufnr = bufnr('')
                                    let temp_state.bufnr = bufnr
                                    let restore = 'call setwinvar(bufwinnr('.bufnr.'),"&scrollbind",0)'
                                    if exists('+cursorbind')
                                      let restore .= '|call setwinvar(bufwinnr('.bufnr.'),"&cursorbind",0)'
                                    endif
                                    if &l:wrap
                                      let restore .= '|call setwinvar(bufwinnr('.bufnr.'),"&wrap",1)'
                                    endif
                                    if &l:foldenable
                                      let restore .= '|call setwinvar(bufwinnr('.bufnr.'),"&foldenable",1)'
                                    endif
                                    setlocal scrollbind nowrap nofoldenable
                                    if exists('+cursorbind')
                                      setlocal cursorbind
                                    endif
                                    let top = line('w0') + &scrolloff
                                    let current = line('.')
                                    exe 'silent keepalt' (a:bang ? s:Mods(mods) . 'split' : s:Mods(mods, 'leftabove') . 'vsplit') s:fnameescape(temp)
                                    let w:fugitive_leave = restore
                                    execute top
                                    normal! zt
                                    execute current
                                    if exists('+cursorbind')
                                      setlocal cursorbind
                                    endif
                                    setlocal nonumber scrollbind nowrap foldcolumn=0 nofoldenable winfixwidth
                                    if exists('+relativenumber')
                                      setlocal norelativenumber
                                    endif
                                    execute "vertical resize ".(s:linechars('.\{-\}\ze\s\+\d\+)')+1)
                                    call s:Map('n', 'A', ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze [0-9:/+-][0-9:/+ -]* \\d\\+)')+1+v:count)<CR>", '<silent>')
                                    call s:Map('n', 'C', ":<C-u>exe 'vertical resize '.(<SID>linechars('^\\S\\+')+1+v:count)<CR>", '<silent>')
                                    call s:Map('n', 'D', ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze\\d\\ze\\s\\+\\d\\+)')+1-v:count)<CR>", '<silent>')
                                    redraw
                                    syncbind
                                  endif
                                endtry
                                return ''
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000006 function! s:BlameCommit(cmd, ...) abort
                              let line = a:0 ? a:1 : getline('.')
                              let state = a:0 ? a:2 : s:TempState()
                              let sigil = has_key(state, 'blame_reverse_end') ? '-' : '+'
                              let mods = (s:BlameBufnr() < 0 ? '' : &splitbelow ? "botright " : "topleft ")
                              let [commit, path, lnum] = s:BlameCommitFileLnum(line, state)
                              if empty(commit) && len(path) && has_key(state, 'blame_reverse_end')
                                let path = (len(state.blame_reverse_end) ? state.blame_reverse_end . ':' : ':(top)') . path
                                return fugitive#Open(mods . a:cmd, 0, '', '+' . lnum . ' ' . s:fnameescape(path), ['+' . lnum, path])
                              endif
                              if commit =~# '^0*$'
                                return 'echoerr ' . string('fugitive: no commit')
                              endif
                              if line =~# '^\^' && !has_key(state, 'blame_reverse_end')
                                let path = commit . ':' . path
                                return fugitive#Open(mods . a:cmd, 0, '', '+' . lnum . ' ' . s:fnameescape(path), ['+' . lnum, path])
                              endif
                              let cmd = fugitive#Open(mods . a:cmd, 0, '', commit, [commit])
                              if cmd =~# '^echoerr'
                                return cmd
                              endif
                              execute cmd
                              if a:cmd ==# 'pedit' || empty(path)
                                return ''
                              endif
                              if search('^diff .* b/\M'.escape(path,'\').'$','W')
                                call search('^+++')
                                let head = line('.')
                                while search('^@@ \|^diff ') && getline('.') =~# '^@@ '
                                  let top = +matchstr(getline('.'),' ' . sigil .'\zs\d\+')
                                  let len = +matchstr(getline('.'),' ' . sigil . '\d\+,\zs\d\+')
                                  if lnum >= top && lnum <= top + len
                                    let offset = lnum - top
                                    if &scrolloff
                                      +
                                      normal! zt
                                    else
                                      normal! zt
                                      +
                                    endif
                                    while offset > 0 && line('.') < line('$')
                                      +
                                      if getline('.') =~# '^[ ' . sigil . ']'
                                        let offset -= 1
                                      endif
                                    endwhile
                                    return 'normal! zv'
                                  endif
                                endwhile
                                execute head
                                normal! zt
                              endif
                              return ''
                            endfunction
                            
    1              0.000005 function! s:BlameJump(suffix, ...) abort
                              let suffix = a:suffix
                              let [commit, path, lnum] = s:BlameCommitFileLnum()
                              if empty(path)
                                return 'echoerr ' . string('fugitive: could not determine filename for blame')
                              endif
                              if commit =~# '^0*$'
                                let commit = 'HEAD'
                                let suffix = ''
                              endif
                              let offset = line('.') - line('w0')
                              let flags = get(s:TempState(), 'blame_flags', [])
                              if a:0 && a:1
                                if s:HasOpt(flags, '--reverse')
                                  call remove(flags, '--reverse')
                                else
                                  call add(flags, '--reverse')
                                endif
                              endif
                              let blame_bufnr = s:BlameBufnr()
                              if blame_bufnr > 0
                                let bufnr = bufnr('')
                                let winnr = bufwinnr(blame_bufnr)
                                if winnr > 0
                                  exe winnr.'wincmd w'
                                endif
                                execute 'Gedit' s:fnameescape(commit . suffix . ':' . path)
                                execute lnum
                                if winnr > 0
                                  exe bufnr.'bdelete'
                                endif
                              endif
                              if exists(':Gblame')
                                let my_bufnr = bufnr('')
                                if blame_bufnr < 0
                                  let blame_args = flags + [commit . suffix, '--', path]
                                  let result = s:BlameSubcommand(0, 0, 0, 0, '', blame_args)
                                else
                                  let blame_args = flags
                                  let result = s:BlameSubcommand(-1, -1, 0, 0, '', blame_args)
                                endif
                                if bufnr('') == my_bufnr
                                  return result
                                endif
                                execute result
                                execute lnum
                                let delta = line('.') - line('w0') - offset
                                if delta > 0
                                  execute 'normal! '.delta."\<C-E>"
                                elseif delta < 0
                                  execute 'normal! '.(-delta)."\<C-Y>"
                                endif
                                keepjumps syncbind
                                redraw
                                echo ':Gblame' s:fnameescape(blame_args)
                              endif
                              return ''
                            endfunction
                            
    1              0.000006 let s:hash_colors = {}
                            
    1              0.000003 function! fugitive#BlameSyntax() abort
                              let conceal = has('conceal') ? ' conceal' : ''
                              let config = fugitive#Config()
                              let flags = get(s:TempState(), 'blame_flags', [])
                              syn match FugitiveblameBlank                      "^\s\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalFile,FugitiveblameOriginalLineNumber skipwhite
                              syn match FugitiveblameHash       "\%(^\^\=[?*]*\)\@<=\<\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              syn match FugitiveblameUncommitted "\%(^\^\=\)\@<=\<0\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              if get(get(config, 'blame.blankboundary', ['x']), 0, 'x') =~# '^$\|^true$' || s:HasOpt(flags, '-b')
                                syn match FugitiveblameBoundaryIgnore "^\^[*?]*\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              else
                                syn match FugitiveblameBoundary "^\^"
                              endif
                              syn match FugitiveblameScoreDebug        " *\d\+\s\+\d\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile contained skipwhite
                              syn region FugitiveblameAnnotation matchgroup=FugitiveblameDelimiter start="(" end="\%(\s\d\+\)\@<=)" contained keepend oneline
                              syn match FugitiveblameTime "[0-9:/+-][0-9:/+ -]*[0-9:/+-]\%(\s\+\d\+)\)\@=" contained containedin=FugitiveblameAnnotation
                              exec 'syn match FugitiveblameLineNumber         "\s*\d\+)\@=" contained containedin=FugitiveblameAnnotation' conceal
                              exec 'syn match FugitiveblameOriginalFile       "\s\%(\f\+\D\@<=\|\D\@=\f\+\)\%(\%(\s\+\d\+\)\=\s\%((\|\s*\d\+)\)\)\@=" contained nextgroup=FugitiveblameOriginalLineNumber,FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-name', '-f') ? '' : conceal)
                              exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s(\)\@=" contained nextgroup=FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
                              exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s\+\d\+)\)\@=" contained nextgroup=FugitiveblameShort skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
                              syn match FugitiveblameShort              " \d\+)" contained contains=FugitiveblameLineNumber
                              syn match FugitiveblameNotCommittedYet "(\@<=Not Committed Yet\>" contained containedin=FugitiveblameAnnotation
                              hi def link FugitiveblameBoundary           Keyword
                              hi def link FugitiveblameHash               Identifier
                              hi def link FugitiveblameBoundaryIgnore     Ignore
                              hi def link FugitiveblameUncommitted        Ignore
                              hi def link FugitiveblameScoreDebug         Debug
                              hi def link FugitiveblameTime               PreProc
                              hi def link FugitiveblameLineNumber         Number
                              hi def link FugitiveblameOriginalFile       String
                              hi def link FugitiveblameOriginalLineNumber Float
                              hi def link FugitiveblameShort              FugitiveblameDelimiter
                              hi def link FugitiveblameDelimiter          Delimiter
                              hi def link FugitiveblameNotCommittedYet    Comment
                              if !get(g:, 'fugitive_dynamic_colors', 1) && !s:HasOpt(flags, '--color-lines') || s:HasOpt(flags, '--no-color-lines')
                                return
                              endif
                              let seen = {}
                              for lnum in range(1, line('$'))
                                let hash = matchstr(getline(lnum), '^\^\=\zs\x\{6\}')
                                if hash ==# '' || hash ==# '000000' || has_key(seen, hash)
                                  continue
                                endif
                                let seen[hash] = 1
                                if &t_Co > 16 && get(g:, 'CSApprox_loaded') && !empty(findfile('autoload/csapprox/per_component.vim', escape(&rtp, ' ')))
                                      \ && empty(get(s:hash_colors, hash))
                                  let [s, r, g, b; __] = map(matchlist(hash, '\(\x\x\)\(\x\x\)\(\x\x\)'), 'str2nr(v:val,16)')
                                  let color = csapprox#per_component#Approximate(r, g, b)
                                  if color == 16 && &background ==# 'dark'
                                    let color = 8
                                  endif
                                  let s:hash_colors[hash] = ' ctermfg='.color
                                else
                                  let s:hash_colors[hash] = ''
                                endif
                                exe 'syn match FugitiveblameHash'.hash.'       "\%(^\^\=\)\@<='.hash.'\x\{1,34\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile skipwhite'
                              endfor
                              call s:BlameRehighlight()
                            endfunction
                            
    1              0.000006 function! s:BlameRehighlight() abort
                              for [hash, cterm] in items(s:hash_colors)
                                if !empty(cterm) || has('gui_running') || has('termguicolors') && &termguicolors
                                  exe 'hi FugitiveblameHash'.hash.' guifg=#'.hash.get(s:hash_colors, hash, '')
                                else
                                  exe 'hi link FugitiveblameHash'.hash.' Identifier'
                                endif
                              endfor
                            endfunction
                            
    1              0.000003 function! s:BlameFileType() abort
                              setlocal nomodeline
                              setlocal foldmethod=manual
                              if len(s:Dir())
                                let &l:keywordprg = s:Keywordprg()
                              endif
                              let b:undo_ftplugin = 'setl keywordprg= foldmethod<'
                              if exists('+concealcursor')
                                setlocal concealcursor=nc conceallevel=2
                                let b:undo_ftplugin .= ' concealcursor< conceallevel<'
                              endif
                              if &modifiable
                                return ''
                              endif
                              call s:Map('n', '<F1>', ':help fugitive-:Gblame<CR>', '<silent>')
                              call s:Map('n', 'g?',   ':help fugitive-:Gblame<CR>', '<silent>')
                              if mapcheck('q', 'n') =~# '^$\|bdelete'
                                call s:Map('n', 'q',  ':exe <SID>BlameQuit()<Bar>echohl WarningMsg<Bar>echo ":Gblame q is deprecated in favor of gq"<Bar>echohl NONE<CR>', '<silent>')
                              endif
                              call s:Map('n', 'gq',   ':exe <SID>BlameQuit()<CR>', '<silent>')
                              call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', '<CR>', ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', '-',    ':<C-U>exe <SID>BlameJump("")<CR>', '<silent>')
                              call s:Map('n', 'P',    ':<C-U>exe <SID>BlameJump("^".v:count1)<CR>', '<silent>')
                              call s:Map('n', '~',    ':<C-U>exe <SID>BlameJump("~".v:count1)<CR>', '<silent>')
                              call s:Map('n', 'i',    ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', 'o',    ':<C-U>exe <SID>BlameCommit("split")<CR>', '<silent>')
                              call s:Map('n', 'O',    ':<C-U>exe <SID>BlameCommit("tabedit")<CR>', '<silent>')
                              call s:Map('n', 'p',    ':<C-U>exe <SID>BlameCommit("pedit")<CR>', '<silent>')
                            endfunction
                            
    1              0.000007 augroup fugitive_blame
    1              0.000085   autocmd!
    1              0.000018   autocmd FileType fugitiveblame call s:BlameFileType()
    1              0.000011   autocmd ColorScheme,GUIEnter * call s:BlameRehighlight()
    1              0.000006   autocmd BufWinLeave * execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
    1              0.000002 augroup END
                            
    1   0.000059   0.000013 call s:command('-buffer -bang -range=-1 -nargs=? -complete=customlist,s:BlameComplete Gblame', 'blame')
                            
                            " Section: :Gbrowse
                            
    1              0.000003 let s:redirects = {}
                            
    1              0.000005 function! fugitive#BrowseCommand(line1, count, range, bang, mods, arg, args) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              try
                                let validremote = '\.\|\.\=/.*\|[[:alnum:]_-]\+\%(://.\{-\}\)\='
                                if a:args ==# ['-']
                                  if a:count >= 0
                                    return 'echoerr ' . string('fugitive: ''-'' no longer required to get persistent URL if range given')
                                  else
                                    return 'echoerr ' . string('fugitive: use :0Gbrowse instead of :Gbrowse -')
                                  endif
                                elseif len(a:args)
                                  let remote = matchstr(join(a:args, ' '),'@\zs\%('.validremote.'\)$')
                                  let rev = substitute(join(a:args, ' '),'@\%('.validremote.'\)$','','')
                                else
                                  let remote = ''
                                  let rev = ''
                                endif
                                if rev ==# ''
                                  let rev = s:DirRev(@%)[1]
                                endif
                                if rev =~# '^:\=$'
                                  let expanded = s:Relative()
                                else
                                  let expanded = s:Expand(rev)
                                endif
                                let cdir = FugitiveVimPath(fugitive#CommonDir(dir))
                                for subdir in ['tags/', 'heads/', 'remotes/']
                                  if expanded !~# '^[./]' && filereadable(cdir . '/refs/' . subdir . expanded)
                                    let expanded = '.git/refs/' . subdir . expanded
                                  endif
                                endfor
                                let full = fugitive#Find(expanded, dir)
                                let commit = ''
                                if full =~? '^fugitive:'
                                  let [pathdir, commit, path] = s:DirCommitFile(full)
                                  if commit =~# '^:\=\d$'
                                    let commit = ''
                                  endif
                                  if commit =~ '..'
                                    let type = s:TreeChomp('cat-file','-t',commit.s:sub(path,'^/',':'))
                                    let branch = matchstr(expanded, '^[^:]*')
                                  else
                                    let type = 'blob'
                                  endif
                                  let path = path[1:-1]
                                elseif empty(s:Tree(dir))
                                  let path = '.git/' . full[strlen(dir)+1:-1]
                                  let type = ''
                                else
                                  let path = fugitive#Path(full, '/')[1:-1]
                                  if path =~# '^\.git/'
                                    let type = ''
                                  elseif isdirectory(full) || empty(path)
                                    let type = 'tree'
                                  else
                                    let type = 'blob'
                                  endif
                                endif
                                if type ==# 'tree' && !empty(path)
                                  let path = s:sub(path, '/\=$', '/')
                                endif
                                if path =~# '^\.git/.*HEAD$' && filereadable(dir . '/' . path[5:-1])
                                  let body = readfile(dir . '/' . path[5:-1])[0]
                                  if body =~# '^\x\{40,\}$'
                                    let commit = body
                                    let type = 'commit'
                                    let path = ''
                                  elseif body =~# '^ref: refs/'
                                    let path = '.git/' . matchstr(body,'ref: \zs.*')
                                  endif
                                endif
                            
                                let merge = ''
                                if path =~# '^\.git/refs/remotes/.'
                                  if empty(remote)
                                    let remote = matchstr(path, '^\.git/refs/remotes/\zs[^/]\+')
                                    let branch = matchstr(path, '^\.git/refs/remotes/[^/]\+/\zs.\+')
                                  else
                                    let merge = matchstr(path, '^\.git/refs/remotes/[^/]\+/\zs.\+')
                                    let path = '.git/refs/heads/'.merge
                                  endif
                                elseif path =~# '^\.git/refs/heads/.'
                                  let branch = path[16:-1]
                                elseif !exists('branch')
                                  let branch = FugitiveHead()
                                endif
                                if !empty(branch)
                                  let r = fugitive#Config('branch.'.branch.'.remote')
                                  let m = fugitive#Config('branch.'.branch.'.merge')[11:-1]
                                  if r ==# '.' && !empty(m)
                                    let r2 = fugitive#Config('branch.'.m.'.remote')
                                    if r2 !~# '^\.\=$'
                                      let r = r2
                                      let m = fugitive#Config('branch.'.m.'.merge')[11:-1]
                                    endif
                                  endif
                                  if empty(remote)
                                    let remote = r
                                  endif
                                  if r ==# '.' || r ==# remote
                                    let merge = m
                                    if path =~# '^\.git/refs/heads/.'
                                      let path = '.git/refs/heads/'.merge
                                    endif
                                  endif
                                endif
                            
                                let line1 = a:count > 0 ? a:line1 : 0
                                let line2 = a:count > 0 ? a:count : 0
                                if empty(commit) && path !~# '^\.git/'
                                  if a:count < 0 && !empty(merge)
                                    let commit = merge
                                  else
                                    let commit = ''
                                    if len(merge)
                                      let owner = s:Owner(@%)
                                      let [commit, exec_error] = s:ChompError(['merge-base', 'refs/remotes/' . remote . '/' . merge, empty(owner) ? 'HEAD' : owner, '--'])
                                      if exec_error
                                        let commit = ''
                                      endif
                                      if a:count > 0 && empty(a:args) && commit =~# '^\x\{40,\}$'
                                        let blame_list = tempname()
                                        call writefile([commit, ''], blame_list, 'b')
                                        let blame_in = tempname()
                                        silent exe '%write' blame_in
                                        let [blame, exec_error] = s:LinesError(['-c', 'blame.coloring=none', 'blame', '--contents', blame_in, '-L', a:line1.','.a:count, '-S', blame_list, '-s', '--show-number', './' . path])
                                        if !exec_error
                                          let blame_regex = '^\^\x\+\s\+\zs\d\+\ze\s'
                                          if get(blame, 0) =~# blame_regex && get(blame, -1) =~# blame_regex
                                            let line1 = +matchstr(blame[0], blame_regex)
                                            let line2 = +matchstr(blame[-1], blame_regex)
                                          else
                                            call s:throw("Can't browse to uncommitted change")
                                          endif
                                        endif
                                      endif
                                    endif
                                  endif
                                  if empty(commit)
                                    let commit = readfile(fugitive#Find('.git/HEAD', dir), '', 1)[0]
                                  endif
                                  let i = 0
                                  while commit =~# '^ref: ' && i < 10
                                    let commit = readfile(cdir . '/' . commit[5:-1], '', 1)[0]
                                    let i -= 1
                                  endwhile
                                endif
                            
                                if empty(remote)
                                  let remote = '.'
                                endif
                                let raw = fugitive#RemoteUrl(remote)
                                if empty(raw)
                                  let raw = remote
                                endif
                            
                                if raw =~# '^https\=://' && s:executable('curl')
                                  if !has_key(s:redirects, raw)
                                    let s:redirects[raw] = matchstr(system('curl -I ' .
                                          \ s:shellesc(raw . '/info/refs?service=git-upload-pack')),
                                          \ 'Location: \zs\S\+\ze/info/refs?')
                                  endif
                                  if len(s:redirects[raw])
                                    let raw = s:redirects[raw]
                                  endif
                                endif
                            
                                let opts = {
                                      \ 'dir': dir,
                                      \ 'repo': fugitive#repo(dir),
                                      \ 'remote': raw,
                                      \ 'revision': 'No longer provided',
                                      \ 'commit': commit,
                                      \ 'path': path,
                                      \ 'type': type,
                                      \ 'line1': line1,
                                      \ 'line2': line2}
                            
                                let url = ''
                                for Handler in get(g:, 'fugitive_browse_handlers', [])
                                  let url = call(Handler, [copy(opts)])
                                  if !empty(url)
                                    break
                                  endif
                                endfor
                            
                                if empty(url)
                                  call s:throw("No Gbrowse handler installed for '".raw."'")
                                endif
                            
                                let url = s:gsub(url, '[ <>]', '\="%".printf("%02X",char2nr(submatch(0)))')
                                if a:bang
                                  if has('clipboard')
                                    let @+ = url
                                  endif
                                  return 'echomsg '.string(url)
                                elseif exists(':Browse') == 2
                                  return 'echomsg '.string(url).'|Browse '.url
                                else
                                  if !exists('g:loaded_netrw')
                                    runtime! autoload/netrw.vim
                                  endif
                                  if exists('*netrw#BrowseX')
                                    return 'echomsg '.string(url).'|call netrw#BrowseX('.string(url).', 0)'
                                  else
                                    return 'echomsg '.string(url).'|call netrw#NetrwBrowseX('.string(url).', 0)'
                                  endif
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
                            " Section: Go to file
                            
    1              0.000079 nnoremap <SID>: :<C-U><C-R>=v:count ? v:count : ''<CR>
    1              0.000003 function! fugitive#MapCfile(...) abort
                              exe 'cnoremap <buffer> <expr> <Plug><cfile>' (a:0 ? a:1 : 'fugitive#Cfile()')
                              let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|sil! exe "cunmap <buffer> <Plug><cfile>"'
                              if !exists('g:fugitive_no_maps')
                                call s:Map('n', 'gf',          '<SID>:find <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W>f',     '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W><C-F>', '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W>gf',  '<SID>:tabfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('c', '<C-R><C-F>', '<Plug><cfile>', '<silent><unique>', 1)
                              endif
                            endfunction
                            
    1              0.000004 function! s:ContainingCommit() abort
                              let commit = s:Owner(@%)
                              return empty(commit) ? 'HEAD' : commit
                            endfunction
                            
    1              0.000003 function! s:SquashArgument(...) abort
                              if &filetype == 'fugitive'
                                let commit = matchstr(getline('.'), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\{4,\}\ze ')
                              elseif has_key(s:temp_files, s:cpath(expand('%:p')))
                                let commit = matchstr(getline('.'), '\<\x\{4,\}\>')
                              else
                                let commit = s:Owner(@%)
                              endif
                              return len(commit) && a:0 ? printf(a:1, commit) : commit
                            endfunction
                            
    1              0.000003 function! s:RebaseArgument() abort
                              return s:SquashArgument(' %s^')
                            endfunction
                            
    1              0.000003 function! s:NavigateUp(count) abort
                              let rev = substitute(s:DirRev(@%)[1], '^$', ':', 'g')
                              let c = a:count
                              while c
                                if rev =~# ':.*/.'
                                  let rev = matchstr(rev, '.*\ze/.\+', '')
                                elseif rev =~# '.:.'
                                  let rev = matchstr(rev, '^.[^:]*:')
                                elseif rev =~# '^:'
                                  let rev = 'HEAD^{}'
                                elseif rev =~# ':$'
                                  let rev = rev[0:-2]
                                else
                                  return rev.'~'.c
                                endif
                                let c -= 1
                              endwhile
                              return rev
                            endfunction
                            
    1              0.000004 function! s:MapMotion(lhs, rhs) abort
                              call s:Map('n', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>")
                              call s:Map('o', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>")
                              call s:Map('x', a:lhs, ":<C-U>exe 'normal! gv'<Bar>" . a:rhs . "<CR>", "<silent>")
                            endfunction
                            
    1              0.000003 function! fugitive#MapJumps(...) abort
                              if !&modifiable
                                if get(b:, 'fugitive_type', '') ==# 'blob'
                                  let blame_map = 'Gblame<C-R>=v:count ? " --reverse" : ""<CR><CR>'
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>0,2' . blame_map, '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>0,3' . blame_map, '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>0,4' . blame_map, '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>0,5' . blame_map, '<silent>')
                            
                                  call s:Map('n', 'D',  ":<C-U>call <SID>DiffClose()<Bar>Gdiffsplit!<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
                                  call s:Map('n', 'dd', ":<C-U>call <SID>DiffClose()<Bar>Gdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dh', ":<C-U>call <SID>DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'ds', ":<C-U>call <SID>DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dv', ":<C-U>call <SID>DiffClose()<Bar>Gvdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
                            
                                else
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>exe <SID>GF("split")<CR>', '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>exe <SID>GF("vsplit")<CR>', '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>exe <SID>GF("tabedit")<CR>', '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>exe <SID>GF("pedit")<CR>', '<silent>')
                            
                                  if !exists('g:fugitive_no_maps')
                                    if exists(':CtrlP') && get(g:, 'ctrl_p_map') =~? '^<c-p>$'
                                      nnoremap <buffer> <silent> <C-P> :<C-U>execute line('.') == 1 ? 'CtrlP ' . fnameescape(<SID>Tree()) : <SID>PreviousItem(v:count1)<CR>
                                    else
                                      nnoremap <buffer> <silent> <C-P> :<C-U>execute <SID>PreviousItem(v:count1)<CR>
                                    endif
                                    nnoremap <buffer> <silent> <C-N> :<C-U>execute <SID>NextItem(v:count1)<CR>
                                  endif
                                  call s:MapMotion('(', 'exe <SID>PreviousItem(v:count1)')
                                  call s:MapMotion(')', 'exe <SID>NextItem(v:count1)')
                                  call s:MapMotion('K', 'exe <SID>PreviousHunk(v:count1)')
                                  call s:MapMotion('J', 'exe <SID>NextHunk(v:count1)')
                                  call s:MapMotion('[c', 'exe <SID>PreviousHunk(v:count1)')
                                  call s:MapMotion(']c', 'exe <SID>NextHunk(v:count1)')
                                  call s:MapMotion('[/', 'exe <SID>PreviousFile(v:count1)')
                                  call s:MapMotion(']/', 'exe <SID>NextFile(v:count1)')
                                  call s:MapMotion('[m', 'exe <SID>PreviousFile(v:count1)')
                                  call s:MapMotion(']m', 'exe <SID>NextFile(v:count1)')
                                  call s:MapMotion('[[', 'exe <SID>PreviousSection(v:count1)')
                                  call s:MapMotion(']]', 'exe <SID>NextSection(v:count1)')
                                  call s:MapMotion('[]', 'exe <SID>PreviousSectionEnd(v:count1)')
                                  call s:MapMotion('][', 'exe <SID>NextSectionEnd(v:count1)')
                                  call s:Map('nxo', '*', '<SID>PatchSearchExpr(0)', '<expr>')
                                  call s:Map('nxo', '#', '<SID>PatchSearchExpr(1)', '<expr>')
                                endif
                                call s:Map('n', 'S',    ':<C-U>echoerr "Use gO"<CR>', '<silent>')
                                call s:Map('n', 'dq', ":<C-U>call <SID>DiffClose()<CR>", '<silent>')
                                call s:Map('n', '-', ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>NavigateUp(v:count1))<Bar> if getline(1) =~# '^tree \x\{40,\}$' && empty(getline(2))<Bar>call search('^'.escape(expand('#:t'),'.*[]~\').'/\=$','wc')<Bar>endif<CR>", '<silent>')
                                call s:Map('n', 'P',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'^'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
                                call s:Map('n', '~',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'~'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
                                call s:Map('n', 'C',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'cp',    ":<C-U>echoerr 'Use gC'<CR>", '<silent>')
                                call s:Map('n', 'gC',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'gc',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
                                call s:Map('x', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
                            
                                nnoremap <buffer>       c<Space> :Git commit<Space>
                                nnoremap <buffer>          c<CR> :Git commit<CR>
                                nnoremap <buffer>      cv<Space> :Git commit -v<Space>
                                nnoremap <buffer>         cv<CR> :Git commit -v<CR>
                                nnoremap <buffer> <silent> ca    :<C-U>Gcommit --amend<CR>
                                nnoremap <buffer> <silent> cc    :<C-U>Gcommit<CR>
                                nnoremap <buffer> <silent> ce    :<C-U>Gcommit --amend --no-edit<CR>
                                nnoremap <buffer> <silent> cw    :<C-U>Gcommit --amend --only<CR>
                                nnoremap <buffer> <silent> cva   :<C-U>Gcommit -v --amend<CR>
                                nnoremap <buffer> <silent> cvc   :<C-U>Gcommit -v<CR>
                                nnoremap <buffer> <silent> cRa   :<C-U>Gcommit --reset-author --amend<CR>
                                nnoremap <buffer> <silent> cRe   :<C-U>Gcommit --reset-author --amend --no-edit<CR>
                                nnoremap <buffer> <silent> cRw   :<C-U>Gcommit --reset-author --amend --only<CR>
                                nnoremap <buffer>          cf    :<C-U>Gcommit --fixup=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cF    :<C-U><Bar>Grebase --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Gcommit --fixup=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cs    :<C-U>Gcommit --squash=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cS    :<C-U><Bar>Grebase --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Gcommit --squash=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cA    :<C-U>Gcommit --edit --squash=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer> <silent> c?    :<C-U>help fugitive_c<CR>
                            
                                nnoremap <buffer>      cr<Space> :Git revert<Space>
                                nnoremap <buffer>         cr<CR> :Git revert<CR>
                                nnoremap <buffer> <silent> crc   :<C-U>Grevert <C-R>=<SID>SquashArgument()<CR><CR>
                                nnoremap <buffer> <silent> crn   :<C-U>Grevert --no-commit <C-R>=<SID>SquashArgument()<CR><CR>
                                nnoremap <buffer> <silent> cr?   :help fugitive_cr<CR>
                            
                                nnoremap <buffer>      cm<Space> :Git merge<Space>
                                nnoremap <buffer>         cm<CR> :Git merge<CR>
                                nnoremap <buffer> <silent> cm?   :help fugitive_cm<CR>
                            
                                nnoremap <buffer>      cz<Space> :Git stash<Space>
                                nnoremap <buffer>         cz<CR> :Git stash<CR>
                                nnoremap <buffer> <silent> cza   :<C-U>exe <SID>EchoExec(['stash', 'apply', '--quiet', '--index', 'stash@{' . v:count . '}'])<CR>
                                nnoremap <buffer> <silent> czA   :<C-U>exe <SID>EchoExec(['stash', 'apply', '--quiet', 'stash@{' . v:count . '}'])<CR>
                                nnoremap <buffer> <silent> czp   :<C-U>exe <SID>EchoExec(['stash', 'pop', '--quiet', '--index', 'stash@{' . v:count . '}'])<CR>
                                nnoremap <buffer> <silent> czP   :<C-U>exe <SID>EchoExec(['stash', 'pop', '--quiet', 'stash@{' . v:count . '}'])<CR>
                                nnoremap <buffer> <silent> czv   :<C-U>exe 'Gedit' fugitive#RevParse('stash@{' . v:count . '}')<CR>
                                nnoremap <buffer> <silent> czw   :<C-U>exe <SID>EchoExec(['stash', '--keep-index'] + (v:count > 1 ? ['--all'] : v:count ? ['--include-untracked'] : []))<CR>
                                nnoremap <buffer> <silent> czz   :<C-U>exe <SID>EchoExec(['stash'] + (v:count > 1 ? ['--all'] : v:count ? ['--include-untracked'] : []))<CR>
                                nnoremap <buffer> <silent> cz?   :<C-U>help fugitive_cz<CR>
                            
                                nnoremap <buffer>      co<Space> :Git checkout<Space>
                                nnoremap <buffer>         co<CR> :Git checkout<CR>
                                nnoremap <buffer>          coo   :exe <SID>EchoExec(['checkout'] + split(<SID>SquashArgument()) + ['--'])<CR>
                                nnoremap <buffer>          co?   :<C-U>help fugitive_co<CR>
                            
                                nnoremap <buffer>      cb<Space> :Git branch<Space>
                                nnoremap <buffer>         cb<CR> :Git branch<CR>
                                nnoremap <buffer>         cb?    :<C-U>help fugitive_cb<CR>
                            
                                nnoremap <buffer>       r<Space> :Git rebase<Space>
                                nnoremap <buffer>          r<CR> :Git rebase<CR>
                                nnoremap <buffer> <silent> ri    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><CR>
                                nnoremap <buffer> <silent> rf    :<C-U>Grebase --autosquash<C-R>=<SID>RebaseArgument()<CR><CR>
                                nnoremap <buffer> <silent> ru    :<C-U>Grebase --interactive @{upstream}<CR>
                                nnoremap <buffer> <silent> rp    :<C-U>Grebase --interactive @{push}<CR>
                                nnoremap <buffer> <silent> rw    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/reword/e<CR>
                                nnoremap <buffer> <silent> rm    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/edit/e<CR>
                                nnoremap <buffer> <silent> rd    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>
                                nnoremap <buffer> <silent> rk    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>
                                nnoremap <buffer> <silent> rx    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>
                                nnoremap <buffer> <silent> rr    :<C-U>Grebase --continue<CR>
                                nnoremap <buffer> <silent> rs    :<C-U>Grebase --skip<CR>
                                nnoremap <buffer> <silent> re    :<C-U>Grebase --edit-todo<CR>
                                nnoremap <buffer> <silent> ra    :<C-U>Grebase --abort<CR>
                                nnoremap <buffer> <silent> r?    :<C-U>help fugitive_r<CR>
                            
                                call s:Map('n', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
                                call s:Map('x', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
                                call s:Map('n', 'g?',    ":<C-U>help fugitive-map<CR>", '<silent>')
                                call s:Map('n', '<F1>',  ":<C-U>help fugitive-map<CR>", '<silent>')
                              endif
                            endfunction
                            
    1              0.000007 function! s:StatusCfile(...) abort
                              let tree = s:Tree()
                              let lead = s:cpath(tree, getcwd()) ? './' : tree . '/'
                              let info = s:StageInfo()
                              let line = getline('.')
                              if len(info.sigil) && len(info.section) && len(info.paths)
                                if info.section ==# 'Unstaged' && info.sigil !=# '-'
                                  return [lead . info.relative[0], info.offset, 'normal!zv']
                                elseif info.section ==# 'Staged' && info.sigil ==# '-'
                                  return ['@:' . info.relative[0], info.offset, 'normal!zv']
                                else
                                  return [':0:' . info.relative[0], info.offset, 'normal!zv']
                                endif
                              elseif len(info.paths)
                                return [lead . info.relative[0]]
                              elseif len(info.commit)
                                return [info.commit]
                              elseif line =~# '^\%(Head\|Merge\|Rebase\|Upstream\|Pull\|Push\): '
                                return [matchstr(line, ' \zs.*')]
                              else
                                return ['']
                              endif
                            endfunction
                            
    1              0.000004 function! fugitive#StatusCfile() abort
                              let file = s:Generate(s:StatusCfile()[0])
                              return empty(file) ? fugitive#Cfile() : s:fnameescape(file)
                            endfunction
                            
    1              0.000003 function! s:MessageCfile(...) abort
                              let tree = s:Tree()
                              let lead = s:cpath(tree, getcwd()) ? './' : tree . '/'
                              if getline('.') =~# '^.\=\trenamed:.* -> '
                                return lead . matchstr(getline('.'),' -> \zs.*')
                              elseif getline('.') =~# '^.\=\t\(\k\| \)\+\p\?: *.'
                                return lead . matchstr(getline('.'),': *\zs.\{-\}\ze\%( ([^()[:digit:]]\+)\)\=$')
                              elseif getline('.') =~# '^.\=\t.'
                                return lead . matchstr(getline('.'),'\t\zs.*')
                              elseif getline('.') =~# ': needs merge$'
                                return lead . matchstr(getline('.'),'.*\ze: needs merge$')
                              elseif getline('.') =~# '^\%(. \)\=Not currently on any branch.$'
                                return 'HEAD'
                              elseif getline('.') =~# '^\%(. \)\=On branch '
                                return 'refs/heads/'.getline('.')[12:]
                              elseif getline('.') =~# "^\\%(. \\)\=Your branch .*'"
                                return matchstr(getline('.'),"'\\zs\\S\\+\\ze'")
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#MessageCfile() abort
                              let file = s:Generate(s:MessageCfile())
                              return empty(file) ? fugitive#Cfile() : s:fnameescape(file)
                            endfunction
                            
    1              0.000002 function! s:cfile() abort
                              try
                                let myhash = s:DirRev(@%)[1]
                                if len(myhash)
                                  try
                                    let myhash = fugitive#RevParse(myhash)
                                  catch /^fugitive:/
                                    let myhash = ''
                                  endtry
                                endif
                                if empty(myhash) && getline(1) =~# '^\%(commit\|tag\) \w'
                                  let myhash = matchstr(getline(1),'^\w\+ \zs\S\+')
                                endif
                            
                                let showtree = (getline(1) =~# '^tree ' && getline(2) == "")
                            
                                let treebase = substitute(s:DirCommitFile(@%)[1], '^\d$', ':&', '') . ':' .
                                      \ s:Relative('') . (s:Relative('') =~# '^$\|/$' ? '' : '/')
                            
                                if getline('.') =~# '^\d\{6\} \l\{3,8\} \x\{40,\}\t'
                                  return [treebase . s:sub(matchstr(getline('.'),'\t\zs.*'),'/$','')]
                                elseif showtree
                                  return [treebase . s:sub(getline('.'),'/$','')]
                            
                                else
                            
                                  let dcmds = []
                            
                                  " Index
                                  if getline('.') =~# '^\d\{6\} \x\{40,\} \d\t'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let file = ':'.s:sub(matchstr(getline('.'),'\d\t.*'),'\t',':')
                                    return [file]
                                  endif
                            
                                  if getline('.') =~# '^ref: '
                                    let ref = strpart(getline('.'),5)
                            
                                  elseif getline('.') =~# '^commit \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    return [ref]
                            
                                  elseif getline('.') =~# '^parent \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let line = line('.')
                                    let parent = 0
                                    while getline(line) =~# '^parent '
                                      let parent += 1
                                      let line -= 1
                                    endwhile
                                    return [ref]
                            
                                  elseif getline('.') =~# '^tree \x\{40,\}$'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    if len(myhash) && fugitive#RevParse(myhash.':') ==# ref
                                      let ref = myhash.':'
                                    endif
                                    return [ref]
                            
                                  elseif getline('.') =~# '^object \x\{40,\}$' && getline(line('.')+1) =~ '^type \%(commit\|tree\|blob\)$'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let type = matchstr(getline(line('.')+1),'type \zs.*')
                            
                                  elseif getline('.') =~# '^\l\{3,8\} '.myhash.'$'
                                    let ref = s:DirRev(@%)[1]
                            
                                  elseif getline('.') =~# '^\l\{3,8\} \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    echoerr "warning: unknown context ".matchstr(getline('.'),'^\l*')
                            
                                  elseif getline('.') =~# '^[+-]\{3\} [abciow12]\=/'
                                    let ref = getline('.')[4:]
                            
                                  elseif getline('.') =~# '^[+-]' && search('^@@ -\d\+\%(,\d\+\)\= +\d\+','bnW')
                                    let type = getline('.')[0]
                                    let lnum = line('.') - 1
                                    let offset = 0
                                    while getline(lnum) !~# '^@@ -\d\+\%(,\d\+\)\= +\d\+'
                                      if getline(lnum) =~# '^[ '.type.']'
                                        let offset += 1
                                      endif
                                      let lnum -= 1
                                    endwhile
                                    let offset += matchstr(getline(lnum), type.'\zs\d\+')
                                    let ref = getline(search('^'.type.'\{3\} [abciow12]/','bnW'))[4:-1]
                                    let dcmds = [offset, 'normal!zv']
                            
                                  elseif getline('.') =~# '^rename from '
                                    let ref = 'a/'.getline('.')[12:]
                                  elseif getline('.') =~# '^rename to '
                                    let ref = 'b/'.getline('.')[10:]
                            
                                  elseif getline('.') =~# '^@@ -\d\+\%(,\d\+\)\= +\d\+'
                                    let diff = getline(search('^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)', 'bcnW'))
                                    let offset = matchstr(getline('.'), '+\zs\d\+')
                            
                                    let dref = matchstr(diff, '\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(diff, '\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit! +'.offset
                            
                                  elseif getline('.') =~# '^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)'
                                    let dref = matchstr(getline('.'),'\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(getline('.'),'\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit!'
                            
                                  elseif getline('.') =~# '^index ' && getline(line('.')-1) =~# '^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)'
                                    let line = getline(line('.')-1)
                                    let dref = matchstr(line,'\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(line,'\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit!'
                            
                                  elseif line('$') == 1 && getline('.') =~ '^\x\{40,\}$'
                                    let ref = getline('.')
                            
                                  elseif expand('<cword>') =~# '^\x\{7,\}\>'
                                    return [expand('<cword>')]
                            
                                  else
                                    let ref = ''
                                  endif
                            
                                  let prefixes = {
                                        \ '1': '',
                                        \ '2': '',
                                        \ 'b': ':0:',
                                        \ 'i': ':0:',
                                        \ 'o': '',
                                        \ 'w': ''}
                            
                                  if len(myhash)
                                    let prefixes.a = myhash.'^:'
                                    let prefixes.b = myhash.':'
                                  endif
                                  let ref = substitute(ref, '^\(\w\)/', '\=get(prefixes, submatch(1), "HEAD:")', '')
                                  if exists('dref')
                                    let dref = substitute(dref, '^\(\w\)/', '\=get(prefixes, submatch(1), "HEAD:")', '')
                                  endif
                            
                                  if ref ==# '/dev/null'
                                    " Empty blob
                                    let ref = 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'
                                  endif
                            
                                  if exists('dref')
                                    return [ref, dcmd . ' ' . s:fnameescape(dref)] + dcmds
                                  elseif ref != ""
                                    return [ref] + dcmds
                                  endif
                            
                                endif
                                return []
                              endtry
                            endfunction
                            
    1              0.000004 function! s:GF(mode) abort
                              try
                                let results = &filetype ==# 'fugitive' ? s:StatusCfile() : &filetype ==# 'gitcommit' ? [s:MessageCfile()] : s:cfile()
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if len(results) > 1
                                return 'G' . a:mode .
                                      \ ' +' . escape(results[1], ' ') . ' ' .
                                      \ s:fnameescape(results[0]) . join(map(results[2:-1], '"|" . v:val'), '')
                              elseif len(results) && len(results[0])
                                return 'G' . a:mode . ' ' . s:fnameescape(results[0])
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#Cfile() abort
                              let pre = ''
                              let results = s:cfile()
                              if empty(results)
                                let cfile = expand('<cfile>')
                                if &includeexpr =~# '\<v:fname\>'
                                  sandbox let cfile = eval(substitute(&includeexpr, '\C\<v:fname\>', '\=string(cfile)', 'g'))
                                endif
                                return cfile
                              elseif len(results) > 1
                                let pre = '+' . join(map(results[1:-1], 'escape(v:val, " ")'), '\|') . ' '
                              endif
                              return pre . s:fnameescape(s:Generate(results[0]))
                            endfunction
                            
                            " Section: Statusline
                            
    1              0.000003 function! fugitive#Statusline(...) abort
                              let dir = s:Dir(bufnr(''))
                              if empty(dir)
                                return ''
                              endif
                              let status = ''
                              let commit = s:DirCommitFile(@%)[1]
                              if len(commit)
                                let status .= ':' . commit[0:6]
                              endif
                              let status .= '('.FugitiveHead(7, dir).')'
                              return '[Git'.status.']'
                            endfunction
                            
    1              0.000003 function! fugitive#statusline(...) abort
                              return fugitive#Statusline()
                            endfunction
                            
    1              0.000003 function! fugitive#head(...) abort
                              if empty(s:Dir())
                                return ''
                              endif
                            
                              return fugitive#Head(a:0 ? a:1 : 0)
                            endfunction
                            
                            " Section: Folding
                            
    1              0.000002 function! fugitive#Foldtext() abort
                              if &foldmethod !=# 'syntax'
                                return foldtext()
                              endif
                            
                              let line_foldstart = getline(v:foldstart)
                              if line_foldstart =~# '^diff '
                                let [add, remove] = [-1, -1]
                                let filename = ''
                                for lnum in range(v:foldstart, v:foldend)
                                  let line = getline(lnum)
                                  if filename ==# '' && line =~# '^[+-]\{3\} [abciow12]/'
                                    let filename = line[6:-1]
                                  endif
                                  if line =~# '^+'
                                    let add += 1
                                  elseif line =~# '^-'
                                    let remove += 1
                                  elseif line =~# '^Binary '
                                    let binary = 1
                                  endif
                                endfor
                                if filename ==# ''
                                  let filename = matchstr(line_foldstart, '^diff .\{-\} [abciow12]/\zs.*\ze [abciow12]/')
                                endif
                                if filename ==# ''
                                  let filename = line_foldstart[5:-1]
                                endif
                                if exists('binary')
                                  return 'Binary: '.filename
                                else
                                  return (add<10&&remove<100?' ':'') . add . '+ ' . (remove<10&&add<100?' ':'') . remove . '- ' . filename
                                endif
                              elseif line_foldstart =~# '^# .*:$'
                                let lines = getline(v:foldstart, v:foldend)
                                call filter(lines, 'v:val =~# "^#\t"')
                                cal map(lines, "s:sub(v:val, '^#\t%(modified: +|renamed: +)=', '')")
                                cal map(lines, "s:sub(v:val, '^([[:alpha:] ]+): +(.*)', '\\2 (\\1)')")
                                return line_foldstart.' '.join(lines, ', ')
                              endif
                              return foldtext()
                            endfunction
                            
    1              0.000003 function! fugitive#foldtext() abort
                              return fugitive#Foldtext()
                            endfunction
                            
    1              0.000004 augroup fugitive_folding
    1              0.000080   autocmd!
    1              0.000015   autocmd User Fugitive
                                    \ if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |
                                    \    set foldtext=fugitive#Foldtext() |
                                    \ endif
    1              0.000003 augroup END
                            
                            " Section: Initialization
                            
    1              0.000003 function! fugitive#Init() abort
                              if exists('#User#FugitiveBoot')
                                try
                                  let [save_mls, &modelines] = [&mls, 0]
                                  doautocmd User FugitiveBoot
                                finally
                                  let &mls = save_mls
                                endtry
                              endif
                              let dir = s:Dir()
                              if stridx(&tags, escape(dir, ', ')) == -1 && &tags !~# '\.git' && !exists('s:tags_warning')
                                let actualdir = fugitive#Find('.git/', dir)
                                if filereadable(actualdir . 'tags')
                                  let s:tags_warning = 1
                                  echohl WarningMsg
                                  echo "Fugitive .git/tags support removed in favor of `:set tags^=./.git/tags;`"
                                  echohl NONE
                                endif
                              endif
                              try
                                let [save_mls, &modelines] = [&mls, 0]
                                call s:define_commands()
                                doautocmd User Fugitive
                              finally
                                let &mls = save_mls
                              endtry
                            endfunction
                            
    1              0.000003 function! fugitive#is_git_dir(path) abort
                              return FugitiveIsGitDir(a:path)
                            endfunction
                            
    1              0.000002 function! fugitive#extract_git_dir(path) abort
                              return FugitiveExtractGitDir(a:path)
                            endfunction
                            
    1              0.000003 function! fugitive#detect(path) abort
                              return FugitiveDetect(a:path)
                            endfunction
                            
                            " Section: End

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/guru.vim
Sourced 1 time
Total time:   0.000971
 Self time:   0.000971

count  total (s)   self (s)
                            "  guru.vim -- Vim integration for the Go guru.
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000013 let s:cpo_save = &cpo
    1              0.000013 set cpo&vim
                            
                            " guru_cmd returns a dict that contains the command to execute guru. args
                            " is dict with following options:
                            "  mode        : guru mode, such as 'implements'
                            "  format      : output format, either 'plain' or 'json'
                            "  needs_scope : if 1, adds the current package to the scope
                            "  selected    : if 1, means it's a range of selection, otherwise it picks up the
                            "                offset under the cursor
                            " example output:
                            "  {'cmd' : ['guru', '-json', 'implements', 'demo/demo.go:#66']}
    1              0.000006 function! s:guru_cmd(args) range abort
                              let mode = a:args.mode
                              let format = a:args.format
                              let needs_scope = a:args.needs_scope
                              let selected = a:args.selected
                              let postype = get(a:args, 'postype', 'cursor')
                            
                              let result = {}
                            
                              "return with a warning if the binary doesn't exist
                              let bin_path = go#path#CheckBinPath("guru")
                              if empty(bin_path)
                                return {'err': "bin path not found"}
                              endif
                            
                              " start constructing the command
                              let cmd = [bin_path, '-tags', go#config#BuildTags()]
                            
                              if &modified
                                let result.stdin_content = go#util#archive()
                                call add(cmd, "-modified")
                              endif
                            
                              " enable outputting in json format
                              if format == "json"
                                call add(cmd, "-json")
                              endif
                            
                              let scopes = go#config#GuruScope()
                              if empty(scopes)
                                " some modes require scope to be defined (such as callers). For these we
                                " choose a sensible setting, which is using the current file's package
                                if needs_scope
                                  let pkg = go#package#ImportPath()
                                  if pkg == -1
                                    return {'err': "current directory is not inside of a valid GOPATH"}
                                  endif
                                  let scopes = [pkg]
                                endif
                              endif
                            
                              " Add the scope.
                              if !empty(scopes)
                                " guru expect a comma-separated list of patterns.
                                let l:scope = join(scopes, ",")
                                let result.scope = l:scope
                                call extend(cmd, ["-scope", l:scope])
                              endif
                            
                              if postype == 'balloon'
                                let pos = printf("#%s", go#util#Offset(v:beval_lnum, v:beval_col))
                              else
                                let pos = printf("#%s", go#util#OffsetCursor())
                                if selected != -1
                                  " means we have a range, get it
                                  let pos1 = go#util#Offset(line("'<"), col("'<"))
                                  let pos2 = go#util#Offset(line("'>"), col("'>"))
                                  let pos = printf("#%s,#%s", pos1, pos2)
                                endif
                              endif
                            
                              let l:filename = fnamemodify(expand("%"), ':p:gs?\\?/?') . ':' . pos
                              call extend(cmd, [mode, l:filename])
                            
                              let result.cmd = cmd
                              return result
                            endfunction
                            
                            " sync_guru runs guru in sync mode with the given arguments
    1              0.000004 function! s:sync_guru(args) abort
                              let result = s:guru_cmd(a:args)
                              if has_key(result, 'err')
                                call go#util#EchoError(result.err)
                                return -1
                              endif
                            
                              if !has_key(a:args, 'disable_progress')
                                if a:args.needs_scope
                                  call go#util#EchoProgress("analysing with scope ". result.scope .
                                        \ " (see ':help go-guru-scope' if this doesn't work)...")
                                elseif a:args.mode !=# 'what'
                                  " the query might take time, let us give some feedback
                                  call go#util#EchoProgress("analysing ...")
                                endif
                              endif
                            
                              " run, forrest run!!!
                              if has_key(l:result, 'stdin_content')
                                let [l:out, l:err] = go#util#Exec(l:result.cmd, l:result.stdin_content)
                              else
                                let [l:out, l:err] = go#util#Exec(l:result.cmd)
                              endif
                            
                              if has_key(a:args, 'custom_parse')
                                call a:args.custom_parse(l:err, l:out, a:args.mode)
                              else
                                call s:parse_guru_output(l:err, l:out, a:args.mode)
                              endif
                            
                              return l:out
                            endfunc
                            
                            " async_guru runs guru in async mode with the given arguments
    1              0.000004 function! s:async_guru(args) abort
                              let result = s:guru_cmd(a:args)
                              if has_key(result, 'err')
                                call go#util#EchoError(result.err)
                                return
                              endif
                            
                              let state = {
                                    \ 'mode': a:args.mode,
                                    \ 'parse' : get(a:args, 'custom_parse', funcref("s:parse_guru_output"))
                                  \ }
                            
                              " explicitly bind complete to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
                              let state.complete = function('s:complete', [], state)
                            
                              let opts = {
                                    \ 'statustype': get(a:args, 'statustype', a:args.mode),
                                    \ 'for': '_',
                                    \ 'errorformat': "%f:%l.%c-%[%^:]%#:\ %m,%f:%l:%c:\ %m",
                                    \ 'complete': state.complete,
                                    \ }
                            
                              if has_key(a:args, 'disable_progress')
                                let opts.statustype = ''
                              endif
                            
                              let opts = go#job#Options(l:opts)
                            
                              if has_key(result, 'stdin_content')
                                let l:tmpname = tempname()
                                call writefile(split(result.stdin_content, "\n"), l:tmpname, "b")
                                let l:opts.in_io = "file"
                                let l:opts.in_name = l:tmpname
                              endif
                            
                              call go#job#Start(result.cmd, opts)
                            
                              if a:args.needs_scope && go#config#EchoCommandInfo() && !has_key(a:args, 'disable_progress')
                                call go#util#EchoProgress("analysing with scope " . result.scope .
                                      \ " (see ':help go-guru-scope' if this doesn't work)...")
                              endif
                            endfunc
                            
    1              0.000005 function! s:complete(job, exit_status, messages) dict abort
                              let output = join(a:messages, "\n")
                              call self.parse(a:exit_status, output, self.mode)
                            endfunction
                            
                            " run_guru runs the given guru argument
    1              0.000003 function! s:run_guru(args) abort
                              if go#util#has_job()
                                let res = s:async_guru(a:args)
                              else
                                let res = s:sync_guru(a:args)
                              endif
                            
                              return res
                            endfunction
                            
                            " Show 'implements' relation for selected package
    1              0.000003 function! go#guru#Implements(selected) abort
                              let args = {
                                    \ 'mode': 'implements',
                                    \ 'format': 'plain',
                                    \ 'selected': a:selected,
                                    \ 'needs_scope': 1,
                                    \ }
                            
                              call s:run_guru(args)
                            endfunction
                            
                            " Shows the set of possible objects to which a pointer may point.
    1              0.000003 function! go#guru#PointsTo(selected) abort
                              let l:args = {
                                    \ 'mode': 'pointsto',
                                    \ 'format': 'plain',
                                    \ 'selected': a:selected,
                                    \ 'needs_scope': 1,
                                    \ }
                            
                              call s:run_guru(l:args)
                            endfunction
                            
                            " Report the possible constants, global variables, and concrete types that may
                            " appear in a value of type error
    1              0.000003 function! go#guru#Whicherrs(selected) abort
                              let args = {
                                    \ 'mode': 'whicherrs',
                                    \ 'format': 'plain',
                                    \ 'selected': a:selected,
                                    \ 'needs_scope': 1,
                                    \ }
                            
                            
                              " TODO(arslan): handle empty case for both sync/async
                              " if empty(out.out)
                              "   call go#util#EchoSuccess("no error variables found. Try to change the scope with :GoGuruScope")
                              "   return
                              " endif
                              call s:run_guru(args)
                            endfunction
                            
                            " Describe selected syntax: definition, methods, etc
    1              0.000002 function! go#guru#Describe(selected) abort
                              let args = {
                                    \ 'mode': 'describe',
                                    \ 'format': 'plain',
                                    \ 'selected': a:selected,
                                    \ 'needs_scope': 1,
                                    \ }
                            
                              call s:run_guru(args)
                            endfunction
                            
    1              0.000002 function! go#guru#DescribeInfo(showstatus) abort
                              " json_encode() and friends are introduced with this patch (7.4.1304)
                              " vim: https://groups.google.com/d/msg/vim_dev/vLupTNhQhZ8/cDGIk0JEDgAJ
                              " nvim: https://github.com/neovim/neovim/pull/4131
                              if !exists("*json_decode")
                                call go#util#EchoError("requires 'json_decode'. Update your Vim/Neovim version.")
                                return
                              endif
                            
                              let args = {
                                    \ 'mode': 'describe',
                                    \ 'format': 'json',
                                    \ 'selected': -1,
                                    \ 'needs_scope': 0,
                                    \ 'custom_parse': function('s:info'),
                                    \ 'disable_progress': a:showstatus == 0,
                                    \ }
                            
                              call s:run_guru(args)
                            endfunction
                            
    1              0.000004 function! s:info(exit_val, output, mode)
                              if a:exit_val != 0
                                return
                              endif
                            
                              if a:output[0] !=# '{'
                                return
                              endif
                            
                              if empty(a:output) || type(a:output) != type("")
                                return
                              endif
                            
                              let result = json_decode(a:output)
                              if type(result) != type({})
                                call go#util#EchoError(printf("malformed output from guru: %s", a:output))
                                return
                              endif
                            
                              if !has_key(result, 'detail')
                                " if there is no detail check if there is a description and print it
                                if has_key(result, "desc")
                                  call go#util#EchoInfo(result["desc"])
                                  return
                                endif
                            
                                call go#util#EchoError("detail key is missing. Please open a bug report on vim-go repo.")
                                return
                              endif
                            
                              let detail = result['detail']
                              let info = ""
                            
                              " guru gives different information based on the detail mode. Let try to
                              " extract the most useful information
                            
                              if detail == "value"
                                if !has_key(result, 'value')
                                  call go#util#EchoError("value key is missing. Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let val = result["value"]
                                if !has_key(val, 'type')
                                  call go#util#EchoError("type key is missing (value.type). Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let info = val["type"]
                              elseif detail == "type"
                                if !has_key(result, 'type')
                                  call go#util#EchoError("type key is missing. Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let type = result["type"]
                                if !has_key(type, 'type')
                                  call go#util#EchoError("type key is missing (type.type). Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let info = type["type"]
                              elseif detail == "package"
                                if !has_key(result, 'package')
                                  call go#util#EchoError("package key is missing. Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let package = result["package"]
                                if !has_key(package, 'path')
                                  call go#util#EchoError("path key is missing (package.path). Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let info = printf("package %s", package["path"])
                              elseif detail == "unknown"
                                let info = result["desc"]
                              else
                                call go#util#EchoError(printf("unknown detail mode found '%s'. Please open a bug report on vim-go repo", detail))
                                return
                              endif
                            
                              call go#util#ShowInfo(info)
                            endfunction
                            
                            " Show possible targets of selected function call
    1              0.000002 function! go#guru#Callees(selected) abort
                              let args = {
                                    \ 'mode': 'callees',
                                    \ 'format': 'plain',
                                    \ 'selected': a:selected,
                                    \ 'needs_scope': 1,
                                    \ }
                            
                              call s:run_guru(args)
                            endfunction
                            
                            " Show possible callers of selected function
    1              0.000002 function! go#guru#Callers(selected) abort
                              let args = {
                                    \ 'mode': 'callers',
                                    \ 'format': 'plain',
                                    \ 'selected': a:selected,
                                    \ 'needs_scope': 1,
                                    \ }
                            
                              call s:run_guru(args)
                            endfunction
                            
                            " Show path from callgraph root to selected function
    1              0.000002 function! go#guru#Callstack(selected) abort
                              let args = {
                                    \ 'mode': 'callstack',
                                    \ 'format': 'plain',
                                    \ 'selected': a:selected,
                                    \ 'needs_scope': 1,
                                    \ }
                            
                              call s:run_guru(args)
                            endfunction
                            
                            " Show free variables of selection
    1              0.000002 function! go#guru#Freevars(selected) abort
                              " Freevars requires a selection
                              if a:selected == -1
                                call go#util#EchoError("GoFreevars requires a selection (range) of code")
                                return
                              endif
                            
                              let args = {
                                    \ 'mode': 'freevars',
                                    \ 'format': 'plain',
                                    \ 'selected': 1,
                                    \ 'needs_scope': 0,
                                    \ }
                            
                              call s:run_guru(args)
                            endfunction
                            
                            " Show send/receive corresponding to selected channel op
    1              0.000004 function! go#guru#ChannelPeers(selected) abort
                              let args = {
                                    \ 'mode': 'peers',
                                    \ 'format': 'plain',
                                    \ 'selected': a:selected,
                                    \ 'needs_scope': 1,
                                    \ }
                            
                              call s:run_guru(args)
                            endfunction
                            
                            " Show all refs to entity denoted by selected identifier
    1              0.000002 function! go#guru#Referrers(selected) abort
                              let args = {
                                    \ 'mode': 'referrers',
                                    \ 'format': 'plain',
                                    \ 'selected': a:selected,
                                    \ 'needs_scope': 0,
                                    \ }
                            
                              call s:run_guru(args)
                            endfunction
                            
    1              0.000002 function! go#guru#SameIds(showstatus) abort
                              " we use matchaddpos() which was introduce with 7.4.330, be sure we have
                              " it: http://ftp.vim.org/vim/patches/7.4/7.4.330
                              if !exists("*matchaddpos")
                                call go#util#EchoError("GoSameIds requires 'matchaddpos'. Update your Vim/Neovim version.")
                                return
                              endif
                            
                              " json_encode() and friends are introduced with this patch (7.4.1304)
                              " vim: https://groups.google.com/d/msg/vim_dev/vLupTNhQhZ8/cDGIk0JEDgAJ
                              " nvim: https://github.com/neovim/neovim/pull/4131
                              if !exists("*json_decode")
                                call go#util#EchoError("GoSameIds requires 'json_decode'. Update your Vim/Neovim version.")
                                return
                              endif
                            
                              let args = {
                                    \ 'mode': 'what',
                                    \ 'format': 'json',
                                    \ 'selected': -1,
                                    \ 'needs_scope': 0,
                                    \ 'custom_parse': function('s:same_ids_highlight'),
                                    \ }
                              if !a:showstatus
                                let args.disable_progress = 1
                              endif
                            
                              call s:run_guru(args)
                            endfunction
                            
    1              0.000004 function! s:same_ids_highlight(exit_val, output, mode) abort
                              call go#guru#ClearSameIds() " run after calling guru to reduce flicker.
                            
                              if a:output[0] !=# '{'
                                if !go#config#AutoSameids()
                                  call go#util#EchoError(a:output)
                                endif
                                return
                              endif
                            
                              let result = json_decode(a:output)
                              if type(result) != type({}) && !go#config#AutoSameids()
                                call go#util#EchoError("malformed output from guru")
                                return
                              endif
                            
                              if !has_key(result, 'sameids')
                                if !go#config#AutoSameids()
                                  call go#util#EchoError("no same_ids founds for the given identifier")
                                endif
                                return
                              endif
                            
                              let poslen = 0
                              for enclosing in result['enclosing']
                                if enclosing['desc'] == 'identifier'
                                  let poslen = enclosing['end'] - enclosing['start']
                                  break
                                endif
                              endfor
                            
                              " return when there's no identifier to highlight.
                              if poslen == 0
                                return
                              endif
                            
                              let same_ids = result['sameids']
                              " highlight the lines
                              for item in same_ids
                                let pos = split(item, ':')
                                call matchaddpos('goSameId', [[str2nr(pos[-2]), str2nr(pos[-1]), str2nr(poslen)]])
                              endfor
                            
                              if go#config#AutoSameids()
                                " re-apply SameIds at the current cursor position at the time the buffer
                                " is redisplayed: e.g. :edit, :GoRename, etc.
                                augroup vim-go-sameids
                                  autocmd! * <buffer>
                                  autocmd BufWinEnter <buffer> nested call go#guru#SameIds(0)
                                augroup end
                              endif
                            endfunction
                            
                            " ClearSameIds returns 0 when it removes goSameId groups and non-zero if no
                            " goSameId groups are found.
    1              0.000002 function! go#guru#ClearSameIds() abort
                              let l:cleared = 0
                            
                              let m = getmatches()
                              for item in m
                                if item['group'] == 'goSameId'
                                  call matchdelete(item['id'])
                                  let l:cleared = 1
                                endif
                              endfor
                            
                              if !l:cleared
                                return 1
                              endif
                            
                              " remove the autocmds we defined
                              augroup vim-go-sameids
                                autocmd! * <buffer>
                              augroup end
                            
                              return 0
                            endfunction
                            
    1              0.000002 function! go#guru#ToggleSameIds() abort
                              if go#guru#ClearSameIds() != 0
                                call go#guru#SameIds(1)
                              endif
                            endfunction
                            
    1              0.000002 function! go#guru#AutoToggleSameIds() abort
                              if go#config#AutoSameids()
                                call go#util#EchoProgress("sameids auto highlighting disabled")
                                call go#guru#ClearSameIds()
                                call go#config#SetAutoSameids(0)
                                return
                              endif
                            
                              call go#util#EchoSuccess("sameids auto highlighting enabled")
                              call go#config#SetAutoSameids(1)
                            endfunction
                            
                            
                            """"""""""""""""""""""""""""""""""""""""
                            "" HELPER FUNCTIONS
                            """"""""""""""""""""""""""""""""""""""""
                            
                            " This uses Vim's errorformat to parse the output from Guru's 'plain output
                            " and put it into location list. I believe using errorformat is much more
                            " easier to use. If we need more power we can always switch back to parse it
                            " via regex. Match two possible styles of errorformats:
                            "
                            "   'file:line.col-line2.col2: message'
                            "   'file:line:col: message'
                            "
                            " We discard line2 and col2 for the first errorformat, because it's not
                            " useful and location only has the ability to show one line and column
                            " number
    1              0.000003 function! s:parse_guru_output(exit_val, output, title) abort
                              if a:exit_val
                                call go#util#EchoError(a:output)
                                return
                              endif
                            
                              let errformat = "%f:%l.%c-%[%^:]%#:\ %m,%f:%l:%c:\ %m"
                              let l:listtype = go#list#Type("_guru")
                              call go#list#ParseFormat(l:listtype, errformat, a:output, a:title)
                            
                              let errors = go#list#Get(l:listtype)
                              call go#list#Window(l:listtype, len(errors))
                            endfun
                            
    1              0.000002 function! go#guru#Scope(...) abort
                              if a:0
                                let scope = a:000
                                if a:0 == 1 && a:1 == '""'
                                  let scope = []
                                endif
                            
                                call go#config#SetGuruScope(scope)
                                if empty(scope)
                                  call go#util#EchoSuccess("guru scope is cleared")
                                else
                                  call go#util#EchoSuccess("guru scope changed to: ". join(a:000, ","))
                                endif
                            
                                return
                              endif
                            
                              let scope = go#config#GuruScope()
                              if empty(scope)
                                call go#util#EchoError("guru scope is not set")
                              else
                                call go#util#EchoSuccess("current guru scope: ". join(scope, ","))
                              endif
                            endfunction
                            
    1              0.000005 function! go#guru#DescribeBalloon() abort
                              " don't even try if async isn't available.
                              if !go#util#has_job()
                                return
                              endif
                            
                              " json_encode() and friends are introduced with this patch (7.4.1304)
                              " vim: https://groups.google.com/d/msg/vim_dev/vLupTNhQhZ8/cDGIk0JEDgAJ
                              " nvim: https://github.com/neovim/neovim/pull/4131
                              if !exists("*json_decode")
                                call go#util#EchoError("requires 'json_decode'. Update your Vim/Neovim version.")
                                return
                              endif
                            
                              " change the active window to the window where the cursor is.
                              let l:winid = win_getid(winnr())
                              call win_gotoid(v:beval_winid)
                            
                              let l:args = {
                                    \ 'mode': 'describe',
                                    \ 'format': 'json',
                                    \ 'selected': -1,
                                    \ 'needs_scope': 0,
                                    \ 'custom_parse': function('s:describe_balloon'),
                                    \ 'disable_progress': 1,
                                    \ 'postype': 'balloon',
                                    \ }
                            
                              call s:async_guru(args)
                            
                              " make the starting window active again
                              call win_gotoid(l:winid)
                            
                              return ''
                            endfunction
                            
    1              0.000004 function! s:describe_balloon(exit_val, output, mode)
                              if a:exit_val != 0
                                return
                              endif
                            
                              if a:output[0] !=# '{'
                                return
                              endif
                            
                              if empty(a:output) || type(a:output) != type("")
                                return
                              endif
                            
                              let l:result = json_decode(a:output)
                              if type(l:result) != type({})
                                call go#util#EchoError(printf('malformed output from guru: %s', a:output))
                                return
                              endif
                            
                              let l:info = []
                              if has_key(l:result, 'desc')
                                if l:result['desc'] != 'identifier'
                                  let l:info = add(l:info, l:result['desc'])
                                endif
                              endif
                            
                              if has_key(l:result, 'detail')
                                let l:detail = l:result['detail']
                            
                                " guru gives different information based on the detail mode. Let try to
                                " extract the most useful information
                            
                                if l:detail == 'value'
                                  if !has_key(l:result, 'value')
                                    call go#util#EchoError('value key is missing. Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:val = l:result['value']
                                  if !has_key(l:val, 'type')
                                    call go#util#EchoError('type key is missing (value.type). Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:info = add(l:info, printf('type: %s', l:val['type']))
                                  if has_key(l:val, 'value')
                                    let l:info = add(l:info, printf('value: %s', l:val['value']))
                                  endif
                                elseif l:detail == 'type'
                                  if !has_key(l:result, 'type')
                                    call go#util#EchoError('type key is missing. Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:type = l:result['type']
                                  if !has_key(l:type, 'type')
                                    call go#util#EchoError('type key is missing (type.type). Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:info = add(l:info, printf('type: %s', l:type['type']))
                            
                                  if has_key(l:type, 'methods')
                                    let l:info = add(l:info, 'methods:')
                                    for l:m in l:type.methods
                                      let l:info = add(l:info, printf("\t%s", l:m['name']))
                                    endfor
                                  endif
                                elseif l:detail == 'package'
                                  if !has_key(l:result, 'package')
                                    call go#util#EchoError('package key is missing. Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:package = result['package']
                                  if !has_key(l:package, 'path')
                                    call go#util#EchoError('path key is missing (package.path). Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:info = add(l:info, printf('package: %s', l:package["path"]))
                                elseif l:detail == 'unknown'
                                  " the description is already included in l:info, and there's no other
                                  " information on unknowns.
                                else
                                  call go#util#EchoError(printf('unknown detail mode (%s) found. Please open a bug report on vim-go repo', l:detail))
                                  return
                                endif
                              endif
                            
                              if has('balloon_eval')
                                call balloon_show(join(l:info, "\n"))
                                return
                              endif
                            
                              call balloon_show(l:info)
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000010 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-qf/autoload/qf.vim
Sourced 1 time
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
                            " vim-qf - Tame the quickfix window
                            " Maintainer:	romainl <romainlafourcade@gmail.com>
                            " Version:	0.2.0
                            " License:	MIT
                            " Location:	autoload/qf.vim
                            " Website:	https://github.com/romainl/vim-qf
                            "
                            " Use this command to get help on vim-qf:
                            "
                            "     :help qf
                            "
                            " If this doesn't work and you installed vim-qf manually, use the following
                            " command to index vim-qf's documentation:
                            "
                            "     :helptags ~/.vim/doc
                            "
                            " or read your runtimepath/plugin manager documentation.
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000011 set cpo&vim
                            
                            " open the current entry in th preview window
    1              0.000003 function qf#PreviewFileUnderCursor()
                                let cur_list = b:qf_isLoc == 1 ? getloclist('.') : getqflist()
                                let cur_line = getline(line('.'))
                                let cur_file = fnameescape(substitute(cur_line, '|.*$', '', ''))
                                if cur_line =~ '|\d\+'
                                    let cur_pos  = substitute(cur_line, '^\(.\{-}|\)\(\d\+\)\(.*\)', '\2', '')
                                    execute "pedit +" . cur_pos . " " . cur_file
                                else
                                    execute "pedit " . cur_file
                                endif
                            endfunction
                            
                            " helper function
                            " returns 1 if the window with the given number is a quickfix window
                            "         0 if the window with the given number is not a quickfix window
                            " TODO (Nelo-T. Wallus): make a:nbmr optional and return current window
                            "                        by default
    1              0.000003 function! qf#IsQfWindow(nmbr)
                                if getwinvar(a:nmbr, "&filetype") == "qf"
                                    return qf#IsLocWindow(a:nmbr) ? 0 : 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " helper function
                            " returns 1 if the window with the given number is a location window
                            "         0 if the window with the given number is not a location window
    1              0.000002 function! qf#IsLocWindow(nmbr)
                                return getbufvar(winbufnr(a:nmbr), "qf_isLoc") == 1
                            endfunction
                            
                            " returns bool: Is quickfix window open?
    1              0.000002 function! qf#IsQfWindowOpen() abort
                                for winnum in range(1, winnr('$'))
                                    if qf#IsQfWindow(winnum)
                                        return 1
                                    endif
                                endfor
                                return 0
                            endfunction
                            
                            " returns bool: Is location window for window with given number open?
    1              0.000002 function! qf#IsLocWindowOpen(nmbr) abort
                                let loclist = getloclist(a:nmbr)
                                for winnum in range(1, winnr('$'))
                                    if qf#IsLocWindow(winnum) && loclist ==# getloclist(winnum)
                                        return 1
                                    endif
                                endfor
                                return 0
                            endfunction
                            
                            " returns location list of the current loclist if isLoc is set
                            "         qf list otherwise
    1              0.000002 function! qf#GetList()
                                if get(b:, 'qf_isLoc', 0)
                                    return getloclist(0)
                                else
                                    return getqflist()
                                endif
                            endfunction
                            
                            " sets location or qf list based in b:qf_isLoc to passed newlist
    1              0.000002 function! qf#SetList(newlist, ...)
                                " generate partial
                                let Func = get(b:, 'qf_isLoc', 0)
                                            \ ? function('setloclist', [0, a:newlist])
                                            \ : function('setqflist', [a:newlist])
                            
                                " get user-defined maximum height
                                let max_height = get(g:, 'qf_max_height', 10) < 1 ? 10 : get(g:, 'qf_max_height', 10)
                            
                                " call partial with optional arguments
                                call call(Func, a:000)
                            
                                if get(b:, 'qf_isLoc', 0)
                                    execute get(g:, "qf_auto_resize", 1) ? 'lclose|' . min([ max_height, len(getloclist(0)) ]) . 'lwindow' : 'lwindow'
                                else
                                    execute get(g:, "qf_auto_resize", 1) ? 'cclose|' . min([ max_height, len(getqflist()) ]) . 'cwindow' : 'cwindow'
                                endif
                            endfunction
                            
    1              0.000002 function! qf#GetEntryPath(line) abort
                                "                          +- match from the first pipe to the end of line
                                "                          |  declaring EOL explicitly is faster than implicitly
                                "                          |      +- replace match with nothing
                                "                          |      |   +- no flags
                                return substitute(a:line, '|.*$', '', '')
                            endfunction
                            
                            " open the quickfix window if there are valid errors
    1              0.000002 function! qf#OpenQuickfix()
                                if get(g:, 'qf_auto_open_quickfix', 1)
                                    " get user-defined maximum height
                                    let max_height = get(g:, 'qf_max_height', 10) < 1 ? 10 : get(g:, 'qf_max_height', 10)
                                    execute get(g:, "qf_auto_resize", 1) ? 'cclose|' . min([ max_height, len(getqflist()) ]) . 'cwindow' : 'cwindow'
                                endif
                            endfunction
                            
                            " open a location window if there are valid locations
    1              0.000002 function! qf#OpenLoclist()
                                if get(g:, 'qf_auto_open_loclist', 1)
                                    " get user-defined maximum height
                                    let max_height = get(g:, 'qf_max_height', 10) < 1 ? 10 : get(g:, 'qf_max_height', 10)
                                    execute get(g:, "qf_auto_resize", 1) ? 'lclose|' . min([ max_height, len(getloclist(0)) ]) . 'lwindow' : 'lwindow'
                                endif
                            endfunction
                            
    1              0.000012 let &cpo = s:save_cpo

SCRIPT  /home/c5262761/configit/vim/modules/vim-signify/autoload/sy/sign.vim
Sourced 1 time
Total time:   0.000398
 Self time:   0.000398

count  total (s)   self (s)
                            " vim: et sw=2 sts=2
                            
    1              0.000005 scriptencoding utf-8
                            
                            " Init: values {{{1
    1              0.000008 if get(g:, 'signify_sign_show_text', 1)
    1              0.000006   let s:sign_delete = get(g:, 'signify_sign_delete', '_')
                            else
                              let s:sign_delete = ' '
    1              0.000001 endif
                            
    1              0.000015 let s:sign_show_count  = get(g:, 'signify_sign_show_count', 1)
    1              0.000004 let s:delete_highlight = ['', 'SignifyLineDelete']
                            
                            " Function: #id_next {{{1
    1              0.000003 function! sy#sign#id_next(sy) abort
                              let id = a:sy.signid
                              let a:sy.signid += 1
                              return id
                            endfunction
                            
                            " Function: #get_current_signs {{{1
    1              0.000004 function! sy#sign#get_current_signs(sy) abort
                              let a:sy.internal = {}
                              let a:sy.external = {}
                            
                              let signlist = sy#util#execute('sign place buffer='. a:sy.buffer)
                            
                              for signline in split(signlist, '\n')[2:]
                                let tokens = matchlist(signline, '\v^\s+\S+\=(\d+)\s+\S+\=(\d+)\s+\S+\=(.*)$')
                                let line   = str2nr(tokens[1])
                                let id     = str2nr(tokens[2])
                                let type   = tokens[3]
                            
                                if type =~# '^Signify'
                                  " Handle ambiguous signs. Assume you have signs on line 3 and 4.
                                  " Removing line 3 would lead to the second sign to be shifted up
                                  " to line 3. Now there are still 2 signs, both one line 3.
                                  if has_key(a:sy.internal, line)
                                    execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
                                  endif
                                  let a:sy.internal[line] = { 'type': type, 'id': id }
                                else
                                  let a:sy.external[line] = id
                                endif
                              endfor
                            endfunction
                            
                            
                            " Function: #process_diff {{{1
    1              0.000005 function! sy#sign#process_diff(sy, vcs, diff) abort
                              let a:sy.signtable             = {}
                              let a:sy.hunks                 = []
                              let [added, modified, deleted] = [0, 0, 0]
                            
                              call sy#sign#get_current_signs(a:sy)
                            
                              " Determine where we have to put our signs.
                              for line in filter(a:diff, 'v:val =~ "^@@ "')
                                let a:sy.lines = []
                                let ids        = []
                            
                                let [old_line, new_line, old_count, new_count] = sy#sign#parse_hunk(line)
                            
                                " Workaround for non-conventional diff output in older Fossil versions:
                                " https://fossil-scm.org/forum/forumpost/834ce0f1e1
                                " Fixed as of: https://fossil-scm.org/index.html/info/7fd2a3652ea7368a
                                if a:vcs == 'fossil' && new_line == 0
                                  let new_line = old_line - 1 - deleted
                                endif
                            
                                " 2 lines added:
                            
                                " @@ -5,0 +6,2 @@ this is line 5
                                " +this is line 5
                                " +this is line 5
                                if (old_count == 0) && (new_count >= 1)
                                  let added += new_count
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
                                  endwhile
                            
                                " 2 lines removed:
                            
                                " @@ -6,2 +5,0 @@ this is line 5
                                " -this is line 6
                                " -this is line 7
                                elseif (old_count >= 1) && (new_count == 0)
                                  if s:external_sign_present(a:sy, new_line) | continue | endif
                                  let deleted += old_count
                                  if new_line == 0
                                    call add(ids, s:add_sign(a:sy, 1, 'SignifyRemoveFirstLine'))
                                  elseif s:sign_show_count
                                    let text = s:sign_delete . (old_count <= 99 ? old_count : '>')
                                    while strwidth(text) > 2
                                      let text = substitute(text, '.', '', '')
                                    endwhile
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDelete'. old_count, text))
                                  else
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDeleteMore', s:sign_delete))
                                  endif
                            
                                " 2 lines changed:
                            
                                " @@ -5,2 +5,2 @@ this is line 4
                                " -this is line 5
                                " -this is line 6
                                " +this os line 5
                                " +this os line 6
                                elseif old_count == new_count
                                  let modified += old_count
                                  let offset    = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                  endwhile
                                else
                            
                                  " 2 lines changed; 2 lines removed:
                            
                                  " @@ -5,4 +5,2 @@ this is line 4
                                  " -this is line 5
                                  " -this is line 6
                                  " -this is line 7
                                  " -this is line 8
                                  " +this os line 5
                                  " +this os line 6
                                  if old_count > new_count
                                    let modified += new_count
                                    let removed   = old_count - new_count
                                    let deleted  += removed
                                    let offset    = 0
                                    while offset < new_count - 1
                                      let line    = new_line + offset
                                      let offset += 1
                                      if s:external_sign_present(a:sy, line) | continue | endif
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                    endwhile
                                    let line = new_line + offset
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, (removed > 9)
                                          \ ? 'SignifyChangeDeleteMore'
                                          \ : 'SignifyChangeDelete'. removed))
                            
                                  " lines changed and added:
                            
                                  " @@ -5 +5,3 @@ this is line 4
                                  " -this is line 5
                                  " +this os line 5
                                  " +this is line 42
                                  " +this is line 666
                                  else
                                    let modified += old_count
                                    let offset    = 0
                                    while offset < old_count
                                      let line    = new_line + offset
                                      let offset += 1
                                      if s:external_sign_present(a:sy, line) | continue | endif
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                    endwhile
                                    while offset < new_count
                                      let added  += 1
                                      let line    = new_line + offset
                                      let offset += 1
                                      if s:external_sign_present(a:sy, line) | continue | endif
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
                                    endwhile
                                  endif
                                endif
                            
                                if !empty(ids)
                                  call add(a:sy.hunks, {
                                        \ 'ids'  : ids,
                                        \ 'start': a:sy.lines[0],
                                        \ 'end'  : a:sy.lines[-1] })
                                endif
                              endfor
                            
                              " Remove obsoleted signs.
                              for line in filter(keys(a:sy.internal), '!has_key(a:sy.signtable, v:val)')
                                execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
                              endfor
                            
                              if has('gui_macvim') && has('gui_running') && mode() == 'n'
                                " MacVim needs an extra kick in the butt, when setting signs from the
                                " exit handler. :redraw would trigger a "hanging cursor" issue.
                                call feedkeys("\<c-l>", 'n')
                              endif
                            
                              if empty(a:sy.updated_by) && empty(a:sy.hunks)
                                call sy#verbose('Successful exit value, but no diff. Keep VCS for time being.', a:vcs)
                                return
                              endif
                            
                              call sy#verbose('Signs updated.', a:vcs)
                              let a:sy.updated_by = a:vcs
                              if len(a:sy.vcs) > 1
                                call sy#verbose('Disable all other VCS.', a:vcs)
                                let a:sy.vcs = [a:vcs]
                              endif
                            
                              let a:sy.stats = [added, modified, deleted]
                            endfunction
                            
                            " Function: #remove_all_signs {{{1
    1              0.000003 function! sy#sign#remove_all_signs(bufnr) abort
                              let sy = getbufvar(a:bufnr, 'sy')
                            
                              for hunk in sy.hunks
                                for id in hunk.ids
                                  execute 'sign unplace' id 'buffer='.a:bufnr
                                endfor
                              endfor
                            
                              let sy.hunks = []
                            endfunction
                            
                            " Function: #parse_hunk {{{1
                            " Parse a hunk as '@@ -273,3 +267,14' into [old_line, new_line, old_count, new_count]
    1              0.000004 function! sy#sign#parse_hunk(diffline) abort
                              let tokens = matchlist(a:diffline, '^@@ -\v(\d+),?(\d*) \+(\d+),?(\d*)')
                              return [
                                    \ str2nr(tokens[1]),
                                    \ str2nr(tokens[3]),
                                    \ empty(tokens[2]) ? 1 : str2nr(tokens[2]),
                                    \ empty(tokens[4]) ? 1 : str2nr(tokens[4])
                                    \ ]
                            endfunction
                            
                            " Function: #set_signs {{{1
    1              0.000003 function! sy#sign#set_signs(sy, vcs, diff) abort
                              call sy#verbose('sy#sign#set_signs()', a:vcs)
                            
                              if a:sy.stats == [-1, -1, -1]
                                let a:sy.stats = [0, 0, 0]
                              endif
                            
                              if empty(a:diff)
                                call sy#verbose('No changes found.', a:vcs)
                                let a:sy.stats = [0, 0, 0]
                                call sy#sign#remove_all_signs(a:sy.buffer)
                                return
                              endif
                            
                              if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_enable()
                              else
                                call sy#highlight#line_disable()
                              endif
                            
                              call sy#sign#process_diff(a:sy, a:vcs, a:diff)
                            
                              if exists('#User#Signify')
                                doautocmd <nomodeline> User Signify
                              endif
                            endfunction
                            
                            " Function: s:add_sign {{{1
    1              0.000005 function! s:add_sign(sy, line, type, ...) abort
                              call add(a:sy.lines, a:line)
                              let a:sy.signtable[a:line] = 1
                            
                              if has_key(a:sy.internal, a:line)
                                " There is a sign on this line already.
                                if a:type == a:sy.internal[a:line].type
                                  " Keep current sign since the new one is of the same type.
                                  return a:sy.internal[a:line].id
                                else
                                  " Update sign by overwriting the ID of the current sign.
                                  let id = a:sy.internal[a:line].id
                                endif
                              endif
                            
                              if !exists('id')
                                let id = sy#sign#id_next(a:sy)
                              endif
                            
                              if a:type =~# 'SignifyDelete'
                                execute printf('sign define %s text=%s texthl=SignifySignDelete linehl=%s',
                                      \ a:type,
                                      \ a:1,
                                      \ s:delete_highlight[g:signify_line_highlight])
                              endif
                              execute printf('sign place %d line=%d name=%s buffer=%s',
                                    \ id,
                                    \ a:line,
                                    \ a:type,
                                    \ a:sy.buffer)
                            
                              return id
                            endfunction
                            
                            " Function: s:external_sign_present {{{1
    1              0.000004 function! s:external_sign_present(sy, line) abort
                              if has_key(a:sy.external, a:line)
                                if has_key(a:sy.internal, a:line)
                                  " Remove Sy signs from lines with other signs.
                                  execute 'sign unplace' a:sy.internal[a:line].id 'buffer='.a:sy.buffer
                                endif
                                return 1
                              endif
                            endfunction

SCRIPT  /home/c5262761/configit/vim/modules/vim-signify/autoload/sy/highlight.vim
Sourced 1 time
Total time:   0.000210
 Self time:   0.000154

count  total (s)   self (s)
                            " vim: et sw=2 sts=2
                            
    1              0.000004 scriptencoding utf-8
                            
                            " Init: values {{{1
    1              0.000006 if get(g:, 'signify_sign_show_text', 1)
    1              0.000006   let s:sign_add               = get(g:, 'signify_sign_add',               '+')
    1              0.000005   let s:sign_delete_first_line = get(g:, 'signify_sign_delete_first_line', '‾')
    1              0.000005   let s:sign_change            = get(g:, 'signify_sign_change',            '!')
    1              0.000005   let s:sign_changedelete      = get(g:, 'signify_sign_changedelete',      s:sign_change)
                            else
                              let s:sign_add               = ' '
                              let s:sign_delete_first_line = ' '
                              let s:sign_change            = ' '
                              let s:sign_changedelete      = ' '
    1              0.000001 endif
                            
    1              0.000004 let s:sign_show_count = get(g:, 'signify_sign_show_count', 1)
                            
                            " Function: #setup {{{1
    1              0.000003 function! sy#highlight#setup() abort
                              highlight default link SignifyLineAdd             DiffAdd
                              highlight default link SignifyLineDelete          DiffDelete
                              highlight default link SignifyLineDeleteFirstLine SignifyLineDelete
                              highlight default link SignifyLineChange          DiffChange
                              highlight default link SignifyLineChangeDelete    SignifyLineChange
                            
                              highlight default link SignifySignAdd             DiffAdd
                              highlight default link SignifySignDelete          DiffDelete
                              highlight default link SignifySignDeleteFirstLine SignifySignDelete
                              highlight default link SignifySignChange          DiffChange
                              highlight default link SignifySignChangeDelete    SignifySignChange
                            endfunction
                            
                            " Function: #line_enable {{{1
    1              0.000002 function! sy#highlight#line_enable() abort
                              execute 'sign define SignifyAdd text='. s:sign_add 'texthl=SignifySignAdd linehl=SignifyLineAdd'
                              execute 'sign define SignifyChange text='. s:sign_change 'texthl=SignifySignChange linehl=SignifyLineChange'
                              execute 'sign define SignifyRemoveFirstLine text='. s:sign_delete_first_line 'texthl=SignifySignDeleteFirstLine linehl=SignifyLineDeleteFirstLine'
                            
                              if s:sign_show_count
                                let s:sign_changedelete = substitute(s:sign_changedelete, '^.\zs.*', '', '')
                                for n in range(1, 9)
                                  execute 'sign define SignifyChangeDelete'. n 'text='. s:sign_changedelete . n 'texthl=SignifySignChangeDelete linehl=SignifyLineChangeDelete'
                                endfor
                                execute 'sign define SignifyChangeDeleteMore text='. s:sign_changedelete .'> texthl=SignifySignChangeDelete linehl=SignifyLineChangeDelete'
                              else
                                for n in range(1, 9)
                                  execute 'sign define SignifyChangeDelete'. n 'text='. s:sign_changedelete 'texthl=SignifySignChangeDelete linehl=SignifyLineChangeDelete'
                                endfor
                                execute 'sign define SignifyChangeDeleteMore text='. s:sign_changedelete 'texthl=SignifySignChangeDelete linehl=SignifyLineChangeDelete'
                              endif
                            
                              let g:signify_line_highlight = 1
                            endfunction
                            
                            " Function: #line_disable {{{1
    1              0.000003 function! sy#highlight#line_disable() abort
                              execute 'sign define SignifyAdd text='. s:sign_add 'texthl=SignifySignAdd linehl='
                              execute 'sign define SignifyChange text='. s:sign_change 'texthl=SignifySignChange linehl='
                              execute 'sign define SignifyRemoveFirstLine text='. s:sign_delete_first_line 'texthl=SignifySignDeleteFirstLine linehl='
                            
                              if s:sign_show_count
                                while strwidth(s:sign_changedelete) > 1
                                  let s:sign_changedelete = substitute(s:sign_changedelete, '.', '', '')
                                endwhile
                                for n in range(1, 9)
                                  execute 'sign define SignifyChangeDelete'. n 'text='. s:sign_changedelete . n 'texthl=SignifySignChangeDelete linehl='
                                endfor
                                execute 'sign define SignifyChangeDeleteMore text='. s:sign_changedelete .'> texthl=SignifySignChangeDelete linehl='
                              else
                                for n in range(1, 9)
                                  execute 'sign define SignifyChangeDelete'. n 'text='. s:sign_changedelete 'texthl=SignifySignChangeDelete linehl='
                                endfor
                                execute 'sign define SignifyChangeDeleteMore text='. s:sign_changedelete 'texthl=SignifySignChangeDelete linehl='
                              endif
                            
                              let g:signify_line_highlight = 0
                            endfunction
                            
                            " Function: #line_toggle {{{1
    1              0.000002 function! sy#highlight#line_toggle() abort
                              if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_disable()
                              else
                                call sy#highlight#line_enable()
                              endif
                            
                              redraw!
                              call sy#start()
                            endfunction
                            " }}}
                            
    1   0.000065   0.000009 call sy#highlight#setup()

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/auto.vim
Sourced 1 time
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000021 let s:cpo_save = &cpo
    1              0.000016 set cpo&vim
                            
    1              0.000006 function! go#auto#template_autocreate()
                              if !go#config#TemplateAutocreate() || !&modifiable
                                return
                              endif
                            
                              " create new template from scratch
                              call go#template#create()
                            endfunction
                            
    1              0.000002 function! go#auto#echo_go_info()
                              if !go#config#EchoGoInfo()
                                return
                              endif
                            
                              if !exists('v:completed_item') || empty(v:completed_item)
                                return
                              endif
                              let item = v:completed_item
                            
                              if !has_key(item, "info")
                                return
                              endif
                            
                              if empty(item.info)
                                return
                              endif
                            
                              redraws! | echo "vim-go: " | echohl Function | echon item.info | echohl None
                            endfunction
                            
    1              0.000002 function! go#auto#auto_type_info()
                              if !go#config#AutoTypeInfo() || !isdirectory(expand('%:p:h'))
                                return
                              endif
                            
                              " GoInfo automatic update
                              call go#tool#Info(0)
                            endfunction
                            
    1              0.000003 function! go#auto#auto_sameids()
                              if !go#config#AutoSameids() || !isdirectory(expand('%:p:h'))
                                return
                              endif
                            
                              " GoSameId automatic update
                              call go#guru#SameIds(0)
                            endfunction
                            
    1              0.000003 function! go#auto#fmt_autosave()
                              if !(go#config#FmtAutosave() && isdirectory(expand('%:p:h')) && expand('<afile>:p') == expand('%:p'))
                                return
                              endif
                            
                              " Go code formatting on save
                              call go#fmt#Format(-1)
                            endfunction
                            
    1              0.000002 function! go#auto#metalinter_autosave()
                              if !go#config#MetalinterAutosave() || !isdirectory(expand('%:p:h'))
                                return
                              endif
                            
                              " run gometalinter on save
                              call go#lint#Gometa(!g:go_jump_to_error, 1)
                            endfunction
                            
    1              0.000002 function! go#auto#modfmt_autosave()
                              if !(go#config#ModFmtAutosave() && isdirectory(expand('%:p:h')) && expand('<afile>:p') == expand('%:p'))
                                return
                              endif
                            
                              " go.mod code formatting on save
                              call go#mod#Format()
                            endfunction
                            
    1              0.000002 function! go#auto#asmfmt_autosave()
                              if !(go#config#AsmfmtAutosave() && isdirectory(expand('%:p:h')) && expand('<afile>:p') == expand('%:p'))
                                return
                              endif
                            
                              " Go asm formatting on save
                              call go#asmfmt#Format()
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000013 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/fmt.vim
Sourced 1 time
Total time:   0.000283
 Self time:   0.000283

count  total (s)   self (s)
                            " Copyright 2011 The Go Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style
                            " license that can be found in the LICENSE file.
                            "
                            " fmt.vim: Vim command to format Go files with gofmt (and gofmt compatible
                            " toorls, such as goimports).
                            
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000011 let s:cpo_save = &cpo
    1              0.000011 set cpo&vim
                            
                            "  we have those problems :
                            "  http://stackoverflow.com/questions/12741977/prevent-vim-from-updating-its-undo-tree
                            "  http://stackoverflow.com/questions/18532692/golang-formatter-and-vim-how-to-destroy-history-record?rq=1
                            "
                            "  The below function is an improved version that aims to fix all problems.
                            "  it doesn't undo changes and break undo history.  If you are here reading
                            "  this and have VimL experience, please look at the function for
                            "  improvements, patches are welcome :)
    1              0.000006 function! go#fmt#Format(withGoimport) abort
                              if go#config#FmtExperimental()
                                " Using winsaveview to save/restore cursor state has the problem of
                                " closing folds on save:
                                "   https://github.com/fatih/vim-go/issues/502
                                " One fix is to use mkview instead. Unfortunately, this sometimes causes
                                " other bad side effects:
                                "   https://github.com/fatih/vim-go/issues/728
                                " and still closes all folds if foldlevel>0:
                                "   https://github.com/fatih/vim-go/issues/732
                                let l:curw = {}
                                try
                                  mkview!
                                catch
                                  let l:curw = winsaveview()
                                endtry
                            
                                " save our undo file to be restored after we are done. This is needed to
                                " prevent an additional undo jump due to BufWritePre auto command and also
                                " restore 'redo' history because it's getting being destroyed every
                                " BufWritePre
                                let tmpundofile = tempname()
                                exe 'wundo! ' . tmpundofile
                              else
                                " Save cursor position and many other things.
                                let l:curw = winsaveview()
                              endif
                            
                              " Write current unsaved buffer to a temp file
                              let l:tmpname = tempname() . '.go'
                              call writefile(go#util#GetLines(), l:tmpname)
                              if go#util#IsWin()
                                let l:tmpname = tr(l:tmpname, '\', '/')
                              endif
                            
                              let bin_name = go#config#FmtCommand()
                              if a:withGoimport == 1
                                let bin_name = "goimports"
                              endif
                            
                              let current_col = col('.')
                              let [l:out, l:err] = go#fmt#run(bin_name, l:tmpname, expand('%'))
                              let diff_offset = len(readfile(l:tmpname)) - line('$')
                            
                              if l:err == 0
                                call go#fmt#update_file(l:tmpname, expand('%'))
                              elseif !go#config#FmtFailSilently()
                                let errors = s:parse_errors(expand('%'), out)
                                call s:show_errors(errors)
                              endif
                            
                              " We didn't use the temp file, so clean up
                              call delete(l:tmpname)
                            
                              if go#config#FmtExperimental()
                                " restore our undo history
                                silent! exe 'rundo ' . tmpundofile
                                call delete(tmpundofile)
                            
                                " Restore our cursor/windows positions, folds, etc.
                                if empty(l:curw)
                                  silent! loadview
                                else
                                  call winrestview(l:curw)
                                endif
                              else
                                " Restore our cursor/windows positions.
                                call winrestview(l:curw)
                              endif
                            
                              " be smart and jump to the line the new statement was added/removed
                              call cursor(line('.') + diff_offset, current_col)
                            
                              " Syntax highlighting breaks less often.
                              syntax sync fromstart
                            endfunction
                            
                            " update_file updates the target file with the given formatted source
    1              0.000005 function! go#fmt#update_file(source, target)
                              " remove undo point caused via BufWritePre
                              try | silent undojoin | catch | endtry
                            
                              let old_fileformat = &fileformat
                              if exists("*getfperm")
                                " save file permissions
                                let original_fperm = getfperm(a:target)
                              endif
                            
                              call rename(a:source, a:target)
                            
                              " restore file permissions
                              if exists("*setfperm") && original_fperm != ''
                                call setfperm(a:target , original_fperm)
                              endif
                            
                              " reload buffer to reflect latest changes
                              silent edit!
                            
                              let &fileformat = old_fileformat
                              let &syntax = &syntax
                            
                              let l:listtype = go#list#Type("GoFmt")
                            
                              " the title information was introduced with 7.4-2200
                              " https://github.com/vim/vim/commit/d823fa910cca43fec3c31c030ee908a14c272640
                              if has('patch-7.4.2200')
                                " clean up previous list
                                if l:listtype == "quickfix"
                                  let l:list_title = getqflist({'title': 1})
                                else
                                  let l:list_title = getloclist(0, {'title': 1})
                                endif
                              else
                                " can't check the title, so assume that the list was for go fmt.
                                let l:list_title = {'title': 'Format'}
                              endif
                            
                              if has_key(l:list_title, "title") && l:list_title['title'] == "Format"
                                call go#list#Clean(l:listtype)
                              endif
                            endfunction
                            
                            " run runs the gofmt/goimport command for the given source file and returns
                            " the output of the executed command. Target is the real file to be formatted.
    1              0.000003 function! go#fmt#run(bin_name, source, target)
                              let l:cmd = s:fmt_cmd(a:bin_name, a:source, a:target)
                              if empty(l:cmd)
                                return
                              endif
                              return go#util#Exec(l:cmd)
                            endfunction
                            
                            " fmt_cmd returns the command to run as a list.
    1              0.000004 function! s:fmt_cmd(bin_name, source, target)
                              let l:cmd = [a:bin_name, '-w']
                            
                              " add the options for binary (if any). go_fmt_options was by default of type
                              " string, however to allow customization it's now a dictionary of binary
                              " name mapping to options.
                              let opts = go#config#FmtOptions()
                              if type(opts) == type({})
                                let opts = has_key(opts, a:bin_name) ? opts[a:bin_name] : ""
                              endif
                              call extend(cmd, split(opts, " "))
                              if a:bin_name is# 'goimports'
                                call extend(cmd, ["-srcdir", a:target])
                              endif
                            
                              call add(cmd, a:source)
                              return cmd
                            endfunction
                            
                            " parse_errors parses the given errors and returns a list of parsed errors
    1              0.000004 function! s:parse_errors(filename, content) abort
                              let splitted = split(a:content, '\n')
                            
                              " list of errors to be put into location list
                              let errors = []
                              for line in splitted
                                let tokens = matchlist(line, '^\(.\{-}\):\(\d\+\):\(\d\+\)\s*\(.*\)')
                                if !empty(tokens)
                                  call add(errors,{
                                        \"filename": a:filename,
                                        \"lnum":     tokens[2],
                                        \"col":      tokens[3],
                                        \"text":     tokens[4],
                                        \ })
                                endif
                              endfor
                            
                              return errors
                            endfunction
                            
                            " show_errors opens a location list and shows the given errors. If the given
                            " errors is empty, it closes the the location list
    1              0.000003 function! s:show_errors(errors) abort
                              let l:listtype = go#list#Type("GoFmt")
                              if !empty(a:errors)
                                call go#list#Populate(l:listtype, a:errors, 'Format')
                                echohl Error | echomsg "Gofmt returned error" | echohl None
                              endif
                            
                              " this closes the window if there are no errors or it opens
                              " it if there is any
                              call go#list#Window(l:listtype, len(a:errors))
                            endfunction
                            
    1              0.000002 function! go#fmt#ToggleFmtAutoSave() abort
                              if go#config#FmtAutosave()
                                call go#config#SetFmtAutosave(0)
                                call go#util#EchoProgress("auto fmt disabled")
                                return
                              end
                            
                              call go#config#SetFmtAutosave(1)
                              call go#util#EchoProgress("auto fmt enabled")
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000012 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/c5262761/configit/vim/modules/vim-go/autoload/go/list.vim
Sourced 1 time
Total time:   0.000248
 Self time:   0.000248

count  total (s)   self (s)
                            " don't spam the user when Vim is started in Vi compatibility mode
    1              0.000012 let s:cpo_save = &cpo
    1              0.000012 set cpo&vim
                            
                            " Window opens the list with the given height up to 10 lines maximum.
                            " Otherwise g:go_loclist_height is used.
                            "
                            " If no or zero height is given it closes the window by default.
                            " To prevent this, set g:go_list_autoclose = 0
    1              0.000004 function! go#list#Window(listtype, ...) abort
                              " we don't use lwindow to close the location list as we need also the
                              " ability to resize the window. So, we are going to use lopen and lclose
                              " for a better user experience. If the number of errors in a current
                              " location list increases/decreases, cwindow will not resize when a new
                              " updated height is passed. lopen in the other hand resizes the screen.
                              if !a:0 || a:1 == 0
                                call go#list#Close(a:listtype)
                                return
                              endif
                            
                              let height = go#config#ListHeight()
                              if height == 0
                                " prevent creating a large location height for a large set of numbers
                                if a:1 > 10
                                  let height = 10
                                else
                                  let height = a:1
                                endif
                              endif
                            
                              if a:listtype == "locationlist"
                                exe 'lopen ' . height
                              else
                                exe 'copen ' . height
                              endif
                            endfunction
                            
                            
                            " Get returns the current items from the list
    1              0.000002 function! go#list#Get(listtype) abort
                              if a:listtype == "locationlist"
                                return getloclist(0)
                              else
                                return getqflist()
                              endif
                            endfunction
                            
                            " Populate populate the list with the given items
    1              0.000003 function! go#list#Populate(listtype, items, title) abort
                              if a:listtype == "locationlist"
                                call setloclist(0, a:items, 'r')
                            
                                " The last argument ({what}) is introduced with 7.4.2200:
                                " https://github.com/vim/vim/commit/d823fa910cca43fec3c31c030ee908a14c272640
                                if has("patch-7.4.2200") | call setloclist(0, [], 'a', {'title': a:title}) | endif
                              else
                                call setqflist(a:items, 'r')
                                if has("patch-7.4.2200") | call setqflist([], 'a', {'title': a:title}) | endif
                              endif
                            endfunction
                            
                            " Parse parses the given items based on the specified errorformat and
                            " populates the list.
    1              0.000003 function! go#list#ParseFormat(listtype, errformat, items, title) abort
                              " backup users errorformat, will be restored once we are finished
                              let old_errorformat = &errorformat
                            
                              " parse and populate the location list
                              let &errorformat = a:errformat
                              try
                                call go#list#Parse(a:listtype, a:items, a:title)
                              finally
                                "restore back
                                let &errorformat = old_errorformat
                              endtry
                            endfunction
                            
                            " Parse parses the given items based on the global errorformat and
                            " populates the list.
    1              0.000002 function! go#list#Parse(listtype, items, title) abort
                              if a:listtype == "locationlist"
                                lgetexpr a:items
                                if has("patch-7.4.2200") | call setloclist(0, [], 'a', {'title': a:title}) | endif
                              else
                                cgetexpr a:items
                                if has("patch-7.4.2200") | call setqflist([], 'a', {'title': a:title}) | endif
                              endif
                            endfunction
                            
                            " JumpToFirst jumps to the first item in the location list
    1              0.000003 function! go#list#JumpToFirst(listtype) abort
                              if a:listtype == "locationlist"
                                ll 1
                              else
                                cc 1
                              endif
                            endfunction
                            
                            " Clean cleans and closes the location list 
    1              0.000002 function! go#list#Clean(listtype) abort
                              if a:listtype == "locationlist"
                                lex []
                              else
                                cex []
                              endif
                            
                              call go#list#Close(a:listtype)
                            endfunction
                            
                            " Close closes the location list
    1              0.000002 function! go#list#Close(listtype) abort
                              let autoclose_window = go#config#ListAutoclose()
                              if !autoclose_window
                                return
                              endif
                            
                              if a:listtype == "locationlist"
                                lclose
                              else
                                cclose
                              endif
                            endfunction
                            
    1              0.000004 function! s:listtype(listtype) abort
                              let listtype = go#config#ListType()
                              if empty(listtype)
                                return a:listtype
                              endif
                            
                              return listtype
                            endfunction
                            
                            " s:default_list_type_commands is the defaults that will be used for each of
                            " the supported commands (see documentation for g:go_list_type_commands). When
                            " defining a default, quickfix should be used if the command operates on
                            " multiple files, while locationlist should be used if the command operates on a
                            " single file or buffer. Keys that begin with an underscore are not supported
                            " in g:go_list_type_commands.
    1              0.000030 let s:default_list_type_commands = {
                                  \ "GoBuild":              "quickfix",
                                  \ "GoDebug":              "quickfix",
                                  \ "GoErrCheck":           "quickfix",
                                  \ "GoFmt":                "locationlist",
                                  \ "GoGenerate":           "quickfix",
                                  \ "GoInstall":            "quickfix",
                                  \ "GoLint":               "quickfix",
                                  \ "GoMetaLinter":         "quickfix",
                                  \ "GoMetaLinterAutoSave": "locationlist",
                                  \ "GoModFmt":             "locationlist",
                                  \ "GoModifyTags":         "locationlist",
                                  \ "GoRename":             "quickfix",
                                  \ "GoRun":                "quickfix",
                                  \ "GoTest":               "quickfix",
                                  \ "GoVet":                "quickfix",
                                  \ "_guru":                "locationlist",
                                  \ "_term":                "locationlist",
                                  \ "_job":                 "locationlist",
                              \ }
                            
    1              0.000003 function! go#list#Type(for) abort
                              let l:listtype = s:listtype(get(s:default_list_type_commands, a:for))
                              if l:listtype == "0"
                                call go#util#EchoError(printf(
                                      \ "unknown list type command value found ('%s'). Please open a bug report in the vim-go repo.",
                                      \ a:for))
                                let l:listtype = "quickfix"
                              endif
                            
                              return get(go#config#ListTypeCommands(), a:for, l:listtype)
                            endfunction
                            
                            " restore Vi compatibility settings
    1              0.000010 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: sw=2 ts=2 et

FUNCTION  <SNR>49_redraw()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              redraw
                              return ""

FUNCTION  FugitiveExtractGitDir()
Called 1 time
Total time:   0.000594
 Self time:   0.000464

count  total (s)   self (s)
    1   0.000034   0.000018   let path = s:Slash(a:path)
    1              0.000012   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
    1              0.000009   elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
    1              0.000001   else
    1              0.000029     let path = fnamemodify(path, ':p:h:s?/$??')
    1              0.000002   endif
    1              0.000021   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    1              0.000004   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
    1              0.000001   endif
    1              0.000019   let root = resolve(path)
    1              0.000002   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
    1              0.000001   endif
    1              0.000002   let previous = ""
    1              0.000010   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    1   0.000025   0.000007   call s:Tree(env_git_dir)
    3              0.000006   while root !=# previous
    3              0.000031     if root =~# '\v^//%([^/]+/?)?$'
                                  break
    3              0.000002     endif
    3              0.000026     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
    3              0.000001     endif
    3              0.000010     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
    3              0.000010     elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
    3              0.000003     endif
    3              0.000045     let dir = substitute(root, '[\/]$', '', '') . '/.git'
    3              0.000034     let type = getftype(dir)
    3   0.000046   0.000013     if type ==# 'dir' && FugitiveIsGitDir(dir)
    1              0.000001       return dir
    2              0.000012     elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
    2              0.000004     elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
    2   0.000072   0.000009     elseif FugitiveIsGitDir(root)
                                  return root
    2              0.000002     endif
    2              0.000004     let previous = root
    2              0.000008     let root = fnamemodify(root, ':h')
    2              0.000002   endwhile
                              return ''

FUNCTION  <SNR>104_async_guru()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let result = s:guru_cmd(a:args)
                              if has_key(result, 'err')
                                call go#util#EchoError(result.err)
                                return
                              endif
                            
                              let state = { 'mode': a:args.mode, 'parse' : get(a:args, 'custom_parse', funcref("s:parse_guru_output")) }
                            
                              " explicitly bind complete to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
                              let state.complete = function('s:complete', [], state)
                            
                              let opts = { 'statustype': get(a:args, 'statustype', a:args.mode), 'for': '_', 'errorformat': "%f:%l.%c-%[%^:]%#:\ %m,%f:%l:%c:\ %m", 'complete': state.complete, }
                            
                              if has_key(a:args, 'disable_progress')
                                let opts.statustype = ''
                              endif
                            
                              let opts = go#job#Options(l:opts)
                            
                              if has_key(result, 'stdin_content')
                                let l:tmpname = tempname()
                                call writefile(split(result.stdin_content, "\n"), l:tmpname, "b")
                                let l:opts.in_io = "file"
                                let l:opts.in_name = l:tmpname
                              endif
                            
                              call go#job#Start(result.cmd, opts)
                            
                              if a:args.needs_scope && go#config#EchoCommandInfo() && !has_key(a:args, 'disable_progress')
                                call go#util#EchoProgress("analysing with scope " . result.scope . " (see ':help go-guru-scope' if this doesn't work)...")
                              endif

FUNCTION  go#config#GolintBin()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_golint_bin", "golint")

FUNCTION  <SNR>94_callback()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call add(self.messages, a:msg)

FUNCTION  <SNR>41_gofiletype_pre()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000006   let s:current_fileformats = &g:fileformats
    1              0.000002   let s:current_fileencodings = &g:fileencodings
    1              0.000007   set fileencodings=utf-8 fileformats=unix

FUNCTION  go#lsp#DidOpen()
Called 3 times
Total time:   0.035312
 Self time:   0.000590

count  total (s)   self (s)
    3              0.000018   if get(b:, 'go_lsp_did_open', 0)
    2              0.000002     return
    1              0.000001   endif
                            
    1              0.000014   if !filereadable(a:fname)
                                return
    1              0.000001   endif
                            
    1   0.002928   0.000030   let l:lsp = s:lspfactory.get()
    1   0.001536   0.000467   let l:msg = go#lsp#message#DidOpen(fnamemodify(a:fname, ':p'), join(go#util#GetLines(), "\n") . "\n")
    1   0.000043   0.000008   let l:state = s:newHandlerState('')
    1              0.000004   let l:state.handleResult = funcref('s:noop')
                            
                              " TODO(bc): setting a buffer level variable here assumes that a:fname is the
                              " current buffer. Change to a:fname first before setting it and then change
                              " back to active buffer.
    1              0.000008   let b:go_lsp_did_open = 1
                            
    1   0.030747   0.000027   return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  go#config#HighlightExtraTypes()
Called 3 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    3              0.000019   return get(g:, 'go_highlight_extra_types', 0)

FUNCTION  go#util#StripPathSep()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let last_char = strlen(a:path) - 1
                              if a:path[last_char] == go#util#PathSep()
                                return strpart(a:path, 0, last_char)
                              endif
                            
                              return a:path

FUNCTION  gutentags#is_path_rooted()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000007         return !empty(a:path) && a:path[0] == '/'

FUNCTION  gutentags#add_job()
Called 2 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000037     call add(s:update_in_progress[a:module], [a:tags_file, a:data])

FUNCTION  <SNR>14_set_rust_filetype()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if &filetype !=# 'rust'
                                    set filetype=rust
                                endif

FUNCTION  1()
Called 5 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    5              0.000026   let sub = deepcopy(self)
    5              0.000016   return a:0 ? extend(sub,a:1) : sub

FUNCTION  2()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return self.clone().go(a:bang,a:line1,a:line2,a:count,a:args)

FUNCTION  3()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let self.bang = a:bang
                              let self.line1 = a:line1
                              let self.line2 = a:line2
                              let self.count = a:count
                              return self.process(a:bang,a:line1,a:line2,a:count,a:args)

FUNCTION  4()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:extractopts(a:args,self.options)
                              if self.options.word
                                let self.options.flags .= "w"
                              elseif self.options.variable
                                let self.options.flags .= "v"
                              endif
                              let opts = s:normalize_options(self.options)
                              if len(a:args) > 1
                                return s:grep_command(join(a:args[1:]," "),a:bang,opts,a:args[0])
                              elseif len(a:args) == 1
                                return s:find_command(a:bang ? "!" : " ",opts,a:args[0])
                              else
                                call s:throw("E471: Argument required")
                              endif

FUNCTION  5()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:extractopts(a:args,self.options)
                              if self.options.word
                                let self.options.flags .= "w"
                              elseif self.options.variable
                                let self.options.flags .= "v"
                              endif
                              let opts = s:normalize_options(self.options)
                              if len(a:args) <= 1
                                call s:throw("E471: Argument required")
                              else
                                let good = join(a:args[1:],"")
                                let cmd = a:bang ? "." : "%"
                                return s:substitute_command(cmd,a:args[0],good,self.options)
                              endif

FUNCTION  6()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = copy(a:args)
                              call s:extractopts(a:args,self.options)
                              if self.options.delete
                                let cmd = "unabbrev"
                                let good = ""
                              else
                                let cmd = "noreabbrev"
                              endif
                              if !self.options.cmdline
                                let cmd = "i" . cmd
                              endif
                              if self.options.delete
                                let cmd = "silent! ".cmd
                              endif
                              if self.options.buffer
                                let cmd = cmd . " <buffer>"
                              endif
                              let [bad, good] = s:badgood(a:args)
                              if substitute(bad, '[{},]', '', 'g') !~# '^\k*$'
                                call s:throw("E474: Invalid argument (not a keyword: ".string(bad).")")
                              endif
                              if !self.options.delete && good == ""
                                call s:throw("E471: Argument required".a:args[0])
                              endif
                              let dict = s:create_dictionary(bad,good,self.options)
                              call s:abbreviate_from_dict(cmd,dict)
                              if a:bang
                                let i = 0
                                let str = "Abolish ".join(args," ")
                                let file = g:abolish_save_file
                                if !isdirectory(fnamemodify(file,':h'))
                                  call mkdir(fnamemodify(file,':h'),'p')
                                endif
                            
                                if filereadable(file)
                                  let old = readfile(file)
                                else
                                  let old = ["\" Exit if :Abolish isn't available.","if !exists(':Abolish')","    finish","endif",""]
                                endif
                                call writefile(old + [str],file)
                              endif
                              return ""

FUNCTION  7()
Called 2 times
Total time:   0.002917
 Self time:   0.000080

count  total (s)   self (s)
    2              0.000020   if empty(get(self, 'current', {})) || empty(get(self.current, 'job', {}))
    1   0.002879   0.000042     let self.current = s:newlsp()
    2              0.000002   endif
                            
    2              0.000007   return self.current

FUNCTION  8()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if has_key(self, 'current')
                                call remove(self, 'current')
                              endif

FUNCTION  9()
Called 16 times
Total time:   0.009239
 Self time:   0.008157

count  total (s)   self (s)
   16              0.000073     let l:responses = []
   16              0.000070     let l:rest = a:data
                            
   69              0.000127     while 1
                                  " Look for the end of the HTTP headers
   69              0.000802       let l:body_start_idx = matchend(l:rest, "\r\n\r\n")
                            
   69              0.000174       if l:body_start_idx < 0
                                    " incomplete header
   16              0.000021         break
   53              0.000042       endif
                            
                                  " Parse the Content-Length header.
   53              0.000387       let l:header = l:rest[:l:body_start_idx - 4]
   53              0.001282       let l:length_match = matchlist(   l:header,   '\vContent-Length: *(\d+)')
                            
   53              0.000202       if empty(l:length_match)
                                    " TODO(bc): shutdown gopls?
                                    throw "invalid JSON-RPC header:\n" . l:header
   53              0.000047       endif
                            
                                  " get the start of the rest
   53              0.000365       let l:next_start_idx = l:body_start_idx + str2nr(l:length_match[1])
                            
   53              0.000242       if len(l:rest) < l:next_start_idx
                                    " incomplete response body
                                    break
   53              0.000037       endif
                            
   53   0.001630   0.000548       call s:debug('received', l:rest[:l:next_start_idx - 1])
                            
   53              0.000380       let l:body = l:rest[l:body_start_idx : l:next_start_idx - 1]
   53              0.000220       let l:rest = l:rest[l:next_start_idx :]
                            
   53              0.000060       try
                                    " add the json body to the list.
   53              0.001142         call add(l:responses, json_decode(l:body))
                                  catch
                                    " TODO(bc): log the message and/or show an error message.
   53              0.000076       finally
                                    " intentionally left blank.
   53              0.000062       endtry
   69              0.000078     endwhile
                            
   16              0.000062     return [l:rest, l:responses]

FUNCTION  go#uri#Encode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return s:encode(a:value, '[^A-Za-z0-9_.~-]')

FUNCTION  <SNR>4_GetPage()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:0 >= 2
                                let sect = a:1
                                let page = a:2
                              elseif a:0 >= 1
                                let sect = ""
                                let page = a:1
                              else
                                return
                              endif
                            
                              " To support:	    nmap K :Man <cword>
                              if page == '<cword>'
                                let page = expand('<cword>')
                              endif
                            
                              if sect != "" && s:FindPage(sect, page) == 0
                                let sect = ""
                              endif
                              if s:FindPage(sect, page) == 0
                                echo "\nCannot find a '".page."'."
                                return
                              endif
                              exec "let s:man_tag_buf_".s:man_tag_depth." = ".bufnr("%")
                              exec "let s:man_tag_lin_".s:man_tag_depth." = ".line(".")
                              exec "let s:man_tag_col_".s:man_tag_depth." = ".col(".")
                              let s:man_tag_depth = s:man_tag_depth + 1
                            
                              " Use an existing "man" window if it exists, otherwise open a new one.
                              if &filetype != "man"
                                let thiswin = winnr()
                                exe "norm! \<C-W>b"
                                if winnr() > 1
                                  exe "norm! " . thiswin . "\<C-W>w"
                                  while 1
                            	if &filetype == "man"
                            	  break
                            	endif
                            	exe "norm! \<C-W>w"
                            	if thiswin == winnr()
                            	  break
                            	endif
                                  endwhile
                                endif
                                if &filetype != "man"
                                  if exists("g:ft_man_open_mode")
                                    if g:ft_man_open_mode == "vert"
                                      vnew
                                    elseif g:ft_man_open_mode == "tab"
                                      tabnew
                                    else
                                      new
                                    endif
                                  else
                            	if a:cmdmods != ''
                            	  exe a:cmdmods . ' new'
                            	else
                            	  new
                            	endif
                                  endif
                                  setl nonu fdc=0
                                endif
                              endif
                              silent exec "edit $HOME/".page.".".sect."~"
                              " Avoid warning for editing the dummy file twice
                              setl buftype=nofile noswapfile
                            
                              setl ma nonu nornu nofen
                              silent exec "norm! 1GdG"
                              let unsetwidth = 0
                              if empty($MANWIDTH)
                                let $MANWIDTH = winwidth(0)
                                let unsetwidth = 1
                              endif
                            
                              " Ensure Vim is not recursively invoked (man-db does this) when doing ctrl-[
                              " on a man page reference by unsetting MANPAGER.
                              " Some versions of env(1) do not support the '-u' option, and in such case
                              " we set MANPAGER=cat.
                              if !exists('s:env_has_u')
                                call system('env -u x true')
                                let s:env_has_u = (v:shell_error == 0)
                              endif
                              let env_cmd = s:env_has_u ? 'env -u MANPAGER' : 'env MANPAGER=cat'
                              let man_cmd = env_cmd . ' man ' . s:GetCmdArg(sect, page) . ' | col -b'
                              silent exec "r !" . man_cmd
                            
                              if unsetwidth
                                let $MANWIDTH = ''
                              endif
                              " Remove blank lines from top and bottom.
                              while getline(1) =~ '^\s*$'
                                silent keepj norm! ggdd
                              endwhile
                              while getline('$') =~ '^\s*$'
                                silent keepj norm! Gdd
                              endwhile
                              1
                              setl ft=man nomod
                              setl bufhidden=hide
                              setl nobuflisted
                              setl noma

FUNCTION  go#util#ModuleRoot()
Called 1 time
Total time:   0.023270
 Self time:   0.000102

count  total (s)   self (s)
    1   0.023176   0.000018   let [l:out, l:err] = go#util#ExecInDir(['go', 'env', 'GOMOD'])
    1              0.000005   if l:err != 0
                                return -1
    1              0.000001   endif
                            
    1              0.000041   let l:module = split(l:out, '\n', 1)[0]
                            
                              " When run with `GO111MODULE=on and not in a module directory, the module will be reported as /dev/null.
    1              0.000003   let l:fakeModule = '/dev/null'
    1   0.000018   0.000008   if go#util#IsWin()
                                let l:fakeModule = 'NUL'
    1              0.000001   endif
                            
    1              0.000003   if l:fakeModule == l:module
                                return expand('%:p:h')
    1              0.000000   endif
                            
    1              0.000010   return fnamemodify(l:module, ':p:h')

FUNCTION  FugitivePrepare()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return call('fugitive#Prepare', a:000)

FUNCTION  <SNR>57_LP_Execute()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            "  call Dfunc("LP_Execute(preclvl=".a:preclvl.") npatstack=".s:npatstack." nopstack=".s:nopstack)
                            
                              " execute all higher precedence operators
                              while s:nopstack > 0 && a:preclvl < s:opprec_{s:nopstack}
                               let op= s:opstack_{s:nopstack}
                            "   call Decho("op<".op."> nop=".s:nopstack." [preclvl=".a:preclvl."] < [opprec_".s:nopstack."=".s:opprec_{s:nopstack}."]")
                            
                               let s:nopstack = s:nopstack - 1
                             
                               if     op == '!'
                                let n1= s:LP_PatPop(1)
                            	call s:LP_PatPush(s:LP_Not(n1))
                             
                               elseif op == '|'
                                let n1= s:LP_PatPop(1)
                                let n2= s:LP_PatPop(1)
                                call s:LP_PatPush(s:LP_Or(n2,n1))
                             
                               elseif op =~ '&'
                                let n1= s:LP_PatPop(1)
                                let n2= s:LP_PatPop(1)
                                call s:LP_PatPush(s:LP_And(n2,n1))
                               endif
                             
                            "   call s:StackLook("execute") "Decho
                              endwhile
                            
                            "  call Dret("LP_Execute")

FUNCTION  fugitive#setfperm()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              let entry = s:PathInfo(a:url)
                              let perm = fugitive#getfperm(a:url)
                              if commit !~# '^\d$' || entry[2] !=# 'blob' || substitute(perm, 'x', '-', 'g') !=# substitute(a:perm, 'x', '-', 'g')
                                return -2
                              endif
                              let exec_error = s:SystemError([dir, 'update-index', '--index-info'], (a:perm =~# 'x' ? '000755 ' : '000644 ') . entry[3] . ' ' . commit . "\t" . file[1:-1])[1]
                              return exec_error ? -1 : 0

FUNCTION  <SNR>103_TempCmd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let prefix = ''
                              try
                                let cmd = (type(a:cmd) == type([]) ? fugitive#Prepare(a:cmd) : a:cmd)
                                let redir = ' > ' . a:out
                                if s:winshell()
                                  let cmd_escape_char = &shellxquote == '(' ?  '^' : '^^^'
                                  return s:SystemError('cmd /c "' . prefix . s:gsub(cmd, '[<>]', cmd_escape_char . '&') . redir . '"')
                                elseif &shell =~# 'fish'
                                  return s:SystemError(' begin;' . prefix . cmd . redir . ';end ')
                                else
                                  return s:SystemError(' (' . prefix . cmd . redir . ') ')
                                endif
                              endtry

FUNCTION  <SNR>49_inputtarget()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let c = s:getchar()
                              while c =~ '^\d\+$'
                                let c .= s:getchar()
                              endwhile
                              if c == " "
                                let c .= s:getchar()
                              endif
                              if c =~ "\<Esc>\|\<C-C>\|\0"
                                return ""
                              else
                                return c
                              endif

FUNCTION  sy#util#refresh_windows()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('*win_getid')
                                let winid = win_getid()
                              else
                                let winnr = winnr()
                              endif
                            
                              if !get(g:, 'signify_cmdwin_active')
                                keepjumps windo if exists('b:sy') | call sy#start() | endif
                              endif
                            
                              if exists('winid')
                                call win_gotoid(winid)
                              else
                                execute winnr .'wincmd w'
                              endif

FUNCTION  <SNR>94_callback2on_stdout()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let self.stdout_buf = s:neocb(a:mode, a:ch, self.stdout_buf, a:data, self.callback)

FUNCTION  <SNR>103_PreviousFile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              exe s:StageInline('hide')
                              for i in range(a:count)
                                if !search(s:file_pattern, 'Wb')
                                  break
                                endif
                                exe s:StageInline('hide')
                              endfor
                              return '.'

FUNCTION  <SNR>103_diff_modifier()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let fdc = matchstr(&diffopt, 'foldcolumn:\zs\d\+')
                              if &diffopt =~# 'horizontal' && &diffopt !~# 'vertical'
                                return ''
                              elseif &diffopt =~# 'vertical'
                                return 'vertical '
                              elseif winwidth(0) <= a:count * ((&tw ? &tw : 80) + (empty(fdc) ? 2 : fdc))
                                return ''
                              else
                                return 'vertical '
                              endif

FUNCTION  <SNR>92_requestComplete()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000005   if self.statustype == ''
    1              0.000013     return
                              endif
                            
                              if go#config#EchoCommandInfo()
                                let prefix = '[' . self.statustype . '] '
                                if a:ok
                                  call go#util#EchoSuccess(prefix . "SUCCESS")
                                else
                                  call go#util#EchoError(prefix . "FAIL")
                                endif
                              endif
                            
                              let status = { 'desc': 'last status', 'type': self.statustype, 'state': "success", }
                            
                              if !a:ok
                                let status.state = "failed"
                              endif
                            
                              if has_key(self, 'started_at')
                                let elapsed_time = reltimestr(reltime(self.started_at))
                                " strip whitespace
                                let elapsed_time = substitute(elapsed_time, '^\s*\(.\{-}\)\s*$', '\1', '')
                                let status.state .= printf(" (%ss)", elapsed_time)
                              endif
                            
                              call go#statusline#Update(self.jobdir, status)

FUNCTION  <SNR>51_Tree()
Called 2 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    2              0.000005   let dir = a:path
    2              0.000015   if dir =~# '/\.git$'
    1              0.000017     return len(dir) ==# 5 ? '/' : dir[0:-6]
    1              0.000001   elseif dir ==# ''
    1              0.000001     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = s:Slash(FugitiveVimPath(matchstr(config[0], '= *\zs.*')))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = s:Slash(fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h'))
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = worktree
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  <SNR>49_extractafter()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:str =~ '\r'
                                return matchstr(a:str,'\r\zs.*')
                              else
                                return matchstr(a:str,'\n\zs.*')
                              endif

FUNCTION  go#config#GuruScope()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let scope = get(g:, 'go_guru_scope', [])
                            
                              if !empty(scope)
                                " strip trailing slashes for each path in scope. bug:
                                " https://github.com/golang/go/issues/14584
                                let scopes = go#util#StripTrailingSlash(scope)
                              endif
                            
                              return scope

FUNCTION  <SNR>103_BlameCommitFileLnum()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let line = a:0 ? a:1 : getline('.')
                              let state = a:0 ? a:2 : s:TempState()
                              let commit = matchstr(line, '^\^\=\zs\x\+')
                              if commit =~# '^0\+$'
                                let commit = ''
                              elseif line !~# '^\^' && has_key(state, 'blame_reverse_end')
                                let commit = get(s:LinesError('rev-list', '--ancestry-path', '--reverse', commit . '..' . state.blame_reverse_end)[0], 0, '')
                              endif
                              let lnum = +matchstr(line, ' \zs\d\+\ze \%((\| *\d\+)\)')
                              let path = matchstr(line, '^\^\=[?*]*\x* \+\%(\d\+ \+\d\+ \+\)\=\zs.\{-\}\ze\s\+\%(\%( \d\+ \)\@<!([^()]*\w \d\+)\|\d\+ \)')
                              if empty(path) && lnum
                                let path = get(state, 'blame_file', '')
                              endif
                              return [commit, path, lnum]

FUNCTION  <SNR>28_Drag_Block()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " Clean up the temporary convenience...
                                nunmap <buffer>  M
                            
                                " Locate block being shifted...
                                let [buf_left,  line_left,  col_left,  offset_left ] = getpos("'<")
                                let [buf_right, line_right, col_right, offset_right] = getpos("'>")
                            
                                " Identify special '$' blocks...
                                let dollar_block = 0
                                let start_col    = min([col_left+offset_left, col_right+offset_right])
                                let end_col      = max([col_left+offset_left, col_right+offset_right])
                                let visual_width = end_col - start_col + 1
                                for visual_line in split(getreg("v"),"\n")
                                    if strlen(visual_line) > visual_width
                                        let dollar_block = 1
                                        let visual_width = strlen(visual_line)
                                    endif
                                endfor
                                let square_up = (dollar_block ? (start_col+visual_width-2).'|' : '')
                            
                                " Drag left...
                                if a:dir == 'left'
                                    "Can't drag left at left margin...
                                    if col_left == 1 || col_right == 1
                                        return 'gv'
                            
                                    " Otherwise reposition one column left (and optionally trim any whitespace)...
                                    elseif g:DVB_TrimWS
                                        " May need to be able to temporarily step past EOL...
                                        let prev_ve = &virtualedit
                                        set virtualedit=all
                            
                                        " Are we moving past other text???
                                        let square_up_final = ""
                                        if dollar_block
                                            let lines = getline(line_left, line_right)
                                            if match(lines, '^.\{'.(start_col-2).'}\S') >= 0
                                                let dollar_block = 0
                                                let square_up_final = (start_col+visual_width-3).'|'
                                            endif
                                        endif
                            
                                        let vcol = start_col - 2
                                        return   'gv'.square_up.'xhP' . s:NO_REPORT . "gvhoho:s/\\s\\+$//e\<CR>gv\<ESC>" . ':set virtualedit=' . prev_ve . "\<CR>" . s:PREV_REPORT . ":nohlsearch\<CR>gv" . (dollar_block ? '$' : square_up_final )
                                    else
                                        return 'gv'.square_up.'xhPgvhoho'
                                    endif
                            
                                " Drag right...
                                elseif a:dir == 'right'
                                    " May need to be able to temporarily step past EOL...
                                    let prev_ve = &virtualedit
                                    set virtualedit=all
                            
                                    " Reposition block one column to the right...
                                    if g:DVB_TrimWS
                                        let vcol = start_col
                                        return   'gv'.square_up.'xp' . s:NO_REPORT . "gvlolo" . ":s/\\s\\+$//e\<CR>gv\<ESC>" . ":nohlsearch\<CR>:set virtualedit=" . prev_ve . "\<CR>" . s:PREV_REPORT . (dollar_block ? 'gv$' : 'gv')
                                    else
                                        return 'gv'.square_up.'xp:set virtualedit=' . prev_ve . "\<CR>gvlolo"
                                    endif
                            
                                " Drag upwards...
                                elseif a:dir == 'up'
                                    " Can't drag upwards at top margin...
                                    if line_left == 1 || line_right == 1
                                        return 'gv'
                                    endif
                            
                                    " May need to be able to temporarily step past EOL...
                                    let prev_ve = &virtualedit
                                    set virtualedit=all
                            
                                    " If trimming whitespace, jump to just below block to do it...
                                    if g:DVB_TrimWS
                                        let height = line_right - line_left + 1
                                        return  'gv'.square_up.'xkPgvkoko"vy' . height . 'j:s/\s\+$//e' . "\<CR>:nohlsearch\<CR>:set virtualedit=" . prev_ve . "\<CR>gv" . (dollar_block ? '$' : '')
                            
                                    " Otherwise just move and reselect...
                                    else
                                        return   'gv'.square_up.'xkPgvkoko"vy:set virtualedit=' . prev_ve . "\<CR>gv" . (dollar_block ? '$' : '')
                                    endif
                            
                                " Drag downwards...
                                elseif a:dir == 'down'
                                    " May need to be able to temporarily step past EOL...
                                    let prev_ve = &virtualedit
                                    set virtualedit=all
                            
                                    " If trimming whitespace, move to just above block to do it...
                                    if g:DVB_TrimWS
                                        return   'gv'.square_up.'xjPgvjojo"vyk:s/\s\+$//e' . "\<CR>:nohlsearch\<CR>:set virtualedit=" . prev_ve . "\<CR>gv" . (dollar_block ? '$' : '')
                            
                                    " Otherwise just move and reselect...
                                    else
                                        return   'gv'.square_up.'xjPgvjojo"vy' . "\<CR>:set virtualedit=" . prev_ve . "\<CR>gv" . (dollar_block ? '$' : '')
                                    endif
                                endif

FUNCTION  <SNR>103_PreviousHunk()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for i in range(a:count)
                                if &filetype ==# 'fugitive'
                                  let lnum = search(s:file_pattern . '\|^@','Wbn')
                                  call s:StageInline('show', lnum)
                                  call search('^? .\|^@','Wb')
                                else
                                  call search('^@@', 'Wb')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'

FUNCTION  go#guru#SameIds()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " we use matchaddpos() which was introduce with 7.4.330, be sure we have
                              " it: http://ftp.vim.org/vim/patches/7.4/7.4.330
                              if !exists("*matchaddpos")
                                call go#util#EchoError("GoSameIds requires 'matchaddpos'. Update your Vim/Neovim version.")
                                return
                              endif
                            
                              " json_encode() and friends are introduced with this patch (7.4.1304)
                              " vim: https://groups.google.com/d/msg/vim_dev/vLupTNhQhZ8/cDGIk0JEDgAJ
                              " nvim: https://github.com/neovim/neovim/pull/4131
                              if !exists("*json_decode")
                                call go#util#EchoError("GoSameIds requires 'json_decode'. Update your Vim/Neovim version.")
                                return
                              endif
                            
                              let args = { 'mode': 'what', 'format': 'json', 'selected': -1, 'needs_scope': 0, 'custom_parse': function('s:same_ids_highlight'), }
                              if !a:showstatus
                                let args.disable_progress = 1
                              endif
                            
                              call s:run_guru(args)

FUNCTION  <SNR>34_send()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if type(a:func) == type('') || type(a:func) == type(0)
                                let l:Func = get(a:self,a:func,'')
                              else
                                let l:Func = a:func
                              endif
                              let s = type(a:self) == type({}) ? a:self : {}
                              if type(Func) == type(function('tr'))
                                return call(Func,a:000,s)
                              elseif type(Func) == type({}) && has_key(Func,'apply')
                                return call(Func.apply,a:000,Func)
                              elseif type(Func) == type({}) && has_key(Func,'call')
                                return call(Func.call,a:000,s)
                              elseif type(Func) == type('') && Func == '' && has_key(s,'function missing')
                                return call('s:send',[s,'function missing',a:func] + a:000)
                              else
                                return Func
                              endif

FUNCTION  go#config#AutoSameids()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000007     return get(g:, 'go_auto_sameids', 0)

FUNCTION  fugitive#ReadComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:L =~# '^\w\+!'
                                return fugitive#Complete(a:A, a:L, a:P)
                              else
                                return fugitive#CompleteObject(a:A, a:L, a:P)
                              endif

FUNCTION  TCommentOpFunc_Commentl()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_Commentl')
                            
                            return call('tcomment#operator#Line', a:000)

FUNCTION  <SNR>34_dispatcher()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let i = 0
                              let args = copy(a:args)
                              let command = s:commands.abbrev
                              while i < len(args)
                                if args[i] =~# '^-\w\+$' && has_key(s:commands,matchstr(args[i],'-\zs.*'))
                                  let command = s:commands[matchstr(args[i],'-\zs.*')]
                                  call remove(args,i)
                                  break
                                endif
                                let i += 1
                              endwhile
                              try
                                return command.dispatch(a:bang,a:line1,a:line2,a:count,args)
                              catch /^Abolish: /
                                echohl ErrorMsg
                                echo   v:errmsg
                                echohl NONE
                                return ""
                              endtry

FUNCTION  FugitiveConfig()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:0 == 2 && type(a:2) != type({})
                                return fugitive#Config(a:1, FugitiveGitDir(a:2))
                              elseif a:0 == 1 && a:1 !~# '^[[:alnum:]-]\+\.'
                                return fugitive#Config(FugitiveGitDir(a:1))
                              else
                                return call('fugitive#Config', a:000)
                              endif

FUNCTION  <SNR>94_callback2on_stderr()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let self.stderr_buf = s:neocb(a:mode, a:ch, self.stderr_buf, a:data, self.callback)

FUNCTION  <SNR>7_ParseWords()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let groups = substitute(a:groups.",", s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
                              let groups = substitute(groups, s:notslash . '\zs:\{2,}', ':', 'g')
                              let parsed = ""
                              while groups =~ '[^,:]'
                                let i = matchend(groups, s:notslash . ':')
                                let j = matchend(groups, s:notslash . ',')
                                let ini = strpart(groups, 0, i-1)
                                let tail = strpart(groups, i, j-i-1) . ":"
                                let groups = strpart(groups, j)
                                let parsed = parsed . ini
                                let i = matchend(tail, s:notslash . ':')
                                while i != -1
                                  " In 'if:else:endif', ini='if' and word='else' and then word='endif'.
                                  let word = strpart(tail, 0, i-1)
                                  let tail = strpart(tail, i)
                                  let i = matchend(tail, s:notslash . ':')
                                  let parsed = parsed . ":" . s:Resolve(ini, word, "word")
                                endwhile " Now, tail has been used up.
                                let parsed = parsed . ","
                              endwhile " groups =~ '[^,:]'
                              let parsed = substitute(parsed, ',$', '', '')
                              return parsed

FUNCTION  go#config#DefReuseBuffer()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_def_reuse_buffer', 0)

FUNCTION  <SNR>34_sort()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:a ==? a:b
                                return a:a == a:b ? 0 : a:a > a:b ? 1 : -1
                              elseif strlen(a:a) == strlen(a:b)
                                return a:a >? a:b ? 1 : -1
                              else
                                return strlen(a:a) < strlen(a:b) ? 1 : -1
                              endif

FUNCTION  <SNR>103_FormatLog()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:dict.commit . ' ' . a:dict.subject

FUNCTION  <SNR>103_DoToggleHeadHeader()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              exe 'edit' s:fnameescape(s:Dir())
                              call search('\C^index$', 'wc')

FUNCTION  <SNR>103_DoStageUnstaged()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:DoToggleUnstaged(a:record)

FUNCTION  go#util#Windo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let s:currentWindow = winnr()
                              try
                                execute "windo " . a:command
                              finally
                                execute s:currentWindow. "wincmd w"
                                unlet s:currentWindow
                              endtry

FUNCTION  fugitive#FileReadCmd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let [dir, rev] = s:DirRev(amatch)
                              let line = a:0 > 1 ? a:2 : line("'[")
                              if empty(dir)
                                return 'noautocmd ' . line . 'read ' . s:fnameescape(amatch)
                              endif
                              if rev !~# ':' && s:ChompDefault('', [dir, 'cat-file', '-t', rev]) =~# '^\%(commit\|tag\)$'
                                let cmd = fugitive#Prepare(dir, 'log', '--pretty=format:%B', '-1', rev, '--')
                              else
                                let cmd = fugitive#Prepare(dir, 'cat-file', '-p', rev)
                              endif
                              return line . 'read !' . escape(cmd, '!#%')

FUNCTION  <SNR>33_as_keymapping()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return eval('"' . substitute(escape(a:key, '\"'), '\(<.\{-}>\)', '\\\1', 'g') . '"')

FUNCTION  go#config#ListTypeCommands()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return get(g:, 'go_list_type_commands', {})

FUNCTION  fugitive#glob()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [dirglob, commit, glob] = s:DirCommitFile(a:url)
                              let append = matchstr(glob, '/*$')
                              let glob = substitute(glob, '/*$', '', '')
                              let pattern = '^' . substitute(glob, '/\=\*\*/\=\|/\=\*\|[.?\$]\|^^', '\=get(s:globsubs, submatch(0), "\\" . submatch(0))', 'g')[1:-1] . '$'
                              let results = []
                              for dir in dirglob =~# '[*?]' ? split(glob(dirglob), "\n") : [dirglob]
                                if empty(dir) || !get(g:, 'fugitive_file_api', 1) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                  continue
                                endif
                                let files = items(s:TreeInfo(dir, commit)[0])
                                if len(append)
                                  call filter(files, 'v:val[1][2] ==# "tree"')
                                endif
                                call map(files, 'v:val[0]')
                                call filter(files, 'v:val =~# pattern')
                                let prepend = 'fugitive://' . dir . '//' . substitute(commit, '^:', '', '') . '/'
                                call sort(files)
                                call map(files, 'FugitiveVimPath(prepend . v:val . append)')
                                call extend(results, files)
                              endfor
                              if a:0 > 1 && a:2
                                return results
                              else
                                return join(results, "\n")
                              endif

FUNCTION  <SNR>103_PatchSearchExpr()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let line = getline('.')
                              if col('.') ==# 1 && line =~# '^[+-]'
                                if line =~# '^[+-]\{3\} '
                                  let pattern = '^[+-]\{3\} ' . substitute(escape(strpart(line, 4), '^$.*[]~\'), '^\w/', '\\w/', '') . '$'
                                else
                                  let pattern = '^[+-]\s*' . escape(substitute(strpart(line, 1), '^\s*\|\s*$', '', ''), '^$.*[]~\') . '\s*$'
                                endif
                                if a:reverse
                                  return '?' . escape(pattern, '/') . "\<CR>"
                                else
                                  return '/' . escape(pattern, '/?') . "\<CR>"
                                endif
                              endif
                              return a:reverse ? '#' : '*'

FUNCTION  go#config#AutodetectGopath()
Called 3 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    3              0.000015 	return get(g:, 'go_autodetect_gopath', 0)

FUNCTION  go#config#HighlightVariableAssignments()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000012   return get(g:, 'go_highlight_variable_assignments', 0)

FUNCTION  go#lsp#message#Shutdown()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return { 'notification': 0, 'method': 'shutdown', }

FUNCTION  go#config#HighlightBuildConstraints()
Called 6 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    6              0.000022   return get(g:, 'go_highlight_build_constraints', 0)

FUNCTION  <SNR>93_CygwinPath()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                               return substitute(a:path, '\\', '/', "g")

FUNCTION  go#lsp#message#TypeDefinition()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return { 'notification': 0, 'method': 'textDocument/typeDefinition', 'params': {   'textDocument': {       'uri': go#path#ToURI(a:file)   },   'position': s:position(a:line, a:col) } }

FUNCTION  <SNR>103_BlameJump()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let suffix = a:suffix
                              let [commit, path, lnum] = s:BlameCommitFileLnum()
                              if empty(path)
                                return 'echoerr ' . string('fugitive: could not determine filename for blame')
                              endif
                              if commit =~# '^0*$'
                                let commit = 'HEAD'
                                let suffix = ''
                              endif
                              let offset = line('.') - line('w0')
                              let flags = get(s:TempState(), 'blame_flags', [])
                              if a:0 && a:1
                                if s:HasOpt(flags, '--reverse')
                                  call remove(flags, '--reverse')
                                else
                                  call add(flags, '--reverse')
                                endif
                              endif
                              let blame_bufnr = s:BlameBufnr()
                              if blame_bufnr > 0
                                let bufnr = bufnr('')
                                let winnr = bufwinnr(blame_bufnr)
                                if winnr > 0
                                  exe winnr.'wincmd w'
                                endif
                                execute 'Gedit' s:fnameescape(commit . suffix . ':' . path)
                                execute lnum
                                if winnr > 0
                                  exe bufnr.'bdelete'
                                endif
                              endif
                              if exists(':Gblame')
                                let my_bufnr = bufnr('')
                                if blame_bufnr < 0
                                  let blame_args = flags + [commit . suffix, '--', path]
                                  let result = s:BlameSubcommand(0, 0, 0, 0, '', blame_args)
                                else
                                  let blame_args = flags
                                  let result = s:BlameSubcommand(-1, -1, 0, 0, '', blame_args)
                                endif
                                if bufnr('') == my_bufnr
                                  return result
                                endif
                                execute result
                                execute lnum
                                let delta = line('.') - line('w0') - offset
                                if delta > 0
                                  execute 'normal! '.delta."\<C-E>"
                                elseif delta < 0
                                  execute 'normal! '.(-delta)."\<C-Y>"
                                endif
                                keepjumps syncbind
                                redraw
                                echo ':Gblame' s:fnameescape(blame_args)
                              endif
                              return ''

FUNCTION  go#config#StatuslineDuration()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_statusline_duration', 60000)

FUNCTION  <SNR>94_on_exit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call self.exit_cb(a:jobid, a:exitval)

FUNCTION  <SNR>103_throw()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              throw 'fugitive: '.a:string

FUNCTION  <SNR>103_AddHeader()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if empty(a:value)
                                return
                              endif
                              let before = 1
                              while !empty(getline(before))
                                let before += 1
                              endwhile
                              call append(before - 1, [a:key . ':' . (len(a:value) ? ' ' . a:value : '')])
                              if before == 1 && line('$') == 2
                                silent 2delete _
                              endif

FUNCTION  gutentags#ctags#generate()
Called 2 times
Total time:   0.005861
 Self time:   0.000746

count  total (s)   self (s)
    2              0.000008     let l:write_mode = a:gen_opts['write_mode']
                            
    2              0.000028     let l:tags_file_exists = filereadable(a:tags_file)
    2              0.000028     let l:tags_file_relative = fnamemodify(a:tags_file, ':.')
    2              0.000011     let l:tags_file_is_local = len(l:tags_file_relative) < len(a:tags_file)
                            
    2              0.000005     if l:tags_file_exists && g:gutentags_ctags_check_tagfile
                                    let l:first_lines = readfile(a:tags_file, '', 1)
                                    if len(l:first_lines) == 0 || stridx(l:first_lines[0], '!_TAG_') != 0
                                        call gutentags#throw("File ".a:tags_file." doesn't appear to be "."a ctags file. Please delete it and run ".":GutentagsUpdate!.")
                                        return
                                    endif
    2              0.000002     endif
                            
    2              0.000007     if empty(g:gutentags_cache_dir) && l:tags_file_is_local
                                    " If we don't use the cache directory, we can pass relative paths
                                    " around.
                                    "
                                    " Note that if we don't do this and pass a full path for the project
                                    " root, some `ctags` implementations like Exhuberant Ctags can get
                                    " confused if the paths have spaces -- but not if you're *in* the root 
                                    " directory, for some reason... (which we are, our caller in
                                    " `autoload/gutentags.vim` changed it).
                                    let l:actual_proj_dir = '.'
                                    let l:actual_tags_file = l:tags_file_relative
    2              0.000002     else
                                    " else: the tags file goes in a cache directory, so we need to specify
                                    " all the paths absolutely for `ctags` to do its job correctly.
    2              0.000004         let l:actual_proj_dir = a:proj_dir
    2              0.000004         let l:actual_tags_file = a:tags_file
    2              0.000001     endif
                            
                                " Build the command line.
    2              0.000005     let l:cmd = [s:runner_exe]
    2   0.000119   0.000022     let l:cmd += ['-e', '"' . s:get_ctags_executable(a:proj_dir) . '"']
    2              0.000010     let l:cmd += ['-t', '"' . l:actual_tags_file . '"']
    2              0.000008     let l:cmd += ['-p', '"' . l:actual_proj_dir . '"']
    2              0.000005     if l:write_mode == 0 && l:tags_file_exists
    1              0.000018         let l:cur_file_path = expand('%:p')
    1              0.000004         if empty(g:gutentags_cache_dir) && l:tags_file_is_local
                                        let l:cur_file_path = fnamemodify(l:cur_file_path, ':.')
    1              0.000001         endif
    1              0.000005         let l:cmd += ['-s', '"' . l:cur_file_path . '"']
    1              0.000000     else
    1   0.000026   0.000007         let l:file_list_cmd = gutentags#get_project_file_list_cmd(l:actual_proj_dir)
    1              0.000003         if !empty(l:file_list_cmd)
                                        if match(l:file_list_cmd, '///') > 0
                                            let l:suffopts = split(l:file_list_cmd, '///')
                                            let l:suffoptstr = l:suffopts[1]
                                            let l:file_list_cmd = l:suffopts[0]
                                            if l:suffoptstr == 'absolute'
                                                let l:cmd += ['-A']
                                            endif
                                        endif
                                        let l:cmd += ['-L', '"' . l:file_list_cmd. '"']
    1              0.000001         endif
    2              0.000002     endif
    2              0.000007     if empty(get(l:, 'file_list_cmd', ''))
                                    " Pass the Gutentags recursive options file before the project
                                    " options file, so that users can override --recursive.
                                    " Omit --recursive if this project uses a file list command.
    2   0.000027   0.000019         let l:cmd += ['-o', '"' . gutentags#get_res_file('ctags_recursive.options') . '"']
    2              0.000002     endif
    2              0.000005     if !empty(g:gutentags_ctags_extra_args)
                                    let l:cmd += ['-O', shellescape(join(g:gutentags_ctags_extra_args))]
    2              0.000002     endif
    2              0.000005     if !empty(g:gutentags_ctags_post_process_cmd)
                                    let l:cmd += ['-P', shellescape(g:gutentags_ctags_post_process_cmd)]
    2              0.000002     endif
    2              0.000009     let l:proj_options_file = a:proj_dir . '/' .g:gutentags_ctags_options_file
    2              0.000017     if filereadable(l:proj_options_file)
                                    let l:proj_options_file = s:process_options_file(a:proj_dir, l:proj_options_file)
                                    let l:cmd += ['-o', '"' . l:proj_options_file . '"']
    2              0.000002     endif
    2              0.000004     if g:gutentags_ctags_exclude_wildignore
    2   0.003637   0.000016         call s:generate_wildignore_options()
    2              0.000008         if !empty(s:wildignores_options_path)
    2              0.000055             let l:cmd += ['-x', shellescape('@'.s:wildignores_options_path, 1)]
    2              0.000002         endif
    2              0.000002     endif
    2              0.000007     for exc in g:gutentags_ctags_exclude
                                    let l:cmd += ['-x', '"' . exc . '"']
    2              0.000003     endfor
    2              0.000003     if g:gutentags_pause_after_update
                                    let l:cmd += ['-c']
    2              0.000002     endif
    2              0.000002     if g:gutentags_trace
                                    let l:cmd += ['-l', '"' . l:actual_tags_file . '.log"']
    2              0.000002     endif
    2   0.000557   0.000019     let l:cmd = gutentags#make_args(l:cmd)
                            
    2   0.000055   0.000039     call gutentags#trace("Running: " . string(l:cmd))
    2   0.000035   0.000022     call gutentags#trace("In:      " . getcwd())
    2              0.000004     if !g:gutentags_fake
    2   0.000060   0.000016         let l:job_opts = gutentags#build_default_job_options('ctags')
    2   0.000777   0.000057         let l:job = gutentags#start_job(l:cmd, l:job_opts)
    2   0.000083   0.000044         call gutentags#add_job('ctags', a:tags_file, l:job)
                                else
                                    call gutentags#trace("(fake... not actually running)")
    2              0.000006     endif

FUNCTION  go#util#has_job()
Called 6 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    6              0.000041   if has('nvim')
                                return 1
    6              0.000007   endif
                            
                              " cwd and env parameters to job_start was added in this version.
    6              0.000034   if a:0 > 0 && a:1 is 1
                                return has('job') && has("patch-8.0.0902")
    6              0.000002   endif
                            
                              " job was introduced in 7.4.xxx however there are multiple bug fixes and one
                              " of the latest is 8.0.0087 which is required for a stable async API.
    6              0.000036   return has('job') && has("patch-8.0.0087")

FUNCTION  gutentags#toggletrace()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let g:gutentags_trace = !g:gutentags_trace
                                if a:0 > 0
                                    let g:gutentags_trace = a:1
                                endif
                                if g:gutentags_trace
                                    echom "gutentags: Tracing is enabled."
                                else
                                    echom "gutentags: Tracing is disabled."
                                endif
                                echom ""

FUNCTION  fugitive#RenameComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:A =~# '^[.:]\=/'
                                return fugitive#CompletePath(a:A)
                              else
                                let pre = s:Slash(fnamemodify(expand('%:p:s?[\/]$??'), ':h')) . '/'
                                return map(fugitive#CompletePath(pre.a:A), 'strpart(v:val, len(pre))')
                              endif

FUNCTION  <SNR>103_NextSectionEnd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              +
                              if empty(getline('.'))
                                +
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern, 'W')
                                  return '$'
                                endif
                              endfor
                              return search('^.', 'Wb')

FUNCTION  go#config#TermWidth()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_term_width', winwidth(0))

FUNCTION  <SNR>44_LinuxConfigure()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let apply_style = 0
                            
                                if exists("g:linuxsty_patterns")
                                    let path = expand('%:p')
                                    for p in g:linuxsty_patterns
                                        if path =~ p
                                            let apply_style = 1
                                            break
                                        endif
                                    endfor
                                else
                                    let apply_style = 1
                                endif
                            
                                if apply_style
                                    call s:LinuxCodingStyle()
                                endif

FUNCTION  go#lsp#message#WorkspaceFoldersResult()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return map(copy(a:dirs), function('s:workspaceFolder', []))

FUNCTION  go#config#VersionWarning()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007   return get(g:, 'go_version_warning', 1)

FUNCTION  go#config#AddtagsTransform()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_addtags_transform', "snakecase")

FUNCTION  <SNR>102_generate_wildignore_options()
Called 2 times
Total time:   0.003621
 Self time:   0.003579

count  total (s)   self (s)
    2              0.000011     if s:last_wildignores == &wildignore
                                    " The 'wildignore' setting didn't change since last time we did this.
    1   0.000016   0.000008         call gutentags#trace("Wildignore options file is up to date.")
    1              0.000002         return
    1              0.000000     endif
                            
    1              0.000002     if s:wildignores_options_path == ''
    1              0.000003         if empty(g:gutentags_cache_dir)
                                        let s:wildignores_options_path = tempname()
    1              0.000001         else
    1   0.000034   0.000007             let s:wildignores_options_path = gutentags#stripslash(g:gutentags_cache_dir).'/_wildignore.options'
    1              0.000001         endif
    1              0.000000     endif
                            
    1   0.000015   0.000008     call gutentags#trace("Generating wildignore options: ".s:wildignores_options_path)
    1              0.000003     let l:opt_lines = []
   45              0.000076     for ign in split(&wildignore, ',')
   44              0.000132         call add(l:opt_lines, ign)
   45              0.000044     endfor
    1              0.003239     call writefile(l:opt_lines, s:wildignores_options_path)
    1              0.000008     let s:last_wildignores = &wildignore

FUNCTION  go#guru#Scope()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:0
                                let scope = a:000
                                if a:0 == 1 && a:1 == '""'
                                  let scope = []
                                endif
                            
                                call go#config#SetGuruScope(scope)
                                if empty(scope)
                                  call go#util#EchoSuccess("guru scope is cleared")
                                else
                                  call go#util#EchoSuccess("guru scope changed to: ". join(a:000, ","))
                                endif
                            
                                return
                              endif
                            
                              let scope = go#config#GuruScope()
                              if empty(scope)
                                call go#util#EchoError("guru scope is not set")
                              else
                                call go#util#EchoSuccess("current guru scope: ". join(scope, ","))
                              endif

FUNCTION  go#lsp#DidClose()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !filereadable(a:fname)
                                return
                              endif
                            
                              if !get(b:, 'go_lsp_did_open', 0)
                                return
                              endif
                            
                              let l:lsp = s:lspfactory.get()
                              let l:msg = go#lsp#message#DidClose(fnamemodify(a:fname, ':p'))
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:noop')
                              " TODO(bc): setting a buffer level variable here assumes that a:fname is the
                              " current buffer. Change to a:fname first before setting it and then change
                              " back to active buffer.
                              let b:go_lsp_did_open = 0
                            
                              return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  <SNR>103_BlameSubcommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              exe s:DirCheck()
                              let flags = copy(a:args)
                              let i = 0
                              let raw = 0
                              let commits = []
                              let files = []
                              let ranges = []
                              if a:line1 > 0 && a:count > 0 && a:range != 1
                                call extend(ranges, ['-L', a:line1 . ',' . a:count])
                              endif
                              while i < len(flags)
                                let match = matchlist(flags[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(flags, match[1])
                                  let flags[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = flags[i]
                                if arg =~# '^-p$\|^--\%(help\|porcelain\|line-porcelain\|incremental\)$'
                                  let raw = 1
                                elseif arg ==# '--contents' && i + 1 < len(flags)
                                  call extend(commits, remove(flags, i, i+1))
                                  continue
                                elseif arg ==# '-L' && i + 1 < len(flags)
                                  call extend(ranges, remove(flags, i, i+1))
                                  continue
                                elseif arg =~# '^--contents='
                                  call add(commits, remove(flags, i))
                                  continue
                                elseif arg =~# '^-L.'
                                  call add(ranges, remove(flags, i))
                                  continue
                                elseif arg =~# '^-[GLS]$\|^--\%(date\|encoding\|contents\|ignore-rev\|ignore-revs-file\)$'
                                  let i += 1
                                  if i == len(flags)
                                    echohl ErrorMsg
                                    echo s:ChompError(['blame', arg])[0]
                                    echohl NONE
                                    return ''
                                  endif
                                elseif arg ==# '--'
                                  if i + 1 < len(flags)
                                    call extend(files, remove(flags, i + 1, -1))
                                  endif
                                  call remove(flags, i)
                                  break
                                elseif arg !~# '^-' && (s:HasOpt(flags, '--not') || arg !~# '^\^')
                                  if index(flags, '--') >= 0
                                    call add(commits, remove(flags, i))
                                    continue
                                  endif
                                  if arg =~# '\.\.' && arg !~# '^\.\.\=\%(/\|$\)' && empty(commits)
                                    call add(commits, remove(flags, i))
                                    continue
                                  endif
                                  try
                                    let dcf = s:DirCommitFile(fugitive#Find(arg))
                                    if len(dcf[1]) && empty(dcf[2])
                                      call add(commits, remove(flags, i))
                                      continue
                                    endif
                                  catch /^fugitive:/
                                  endtry
                                  call add(files, remove(flags, i))
                                  continue
                                endif
                                let i += 1
                              endwhile
                              let file = substitute(get(files, 0, get(s:TempState(), 'blame_file', s:Relative('./'))), '^\.\%(/\|$\)', '', '')
                              if empty(commits) && len(files) > 1
                                call add(commits, remove(files, 1))
                              endif
                              exe s:BlameLeave()
                              try
                                let cmd = ['--no-pager', '-c', 'blame.coloring=none', '-c', 'blame.blankBoundary=false', 'blame', '--show-number']
                                call extend(cmd, filter(copy(flags), 'v:val !~# "\\v^%(-b|--%(no-)=color-.*|--progress)$"'))
                                if a:count > 0 && empty(ranges)
                                  let cmd += ['-L', (a:line1 ? a:line1 : line('.')) . ',' . (a:line1 ? a:line1 : line('.'))]
                                endif
                                call extend(cmd, ranges)
                                if len(commits)
                                  let cmd += commits
                                elseif empty(files) && len(matchstr(s:DirCommitFile(@%)[1], '^\x\x\+$'))
                                  let cmd += [matchstr(s:DirCommitFile(@%)[1], '^\x\x\+$')]
                                elseif empty(files) && !s:HasOpt(flags, '--reverse')
                                  let cmd += ['--contents', '-']
                                endif
                                let basecmd = escape(fugitive#Prepare(cmd) . ' -- ' . s:shellesc(len(files) ? files : file), '!#%')
                                let tempname = tempname()
                                let error = tempname . '.err'
                                let temp = tempname . (raw ? '' : '.fugitiveblame')
                                if &shell =~# 'csh'
                                  silent! execute '%write !('.basecmd.' > '.temp.') >& '.error
                                else
                                  silent! execute '%write !'.basecmd.' > '.temp.' 2> '.error
                                endif
                                redraw
                                try
                                  if v:shell_error
                                    let lines = readfile(error)
                                    if empty(lines)
                                      let lines = readfile(temp)
                                    endif
                                    for i in range(len(lines))
                                      if lines[i] =~# '^error: \|^fatal: '
                                        echohl ErrorMsg
                                        echon lines[i]
                                        echohl NONE
                                        break
                                      else
                                        echon lines[i]
                                      endif
                                      if i != len(lines) - 1
                                        echon "\n"
                                      endif
                                    endfor
                                    return ''
                                  endif
                                  let temp_state = {'dir': s:Dir(), 'filetype': (raw ? '' : 'fugitiveblame'), 'blame_flags': flags, 'blame_file': file, 'modifiable': 0}
                                  if s:HasOpt(flags, '--reverse')
                                    let temp_state.blame_reverse_end = matchstr(get(commits, 0, ''), '\.\.\zs.*')
                                  endif
                                  if (a:line1 == 0 || a:range == 1) && a:count > 0
                                    let edit = s:Mods(a:mods) . get(['edit', 'split', 'pedit', 'vsplit', 'tabedit'], a:count - (a:line1 ? a:line1 : 1), 'split')
                                    return s:BlameCommit(edit, get(readfile(temp), 0, ''), temp_state)
                                  else
                                    let temp = s:Resolve(temp)
                                    let s:temp_files[s:cpath(temp)] = temp_state
                                    if len(ranges + commits + files) || raw
                                      let mods = s:Mods(a:mods)
                                      if a:count != 0
                                        exe 'silent keepalt' mods 'split' s:fnameescape(temp)
                                      elseif !&modified || a:bang || &bufhidden ==# 'hide' || (empty(&bufhidden) && &hidden)
                                        exe 'silent' mods 'edit' . (a:bang ? '! ' : ' ') . s:fnameescape(temp)
                                      else
                                        return mods . 'edit ' . s:fnameescape(temp)
                                      endif
                                      return ''
                                    endif
                                    if a:mods =~# '\<tab\>'
                                      silent tabedit %
                                    endif
                                    let mods = substitute(a:mods, '\<tab\>', '', 'g')
                                    for winnr in range(winnr('$'),1,-1)
                                      if getwinvar(winnr, '&scrollbind')
                                        call setwinvar(winnr, '&scrollbind', 0)
                                      endif
                                      if exists('+cursorbind') && getwinvar(winnr, '&cursorbind')
                                        call setwinvar(winnr, '&cursorbind', 0)
                                      endif
                                      if s:BlameBufnr(winbufnr(winnr)) > 0
                                        execute winbufnr(winnr).'bdelete'
                                      endif
                                    endfor
                                    let bufnr = bufnr('')
                                    let temp_state.bufnr = bufnr
                                    let restore = 'call setwinvar(bufwinnr('.bufnr.'),"&scrollbind",0)'
                                    if exists('+cursorbind')
                                      let restore .= '|call setwinvar(bufwinnr('.bufnr.'),"&cursorbind",0)'
                                    endif
                                    if &l:wrap
                                      let restore .= '|call setwinvar(bufwinnr('.bufnr.'),"&wrap",1)'
                                    endif
                                    if &l:foldenable
                                      let restore .= '|call setwinvar(bufwinnr('.bufnr.'),"&foldenable",1)'
                                    endif
                                    setlocal scrollbind nowrap nofoldenable
                                    if exists('+cursorbind')
                                      setlocal cursorbind
                                    endif
                                    let top = line('w0') + &scrolloff
                                    let current = line('.')
                                    exe 'silent keepalt' (a:bang ? s:Mods(mods) . 'split' : s:Mods(mods, 'leftabove') . 'vsplit') s:fnameescape(temp)
                                    let w:fugitive_leave = restore
                                    execute top
                                    normal! zt
                                    execute current
                                    if exists('+cursorbind')
                                      setlocal cursorbind
                                    endif
                                    setlocal nonumber scrollbind nowrap foldcolumn=0 nofoldenable winfixwidth
                                    if exists('+relativenumber')
                                      setlocal norelativenumber
                                    endif
                                    execute "vertical resize ".(s:linechars('.\{-\}\ze\s\+\d\+)')+1)
                                    call s:Map('n', 'A', ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze [0-9:/+-][0-9:/+ -]* \\d\\+)')+1+v:count)<CR>", '<silent>')
                                    call s:Map('n', 'C', ":<C-u>exe 'vertical resize '.(<SID>linechars('^\\S\\+')+1+v:count)<CR>", '<silent>')
                                    call s:Map('n', 'D', ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze\\d\\ze\\s\\+\\d\\+)')+1-v:count)<CR>", '<silent>')
                                    redraw
                                    syncbind
                                  endif
                                endtry
                                return ''
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry

FUNCTION  <SNR>103_DoStageUnpushed()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let remote = matchstr(a:record.heading, 'to \zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:record.heading, 'to \%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Gpush ' . remote . ' ' . a:record.commit . ':' . branch)

FUNCTION  go#lsp#TypeDef()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call go#lsp#DidChange(a:fname)
                            
                              let l:lsp = s:lspfactory.get()
                              let l:state = s:newHandlerState('type definition')
                              let l:msg = go#lsp#message#TypeDefinition(fnamemodify(a:fname, ':p'), a:line, a:col)
                              let l:state.handleResult = funcref('s:typeDefinitionHandler', [function(a:handler, [], l:state)], l:state)
                              return  l:lsp.sendMessage(l:msg, l:state)

FUNCTION  fugitive#Statusline()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Dir(bufnr(''))
                              if empty(dir)
                                return ''
                              endif
                              let status = ''
                              let commit = s:DirCommitFile(@%)[1]
                              if len(commit)
                                let status .= ':' . commit[0:6]
                              endif
                              let status .= '('.FugitiveHead(7, dir).')'
                              return '[Git'.status.']'

FUNCTION  <SNR>103_repo_tree()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Tree(self.git_dir)
                              if dir ==# ''
                                call s:throw('no work tree')
                              else
                                return join([dir]+a:000,'/')
                              endif

FUNCTION  <SNR>103_RebaseArgument()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:SquashArgument(' %s^')

FUNCTION  go#lsp#DebugBrowser()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:lsp = s:lspfactory.get()
                              let l:port = get(l:lsp, 'debugport', 0)
                              if !l:port
                                call go#util#EchoError("gopls was not started with debugging enabled. See :help g:go_debug.")
                                return
                              endif
                            
                              call go#util#OpenBrowser(printf('http://localhost:%d', l:port))

FUNCTION  <SNR>103_diffthis()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !&diff
                                let w:fugitive_diff_restore = s:diff_restore()
                                diffthis
                              endif

FUNCTION  gutentags#throw()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                throw "gutentags: " . a:message

FUNCTION  qf#IsLocWindowOpen()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let loclist = getloclist(a:nmbr)
                                for winnum in range(1, winnr('$'))
                                    if qf#IsLocWindow(winnum) && loclist ==# getloclist(winnum)
                                        return 1
                                    endif
                                endfor
                                return 0

FUNCTION  <SNR>100_check_diff_perforce()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  <SNR>100_check_diff_yadm()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  <SNR>103_repo_dir()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return join([self.git_dir]+a:000,'/')

FUNCTION  go#lsp#message#Exit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return { 'notification': 1, 'method': 'exit', }

FUNCTION  go#lsp#message#ConfigurationResult()
Called 1 time
Total time:   0.000094
 Self time:   0.000084

count  total (s)   self (s)
    1              0.000003   let l:result = []
                            
                              " results must be in the same order as the items
    3              0.000005   for l:item in a:items
    2              0.000009     let l:config = { 'buildFlags': [], 'hoverKind': 'NoDocumentation', }
    2   0.000027   0.000017     let l:buildtags = go#config#BuildTags()
    2              0.000004     if buildtags isnot ''
                                  let l:config.buildFlags = extend(l:config.buildFlags, ['-tags', go#config#BuildTags()])
    2              0.000002     endif
                            
    2              0.000015     let l:result = add(l:result, l:config)
    3              0.000003   endfor
                            
    1              0.000001   return l:result

FUNCTION  gutentags#find_job_index_by_tags_file()
Called 2 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    2              0.000010     let l:idx = -1
    2              0.000017     for upd_info in s:update_in_progress[a:module]
                                    let l:idx += 1
                                    if upd_info[0] == a:tags_file
                                        return l:idx
                                    endif
    2              0.000002     endfor
    2              0.000003     return -1

FUNCTION  FugitiveWorkTree()
Called 1 time
Total time:   0.000137
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000113   0.000012   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  fugitive#Object()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let [fdir, rev] = s:DirRev(a:0 ? a:1 : @%)
                              if s:cpath(dir) !=# s:cpath(fdir)
                                let rev = ''
                              endif
                              let tree = s:Tree(dir)
                              let full = a:0 ? a:1 : @%
                              let full = fnamemodify(full, ':p' . (s:Slash(full) =~# '/$' ? '' : ':s?/$??'))
                              if empty(rev) && empty(tree)
                                return FugitiveGitPath(full)
                              elseif empty(rev)
                                let rev = fugitive#Path(full, './', dir)
                                if rev =~# '^\./.git\%(/\|$\)'
                                  return FugitiveGitPath(full)
                                endif
                              endif
                              if rev !~# '^\.\%(/\|$\)' || s:cpath(getcwd(), tree)
                                return rev
                              else
                                return FugitiveGitPath(tree . rev[1:-1])
                              endif

FUNCTION  <SNR>93_HasPath()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let go_paths = split(go#path#Default(), go#util#PathListSep())
                              let last_char = strlen(a:path) - 1
                            
                              " check cases of '/foo/bar/' and '/foo/bar'
                              if a:path[last_char] == go#util#PathSep()
                                let withSep = a:path
                                let noSep = strpart(a:path, 0, last_char)
                              else
                                let withSep = a:path . go#util#PathSep()
                                let noSep = a:path
                              endif
                            
                              let hasA = index(go_paths, withSep) != -1
                              let hasB = index(go_paths, noSep) != -1
                              return hasA || hasB

FUNCTION  funcref#Call()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = copy(a:000)
                            
                              " add parameters:
                              if (len(args) < 2)
                                call add(args, [])
                              endif
                            
                            
                              let isDict = type(args[0]) == type({})
                            
                              " prepend parameters which were passed by faked function reference:
                              if isDict &&  has_key(args[0], 'args')
                                let args[1] = args[0]['args']+args[1]
                              endif
                            
                              " always pass self. this way you can call functions from dictionaries not
                              " refering to self
                              if (len(args) < 3)
                                call add(args, {})
                              endif
                            
                              " the funcref overrides self:
                              if isDict && has_key(args[0], 'self')
                                let args[2] = args[0]['self']
                              endif
                            
                              if type(a:1) == 2
                                " funcref: function must have been laoded
                                return call(function('call'), args)
                              elseif isDict && has_key(args[0], 'faked_function_reference')
                                let Fun = args[0]['faked_function_reference']
                                if type(Fun) == type('') && (Fun[:len('return ')-1] == 'return '  || Fun[:len('call ')-1] == 'call ' || Fun[:len('if ')-1] == 'if ' || Fun[:len('let ')-1] == 'let ' || Fun[:len('echo ')-1] == 'echo ' || Fun[:len('exec ')-1] == 'exec ' || Fun[:len('debug ')-1] == 'debug ')
                                  " it doesn't make sense to list all vim commands here
                                  " So if you want to execute another action consider using 
                                  " funcref#Function('exec  '.string('aw')) or such
                            
                                  " function is a String, call exec
                                  let ARGS = args[1]
                                  let SELF = args[2]
                                  exec Fun
                                else 
                                  " pseudo function, let's load it..
                                  if type(Fun) == 1
                                    if !exists('*'.Fun)
                                      " lazily load function
                                      let file = substitute(substitute(Fun,'#[^#]*$','',''),'#','/','g')
                                      exec 'runtime /autoload/'.file.'.vim'
                                    endif
                                    let Fun2 = function(Fun)
                                  else
                                    let Fun2 = Fun
                                  endif
                                  let args[0] = Fun
                                  return call(function('call'), args)
                                endif
                              else
                                " no function, return the value
                                return args[0]
                              endif

FUNCTION  <SNR>103_RevertComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:CompleteSub('revert', a:A, a:L, a:P, function('s:CompleteRevision'))

FUNCTION  fugitive#Diffsplit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = copy(a:args)
                              let post = ''
                              if get(args, 0) =~# '^+'
                                let post = remove(args, 0)[1:-1]
                              endif
                              if exists(':DiffGitCached') && empty(args)
                                return s:Mods(a:mods) . 'DiffGitCached' . (len(post) ? '|' . post : '')
                              endif
                              let commit = s:DirCommitFile(@%)[1]
                              if a:mods =~# '\<tab\>'
                                let mods = substitute(a:mods, '\<tab\>', '', 'g')
                                let pre = 'tab split'
                              else
                                let mods = 'keepalt ' . a:mods
                                let pre = ''
                              endif
                              let back = exists('*win_getid') ? 'call win_gotoid(' . win_getid() . ')' : 'wincmd p'
                              if (empty(args) || args[0] ==# ':') && a:keepfocus
                                exe s:DirCheck()
                                if empty(commit) && s:IsConflicted()
                                  let parents = [s:Relative(':2:'), s:Relative(':3:')]
                                elseif empty(commit)
                                  let parents = [s:Relative(':0:')]
                                elseif commit =~# '^\d\=$'
                                  let parents = [s:Relative('HEAD:')]
                                elseif commit =~# '^\x\x\+$'
                                  let parents = s:LinesError(['rev-parse', commit . '^@'])[0]
                                  call map(parents, 's:Relative(v:val . ":")')
                                endif
                              endif
                              try
                                if exists('parents') && len(parents) > 1
                                  exe pre
                                  let mods = (a:autodir ? s:diff_modifier(len(parents) + 1) : '') . s:Mods(mods, 'leftabove')
                                  let nr = bufnr('')
                                  execute mods 'split' s:fnameescape(s:Generate(parents[0]))
                                  call s:Map('n', 'dp', ':diffput '.nr.'<Bar>diffupdate<CR>', '<silent>')
                                  let nr2 = bufnr('')
                                  call s:diffthis()
                                  exe back
                                  call s:Map('n', 'd2o', ':diffget '.nr2.'<Bar>diffupdate<CR>', '<silent>')
                                  let mods = substitute(mods, '\Cleftabove\|rightbelow\|aboveleft\|belowright', '\=submatch(0) =~# "f" ? "rightbelow" : "leftabove"', '')
                                  for i in range(len(parents)-1, 1, -1)
                                    execute mods 'split' s:fnameescape(s:Generate(parents[i]))
                                    call s:Map('n', 'dp', ':diffput '.nr.'<Bar>diffupdate<CR>', '<silent>')
                                    let nrx = bufnr('')
                                    call s:diffthis()
                                    exe back
                                    call s:Map('n', 'd' . (i + 2) . 'o', ':diffget '.nrx.'<Bar>diffupdate<CR>', '<silent>')
                                  endfor
                                  call s:diffthis()
                                  if len(parents) > 1
                                    wincmd =
                                  endif
                                  return post
                                elseif len(args)
                                  let arg = join(args, ' ')
                                  if arg ==# ''
                                    return post
                                  elseif arg ==# ':/'
                                    exe s:DirCheck()
                                    let file = s:Relative()
                                  elseif arg ==# ':'
                                    exe s:DirCheck()
                                    let file = s:Relative(':0:')
                                  elseif arg =~# '^:\d$'
                                    exe s:DirCheck()
                                    let file = s:Relative(arg . ':')
                                  else
                                    try
                                      let file = arg =~# '^:/.' ? fugitive#RevParse(arg) . s:Relative(':') : s:Expand(arg)
                                    catch /^fugitive:/
                                      return 'echoerr ' . string(v:exception)
                                    endtry
                                  endif
                                elseif exists('parents') && len(parents)
                                  let file = parents[-1]
                                elseif len(commit)
                                  let file = s:Relative()
                                elseif s:IsConflicted()
                                  let file = s:Relative(':1:')
                                  let post = 'echohl WarningMsg|echo "Use :Gdiffsplit! for 3 way diff"|echohl NONE|' . post
                                else
                                  exe s:DirCheck()
                                  let file = s:Relative(':0:')
                                endif
                                let spec = s:Generate(file)
                                if spec =~# '^fugitive:' && empty(s:DirCommitFile(spec)[2])
                                  let spec = FugitiveVimPath(spec . s:Relative('/'))
                                endif
                                exe pre
                                let restore = s:diff_restore()
                                let w:fugitive_diff_restore = restore
                                if s:CompareAge(commit, s:DirCommitFile(spec)[1]) < 0
                                  let mods = s:Mods(mods, 'rightbelow')
                                else
                                  let mods = s:Mods(mods, 'leftabove')
                                endif
                                let mods = (a:autodir ? s:diff_modifier(2) : '') . mods
                                if &diffopt =~# 'vertical'
                                  let diffopt = &diffopt
                                  set diffopt-=vertical
                                endif
                                execute mods 'diffsplit' s:fnameescape(spec)
                                let &l:readonly = &l:readonly
                                redraw
                                let w:fugitive_diff_restore = restore
                                let winnr = winnr()
                                if getwinvar('#', '&diff')
                                  if a:keepfocus
                                    exe back
                                  endif
                                endif
                                return post
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                if exists('diffopt')
                                  let &diffopt = diffopt
                                endif
                              endtry

FUNCTION  <SNR>43_exec()
Called 2 times
Total time:   0.051857
 Self time:   0.000155

count  total (s)   self (s)
    2              0.000008   let l:bin = a:cmd[0]
    2   0.000120   0.000023   let l:cmd = go#util#Shelljoin([l:bin] + a:cmd[1:])
    2   0.000052   0.000012   if go#util#HasDebug('shell-commands')
                                call go#util#EchoInfo('shell command: ' . l:cmd)
    2              0.000002   endif
                            
    2   0.051595   0.000041   let l:out = call('s:system', [l:cmd] + a:000)
    2   0.000068   0.000057   return [l:out, go#util#ShellError()]

FUNCTION  <SNR>103_Format()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if type(a:val) == type({})
                                return s:Format{a:val.type}(a:val)
                              elseif type(a:val) == type([])
                                return map(copy(a:val), 's:Format(v:val)')
                              else
                                return '' . a:val
                              endif

FUNCTION  <SNR>100_get_vcs_path()
Called 2 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    2              0.000066   return (a:vcs =~# '\v(git|cvs|accurev|tfs|yadm)') ? b:sy.info.file : b:sy.info.path

FUNCTION  <SNR>103_StageJump()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let line = search('^\%(' . a:section . '\)', 'nw')
                              if !line && a:0
                                let line = search('^\%(' . a:1 . '\)', 'nw')
                              endif
                              if line
                                exe line
                                if a:offset
                                  for i in range(a:offset)
                                    call search(s:file_commit_pattern . '\|^$', 'W')
                                    if empty(getline('.')) && a:0 && getline(line('.') + 1) =~# '^\%(' . a:1 . '\)'
                                      call search(s:file_commit_pattern . '\|^$', 'W')
                                    endif
                                    if empty(getline('.'))
                                      return ''
                                    endif
                                  endfor
                                  call s:StageReveal()
                                else
                                  call s:StageReveal()
                                  +
                                endif
                              endif
                              return ''

FUNCTION  go#util#archive()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let l:buffer = join(go#util#GetLines(), "\n")
                                return expand("%:p:gs!\\!/!") . "\n" . strlen(l:buffer) . "\n" . l:buffer

FUNCTION  go#config#TermHeight()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_term_height', winheight(0))

FUNCTION  <SNR>103_HasOpt()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = a:args[0 : index(a:args, '--')]
                              let opts = copy(a:000)
                              if type(opts[0]) == type([])
                                if empty(args) || index(opts[0], args[0]) == -1
                                  return 0
                                endif
                                call remove(opts, 0)
                              endif
                              for opt in opts
                                if index(args, opt) != -1
                                  return 1
                                endif
                              endfor

FUNCTION  <SNR>103_repo_user()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let username = self.config('user.name')
                              let useremail = self.config('user.email')
                              return username.' <'.useremail.'>'

FUNCTION  <SNR>103_ExpandVar()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let cwd = a:0 ? a:1 : getcwd()
                              if a:other =~# '^\'
                                return a:other[1:-1]
                              elseif a:other =~# '^'''
                                return s:ExpandVarLegacy(substitute(a:other[1:-2], "''", "'", "g"))
                              elseif a:other =~# '^"'
                                return s:ExpandVarLegacy(substitute(a:other[1:-2], '""', '"', "g"))
                              elseif a:other =~# '^!'
                                let buffer = s:BufName(len(a:other) > 1 ? '#'. a:other[1:-1] : '%')
                                let owner = s:Owner(buffer)
                                return len(owner) ? owner : '@'
                              endif
                              let flags = a:flags
                              let file = s:DotRelative(fugitive#Real(s:BufName(a:var)), cwd)
                              while len(flags)
                                let flag = matchstr(flags, s:flag)
                                let flags = strpart(flags, len(flag))
                                if flag ==# ':.'
                                  let file = s:DotRelative(file, cwd)
                                else
                                  let file = fnamemodify(file, flag)
                                endif
                              endwhile
                              let file = s:Slash(file)
                              return (len(a:esc) ? shellescape(file) : file)

FUNCTION  fugitive#StatusCfile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let file = s:Generate(s:StatusCfile()[0])
                              return empty(file) ? fugitive#Cfile() : s:fnameescape(file)

FUNCTION  go#util#goroot()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(s:exec(['go', 'env', 'GOROOT'])[0], '\n', '', 'g')

FUNCTION  go#config#Debug()
Called 63 times
Total time:   0.000352
 Self time:   0.000352

count  total (s)   self (s)
   63              0.000307   return get(g:, 'go_debug', [])

FUNCTION  go#lsp#DidChange()
Called 1 time
Total time:   0.001321
 Self time:   0.000295

count  total (s)   self (s)
                              " DidChange is called even when fname isn't open in a buffer (e.g. via
                              " go#lsp#Info); don't report the file as open or as having changed when it's
                              " not actually a buffer.
    1              0.000029   if bufnr(a:fname) == -1
                                return
    1              0.000002   endif
                            
    1              0.000020   if !filereadable(a:fname)
                                return
    1              0.000001   endif
                            
    1   0.000018   0.000010   call go#lsp#DidOpen(a:fname)
                            
    1   0.000028   0.000009   let l:lsp = s:lspfactory.get()
    1   0.000454   0.000178   let l:msg = go#lsp#message#DidChange(fnamemodify(a:fname, ':p'), join(go#util#GetLines(), "\n") . "\n")
    1   0.000046   0.000011   let l:state = s:newHandlerState('')
    1              0.000007   let l:state.handleResult = funcref('s:noop')
    1   0.000698   0.000010   return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  fugitive#Prepare()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [dir, env, argv] = call('fugitive#PrepareDirEnvArgv', a:000)
                              return s:BuildShell(dir, env, argv)

FUNCTION  <SNR>103_SquashArgument()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &filetype == 'fugitive'
                                let commit = matchstr(getline('.'), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\{4,\}\ze ')
                              elseif has_key(s:temp_files, s:cpath(expand('%:p')))
                                let commit = matchstr(getline('.'), '\<\x\{4,\}\>')
                              else
                                let commit = s:Owner(@%)
                              endif
                              return len(commit) && a:0 ? printf(a:1, commit) : commit

FUNCTION  <SNR>7_Count()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let pat = escape(a:pattern, '\\')
                              if a:0 > 1
                                let foo = substitute(a:string, '[^'.a:pattern.']', "a:1", "g")
                                let foo = substitute(a:string, pat, a:2, "g")
                                let foo = substitute(foo, '[^' . a:2 . ']', "", "g")
                                return strlen(foo)
                              endif
                              let result = 0
                              let foo = a:string
                              let index = matchend(foo, pat)
                              while index != -1
                                let result = result + 1
                                let foo = strpart(foo, index)
                                let index = matchend(foo, pat)
                              endwhile
                              return result

FUNCTION  <SNR>103_Subcommands()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let exec_path = s:ExecPath()
                              return map(split(glob(exec_path.'/git-*'),"\n"),'s:sub(v:val[strlen(exec_path)+5 : -1],"\\.exe$","")')

FUNCTION  <SNR>41_checkVersion()
Called 1 time
Total time:   0.001177
 Self time:   0.000255

count  total (s)   self (s)
                              " Not using the has('patch-7.4.2009') syntax because that wasn't added until
                              " 7.4.237, and we want to be sure this works for everyone (this is also why
                              " we're not using utils#EchoError()).
                              "
                              " Version 7.4.2009 was chosen because that's greater than what the most recent Ubuntu LTS
                              " release (16.04) uses and has a couple of features we need (e.g. execute()
                              " and :message clear).
                            
    1              0.000008   let l:unsupported = 0
    1   0.001132   0.000210   if go#config#VersionWarning() != 0
    1              0.000005     if has('nvim')
                                  let l:unsupported = !has('nvim-0.3.2')
    1              0.000002     else
    1              0.000005       let l:unsupported = (v:version < 704 || (v:version == 704 && !has('patch2009')))
    1              0.000001     endif
                            
    1              0.000002     if l:unsupported == 1
                                  echohl Error
                                  echom "vim-go requires Vim 7.4.2009 or Neovim 0.3.2, but you're using an older version."
                                  echom "Please update your Vim for the best vim-go experience."
                                  echom "If you really want to continue you can set this to make the error go away:"
                                  echom "    let g:go_version_warning = 0"
                                  echom "Note that some features may error out or behave incorrectly."
                                  echom "Please do not report bugs unless you're using Vim 7.4.2009 or newer or Neovim 0.3.2."
                                  echohl None
                            
                                  " Make sure people see this.
                                  sleep 2
    1              0.000001     endif
    1              0.000001   endif

FUNCTION  <SNR>34_dashcase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(s:snakecase(a:word),'_','-','g')

FUNCTION  sy#highlight#setup()
Called 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000019   highlight default link SignifyLineAdd             DiffAdd
    1              0.000005   highlight default link SignifyLineDelete          DiffDelete
    1              0.000003   highlight default link SignifyLineDeleteFirstLine SignifyLineDelete
    1              0.000003   highlight default link SignifyLineChange          DiffChange
    1              0.000004   highlight default link SignifyLineChangeDelete    SignifyLineChange
                            
    1              0.000004   highlight default link SignifySignAdd             DiffAdd
    1              0.000006   highlight default link SignifySignDelete          DiffDelete
    1              0.000003   highlight default link SignifySignDeleteFirstLine SignifySignDelete
    1              0.000004   highlight default link SignifySignChange          DiffChange
    1              0.000003   highlight default link SignifySignChangeDelete    SignifySignChange

FUNCTION  <SNR>92_hoverHandler()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:content = split(a:msg.contents.value, '; ')
                              if len(l:content) > 1
                                let l:curly = stridx(l:content[0], '{')
                                let l:content = extend([l:content[0][0:l:curly]], map(extend([l:content[0][l:curly+1:]], l:content[1:]), '"\t" . v:val'))
                                let l:content[len(l:content)-1] = '}'
                              endif
                            
                              let l:args = [l:content]
                              call call(a:next, l:args)

FUNCTION  gutentags#find_job_index_by_data()
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000004     let l:idx = -1
    1              0.000018     for upd_info in s:update_in_progress[a:module]
    1              0.000003         let l:idx += 1
    1              0.000008         if upd_info[1] == a:data
    1              0.000003             return l:idx
                                    endif
                                endfor
                                return -1

FUNCTION  <SNR>34_badgood()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let words = filter(copy(a:args),'v:val !~ "^-"')
                              call filter(a:args,'v:val =~ "^-"')
                              if empty(words)
                                call s:throw("E471: Argument required")
                              elseif !empty(a:args)
                                call s:throw("Unknown argument: ".a:args[0])
                              endif
                              let [bad; words] = words
                              return [bad, join(words," ")]

FUNCTION  go#util#tempdir()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " See :help tempfile
                              if go#util#IsWin()
                                let l:dirs = [$TMP, $TEMP, 'c:\tmp', 'c:\temp']
                              else
                                let l:dirs = [$TMPDIR, '/tmp', './', $HOME]
                              endif
                            
                              let l:dir = ''
                              for l:d in dirs
                                if !empty(l:d) && filewritable(l:d) == 2
                                  let l:dir = l:d
                                  break
                                endif
                              endfor
                            
                              if l:dir == ''
                                call go#util#EchoError('Unable to find directory to store temporary directory in')
                                return
                              endif
                            
                              " Not great randomness, but "good enough" for our purpose here.
                              let l:rnd = sha256(printf('%s%s', reltimestr(reltime()), fnamemodify(bufname(''), ":p")))
                              let l:tmp = printf("%s/%s%s", l:dir, a:prefix, l:rnd)
                              call mkdir(l:tmp, 'p', 0700)
                              return l:tmp

FUNCTION  go#guru#ToggleSameIds()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if go#guru#ClearSameIds() != 0
                                call go#guru#SameIds(1)
                              endif

FUNCTION  fugitive#buffer()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
                              call extend(buffer, s:buffer_prototype, 'keep')
                              return buffer

FUNCTION  go#util#goarch()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(s:exec(['go', 'env', 'GOARCH'])[0], '\n', '', 'g')

FUNCTION  fugitive#CompletePath()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 == 1 ? a:1 : a:0 == 3 ? a:3 : s:Dir()
                              let tree = s:Tree(dir) . '/'
                              let strip = '^\%(:/:\=\|:(top)\|:(top,literal)\|:(literal,top)\|:(literal)\)'
                              let base = substitute(a:base, strip, '', '')
                              if base =~# '^\.git/'
                                let pattern = s:gsub(base[5:-1], '/', '*&').'*'
                                let matches = s:GlobComplete(dir . '/', pattern)
                                let cdir = fugitive#CommonDir(dir)
                                if len(cdir) && s:cpath(dir) !=# s:cpath(cdir)
                                  call extend(matches, s:GlobComplete(cdir . '/', pattern))
                                endif
                                call s:Uniq(matches)
                                call map(matches, "'.git/' . v:val")
                              elseif base =~# '^\~/'
                                let matches = map(s:GlobComplete(expand('~/'), base[2:-1] . '*'), '"~/" . v:val')
                              elseif a:base =~# '^/\|^\a\+:\|^\.\.\=/\|^:(literal)'
                                let matches = s:GlobComplete('', base . '*')
                              elseif len(tree) > 1
                                let matches = s:GlobComplete(tree, s:gsub(base, '/', '*&').'*')
                              else
                                let matches = []
                              endif
                              call map(matches, 's:fnameescape(s:Slash(matchstr(a:base, strip) . v:val))')
                              return matches

FUNCTION  <SNR>7_ParseSkip()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let skip = a:str
                              if skip[1] == ":"
                                if skip[0] == "s"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') =~? '" . strpart(skip,2) . "'"
                                elseif skip[0] == "S"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') !~? '" . strpart(skip,2) . "'"
                                elseif skip[0] == "r"
                                  let skip = "strpart(getline('.'),0,col('.'))=~'" . strpart(skip,2). "'"
                                elseif skip[0] == "R"
                                  let skip = "strpart(getline('.'),0,col('.'))!~'" . strpart(skip,2). "'"
                                endif
                              endif
                              return skip

FUNCTION  <SNR>28_DuplicateBlock()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                nunmap <buffer>  M
                                " Locate block boundaries...
                                let [buf_left,  line_left,  col_left,  offset_left ] = getpos("'<")
                                let [buf_right, line_right, col_right, offset_right] = getpos("'>")
                            
                                " Identify special '$' blocks...
                                let dollar_block = 0
                                let start_col    = min([col_left+offset_left, col_right+offset_right])
                                let end_col      = max([col_left+offset_left, col_right+offset_right])
                                let visual_width = end_col - start_col + 1
                                for visual_line in split(getreg("v"),"\n")
                                    if strlen(visual_line) > visual_width
                                        let dollar_block = 1
                                        let visual_width = strlen(visual_line)
                                    endif
                                endfor
                                let square_up = (dollar_block ? (start_col+visual_width-2).'|' : '')
                            
                                set virtualedit=all
                                return 'gv'.square_up.'yPgv'. (visual_width-dollar_block) . 'lo' . (visual_width-dollar_block) . 'l'. "y:set virtualedit=block\<CR>gv". (dollar_block ? 'o$' : '')

FUNCTION  go#config#DebugLogOutput()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_debug_log_output', 'debugger,rpc')

FUNCTION  <SNR>34_normalize_options()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if type(a:flags) == type({})
                                let opts = a:flags
                                let flags = get(a:flags,"flags","")
                              else
                                let opts = {}
                                let flags = a:flags
                              endif
                              let g:op1 = copy(opts)
                              if flags =~# 'w'
                                let opts.boundaries = 2
                              elseif flags =~# 'v'
                                let opts.boundaries = 1
                              elseif !has_key(opts,'boundaries')
                                let opts.boundaries = 0
                              endif
                              let opts.case = (flags !~# 'I' ? get(opts,'case',1) : 0)
                              let opts.flags = substitute(flags,'\C[avIiw]','','g')
                              let g:op2 = copy(opts)
                              return opts

FUNCTION  go#config#SearchBinPathFirst()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000012   return get(g:, 'go_search_bin_path_first', 1)

FUNCTION  <SNR>58_NoMatchParen()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let w = winnr()
                              noau windo silent! call matchdelete(3)
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen

FUNCTION  go#auto#fmt_autosave()
Called 1 time
Total time:   0.050701
 Self time:   0.000311

count  total (s)   self (s)
    1   0.000112   0.000099   if !(go#config#FmtAutosave() && isdirectory(expand('%:p:h')) && expand('<afile>:p') == expand('%:p'))
                                return
    1              0.000002   endif
                            
                              " Go code formatting on save
    1   0.050580   0.000203   call go#fmt#Format(-1)

FUNCTION  <SNR>103_repo_head()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#Head(a:0 ? a:1 : 0, self.git_dir)

FUNCTION  <SNR>34_snakecase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let word = substitute(a:word,'::','/','g')
                              let word = substitute(word,'\(\u\+\)\(\u\l\)','\1_\2','g')
                              let word = substitute(word,'\(\l\|\d\)\(\u\)','\1_\2','g')
                              let word = substitute(word,'[.-]','_','g')
                              let word = tolower(word)
                              return word

FUNCTION  go#util#EchoWarning()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:echo(a:msg, 'WarningMsg')

FUNCTION  <SNR>103_QueryLog()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let lines = s:LinesError(['log', '-n', '256', '--format=%h%x09%s', a:refspec, '--'])[0]
                              call map(lines, 'split(v:val, "\t")')
                              call map(lines, '{"type": "Log", "commit": v:val[0], "subject": v:val[-1]}')
                              return lines

FUNCTION  go#config#SetTermCloseOnExit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:go_term_close_on_exit = a:value

FUNCTION  <SNR>90_hi()
Called 1 time
Total time:   0.000039
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000005   hi def link goSameId Search
                            
                              " :GoCoverage commands
    1              0.000002   hi def      goCoverageCovered    ctermfg=green guifg=#A6E22E
    1              0.000001   hi def      goCoverageUncover    ctermfg=red guifg=#F92672
                            
                              " :GoDebug commands
    1   0.000012   0.000006   if go#config#HighlightDebug()
    1              0.000008     hi GoDebugBreakpoint term=standout ctermbg=117 ctermfg=0 guibg=#BAD4F5  guifg=Black
    1              0.000006     hi GoDebugCurrent term=reverse  ctermbg=12  ctermfg=7 guibg=DarkBlue guifg=White
    1              0.000001   endif

FUNCTION  go#config#PlayOpenBrowser()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_play_open_browser", 1)

FUNCTION  <SNR>92_debug()
Called 59 times
Total time:   0.001269
 Self time:   0.000471

count  total (s)   self (s)
   59   0.001115   0.000317   if !go#util#HasDebug('lsp')
   59              0.000083     return
                              endif
                            
                              let l:winid = win_getid()
                            
                              let l:name = '__GOLSP_LOG__'
                              let l:log_winid = bufwinid(l:name)
                              if l:log_winid == -1
                                silent keepalt botright 10new
                                silent file `='__GOLSP_LOG__'`
                                setlocal buftype=nofile bufhidden=wipe nomodified nobuflisted noswapfile nowrap nonumber nocursorline
                                setlocal filetype=golsplog
                              else
                                call win_gotoid(l:log_winid)
                              endif
                            
                              try
                                setlocal modifiable
                                if getline(1) == ''
                                  call setline('$', printf('%s: %s', a:event, a:data))
                                else
                                  call append('$', printf('%s: %s', a:event, a:data))
                                endif
                                normal! G
                                setlocal nomodifiable
                              finally
                                call win_gotoid(l:winid)
                              endtry

FUNCTION  <SNR>103_LogFlushQueue()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let queue = remove(a:state, 'queue')
                              if a:state.child_found
                                call remove(queue, 0)
                              endif
                              if len(queue) && queue[-1] ==# {'text': ''}
                                call remove(queue, -1)
                              endif
                              return queue

FUNCTION  go#uri#Decode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return substitute(   a:value,   '%\(\x\x\)',   '\=nr2char(''0X'' . submatch(1))',   'g')

FUNCTION  go#config#TemplateFile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_template_file', "hello_world.go")

FUNCTION  <SNR>103_RebaseClean()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !filereadable(a:file)
                                return ''
                              endif
                              let old = readfile(a:file)
                              let new = copy(old)
                              for i in range(len(new))
                                let new[i] = substitute(new[i], '^\l\>', '\=get(s:rebase_abbrevs,submatch(0),submatch(0))', '')
                            
                                let sha = matchstr(new[i], '\C\<[a-f0-9]\{5,\}\>')
                                let rebase_shas = getbufvar(a:file, 'fugitive_rebase_shas')
                                if len(sha) && type(rebase_shas) == type({}) && has_key(rebase_shas, sha)
                                  let new[i] = substitute(new[i], '\C\<' . sha . '\>', rebase_shas[sha], '')
                                endif
                              endfor
                              if new !=# old
                                call writefile(new, a:file)
                              endif
                              return ''

FUNCTION  go#lsp#Info()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:fname = expand('%:p')
                              let [l:line, l:col] = go#lsp#lsp#Position()
                            
                              call go#lsp#DidChange(l:fname)
                            
                              let l:lsp = s:lspfactory.get()
                            
                              if a:showstatus
                                let l:state = s:newHandlerState('info')
                              else
                                let l:state = s:newHandlerState('')
                              endif
                            
                              let l:state.handleResult = funcref('s:infoDefinitionHandler', [function('s:info', [1], l:state), a:showstatus], l:state)
                              let l:state.error = funcref('s:noop')
                              let l:msg = go#lsp#message#Definition(l:fname, l:line, l:col)
                              return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  go#list#ParseFormat()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " backup users errorformat, will be restored once we are finished
                              let old_errorformat = &errorformat
                            
                              " parse and populate the location list
                              let &errorformat = a:errformat
                              try
                                call go#list#Parse(a:listtype, a:items, a:title)
                              finally
                                "restore back
                                let &errorformat = old_errorformat
                              endtry

FUNCTION  go#config#HighlightFormatStrings()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000013   return get(g:, 'go_highlight_format_strings', 1)

FUNCTION  <SNR>103_DoStageUntracked()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:DoToggleUntracked(a:record)

FUNCTION  sy#disable()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('b:sy') && b:sy.active
                                call sy#stop(b:sy.buffer)
                                let b:sy.active = 0
                                let b:sy.stats = [-1, -1, -1]
                              endif

FUNCTION  <SNR>103_DoToggleUnpulledHeading()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:DoUnstageUnpulledHeading(a:heading)

FUNCTION  <SNR>103_repo_config()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#Config(a:name, self.git_dir)

FUNCTION  NetrwStatusLine()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif

FUNCTION  go#config#AsmfmtAutosave()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_asmfmt_autosave", 0)

FUNCTION  <SNR>101_write_triggered_update_tags()
Called 1 time
Total time:   0.001660
 Self time:   0.000131

count  total (s)   self (s)
    1              0.000004     if g:gutentags_enabled && g:gutentags_generate_on_write
    2              0.000014         for module in g:gutentags_modules
    1   0.001575   0.000057             call s:update_tags(a:bufno, module, 0, 2)
    2              0.000009         endfor
    1              0.000001     endif
    1   0.000040   0.000029     silent doautocmd User GutentagsUpdating

FUNCTION  <SNR>103_DoUnstageUnpushed()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call feedkeys(':Grebase --autosquash ' . a:record.commit . '^')

FUNCTION  <SNR>103_FilterEscape()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let items = copy(a:items)
                              if a:0 && type(a:1) == type('')
                                call filter(items, 'strpart(v:val, 0, strlen(a:1)) ==# a:1')
                              endif
                              return map(items, 's:fnameescape(v:val)')

FUNCTION  FugitiveRemoteUrl()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#RemoteUrl(a:0 ? a:1 : '', FugitiveGitDir(a:0 > 1 ? a:2 : -1))

FUNCTION  <SNR>103_cfile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              try
                                let myhash = s:DirRev(@%)[1]
                                if len(myhash)
                                  try
                                    let myhash = fugitive#RevParse(myhash)
                                  catch /^fugitive:/
                                    let myhash = ''
                                  endtry
                                endif
                                if empty(myhash) && getline(1) =~# '^\%(commit\|tag\) \w'
                                  let myhash = matchstr(getline(1),'^\w\+ \zs\S\+')
                                endif
                            
                                let showtree = (getline(1) =~# '^tree ' && getline(2) == "")
                            
                                let treebase = substitute(s:DirCommitFile(@%)[1], '^\d$', ':&', '') . ':' . s:Relative('') . (s:Relative('') =~# '^$\|/$' ? '' : '/')
                            
                                if getline('.') =~# '^\d\{6\} \l\{3,8\} \x\{40,\}\t'
                                  return [treebase . s:sub(matchstr(getline('.'),'\t\zs.*'),'/$','')]
                                elseif showtree
                                  return [treebase . s:sub(getline('.'),'/$','')]
                            
                                else
                            
                                  let dcmds = []
                            
                                  " Index
                                  if getline('.') =~# '^\d\{6\} \x\{40,\} \d\t'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let file = ':'.s:sub(matchstr(getline('.'),'\d\t.*'),'\t',':')
                                    return [file]
                                  endif
                            
                                  if getline('.') =~# '^ref: '
                                    let ref = strpart(getline('.'),5)
                            
                                  elseif getline('.') =~# '^commit \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    return [ref]
                            
                                  elseif getline('.') =~# '^parent \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let line = line('.')
                                    let parent = 0
                                    while getline(line) =~# '^parent '
                                      let parent += 1
                                      let line -= 1
                                    endwhile
                                    return [ref]
                            
                                  elseif getline('.') =~# '^tree \x\{40,\}$'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    if len(myhash) && fugitive#RevParse(myhash.':') ==# ref
                                      let ref = myhash.':'
                                    endif
                                    return [ref]
                            
                                  elseif getline('.') =~# '^object \x\{40,\}$' && getline(line('.')+1) =~ '^type \%(commit\|tree\|blob\)$'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let type = matchstr(getline(line('.')+1),'type \zs.*')
                            
                                  elseif getline('.') =~# '^\l\{3,8\} '.myhash.'$'
                                    let ref = s:DirRev(@%)[1]
                            
                                  elseif getline('.') =~# '^\l\{3,8\} \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    echoerr "warning: unknown context ".matchstr(getline('.'),'^\l*')
                            
                                  elseif getline('.') =~# '^[+-]\{3\} [abciow12]\=/'
                                    let ref = getline('.')[4:]
                            
                                  elseif getline('.') =~# '^[+-]' && search('^@@ -\d\+\%(,\d\+\)\= +\d\+','bnW')
                                    let type = getline('.')[0]
                                    let lnum = line('.') - 1
                                    let offset = 0
                                    while getline(lnum) !~# '^@@ -\d\+\%(,\d\+\)\= +\d\+'
                                      if getline(lnum) =~# '^[ '.type.']'
                                        let offset += 1
                                      endif
                                      let lnum -= 1
                                    endwhile
                                    let offset += matchstr(getline(lnum), type.'\zs\d\+')
                                    let ref = getline(search('^'.type.'\{3\} [abciow12]/','bnW'))[4:-1]
                                    let dcmds = [offset, 'normal!zv']
                            
                                  elseif getline('.') =~# '^rename from '
                                    let ref = 'a/'.getline('.')[12:]
                                  elseif getline('.') =~# '^rename to '
                                    let ref = 'b/'.getline('.')[10:]
                            
                                  elseif getline('.') =~# '^@@ -\d\+\%(,\d\+\)\= +\d\+'
                                    let diff = getline(search('^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)', 'bcnW'))
                                    let offset = matchstr(getline('.'), '+\zs\d\+')
                            
                                    let dref = matchstr(diff, '\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(diff, '\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit! +'.offset
                            
                                  elseif getline('.') =~# '^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)'
                                    let dref = matchstr(getline('.'),'\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(getline('.'),'\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit!'
                            
                                  elseif getline('.') =~# '^index ' && getline(line('.')-1) =~# '^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)'
                                    let line = getline(line('.')-1)
                                    let dref = matchstr(line,'\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(line,'\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit!'
                            
                                  elseif line('$') == 1 && getline('.') =~ '^\x\{40,\}$'
                                    let ref = getline('.')
                            
                                  elseif expand('<cword>') =~# '^\x\{7,\}\>'
                                    return [expand('<cword>')]
                            
                                  else
                                    let ref = ''
                                  endif
                            
                                  let prefixes = { '1': '', '2': '', 'b': ':0:', 'i': ':0:', 'o': '', 'w': ''}
                            
                                  if len(myhash)
                                    let prefixes.a = myhash.'^:'
                                    let prefixes.b = myhash.':'
                                  endif
                                  let ref = substitute(ref, '^\(\w\)/', '\=get(prefixes, submatch(1), "HEAD:")', '')
                                  if exists('dref')
                                    let dref = substitute(dref, '^\(\w\)/', '\=get(prefixes, submatch(1), "HEAD:")', '')
                                  endif
                            
                                  if ref ==# '/dev/null'
                                    " Empty blob
                                    let ref = 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'
                                  endif
                            
                                  if exists('dref')
                                    return [ref, dcmd . ' ' . s:fnameescape(dref)] + dcmds
                                  elseif ref != ""
                                    return [ref] + dcmds
                                  endif
                            
                                endif
                                return []
                              endtry

FUNCTION  <SNR>44_LinuxFormatting()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                setlocal tabstop=8
                                setlocal shiftwidth=8
                                setlocal softtabstop=8
                                setlocal textwidth=80
                                setlocal noexpandtab
                            
                                setlocal cindent
                                setlocal cinoptions=:0,l1,t0,g0,(0

FUNCTION  fugitive#getfsize()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let entry = s:PathInfo(a:url)
                              if entry[4] == -2 && entry[2] ==# 'blob' && len(entry[3])
                                let dir = s:DirCommitFile(a:url)[0]
                                let entry[4] = +s:ChompDefault(-1, [dir, 'cat-file', '-s', entry[3]])
                              endif
                              return entry[4]

FUNCTION  go#util#snakecase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let word = substitute(a:word, '::', '/', 'g')
                              let word = substitute(word, '\(\u\+\)\(\u\l\)', '\1_\2', 'g')
                              let word = substitute(word, '\(\l\|\d\)\(\u\)', '\1_\2', 'g')
                              let word = substitute(word, '[.-]', '_', 'g')
                              let word = tolower(word)
                              return word

FUNCTION  sy#verbose()
Called 9 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
    9              0.000021   if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
    9              0.000005   endif

FUNCTION  <SNR>103_BlurStatus()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if (&previewwindow || exists('w:fugitive_status')) && get(b:,'fugitive_type', '') ==# 'index'
                                let winnrs = filter([winnr('#')] + range(1, winnr('$')), 's:UsableWin(v:val)')
                                if len(winnrs)
                                  exe winnrs[0].'wincmd w'
                                else
                                  belowright new
                                endif
                                if &diff
                                  call s:DiffClose()
                                endif
                              endif

FUNCTION  <SNR>103_ExpandSplit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let list = []
                              let string = a:string
                              let handle_bar = a:0 && a:1
                              let dquote = handle_bar ? '"\%([^"]\|""\|\\"\)*"\|' : ''
                              let cwd = a:0 > 1 ? a:2 : getcwd()
                              while string =~# '\S'
                                if handle_bar && string =~# '^\s*|'
                                  return [list, substitute(string, '^\s*', '', '')]
                                endif
                                let arg = matchstr(string, '^\s*\%(' . dquote . '''[^'']*''\|\\.\|[^[:space:] ' . (handle_bar ? '|' : '') . ']\)\+')
                                let string = strpart(string, len(arg))
                                let arg = substitute(arg, '^\s\+', '', '')
                                if !exists('seen_separator')
                                  let arg = substitute(arg, '^\%([^:.][^:]*:\|^:\|^:[0-3]:\)\=\zs\.\.\=\%(/.*\)\=$', '\=s:DotRelative(s:Slash(simplify(getcwd() . "/" . submatch(0))), cwd)', '')
                                endif
                                let arg = substitute(arg, '\(' . dquote . '''\%(''''\|[^'']\)*''\|\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand, '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5), cwd)', 'g')
                                call add(list, arg)
                                if arg ==# '--'
                                  let seen_separator = 1
                                endif
                              endwhile
                              return handle_bar ? [list, ''] : list

FUNCTION  <SNR>7_MultiMatch()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists("b:match_words") || b:match_words == ""
                                return ""
                              end
                              let restore_options = ""
                              if exists("b:match_ignorecase") && b:match_ignorecase != &ic
                                let restore_options .= (&ic ? " " : " no") . "ignorecase"
                                let &ignorecase = b:match_ignorecase
                              endif
                              let startline = line(".")
                              let startcol = col(".")
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR	flag for whether there are backrefs
                              "   s:pat	parsed version of b:match_words
                              "   s:all	regexp based on s:pat and the default groups
                              " This part is copied and slightly modified from s:Match_wrapper().
                              let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") . '\/\*:\*\/,#\s*if\%(def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                              " Allow b:match_words = "GetVimMatchWords()" .
                              if b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                execute "let match_words =" b:match_words
                              endif
                              if (match_words != s:last_words) || (&mps != s:last_mps) || exists("b:match_debug")
                                let s:last_words = match_words
                                let s:last_mps = &mps
                                let match_words = match_words . (strlen(match_words) ? "," : "") . default
                                if match_words !~ s:notslash . '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = '\%(' . substitute(s:pat . (strlen(s:pat) ? "," : "") . default, '[,:]\+', '\\|', 'g') . '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                              endif
                            
                              " Second step:  figure out the patterns for searchpair()
                              " and save the screen, cursor position, and 'ignorecase'.
                              " - TODO:  A lot of this is copied from s:Match_wrapper().
                              " - maybe even more functionality should be split off
                              " - into separate functions!
                              let cdefault = (s:pat =~ '[^,]$' ? "," : "") . default
                              let open =  substitute(s:pat . cdefault, s:notslash . '\zs:.\{-}' . s:notslash . ',', '\\),\\(', 'g')
                              let open =  '\(' . substitute(open, s:notslash . '\zs:.*$', '\\)', '')
                              let close = substitute(s:pat . cdefault, s:notslash . '\zs,.\{-}' . s:notslash . ':', '\\),\\(', 'g')
                              let close = substitute(close, '^.\{-}' . s:notslash . ':', '\\(', '') . '\)'
                              if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" . b:match_comment
                              else
                                let skip = 's:comment\|string'
                              endif
                              let skip = s:ParseSkip(skip)
                              " save v:count1 variable, might be reset from the restore_cursor command
                              let level = v:count1
                              let restore_cursor = virtcol(".") . "|"
                              normal! g0
                              let restore_cursor = line(".") . "G" .  virtcol(".") . "|zs" . restore_cursor
                              normal! H
                              let restore_cursor = "normal!" . line(".") . "Gzt" . restore_cursor
                              execute restore_cursor
                            
                              " Third step: call searchpair().
                              " Replace '\('--but not '\\('--with '\%(' and ',' with '\|'.
                              let openpat =  substitute(open, '\(\\\@<!\(\\\\\)*\)\@<=\\(', '\\%(', 'g')
                              let openpat = substitute(openpat, ',', '\\|', 'g')
                              let closepat = substitute(close, '\(\\\@<!\(\\\\\)*\)\@<=\\(', '\\%(', 'g')
                              let closepat = substitute(closepat, ',', '\\|', 'g')
                            
                              if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = '0'
                              else
                                try
                                  execute "if " . skip . "| let skip = '0' | endif"
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                              mark '
                              while level
                                if searchpair(openpat, '', closepat, a:spflag, skip) < 1
                                  call s:CleanUp(restore_options, a:mode, startline, startcol)
                                  return ""
                                endif
                                let level = level - 1
                              endwhile
                            
                              " Restore options and return a string to restore the original position.
                              call s:CleanUp(restore_options, a:mode, startline, startcol)
                              return restore_cursor

FUNCTION  go#util#HasDebug()
Called 63 times
Total time:   0.000861
 Self time:   0.000509

count  total (s)   self (s)
   63   0.000834   0.000482   return index(go#config#Debug(), a:flag) >= 0

FUNCTION  <SNR>103_BlameLeave()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let bufwinnr = bufwinnr(s:BlameBufnr())
                              if bufwinnr > 0
                                let bufnr = bufnr('')
                                exe bufwinnr . 'wincmd w'
                                return bufnr . 'bdelete'
                              endif
                              return ''

FUNCTION  <SNR>103_Owner()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 ? a:1 : s:Dir()
                              if empty(dir)
                                return ''
                              endif
                              let actualdir = fugitive#Find('.git/', dir)
                              let [pdir, commit, file] = s:DirCommitFile(a:path)
                              if s:cpath(dir, pdir)
                                if commit =~# '^\x\{40,\}$'
                                  return commit
                                elseif commit ==# '2'
                                  return 'HEAD^{}'
                                endif
                                if filereadable(actualdir . 'MERGE_HEAD')
                                  let merge_head = 'MERGE_HEAD'
                                elseif filereadable(actualdir . 'REBASE_HEAD')
                                  let merge_head = 'REBASE_HEAD'
                                else
                                  return ''
                                endif
                                if commit ==# '3'
                                  return merge_head . '^{}'
                                elseif commit ==# '1'
                                  return s:TreeChomp('merge-base', 'HEAD', merge_head, '--')
                                endif
                              endif
                              let path = fnamemodify(a:path, ':p')
                              if s:cpath(actualdir, strpart(path, 0, len(actualdir))) && a:path =~# 'HEAD$'
                                return strpart(path, len(actualdir))
                              endif
                              let refs = fugitive#Find('.git/refs', dir)
                              if s:cpath(refs . '/', path[0 : len(refs)]) && path !~# '[\/]$'
                                return strpart(path, len(refs) - 4)
                              endif
                              return ''

FUNCTION  <SNR>101_manual_update_tags()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let l:restore_prev_trace = 0
                                let l:prev_trace = g:gutentags_trace
                                if &verbose > 0
                                    let g:gutentags_trace = 1
                                    let l:restore_prev_trace = 1
                                endif
                            
                                try
                                    let l:bn = bufnr('%')
                                    for module in g:gutentags_modules
                                        call s:update_tags(l:bn, module, a:bang, 0)
                                    endfor
                                    silent doautocmd User GutentagsUpdating
                                finally
                                    if l:restore_prev_trace
                                        let g:gutentags_trace = l:prev_trace
                                    endif
                                endtry

FUNCTION  <SNR>51_Map()
Called 2 times
Total time:   0.000441
 Self time:   0.000441

count  total (s)   self (s)
    4              0.000029   for mode in split(a:mode, '\zs')
    2              0.000020     let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')
    2              0.000005     let head = a:lhs
    2              0.000002     let tail = ''
    2              0.000010     let keys = get(g:, mode.'remap', {})
    2              0.000007     if type(keys) == type([])
                                  return
    2              0.000002     endif
    6              0.000013     while !empty(head)
    4              0.000012       if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
    4              0.000004       endif
    4              0.000077       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
    4              0.000050       let head = substitute(head, '<[^<>]*>$\|.$', '', '')
    6              0.000007     endwhile
    2              0.000020     if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))
    2              0.000051       exe mode.'map' s:nowait flags head.tail a:rhs
    2              0.000002     endif
    4              0.000004   endfor

FUNCTION  go#auto#auto_sameids()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !go#config#AutoSameids() || !isdirectory(expand('%:p:h'))
                                return
                              endif
                            
                              " GoSameId automatic update
                              call go#guru#SameIds(0)

FUNCTION  tcomment#deprecated#Check()
Called 1 time
Total time:   0.000320
 Self time:   0.000320

count  total (s)   self (s)
    1              0.000031     let vars = {   'tcommentModeExtra': 'g:tcomment#mode_extra' , 'tcommentOpModeExtra': 'g:tcomment#operator#mode_extra' , 'tcommentOptions': 'g:tcomment#options' , 'tcommentGuessFileType': 'g:tcomment#filetype#guess' , 'tcommentMaps': 'g:tcomment_maps' , 'tcommentMapLeader1': 'g:tcomment_mapleader1' , 'tcommentMapLeader2': 'g:tcomment_mapleader2' , 'tcommentMapLeaderOp1': 'g:tcomment_opleader1' , 'tcommentMapLeaderUncommentAnyway': 'g:tcomment_mapleader_uncomment_anyway' , 'tcommentMapLeaderCommentAnyway': 'g:tcomment_mapleader_comment_anyway' , 'tcommentTextObjectInlineComment': 'g:tcomment_textobject_inlinecomment' , 'tcomment#filetype_map': 'g:tcomment#filetype#map' , 'tcomment#syntax_substitute': 'g:tcomment#syntax#substitute' , 'tcommentSyntaxMap': 'g:tcomment#filetype#syntax_map' , 'tcommentLineC_fmt': 'g:tcomment#line_fmt_c' , 'tcommentInlineC': 'g:tcomment#inline_fmt_c' , 'tcommentInlineXML': 'g:tcomment#inline_fmt_xml' , 'tcommentBlockC': 'g:tcomment#block_fmt_c' , 'tcommentBlockXML': 'g:tcomment#block_fmt_xml' , 'tcommentBlockC2': 'g:tcomment#block2_fmt_c' }
                            
    1              0.000005     let patterns = {   'tcommentGuessFileType_\(\w\+\)': 'g:tcomment#filetype#guess_\1' , 'tcommentIgnoreTypes_\(\w\+\)': 'g:tcomment#filetype#ignore_\1' }
                            
    1              0.000020     let pattern = '\C^\%(' . join(keys(patterns) + keys(vars), '\|') . '\)$'
                                " let gvars = filter(keys(g:), 'v:val =~# pattern')
                                " let gvars = filter(keys(g:), 'v:val =~# ''^tcomment''')
    1              0.000230     let gvars = filter(keys(g:), 'strpart(v:val, 0, '. strlen('tcomment') .') ==# ''tcomment''')
                            
    1              0.000003     for gold in gvars
                                    let gnew = ''
                            
                                    if has_key(vars, gold)
                                        let gnew = vars[gold]
                                    elseif gold =~# pattern
                                        for [search, replace] in items(patterns)
                                            if gold =~# search
                                                let gnew = substitute(gold, search, replace, '')
                                                break
                                            endif
                                        endfor
                                    endif
                            
                                    if !empty(gnew)
                                        echom 'tcomment:' gold 'is deprecated; please use' gnew 'instead; your setting might be ignored'
                                        exec 'let' gnew '= g:'. gold
                                    endif
    1              0.000001     endfor

FUNCTION  go#util#Shelljoin()
Called 2 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    2              0.000014   try
    2              0.000006     let ssl_save = &shellslash
    2              0.000004     set noshellslash
    2              0.000002     if a:0
                                  return join(map(copy(a:arglist), 'shellescape(v:val, ' . a:1 . ')'), ' ')
    2              0.000001     endif
                            
    2              0.000041     return join(map(copy(a:arglist), 'shellescape(v:val)'), ' ')
    2              0.000005   finally
    2              0.000006     let &shellslash = ssl_save
    2              0.000004   endtry

FUNCTION  fugitive#CanDiffoff()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:can_diffoff(bufnr(a:buf))

FUNCTION  <SNR>103_RebaseEdit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let rebase_todo = s:fnameescape(fugitive#Find('.git/rebase-merge/git-rebase-todo', a:dir))
                            
                              if filereadable(rebase_todo)
                                let new = readfile(rebase_todo)
                                let sha_length = 0
                                let shas = {}
                            
                                for i in range(len(new))
                                  if new[i] =~# '^\l\+\s\+[0-9a-f]\{5,\}\>'
                                    let sha = matchstr(new[i], '\C\<[a-f0-9]\{5,\}\>')
                                    if !sha_length
                                      let sha_length = len(s:TreeChomp(a:dir, 'rev-parse', '--short', sha))
                                    endif
                                    let shortened_sha = strpart(sha, 0, sha_length)
                                    let shas[shortened_sha] = sha
                                    let new[i] = substitute(new[i], sha, shortened_sha, '')
                                  endif
                                endfor
                                call writefile(new, rebase_todo)
                              endif
                              return a:cmd . ' +setlocal\ bufhidden=wipe\|' . escape('let b:fugitive_rebase_shas = ' . string(shas), ' ') . ' ' . rebase_todo

FUNCTION  fugitive#isdirectory()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:PathInfo(a:url)[2] ==# 'tree'

FUNCTION  <SNR>103_DoStageUnstagedHeading()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:DoToggleUnstagedHeading(a:heading)

FUNCTION  <SNR>103_repo_translate()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:Slash(fugitive#Find(substitute(a:rev, '^/', ':(top)', ''), self.git_dir))

FUNCTION  go#config#FoldEnable()
Called 42 times
Total time:   0.000729
 Self time:   0.000482

count  total (s)   self (s)
   42              0.000085   if a:0 > 0
   21              0.000106     return index(go#config#FoldEnable(), a:1) > -1
   21              0.000015   endif
   21              0.000102   return get(g:, 'go_fold_enable', ['block', 'import', 'varconst', 'package_comment'])

FUNCTION  <SNR>100_check_diff_accurev()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return (a:exitval >= 2) ? [0, []] : [1, a:diff]

FUNCTION  <SNR>103_repo_git_chomp_in_tree()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let cdback = s:Cd(self.tree())
                              try
                                return call(self.git_chomp, a:000, self)
                              finally
                                execute cdback
                              endtry

FUNCTION  <SNR>103_MergeComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:CompleteSub('merge', a:A, a:L, a:P, function('s:CompleteRevision'))

FUNCTION  <SNR>103_Cd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'
                              if !a:0
                                return cd
                              endif
                              let cwd = getcwd()
                              if s:cpath(cwd, a:1)
                                return ''
                              endif
                              exe cd s:fnameescape(a:1)
                              return cd . ' ' . s:fnameescape(cwd)

FUNCTION  <SNR>57_LP_Not()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            "  call Dfunc("LP_Not(pat<".a:pat.">)")
                              if a:pat =~ '^\.\*' && a:pat =~ '\.\*$'
                               let pat= substitute(a:pat,'^\.\*\(.*\)\.\*$','\1','')
                               let ret= '^\%(\%('.pat.'\)\@!.\)*$'
                              else
                               let ret= '^\%(\%('.a:pat.'\)\@!.\)*$'
                              endif
                            "  call Dret("LP_Not ".ret)
                              return ret

FUNCTION  <SNR>1_AddRTP()
Called 26 times
Total time:   0.002181
 Self time:   0.002181

count  total (s)   self (s)
   26              0.000292     let dir = glob(a:dir)
                            
   26              0.000092     if !isdirectory(dir)
   25              0.000448         let dir = glob('~/configit/vim/modules/') . a:dir
   25              0.000176         if !isdirectory(dir)
                                        echomsg printf('Invalid rtp: %s, %s', a:dir, dir)
                                        return v:false
   25              0.000050         endif
   26              0.000053     endif
                            
   26              0.000165     if isdirectory(dir)
   26              0.000127         call add(s:rtp_pre, dir)
   26              0.000030     endif
   26              0.000223     if isdirectory(dir . '/after')
    6              0.000041         call add(s:rtp_after, dir . '/after')
   26              0.000029     endif
                            
   26              0.000065     return v:true

FUNCTION  <SNR>103_RebaseSubcommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:MergeRebase('rebase', a:bang, a:mods, a:args)

FUNCTION  <SNR>49_closematch()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " Close an open (, {, [, or < on the command line.
                              let tail = matchstr(a:str,'.[^\[\](){}<>]*$')
                              if tail =~ '^\[.\+'
                                return "]"
                              elseif tail =~ '^(.\+'
                                return ")"
                              elseif tail =~ '^{.\+'
                                return "}"
                              elseif tail =~ '^<.+'
                                return ">"
                              else
                                return ""
                              endif

FUNCTION  fugitive#detect()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return FugitiveDetect(a:path)

FUNCTION  <SNR>49_beep()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              exe "norm! \<Esc>"
                              return ""

FUNCTION  go#config#TemplateAutocreate()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_template_autocreate", 1)

FUNCTION  <SNR>94_on_stdout()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let self.stdout_buf = s:neocb(a:mode, a:ch, self.stdout_buf, a:data, self.out_cb)

FUNCTION  go#fmt#Format()
Called 1 time
Total time:   0.050067
 Self time:   0.003309

count  total (s)   self (s)
    1   0.000018   0.000010   if go#config#FmtExperimental()
                                " Using winsaveview to save/restore cursor state has the problem of
                                " closing folds on save:
                                "   https://github.com/fatih/vim-go/issues/502
                                " One fix is to use mkview instead. Unfortunately, this sometimes causes
                                " other bad side effects:
                                "   https://github.com/fatih/vim-go/issues/728
                                " and still closes all folds if foldlevel>0:
                                "   https://github.com/fatih/vim-go/issues/732
                                let l:curw = {}
                                try
                                  mkview!
                                catch
                                  let l:curw = winsaveview()
                                endtry
                            
                                " save our undo file to be restored after we are done. This is needed to
                                " prevent an additional undo jump due to BufWritePre auto command and also
                                " restore 'redo' history because it's getting being destroyed every
                                " BufWritePre
                                let tmpundofile = tempname()
                                exe 'wundo! ' . tmpundofile
    1              0.000001   else
                                " Save cursor position and many other things.
    1              0.000009     let l:curw = winsaveview()
    1              0.000001   endif
                            
                              " Write current unsaved buffer to a temp file
    1              0.000006   let l:tmpname = tempname() . '.go'
    1   0.002860   0.002728   call writefile(go#util#GetLines(), l:tmpname)
    1   0.000048   0.000036   if go#util#IsWin()
                                let l:tmpname = tr(l:tmpname, '\', '/')
    1              0.000001   endif
                            
    1   0.000013   0.000007   let bin_name = go#config#FmtCommand()
    1              0.000003   if a:withGoimport == 1
                                let bin_name = "goimports"
    1              0.000001   endif
                            
    1              0.000004   let current_col = col('.')
    1   0.029962   0.000023   let [l:out, l:err] = go#fmt#run(bin_name, l:tmpname, expand('%'))
    1              0.000258   let diff_offset = len(readfile(l:tmpname)) - line('$')
                            
    1              0.000005   if l:err == 0
    1   0.016697   0.000041     call go#fmt#update_file(l:tmpname, expand('%'))
                              elseif !go#config#FmtFailSilently()
                                let errors = s:parse_errors(expand('%'), out)
                                call s:show_errors(errors)
    1              0.000001   endif
                            
                              " We didn't use the temp file, so clean up
    1              0.000010   call delete(l:tmpname)
                            
    1   0.000011   0.000006   if go#config#FmtExperimental()
                                " restore our undo history
                                silent! exe 'rundo ' . tmpundofile
                                call delete(tmpundofile)
                            
                                " Restore our cursor/windows positions, folds, etc.
                                if empty(l:curw)
                                  silent! loadview
                                else
                                  call winrestview(l:curw)
                                endif
    1              0.000001   else
                                " Restore our cursor/windows positions.
    1              0.000086     call winrestview(l:curw)
    1              0.000001   endif
                            
                              " be smart and jump to the line the new statement was added/removed
    1              0.000008   call cursor(line('.') + diff_offset, current_col)
                            
                              " Syntax highlighting breaks less often.
    1              0.000003   syntax sync fromstart

FUNCTION  10()
Called 16 times
Total time:   0.013730
 Self time:   0.002596

count  total (s)   self (s)
   16              0.000374       let self.buf .= a:data
                            
   16   0.009587   0.000348       let [self.buf, l:messages] = self.readMessage(self.buf)
                            
   69              0.000148       for l:message in l:messages
   53              0.000196         if has_key(l:message, 'method')
   52              0.000124           if has_key(l:message, 'id')
    2   0.000431   0.000018             call self.handleRequest(l:message)
   50              0.000039           else
   50   0.000330   0.000276             call self.handleNotification(l:message)
   52              0.000063           endif
    1              0.000007         elseif has_key(l:message, 'result') || has_key(l:message, 'error')
    1   0.001446   0.000018           call self.handleResponse(l:message)
   53              0.000046         endif
   69              0.000091       endfor

FUNCTION  <SNR>103_Remote()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let head = FugitiveHead(0, a:dir)
                              let remote = len(head) ? fugitive#Config('branch.' . head . '.remote') : ''
                              let i = 10
                              while remote ==# '.' && i > 0
                                let head = matchstr(fugitive#Config('branch.' . head . '.merge'), 'refs/heads/\zs.*')
                                let remote = len(head) ? fugitive#Config('branch.' . head . '.remote') : ''
                                let i -= 1
                              endwhile
                              return remote =~# '^\.\=$' ? 'origin' : remote

FUNCTION  12()
Called 50 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
                                  " TODO(bc): handle notifications (e.g. window/showMessage).

FUNCTION  13()
Called 1 time
Total time:   0.001428
 Self time:   0.000150

count  total (s)   self (s)
    1              0.000014     if has_key(a:resp, 'id') && has_key(self.handlers, a:resp.id)
    1              0.000003       try
    1              0.000008         let l:handler = self.handlers[a:resp.id]
                            
    1              0.000007         let l:winid = win_getid(winnr())
                                    " Always set the active window to the window that was active when
                                    " the request was sent. Among other things, this makes sure that
                                    " the correct window's location list will be populated when the
                                    " list type is 'location' and the user has moved windows since
                                    " sending the request.
    1              0.000008         call win_gotoid(l:handler.winid)
                            
    1              0.000003         if has_key(a:resp, 'error')
                                      call l:handler.requestComplete(0)
                                      if has_key(l:handler, 'error')
                                        call call(l:handler.error, [a:resp.error.message])
                                      else
                                        call go#util#EchoError(a:resp.error.message)
                                      endif
                                      call win_gotoid(l:winid)
                                      return
    1              0.000001         endif
    1   0.000036   0.000016         call l:handler.requestComplete(1)
                            
    1              0.000003         let l:winidBeforeHandler = l:handler.winid
    1   0.001273   0.000015         call call(l:handler.handleResult, [a:resp.result])
                            
                                    " change the window back to the window that was active when
                                    " starting to handle the message _only_ if the handler didn't
                                    " update the winid, so that handlers can set the winid if needed
                                    " (e.g. :GoDef).
    1              0.000004         if l:handler.winid == l:winidBeforeHandler
    1              0.000004           call win_gotoid(l:winid)
    1              0.000001         endif
    1              0.000002       finally
    1              0.000007         call remove(self.handlers, a:resp.id)
    1              0.000001       endtry
    1              0.000001     endif

FUNCTION  14()
Called 1 time
Total time:   0.001258
 Self time:   0.000096

count  total (s)   self (s)
    1   0.000010   0.000005     if go#config#EchoCommandInfo()
    1   0.000112   0.000007       call go#util#EchoProgress("initialized gopls")
    1              0.000001     endif
    1              0.000006     let status = { 'desc': '', 'type': 'gopls', 'state': 'initialized', }
    1   0.000155   0.000021     call go#statusline#Update(self.wd, status)
                            
    1              0.000002     let self.ready = 1
    1   0.000043   0.000012     let  l:msg = self.newMessage(go#lsp#message#Initialized())
    1   0.000135   0.000006     call self.write(l:msg)
                            
                                " send messages queued while waiting for ready.
    2              0.000007     for l:item in self.queue
    1   0.000767   0.000009       call self.sendMessage(l:item.data, l:item.handler)
    2              0.000003     endfor
                            
                                " reset the queue
    1              0.000002     let self.queue = []

FUNCTION  15()
Called 3 times
Total time:   0.032166
 Self time:   0.000576

count  total (s)   self (s)
    3              0.000007     if !self.last_request_id
    1   0.023286   0.000016       let l:wd = go#util#ModuleRoot()
    1              0.000002       if l:wd == -1
                                    call go#util#EchoError('could not determine appropriate working directory for gopls')
                                    return -1
    1              0.000001       endif
                            
    1              0.000002       if l:wd == ''
                                    let l:wd = getcwd()
    1              0.000001       endif
    1              0.000005       let self.wd = l:wd
                            
    1   0.000024   0.000018       if go#config#EchoCommandInfo()
    1   0.006009   0.000011         call go#util#EchoProgress("initializing gopls")
    1              0.000001       endif
                            
    1              0.000007       let l:status = { 'desc': '', 'type': 'gopls', 'state': 'initializing', }
    1   0.000833   0.000264       call go#statusline#Update(l:wd, l:status)
                            
    1              0.000008       let self.workspaceDirectories = add(self.workspaceDirectories, l:wd)
    1   0.000313   0.000015       let l:msg = self.newMessage(go#lsp#message#Initialize(l:wd))
                            
    1   0.000044   0.000008       let l:state = s:newHandlerState('')
    1              0.000007       let l:state.handleResult = funcref('self.handleInitializeResult', [], l:self)
                            
    1              0.000006       let self.handlers[l:msg.id] = l:state
                            
    1   0.000014   0.000004       call l:state.start()
    1   0.000124   0.000005       call self.write(l:msg)
    3              0.000003     endif
                            
    3              0.000005     if !self.ready
    1              0.000009       call add(self.queue, {'data': a:data, 'handler': a:handler})
    1              0.000002       return
    2              0.000002     endif
                            
    2   0.000057   0.000013     let l:msg = self.newMessage(a:data)
    2              0.000006     if has_key(l:msg, 'id')
                                  let self.handlers[l:msg.id] = a:handler
    2              0.000002     endif
                            
    2   0.000028   0.000012     call a:handler.start()
    2   0.001236   0.000012     call self.write(l:msg)

FUNCTION  16()
Called 4 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    4              0.000025     let l:msg = { 'method': a:data.method, 'jsonrpc': '2.0', }
                            
    4              0.000008     if !a:data.notification
    1              0.000003       let self.last_request_id += 1
    1              0.000003       let l:msg.id = self.last_request_id
    4              0.000003     endif
                            
    4              0.000012     if has_key(a:data, 'params')
    4              0.000009       let l:msg.params = a:data.params
    4              0.000004     endif
                            
    4              0.000006     return l:msg

FUNCTION  17()
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000011     let l:msg = { 'jsonrpc': '2.0', 'id': a:id, 'result': a:result, }
                            
    2              0.000003     return l:msg

FUNCTION  18()
Called 6 times
Total time:   0.001659
 Self time:   0.001472

count  total (s)   self (s)
    6              0.001046     let l:body = json_encode(a:msg)
    6              0.000096     let l:data = 'Content-Length: ' . strlen(l:body) . "\r\n\r\n" . l:body
                            
    6   0.000256   0.000069     call s:debug('sent', l:data)
                            
    6              0.000035     if has('nvim')
                                  call chansend(self.job, l:data)
                                  return
    6              0.000006     endif
                            
    6              0.000166     call ch_sendraw(self.job, l:data)

FUNCTION  19()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let self.exited = 1
                                if !get(self, 'restarting', 0)
                                  return
                                endif
                            
                                let l:queue = self.queue
                            
                                let l:workspaces = self.workspaceDirectories
                            
                                call s:lspfactory.reset()
                                let l:lsp = s:lspfactory.get()
                            
                                " restore workspaces
                                call call('go#lsp#AddWorkspaceDirectory', l:workspaces)
                                " * send DidOpen messages for all buffers that have b:did_lsp_open set
                                " TODO(bc): check modifiable and filetype, too?
                                bufdo if get(b:, 'go_lsp_did_open', 0) | if &modified | call go#lsp#DidOpen(expand('%:p')) | else | call go#lsp#DidChange(expand('%:p')) | endif | endif
                                let l:lsp.queue = extend(l:lsp.queue, l:queue)
                                return

FUNCTION  gutentags#get_project_file_list_cmd()
Called 1 time
Total time:   0.000019
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000004     if type(g:gutentags_file_list_command) == type("")
    1   0.000014   0.000006         return gutentags#validate_cmd(g:gutentags_file_list_command)
                                elseif type(g:gutentags_file_list_command) == type({})
                                    let l:markers = get(g:gutentags_file_list_command, 'markers', [])
                                    if type(l:markers) == type({})
                                        for [marker, file_list_cmd] in items(l:markers)
                                            if !empty(globpath(a:path, marker, 1))
                                                return gutentags#validate_cmd(file_list_cmd)
                                            endif
                                        endfor
                                    endif
                                    return get(g:gutentags_file_list_command, 'default', "")
                                endif
                                return ""

FUNCTION  fugitive#filereadable()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:PathInfo(a:url)[2] ==# 'blob'

FUNCTION  <SNR>103_FormatFile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:dict.status . ' ' . a:dict.filename

FUNCTION  <SNR>39_load_scopes()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            	let gb = a:bang ? g: : b:
                            	let gb.snipMate = get(gb, 'snipMate', {})
                            	let gb.snipMate.scope_aliases = get(gb.snipMate, 'scope_aliases', {})
                            	let gb.snipMate.scope_aliases['_'] = join(split(get(gb.snipMate.scope_aliases, '_', ''), ',') + a:000, ',')

FUNCTION  <SNR>49_fixindent()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let str = substitute(a:str,'\t',repeat(' ',&sw),'g')
                              let spc = substitute(a:spc,'\t',repeat(' ',&sw),'g')
                              let str = substitute(str,'\(\n\|\%^\).\@=','\1'.spc,'g')
                              if ! &et
                                let str = substitute(str,'\s\{'.&ts.'\}',"\t",'g')
                              endif
                              return str

FUNCTION  <SNR>103_ReloadTabStatus()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let mytab = tabpagenr()
                              let tab = a:0 ? a:1 : mytab
                              for winnr in range(1, tabpagewinnr(tab, '$'))
                                if getbufvar(tabpagebuflist(tab)[winnr-1], 'fugitive_type') ==# 'index'
                                  execute 'tabnext '.tab
                                  if winnr != winnr()
                                    execute winnr.'wincmd w'
                                    let restorewinnr = 1
                                  endif
                                  try
                                    call s:ReloadWinStatus()
                                  finally
                                    if exists('restorewinnr')
                                      unlet restorewinnr
                                      wincmd p
                                    endif
                                    execute 'tabnext '.mytab
                                  endtry
                                endif
                              endfor
                              unlet! t:fugitive_reload_status

FUNCTION  go#config#SetModFmtAutosave()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:go_mod_fmt_autosave = a:value

FUNCTION  <SNR>39_grab_visual()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            	let a_save = @a
                            	try
                            		normal! gv"ay
                            		let b:snipmate_visual = @a
                            	finally
                            		let @a = a_save
                            	endtry

FUNCTION  <SNR>103_Do()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let line = getline('.')
                              let reload = 0
                              if !a:0 && !v:count && line =~# '^[A-Z][a-z]'
                                let header = matchstr(line, '^\S\+\ze:')
                                if len(header) && exists('*s:Do' . a:action . header . 'Header')
                                  let reload = s:Do{a:action}{header}Header(matchstr(line, ': \zs.*')) > 0
                                else
                                  let section = matchstr(line, '^\S\+')
                                  if exists('*s:Do' . a:action . section . 'Heading')
                                    let reload = s:Do{a:action}{section}Heading(line) > 0
                                  endif
                                endif
                                return reload ? s:ReloadStatus() : ''
                              endif
                              let selection = s:Selection(a:visual ? 'v' : 'n')
                              if empty(selection)
                                return ''
                              endif
                              call filter(selection, 'v:val.section ==# selection[0].section')
                              let status = 0
                              let err = ''
                              try
                                for record in selection
                                  if exists('*s:Do' . a:action . record.section)
                                    let status = s:Do{a:action}{record.section}(record)
                                  else
                                    continue
                                  endif
                                  if !status
                                    return ''
                                  endif
                                  let reload = reload || (status > 0)
                                endfor
                                if status < 0
                                  execute record.lnum + 1
                                endif
                                let success = 1
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                if reload
                                  execute s:ReloadStatus()
                                endif
                                if exists('success')
                                  call s:StageReveal()
                                endif
                              endtry
                              return ''

FUNCTION  fugitive#Cwindow()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &buftype == 'quickfix'
                                cwindow
                              else
                                botright cwindow
                                if &buftype == 'quickfix'
                                  wincmd p
                                endif
                              endif

FUNCTION  gutentags#start_job()
Called 2 times
Total time:   0.000720
 Self time:   0.000720

count  total (s)   self (s)
    2              0.000710         return job_start(a:cmd, a:opts)

FUNCTION  go#config#CodeCompletionEnabled()
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000016   return get(g:, "go_code_completion_enabled", 1)

FUNCTION  <SNR>94_on_stderr()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let self.stderr_buf = s:neocb(a:mode, a:ch, self.stderr_buf, a:data, self.err_cb )

FUNCTION  go#fmt#update_file()
Called 1 time
Total time:   0.016656
 Self time:   0.002080

count  total (s)   self (s)
                              " remove undo point caused via BufWritePre
    1              0.000010   try | silent undojoin | catch | endtry
                            
    1              0.000005   let old_fileformat = &fileformat
    1              0.000005   if exists("*getfperm")
                                " save file permissions
    1              0.000009     let original_fperm = getfperm(a:target)
    1              0.000001   endif
                            
    1              0.000213   call rename(a:source, a:target)
                            
                              " restore file permissions
    1              0.000010   if exists("*setfperm") && original_fperm != ''
    1              0.000017     call setfperm(a:target , original_fperm)
    1              0.000002   endif
                            
                              " reload buffer to reflect latest changes
    1   0.012873   0.001555   silent edit!
                            
    1              0.000011   let &fileformat = old_fileformat
    1   0.002842   0.000009   let &syntax = &syntax
                            
    1   0.000608   0.000183   let l:listtype = go#list#Type("GoFmt")
                            
                              " the title information was introduced with 7.4-2200
                              " https://github.com/vim/vim/commit/d823fa910cca43fec3c31c030ee908a14c272640
    1              0.000006   if has('patch-7.4.2200')
                                " clean up previous list
    1              0.000003     if l:listtype == "quickfix"
                                  let l:list_title = getqflist({'title': 1})
    1              0.000001     else
    1              0.000008       let l:list_title = getloclist(0, {'title': 1})
    1              0.000001     endif
                              else
                                " can't check the title, so assume that the list was for go fmt.
                                let l:list_title = {'title': 'Format'}
    1              0.000001   endif
                            
    1              0.000005   if has_key(l:list_title, "title") && l:list_title['title'] == "Format"
                                call go#list#Clean(l:listtype)
    1              0.000001   endif

FUNCTION  go#auto#modfmt_autosave()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !(go#config#ModFmtAutosave() && isdirectory(expand('%:p:h')) && expand('<afile>:p') == expand('%:p'))
                                return
                              endif
                            
                              " go.mod code formatting on save
                              call go#mod#Format()

FUNCTION  fugitive#RemoteUrl()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let remote = !a:0 || a:1 =~# '^\.\=$' ? s:Remote(dir) : a:1
                              if !fugitive#GitVersion(2, 7)
                                return fugitive#Config('remote.' . remote . '.url')
                              endif
                              return s:ChompDefault('', [dir, 'remote', 'get-url', remote, '--'])

FUNCTION  TCommentOpFunc_gcb()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gcb')
                            call tcomment#SetOption("mode_extra", "B")
                            return call('tcomment#operator#Line', a:000)

FUNCTION  20()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " TODO(bc): remove the buffer variables that indicate that gopls has been
                                " informed that the file is open

FUNCTION  21()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:msg =~ '^\tPort = \d\+$' && !get(self, 'debugport', 0)
                                  let self.debugport = substitute(a:msg, '^\tPort = \(\d\+\).*$', '\1', '')
                                endif
                            
                                call s:debug('stderr', a:msg)

FUNCTION  TCommentOpFunc_gcc()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gcc')
                            
                            return call('tcomment#operator#Line', a:000)

FUNCTION  <SNR>103_ExpireStatus()
Called 1 time
Total time:   0.000128
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000004   if a:bufnr == -2
                                let s:last_time = reltime()
                                return ''
    1              0.000001   endif
    1   0.000050   0.000012   let dir = s:Dir(a:bufnr)
    1              0.000003   if len(dir)
    1   0.000058   0.000013     let s:last_times[s:cpath(dir)] = reltime()
    1              0.000002   endif
    1              0.000002   return ''

FUNCTION  go#util#IsMac()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return has('mac') || has('macunix') || has('gui_macvim') || go#util#Exec(['uname'])[0] =~? '^darwin'

FUNCTION  <SNR>103_Generate()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#Find(a:rev, a:0 ? a:1 : s:Dir())

FUNCTION  go#config#LspLog()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " make sure g:go_lsp_log is set so that it can be added to easily.
                              let g:go_lsp_log = get(g:, 'go_lsp_log', [])
                              return g:go_lsp_log

FUNCTION  <SNR>103_BuildShell()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let cmd = copy(a:args)
                              let tree = s:Tree(a:dir)
                              let pre = ''
                              for [var, val] in items(a:env)
                                if s:winshell()
                                  let pre .= 'set ' . var . '=' . s:shellesc(val) . '& '
                                else
                                  let pre = (len(pre) ? pre : 'env ') . var . '=' . s:shellesc(val) . ' '
                                endif
                              endfor
                              if empty(tree) || index(cmd, '--') == len(cmd) - 1
                                call insert(cmd, '--git-dir=' . FugitiveGitPath(a:dir))
                              elseif fugitive#GitVersion(1, 8, 5)
                                call extend(cmd, ['-C', FugitiveGitPath(tree)], 'keep')
                              else
                                let pre = 'cd ' . s:shellesc(tree) . (s:winshell() ? '& ' : '; ') . pre
                              endif
                              return pre . g:fugitive_git_executable . ' ' . join(map(cmd, 's:shellesc(v:val)'))

FUNCTION  <SNR>92_start()
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000011   let self.started_at = reltime()
    3              0.000008   if self.statustype == ''
    3              0.000003     return
                              endif
                              let status = { 'desc': 'current status', 'type': self.statustype, 'state': "started", }
                            
                              call go#statusline#Update(self.jobdir, status)

FUNCTION  TCommentOpFunc_Uncommentb()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_Uncommentb')
                            call tcomment#SetOption("mode_extra", "UB")
                            return call('tcomment#operator#Line', a:000)

FUNCTION  TCommentOpFunc_Uncommentc()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_Uncommentc')
                            call tcomment#SetOption("mode_extra", "U")
                            return call('tcomment#operator#Line', a:000)

FUNCTION  <SNR>34_unknown_coercion()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:word

FUNCTION  go#config#DocMaxHeight()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_doc_max_height", 20)

FUNCTION  go#util#ExecInDir()
Called 1 time
Total time:   0.023158
 Self time:   0.000197

count  total (s)   self (s)
    1              0.000023   if !isdirectory(expand("%:p:h"))
                                return ['', 1]
    1              0.000001   endif
                            
    1              0.000017   let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd ' : 'cd '
    1              0.000004   let dir = getcwd()
    1              0.000002   try
    1              0.000040     execute cd . fnameescape(expand("%:p:h"))
    1   0.022998   0.000037     let [l:out, l:err] = call('go#util#Exec', [a:cmd] + a:000)
    1              0.000004   finally
    1              0.000056     execute cd . fnameescape(l:dir)
    1              0.000003   endtry
    1              0.000003   return [l:out, l:err]

FUNCTION  <SNR>103_LogParse()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:state.context ==# 'hunk' && a:line =~# '^[-+ ]'
                                return []
                              endif
                              let list = matchlist(a:line, '^\%(fugitive \(.\{-\}\)\t\|commit \|From \)\=\(\x\{40,\}\)\%( \(.*\)\)\=$')
                              if len(list)
                                let a:state.context = 'commit'
                                let a:state.base = 'fugitive://' . a:dir . '//' . list[2]
                                let a:state.base_module = len(list[1]) ? list[1] : list[2]
                                let a:state.message = list[3]
                                if has_key(a:state, 'diffing')
                                  call remove(a:state, 'diffing')
                                endif
                                let queue = s:LogFlushQueue(a:state)
                                let a:state.queue = [{ 'valid': 1, 'filename': a:state.base . a:state.target, 'module': a:state.base_module . substitute(a:state.target, '^/', ':', ''), 'text': a:state.message}]
                                let a:state.child_found = 0
                                return queue
                              elseif type(a:line) == type(0)
                                return s:LogFlushQueue(a:state)
                              elseif a:line =~# '^diff'
                                let a:state.context = 'diffhead'
                              elseif a:line =~# '^[+-]\{3\} \w/' && a:state.context ==# 'diffhead'
                                let a:state.diffing = a:line[5:-1]
                              elseif a:line =~# '^@@[^@]*+\d' && has_key(a:state, 'diffing') && has_key(a:state, 'base')
                                let a:state.context = 'hunk'
                                if empty(a:state.target) || a:state.target ==# a:state.diffing
                                  let a:state.child_found = 1
                                  call add(a:state.queue, { 'valid': 1, 'filename': a:state.base . a:state.diffing, 'module': a:state.base_module . substitute(a:state.diffing, '^/', ':', ''), 'lnum': +matchstr(a:line, '+\zs\d\+'), 'text': a:state.message . matchstr(a:line, ' @@\+ .\+')})
                                endif
                              elseif a:state.follow && a:line =~# '^ \%(mode change \d\|\%(create\|delete\) mode \d\|\%(rename\|copy\|rewrite\) .* (\d\+%)$\)'
                                let rename = matchstr(a:line, '^ rename \zs.* => .*\ze (\d\+%)$')
                                if len(rename)
                                  let rename = rename =~# '{.* => .*}' ? rename : '{' . rename . '}'
                                  if a:state.target ==# simplify('/' . substitute(rename, '{.* => \(.*\)}', '\1', ''))
                                    let a:state.target = simplify('/' . substitute(rename, '{\(.*\) => .*}', '\1', ''))
                                  endif
                                endif
                                if !get(a:state, 'ignore_summary')
                                  call add(a:state.queue, {'text': a:line})
                                endif
                              elseif a:state.context ==# 'commit' || a:state.context ==# 'init'
                                call add(a:state.queue, {'text': a:line})
                              endif
                              return []

FUNCTION  qf#IsQfWindow()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if getwinvar(a:nmbr, "&filetype") == "qf"
                                    return qf#IsLocWindow(a:nmbr) ? 0 : 1
                                endif
                            
                                return 0

FUNCTION  go#list#Clean()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:listtype == "locationlist"
                                lex []
                              else
                                cex []
                              endif
                            
                              call go#list#Close(a:listtype)

FUNCTION  <SNR>103_NextExpandedHunk()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for i in range(a:count)
                                call s:StageInline('show', line('.'), 1)
                                call search(s:file_pattern . '\|^@','W')
                              endfor
                              return '.'

FUNCTION  <SNR>103_ReloadWinStatus()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
    1              0.000001     return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatus()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatus()
                              endif

FUNCTION  Tabline()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let l:tabline = ''
                            
                                for i in range(tabpagenr('$'))
                                    let l:buflist = tabpagebuflist(i + 1)
                                    let l:winnr = tabpagewinnr(i + 1)
                                    let l:bufnr = l:buflist[l:winnr - 1]
                                    let l:bufname = fnamemodify(bufname(l:bufnr), ':~:.')
                                                                                "   | +- shorten after pwd
                                                                                "   +- shorten to $HOME
                                    " shwos [+] if buffer is modified, nothing otherwise
                                    let l:bufmod = getbufvar(l:bufnr, '&mod') ? '[+]' : ''
                            
                                    " select the highlighting
                                    if i + 1 == tabpagenr()
                                        let l:tabline .= '%#TabLineSel#'
                                    else
                                        let l:tabline .= '%#TabLine#'
                                    endif
                            
                                    let l:tabline .= printf('| %d %s%s |', i + 1, l:bufname, l:bufmod )
                                                            "   |  | +- buffer modified
                                                            "   |  +- buffer name
                                                            "   +- tab number
                                endfor
                            
                                " avoid hi error when opening new tabs
                                let l:tabline .= '%#TabLine#'
                            
                                " Fill to the end
                                let l:tabline .= '%=%#TabLineFill#%T'
                            
                                return l:tabline

FUNCTION  sy#sign#get_current_signs()
Called 1 time
Total time:   0.000110
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000003   let a:sy.internal = {}
    1              0.000002   let a:sy.external = {}
                            
    1   0.000061   0.000010   let signlist = sy#util#execute('sign place buffer='. a:sy.buffer)
                            
    1              0.000016   for signline in split(signlist, '\n')[2:]
                                let tokens = matchlist(signline, '\v^\s+\S+\=(\d+)\s+\S+\=(\d+)\s+\S+\=(.*)$')
                                let line   = str2nr(tokens[1])
                                let id     = str2nr(tokens[2])
                                let type   = tokens[3]
                            
                                if type =~# '^Signify'
                                  " Handle ambiguous signs. Assume you have signs on line 3 and 4.
                                  " Removing line 3 would lead to the second sign to be shifted up
                                  " to line 3. Now there are still 2 signs, both one line 3.
                                  if has_key(a:sy.internal, line)
                                    execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
                                  endif
                                  let a:sy.internal[line] = { 'type': type, 'id': id }
                                else
                                  let a:sy.external[line] = id
                                endif
    1              0.000002   endfor

FUNCTION  <SNR>103_BlameCommit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let line = a:0 ? a:1 : getline('.')
                              let state = a:0 ? a:2 : s:TempState()
                              let sigil = has_key(state, 'blame_reverse_end') ? '-' : '+'
                              let mods = (s:BlameBufnr() < 0 ? '' : &splitbelow ? "botright " : "topleft ")
                              let [commit, path, lnum] = s:BlameCommitFileLnum(line, state)
                              if empty(commit) && len(path) && has_key(state, 'blame_reverse_end')
                                let path = (len(state.blame_reverse_end) ? state.blame_reverse_end . ':' : ':(top)') . path
                                return fugitive#Open(mods . a:cmd, 0, '', '+' . lnum . ' ' . s:fnameescape(path), ['+' . lnum, path])
                              endif
                              if commit =~# '^0*$'
                                return 'echoerr ' . string('fugitive: no commit')
                              endif
                              if line =~# '^\^' && !has_key(state, 'blame_reverse_end')
                                let path = commit . ':' . path
                                return fugitive#Open(mods . a:cmd, 0, '', '+' . lnum . ' ' . s:fnameescape(path), ['+' . lnum, path])
                              endif
                              let cmd = fugitive#Open(mods . a:cmd, 0, '', commit, [commit])
                              if cmd =~# '^echoerr'
                                return cmd
                              endif
                              execute cmd
                              if a:cmd ==# 'pedit' || empty(path)
                                return ''
                              endif
                              if search('^diff .* b/\M'.escape(path,'\').'$','W')
                                call search('^+++')
                                let head = line('.')
                                while search('^@@ \|^diff ') && getline('.') =~# '^@@ '
                                  let top = +matchstr(getline('.'),' ' . sigil .'\zs\d\+')
                                  let len = +matchstr(getline('.'),' ' . sigil . '\d\+,\zs\d\+')
                                  if lnum >= top && lnum <= top + len
                                    let offset = lnum - top
                                    if &scrolloff
                                      +
                                      normal! zt
                                    else
                                      normal! zt
                                      +
                                    endif
                                    while offset > 0 && line('.') < line('$')
                                      +
                                      if getline('.') =~# '^[ ' . sigil . ']'
                                        let offset -= 1
                                      endif
                                    endwhile
                                    return 'normal! zv'
                                  endif
                                endwhile
                                execute head
                                normal! zt
                              endif
                              return ''

FUNCTION  <SNR>103_StageReveal()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let begin = a:0 ? a:1 : line('.')
                              if getline(begin) =~# '^@'
                                let end = begin + 1
                                while getline(end) =~# '^[ \+-]'
                                  let end += 1
                                endwhile
                              elseif getline(begin) =~# '^commit '
                                let end = begin
                                while end < line('$') && getline(end + 1) !~# '^commit '
                                  let end += 1
                                endwhile
                              elseif getline(begin) =~# s:section_pattern
                                let end = begin
                                while len(getline(end + 1))
                                  let end += 1
                                endwhile
                              endif
                              if exists('end')
                                while line('.') > line('w0') + &scrolloff && end > line('w$')
                                  execute "normal! \<C-E>"
                                endwhile
                              endif

FUNCTION  <SNR>34_create_dictionary()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dictionary = {}
                              let i = 0
                              let expanded = s:expand_braces({a:lhs : a:rhs})
                              for [lhs,rhs] in items(expanded)
                                if get(a:opts,'case',1)
                                  let dictionary[s:mixedcase(lhs)] = s:mixedcase(rhs)
                                  let dictionary[tolower(lhs)] = tolower(rhs)
                                  let dictionary[toupper(lhs)] = toupper(rhs)
                                endif
                                let dictionary[lhs] = rhs
                              endfor
                              let i += 1
                              return dictionary

FUNCTION  <SNR>103_shellesc()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if type(a:arg) == type([])
                                return join(map(copy(a:arg), 's:shellesc(v:val)'))
                              elseif a:arg =~ '^[A-Za-z0-9_/:.-]\+$'
                                return a:arg
                              elseif s:winshell()
                                return '"'.s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"').'"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  <SNR>103_QuickfixStream()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:QuickfixCreate(a:nr, {'title': a:title})
                              let winnr = winnr()
                              exe a:nr < 0 ? 'copen' : 'lopen'
                              if winnr != winnr()
                                wincmd p
                              endif
                            
                              let buffer = []
                              let lines = split(s:SystemError(s:shellesc(a:cmd))[0], "\n")
                              for line in lines
                                call extend(buffer, call(a:callback, a:000 + [line]))
                                if len(buffer) >= 20
                                  call s:QuickfixSet(a:nr, remove(buffer, 0, -1), 'a')
                                  redraw
                                endif
                              endfor
                              call s:QuickfixSet(a:nr, extend(buffer, call(a:callback, a:000 + [0])), 'a')
                            
                              if a:first && len(s:QuickfixGet(a:nr))
                                call s:BlurStatus()
                                return a:nr < 0 ? 'cfirst' : 'lfirst'
                              else
                                return 'exe'
                              endif

FUNCTION  <SNR>103_CompleteRemote()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let remote = matchstr(a:L, '\u\w*[! ] *\zs\S\+\ze ')
                              if !empty(remote)
                                let matches = s:LinesError('ls-remote', remote)[0]
                                call filter(matches, 'v:val =~# "\t" && v:val !~# "{"')
                                call map(matches, 's:sub(v:val, "^.*\t%(refs/%(heads/|tags/)=)=", "")')
                              else
                                let matches = s:LinesError('remote')[0]
                              endif
                              return s:FilterEscape(matches, a:A)

FUNCTION  go#config#FmtCommand()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return get(g:, "go_fmt_command", "gofmt")

FUNCTION  <SNR>52_map()
Called 20 times
Total time:   0.002614
 Self time:   0.002614

count  total (s)   self (s)
   20              0.000181   let flags = (a:0 ? a:1 : '') . (a:rhs =~# '^<Plug>' ? '' : '<script>')
   20              0.000040   let head = a:lhs
   20              0.000026   let tail = ''
   20              0.000102   let keys = get(g:, a:mode.'remap', {})
   20              0.000063   if type(keys) == type([])
                                return
   20              0.000025   endif
   68              0.000158   while !empty(head)
   48              0.000105     if has_key(keys, head)
                                  let head = keys[head]
                                  if empty(head)
                                    return
                                  endif
                                  break
   48              0.000034     endif
   48              0.000432     let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
   48              0.000381     let head = substitute(head, '<[^<>]*>$\|.$', '', '')
   68              0.000092   endwhile
   20              0.000410   exe a:mode.'map' flags head.tail a:rhs

FUNCTION  <SNR>92_infoFromHoverContent()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if len(a:content) < 1
                                return ''
                              endif
                            
                              let l:content = a:content[0]
                            
                              " strip off the method set and fields of structs and interfaces.
                              if l:content =~# '^\(type \)\?[^ ]\+ \(struct\|interface\)'
                                let l:content = substitute(l:content, '{.*', '', '')
                              endif
                            
                              return l:content

FUNCTION  <SNR>103_repo_rev_parse()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#RevParse(a:rev, self.git_dir)

FUNCTION  go#config#AlternateMode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_alternate_mode", "edit")

FUNCTION  <SNR>103_PreviousSection()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let orig = line('.')
                              if getline('.') !~# '^commit '
                                -
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern . '\|\%^', 'bW')
                                  break
                                endif
                              endfor
                              if getline('.') =~# s:section_commit_pattern || line('.') == 1
                                call s:StageReveal()
                                return getline('.') =~# s:section_pattern ? '+' : ':'
                              else
                                return orig
                              endif

FUNCTION  <SNR>103_DoUnstageUnpulledHeading()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call feedkeys(':Grebase')

FUNCTION  go#util#pascalcase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let word = go#util#camelcase(a:word)
                              return toupper(word[0]) . word[1:]

FUNCTION  go#statusline#Clear()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:clear()

FUNCTION  <SNR>34_dotcase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(s:snakecase(a:word),'_','.','g')

FUNCTION  <SNR>34_words()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let words = []
                              let lnum = line('w0')
                              while lnum <= line('w$')
                                let line = getline(lnum)
                                let col = 0
                                while match(line,'\<\k\k\+\>',col) != -1
                                  let words += [matchstr(line,'\<\k\k\+\>',col)]
                                  let col = matchend(line,'\<\k\k\+\>',col)
                                endwhile
                                let lnum += 1
                              endwhile
                              return words

FUNCTION  <SNR>34_grep_command()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let opts = s:normalize_options(a:flags)
                              let dict = s:create_dictionary(a:word,"",opts)
                              if &grepprg == "internal"
                                let lhs = "'".s:pattern(dict,opts.boundaries)."'"
                              else
                                let lhs = "-E '".s:egrep_pattern(dict,opts.boundaries)."'"
                              endif
                              return "grep".(a:bang ? "!" : "")." ".lhs." ".a:args

FUNCTION  <SNR>103_StageDelete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let restore = []
                              let err = ''
                              try
                                for info in s:Selection(a:lnum1, a:lnum2)
                                  if empty(info.paths)
                                    continue
                                  endif
                                  let hash = s:TreeChomp('hash-object', '-w', '--', info.paths[0])
                                  if empty(hash)
                                    continue
                                  endif
                                  if info.patch
                                    call s:StageApply(info, 1, info.section ==# 'Staged' ? ['--index'] : [])
                                  elseif info.status ==# '?'
                                    call s:TreeChomp('clean', '-f', '--', info.paths[0])
                                  elseif a:count == 2
                                    call s:TreeChomp('checkout', '--ours', '--', info.paths[0])
                                  elseif a:count == 3
                                    call s:TreeChomp('checkout', '--theirs', '--', info.paths[0])
                                  elseif info.status =~# '[ADU]' && get(b:fugitive_status[info.section ==# 'Staged' ? 'Unstaged' : 'Staged'], info.filename, '') =~# '[AU]'
                                    call s:TreeChomp('checkout', info.section ==# 'Staged' ? '--ours' : '--theirs', '--', info.paths[0])
                                  elseif info.status ==# 'U'
                                    call s:TreeChomp('rm', '--', info.paths[0])
                                  elseif info.status ==# 'A'
                                    call s:TreeChomp('rm', '-f', '--', info.paths[0])
                                  elseif info.section ==# 'Unstaged'
                                    call s:TreeChomp('checkout', '--', info.paths[0])
                                  else
                                    call s:TreeChomp('checkout', 'HEAD^{}', '--', info.paths[0])
                                  endif
                                  call add(restore, ':Gsplit ' . s:fnameescape(info.relative[0]) . '|Gread ' . hash[0:6])
                                endfor
                              catch /^fugitive:/
                                let err = '|echoerr ' . string(v:exception)
                              endtry
                              if empty(restore)
                                return err[1:-1]
                              endif
                              exe s:ReloadStatus()
                              call s:StageReveal()
                              return 'checktime|redraw|echomsg ' . string('To restore, ' . join(restore, '|')) . err

FUNCTION  go#config#ErrcheckBin()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_errcheck_bin", "errcheck")

FUNCTION  go#guru#Implements()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = { 'mode': 'implements', 'format': 'plain', 'selected': a:selected, 'needs_scope': 1, }
                            
                              call s:run_guru(args)

FUNCTION  <SNR>103_Dispatch()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Dir()
                              let [mp, efm, cc] = [&l:mp, &l:efm, get(b:, 'current_compiler', '')]
                              try
                                let b:current_compiler = 'git'
                                let &l:errorformat = s:common_efm
                                let &l:makeprg = s:UserCommand(dir, s:AskPassArgs(dir) + [a:cmd] + a:args)
                                if exists(':Make') == 2
                                  Make
                                  return ''
                                else
                                  if !has('patch-8.1.0334') && has('terminal') && &autowrite
                                    let autowrite_was_set = 1
                                    set noautowrite
                                    silent! wall
                                  endif
                                  silent noautocmd make!
                                  redraw!
                                  return 'call fugitive#Cwindow()|call fugitive#ReloadStatus()'
                                endif
                              finally
                                let [&l:mp, &l:efm, b:current_compiler] = [mp, efm, cc]
                                if empty(cc) | unlet! b:current_compiler | endif
                                if exists('autowrite_was_set')
                                  set autowrite
                                endif
                              endtry

FUNCTION  go#config#SetDebugDiag()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:go_debug_diag = a:value

FUNCTION  <SNR>43_system()
Called 2 times
Total time:   0.051554
 Self time:   0.000604

count  total (s)   self (s)
                              " Preserve original shell, shellredir and shellcmdflag values
    2              0.000008   let l:shell = &shell
    2              0.000005   let l:shellredir = &shellredir
    2              0.000004   let l:shellcmdflag = &shellcmdflag
                            
    2   0.000037   0.000026   if !go#util#IsWin() && executable('/bin/sh')
    2              0.000020       set shell=/bin/sh shellredir=>%s\ 2>&1 shellcmdflag=-c
    2              0.000003   endif
                            
    2              0.000001   try
    2   0.051331   0.000392     return call('system', [a:cmd] + a:000)
    2              0.000044   finally
                                " Restore original values
    2              0.000053     let &shell = l:shell
    2              0.000008     let &shellredir = l:shellredir
    2              0.000007     let &shellcmdflag = l:shellcmdflag
    2              0.000010   endtry

FUNCTION  <SNR>100_check_diff_git()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  <SNR>95_position()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return {'line': a:line, 'character': a:col}

FUNCTION  <SNR>92_newlsp()
Called 1 time
Total time:   0.002837
 Self time:   0.000740

count  total (s)   self (s)
    1   0.000029   0.000004   if !go#util#has_job()
                                let l:oldshortmess=&shortmess
                                if has('nvim')
                                  set shortmess-=F
                                endif
                                call go#util#EchoWarning('Features that rely on gopls will not work without either Vim 8.0.0087 or newer with +job or Neovim')
                                " Sleep one second to make sure people see the message. Otherwise it is
                                " often immediately overwritten by an async message.
                                sleep 1
                                let &shortmess=l:oldshortmess
                                return {'sendMessage': funcref('s:noop')}
    1              0.000001   endif
                            
                              " job is the job used to talk to the backing instance of gopls.
                              " ready is 0 until the initialize response has been received. 1 afterwards.
                              " queue is messages to send after initialization
                              " last_request_id is id of the most recently sent request.
                              " buf is unprocessed/incomplete responses
                              " handlers is a mapping of request ids to dictionaries of functions.
                              "   request id -> {start, requestComplete, handleResult, error}
                              "   * start is a function that takes no arguments
                              "   * requestComplete is a function that takes 1 argument. The parameter will be 1
                              "     if the call was succesful.
                              "   * handleResult takes a single argument, the result message received from gopls
                              "   * error takes a single argument, the error message received from gopls.
                              "     The error method is optional.
    1              0.000009   let l:lsp = { 'job':  '', 'ready': 0, 'queue': [], 'last_request_id': 0, 'buf': '', 'handlers': {}, 'workspaceDirectories': [], 'wd' : '', }
                            
    1              0.000004   function! l:lsp.readMessage(data) dict abort
                                let l:responses = []
                                let l:rest = a:data
                            
                                while 1
                                  " Look for the end of the HTTP headers
                                  let l:body_start_idx = matchend(l:rest, "\r\n\r\n")
                            
                                  if l:body_start_idx < 0
                                    " incomplete header
                                    break
                                  endif
                            
                                  " Parse the Content-Length header.
                                  let l:header = l:rest[:l:body_start_idx - 4]
                                  let l:length_match = matchlist(   l:header,   '\vContent-Length: *(\d+)')
                            
                                  if empty(l:length_match)
                                    " TODO(bc): shutdown gopls?
                                    throw "invalid JSON-RPC header:\n" . l:header
                                  endif
                            
                                  " get the start of the rest
                                  let l:next_start_idx = l:body_start_idx + str2nr(l:length_match[1])
                            
                                  if len(l:rest) < l:next_start_idx
                                    " incomplete response body
                                    break
                                  endif
                            
                                  call s:debug('received', l:rest[:l:next_start_idx - 1])
                            
                                  let l:body = l:rest[l:body_start_idx : l:next_start_idx - 1]
                                  let l:rest = l:rest[l:next_start_idx :]
                            
                                  try
                                    " add the json body to the list.
                                    call add(l:responses, json_decode(l:body))
                                  catch
                                    " TODO(bc): log the message and/or show an error message.
                                  finally
                                    " intentionally left blank.
                                  endtry
                                endwhile
                            
                                return [l:rest, l:responses]
                              endfunction
                            
    1              0.000002   function! l:lsp.handleMessage(ch, data) dict abort
                                  let self.buf .= a:data
                            
                                  let [self.buf, l:messages] = self.readMessage(self.buf)
                            
                                  for l:message in l:messages
                                    if has_key(l:message, 'method')
                                      if has_key(l:message, 'id')
                                        call self.handleRequest(l:message)
                                      else
                                        call self.handleNotification(l:message)
                                      endif
                                    elseif has_key(l:message, 'result') || has_key(l:message, 'error')
                                      call self.handleResponse(l:message)
                                    endif
                                  endfor
                              endfunction
                            
    1              0.000002   function! l:lsp.handleRequest(req) dict abort
                                if a:req.method == 'workspace/workspaceFolders'
                                  let l:resp = go#lsp#message#WorkspaceFoldersResult(self.workspaceDirectories)
                                elseif a:req.method == 'workspace/configuration' && has_key(a:req, 'params') && has_key(a:req.params, 'items')
                                  let l:resp = go#lsp#message#ConfigurationResult(a:req.params.items)
                                elseif a:req.method == 'client/registerCapability' && has_key(a:req, 'params') && has_key(a:req.params, 'registrations')
                                  let l:resp = v:null
                                else
                                  return
                                endif
                            
                                if get(self, 'exited', 0)
                                  return
                                endif
                            
                                let l:msg = self.newResponse(a:req.id, l:resp)
                                call self.write(l:msg)
                              endfunction
                            
    1              0.000003   function! l:lsp.handleNotification(req) dict abort
                                  " TODO(bc): handle notifications (e.g. window/showMessage).
                              endfunction
                            
    1              0.000002   function! l:lsp.handleResponse(resp) dict abort
                                if has_key(a:resp, 'id') && has_key(self.handlers, a:resp.id)
                                  try
                                    let l:handler = self.handlers[a:resp.id]
                            
                                    let l:winid = win_getid(winnr())
                                    " Always set the active window to the window that was active when
                                    " the request was sent. Among other things, this makes sure that
                                    " the correct window's location list will be populated when the
                                    " list type is 'location' and the user has moved windows since
                                    " sending the request.
                                    call win_gotoid(l:handler.winid)
                            
                                    if has_key(a:resp, 'error')
                                      call l:handler.requestComplete(0)
                                      if has_key(l:handler, 'error')
                                        call call(l:handler.error, [a:resp.error.message])
                                      else
                                        call go#util#EchoError(a:resp.error.message)
                                      endif
                                      call win_gotoid(l:winid)
                                      return
                                    endif
                                    call l:handler.requestComplete(1)
                            
                                    let l:winidBeforeHandler = l:handler.winid
                                    call call(l:handler.handleResult, [a:resp.result])
                            
                                    " change the window back to the window that was active when
                                    " starting to handle the message _only_ if the handler didn't
                                    " update the winid, so that handlers can set the winid if needed
                                    " (e.g. :GoDef).
                                    if l:handler.winid == l:winidBeforeHandler
                                      call win_gotoid(l:winid)
                                    endif
                                  finally
                                    call remove(self.handlers, a:resp.id)
                                  endtry
                                endif
                              endfunction
                            
    1              0.000002   function! l:lsp.handleInitializeResult(result) dict abort
                                if go#config#EchoCommandInfo()
                                  call go#util#EchoProgress("initialized gopls")
                                endif
                                let status = { 'desc': '', 'type': 'gopls', 'state': 'initialized', }
                                call go#statusline#Update(self.wd, status)
                            
                                let self.ready = 1
                                let  l:msg = self.newMessage(go#lsp#message#Initialized())
                                call self.write(l:msg)
                            
                                " send messages queued while waiting for ready.
                                for l:item in self.queue
                                  call self.sendMessage(l:item.data, l:item.handler)
                                endfor
                            
                                " reset the queue
                                let self.queue = []
                              endfunction
                            
    1              0.000002   function! l:lsp.sendMessage(data, handler) dict abort
                                if !self.last_request_id
                                  let l:wd = go#util#ModuleRoot()
                                  if l:wd == -1
                                    call go#util#EchoError('could not determine appropriate working directory for gopls')
                                    return -1
                                  endif
                            
                                  if l:wd == ''
                                    let l:wd = getcwd()
                                  endif
                                  let self.wd = l:wd
                            
                                  if go#config#EchoCommandInfo()
                                    call go#util#EchoProgress("initializing gopls")
                                  endif
                            
                                  let l:status = { 'desc': '', 'type': 'gopls', 'state': 'initializing', }
                                  call go#statusline#Update(l:wd, l:status)
                            
                                  let self.workspaceDirectories = add(self.workspaceDirectories, l:wd)
                                  let l:msg = self.newMessage(go#lsp#message#Initialize(l:wd))
                            
                                  let l:state = s:newHandlerState('')
                                  let l:state.handleResult = funcref('self.handleInitializeResult', [], l:self)
                            
                                  let self.handlers[l:msg.id] = l:state
                            
                                  call l:state.start()
                                  call self.write(l:msg)
                                endif
                            
                                if !self.ready
                                  call add(self.queue, {'data': a:data, 'handler': a:handler})
                                  return
                                endif
                            
                                let l:msg = self.newMessage(a:data)
                                if has_key(l:msg, 'id')
                                  let self.handlers[l:msg.id] = a:handler
                                endif
                            
                                call a:handler.start()
                                call self.write(l:msg)
                              endfunction
                            
                              " newMessage returns a message constructed from data. data should be a dict
                              " with 2 or 3 keys: notification, method, and optionally params.
    1              0.000002   function! l:lsp.newMessage(data) dict abort
                                let l:msg = { 'method': a:data.method, 'jsonrpc': '2.0', }
                            
                                if !a:data.notification
                                  let self.last_request_id += 1
                                  let l:msg.id = self.last_request_id
                                endif
                            
                                if has_key(a:data, 'params')
                                  let l:msg.params = a:data.params
                                endif
                            
                                return l:msg
                              endfunction
                            
    1              0.000002   function l:lsp.newResponse(id, result) dict abort
                                let l:msg = { 'jsonrpc': '2.0', 'id': a:id, 'result': a:result, }
                            
                                return l:msg
                              endfunction
                            
    1              0.000001   function! l:lsp.write(msg) dict abort
                                let l:body = json_encode(a:msg)
                                let l:data = 'Content-Length: ' . strlen(l:body) . "\r\n\r\n" . l:body
                            
                                call s:debug('sent', l:data)
                            
                                if has('nvim')
                                  call chansend(self.job, l:data)
                                  return
                                endif
                            
                                call ch_sendraw(self.job, l:data)
                              endfunction
                            
    1              0.000002   function! l:lsp.exit_cb(job, exit_status) dict
                                let self.exited = 1
                                if !get(self, 'restarting', 0)
                                  return
                                endif
                            
                                let l:queue = self.queue
                            
                                let l:workspaces = self.workspaceDirectories
                            
                                call s:lspfactory.reset()
                                let l:lsp = s:lspfactory.get()
                            
                                " restore workspaces
                                call call('go#lsp#AddWorkspaceDirectory', l:workspaces)
                                " * send DidOpen messages for all buffers that have b:did_lsp_open set
                                " TODO(bc): check modifiable and filetype, too?
                                bufdo if get(b:, 'go_lsp_did_open', 0) | if &modified | call go#lsp#DidOpen(expand('%:p')) | else | call go#lsp#DidChange(expand('%:p')) | endif | endif
                                let l:lsp.queue = extend(l:lsp.queue, l:queue)
                                return
                              endfunction
                            
    1              0.000002   function! l:lsp.close_cb(ch) dict abort
                                " TODO(bc): remove the buffer variables that indicate that gopls has been
                                " informed that the file is open
                              endfunction
                            
    1              0.000002   function! l:lsp.err_cb(ch, msg) dict abort
                                if a:msg =~ '^\tPort = \d\+$' && !get(self, 'debugport', 0)
                                  let self.debugport = substitute(a:msg, '^\tPort = \(\d\+\).*$', '\1', '')
                                endif
                            
                                call s:debug('stderr', a:msg)
                              endfunction
                            
                              " explicitly bind callbacks to l:lsp so that within it, self will always refer
                              " to l:lsp instead of l:opts. See :help Partial for more information.
    1              0.000028   let l:opts = { 'in_mode': 'raw', 'out_mode': 'raw', 'err_mode': 'nl', 'noblock': 1, 'err_cb': funcref('l:lsp.err_cb', [], l:lsp), 'out_cb': funcref('l:lsp.handleMessage', [], l:lsp), 'close_cb': funcref('l:lsp.close_cb', [], l:lsp), 'exit_cb': funcref('l:lsp.exit_cb', [], l:lsp), 'cwd': getcwd(),}
                            
    1   0.000894   0.000199   let l:bin_path = go#path#CheckBinPath("gopls")
    1              0.000002   if empty(l:bin_path)
                                return
    1              0.000000   endif
                            
    1              0.000003   let l:cmd = [l:bin_path]
    1   0.000014   0.000004   if go#util#HasDebug('lsp')
                                let l:cmd = extend(l:cmd, ['-debug', 'localhost:0'])
    1              0.000000   endif
                            
    1   0.001610   0.000243   let l:lsp.job = go#job#Start(l:cmd, l:opts)
                            
    1              0.000010   return l:lsp

FUNCTION  <SNR>94_start()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if go#config#EchoCommandInfo() && self.statustype != ""
                                let prefix = '[' . self.statustype . '] '
                                call go#util#EchoSuccess(prefix . "dispatched")
                              endif
                            
                              if self.statustype != ''
                                let status = { 'desc': 'current status', 'type': self.statustype, 'state': "started", }
                            
                                call go#statusline#Update(self.jobdir, status)
                              endif
                              let self.started_at = reltime()

FUNCTION  go#util#env()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:key = tolower(a:key)
                              if has_key(s:env_cache, l:key)
                                return s:env_cache[l:key]
                              endif
                            
                              if executable('go')
                                let l:var = call('go#util#'.l:key, [])
                                if go#util#ShellError() != 0
                                  call go#util#EchoError(printf("'go env %s' failed", toupper(l:key)))
                                  return ''
                                endif
                              else
                                let l:var = eval("$".toupper(a:key))
                              endif
                            
                              let s:env_cache[l:key] = l:var
                              return l:var

FUNCTION  <SNR>34_subvert_dispatcher()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              try
                                return s:parse_subvert(a:bang,a:line1,a:line2,a:count,a:args)
                              catch /^Subvert: /
                                echohl ErrorMsg
                                echo   v:errmsg
                                echohl NONE
                                return ""
                              endtry

FUNCTION  go#config#HighlightFunctions()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000010   return get(g:, 'go_highlight_functions', 0)

FUNCTION  gutentags#normalizepath()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000004     if exists('+shellslash') && &shellslash
                                    return substitute(a:path, '\v/', '\\', 'g')
    1              0.000006     elseif has('win32')
                                    return substitute(a:path, '\v/', '\\', 'g')
    1              0.000001     else
    1              0.000002         return a:path
                                endif

FUNCTION  <SNR>103_RebaseSequenceAborter()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('s:rebase_sequence_aborter')
                                let temp = tempname() . '.sh'
                                call writefile( ['#!/bin/sh', 'echo exec false | cat - "$1" > "$1.fugitive"', 'mv "$1.fugitive" "$1"'], temp)
                                let s:rebase_sequence_aborter = temp
                              endif
                              return s:rebase_sequence_aborter

FUNCTION  qf#OpenQuickfix()
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000006     if get(g:, 'qf_auto_open_quickfix', 1)
                                    " get user-defined maximum height
    1              0.000006         let max_height = get(g:, 'qf_max_height', 10) < 1 ? 10 : get(g:, 'qf_max_height', 10)
    1              0.000018         execute get(g:, "qf_auto_resize", 1) ? 'cclose|' . min([ max_height, len(getqflist()) ]) . 'cwindow' : 'cwindow'
    1              0.000001     endif

FUNCTION  <SNR>103_fnameescape()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if type(a:file) == type([])
                                return join(map(copy(a:file), 's:fnameescape(v:val)'))
                              elseif exists('*fnameescape')
                                return fnameescape(a:file)
                              else
                                return escape(a:file, s:fnameescape)
                              endif

FUNCTION  <SNR>103_PushSubcommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:Dispatch(a:bang ? '!' : '', 'push', a:args)

FUNCTION  <SNR>103_TreeInfo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:commit =~# '^:\=[0-3]$'
                                let index = get(s:indexes, a:dir, [])
                                let newftime = getftime(fugitive#Find('.git/index', a:dir))
                                if get(index, 0, -1) < newftime
                                  let [lines, exec_error] = s:LinesError([a:dir, 'ls-files', '--stage', '--'])
                                  let s:indexes[a:dir] = [newftime, {'0': {}, '1': {}, '2': {}, '3': {}}]
                                  if exec_error
                                    return [{}, -1]
                                  endif
                                  for line in lines
                                    let [info, filename] = split(line, "\t")
                                    let [mode, sha, stage] = split(info, '\s\+')
                                    let s:indexes[a:dir][1][stage][filename] = [newftime, mode, 'blob', sha, -2]
                                    while filename =~# '/'
                                      let filename = substitute(filename, '/[^/]*$', '', '')
                                      let s:indexes[a:dir][1][stage][filename] = [newftime, '040000', 'tree', '', 0]
                                    endwhile
                                  endfor
                                endif
                                return [get(s:indexes[a:dir][1], a:commit[-1:-1], {}), newftime]
                              elseif a:commit =~# '^\x\{40,\}$'
                                if !has_key(s:trees, a:dir)
                                  let s:trees[a:dir] = {}
                                endif
                                if !has_key(s:trees[a:dir], a:commit)
                                  let [ftime, exec_error] = s:ChompError([a:dir, 'log', '-1', '--pretty=format:%ct', a:commit, '--'])
                                  if exec_error
                                    let s:trees[a:dir][a:commit] = [{}, -1]
                                    return s:trees[a:dir][a:commit]
                                  endif
                                  let s:trees[a:dir][a:commit] = [{}, +ftime]
                                  let [lines, exec_error] = s:LinesError([a:dir, 'ls-tree', '-rtl', '--full-name', a:commit, '--'])
                                  if exec_error
                                    return s:trees[a:dir][a:commit]
                                  endif
                                  for line in lines
                                    let [info, filename] = split(line, "\t")
                                    let [mode, type, sha, size] = split(info, '\s\+')
                                    let s:trees[a:dir][a:commit][0][filename] = [+ftime, mode, type, sha, +size, filename]
                                  endfor
                                endif
                                return s:trees[a:dir][a:commit]
                              endif
                              return [{}, -1]

FUNCTION  go#lsp#message#ChangeWorkspaceFolders()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:addDirs = map(copy(a:add), function('s:workspaceFolder', []))
                              let l:removeDirs = map(copy(a:add), function('s:workspaceFolder', []))
                            
                              return { 'notification': 1, 'method': 'workspace/didChangeWorkspaceFolders', 'params': {   'event': {     'removed': l:removeDirs,     'added': l:addDirs,     }, } }
                            

FUNCTION  <SNR>103_GF()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              try
                                let results = &filetype ==# 'fugitive' ? s:StatusCfile() : &filetype ==# 'gitcommit' ? [s:MessageCfile()] : s:cfile()
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if len(results) > 1
                                return 'G' . a:mode . ' +' . escape(results[1], ' ') . ' ' . s:fnameescape(results[0]) . join(map(results[2:-1], '"|" . v:val'), '')
                              elseif len(results) && len(results[0])
                                return 'G' . a:mode . ' ' . s:fnameescape(results[0])
                              else
                                return ''
                              endif

FUNCTION  go#path#ToURI()
Called 4 times
Total time:   0.000783
 Self time:   0.000382

count  total (s)   self (s)
    4   0.000081   0.000055   let l:absolute = !go#util#IsWin() && a:path[0] is# '/'
    4              0.000009   let l:prefix = ''
    4              0.000008   let l:path = a:path
                            
    4   0.000038   0.000020   if go#util#IsWin() && l:path[1:2] is# ':\'
                                let l:absolute = 1
                                let l:prefix = '/' . l:path[0:1]
                                let l:path = l:path[2:]
    4              0.000004   endif
                            
    4   0.000606   0.000249   return substitute(   (l:absolute ? 'file://' : '') . l:prefix . go#uri#EncodePath(l:path),   '\\',   '/',   'g',)

FUNCTION  go#config#HighlightSpaceTabError()
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000013   return get(g:, 'go_highlight_space_tab_error', 0)

FUNCTION  go#config#FmtOptions()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return get(g:, "go_fmt_options", {})

FUNCTION  go#guru#Callstack()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = { 'mode': 'callstack', 'format': 'plain', 'selected': a:selected, 'needs_scope': 1, }
                            
                              call s:run_guru(args)

FUNCTION  go#util#ParseErrors()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let errors = []
                            
                              for line in a:lines
                                let fatalerrors = matchlist(line, '^\(fatal error:.*\)$')
                                let tokens = matchlist(line, '^\s*\(.\{-}\):\(\d\+\):\s*\(.*\)')
                            
                                if !empty(fatalerrors)
                                  call add(errors, {"text": fatalerrors[1]})
                                elseif !empty(tokens)
                                  " strip endlines of form ^M
                                  let out = substitute(tokens[3], '\r$', '', '')
                            
                                  call add(errors, { "filename" : fnamemodify(tokens[1], ':p'), "lnum"     : tokens[2], "text"     : out, })
                                elseif !empty(errors)
                                  " Preserve indented lines.
                                  " This comes up especially with multi-line test output.
                                  if match(line, '^\s') >= 0
                                    call add(errors, {"text": substitute(line, '\r$', '', '')})
                                  endif
                                endif
                              endfor
                            
                              return errors

FUNCTION  go#guru#PointsTo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:args = { 'mode': 'pointsto', 'format': 'plain', 'selected': a:selected, 'needs_scope': 1, }
                            
                              call s:run_guru(l:args)

FUNCTION  <SNR>103_winshell()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return has('win32') && &shellcmdflag !~# '^-'

FUNCTION  go#util#gopath()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(s:exec(['go', 'env', 'GOPATH'])[0], '\n', '', 'g')

FUNCTION  go#lsp#message#Initialize()
Called 1 time
Total time:   0.000268
 Self time:   0.000047

count  total (s)   self (s)
    1   0.000267   0.000046   return { 'notification': 0, 'method': 'initialize', 'params': { 'processId': getpid(), 'rootUri': go#path#ToURI(a:wd), 'capabilities': { 'workspace': { 'workspaceFolders': v:true, 'didChangeConfiguration': { 'dynamicRegistration': v:true, }, 'configuration': v:true, }, 'textDocument': { 'hover': { 'contentFormat': ['plaintext'], }, } }, 'workspaceFolders': [s:workspaceFolder(0, a:wd)], } }

FUNCTION  go#auto#metalinter_autosave()
Called 1 time
Total time:   0.000021
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000017   0.000011   if !go#config#MetalinterAutosave() || !isdirectory(expand('%:p:h'))
    1              0.000001     return
                              endif
                            
                              " run gometalinter on save
                              call go#lint#Gometa(!g:go_jump_to_error, 1)

FUNCTION  fugitive#readfile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let entry = s:PathInfo(a:url)
                              if entry[2] !=# 'blob'
                                return []
                              endif
                              let temp = s:BlobTemp(a:url)
                              if empty(temp)
                                return []
                              endif
                              return call('readfile', [temp] + a:000)

FUNCTION  <SNR>103_Expand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:rev =~# '^:[0-3]$'
                                let file = len(expand('%')) ? a:rev . ':%' : '%'
                              elseif a:rev ==# '>'
                                let file = '%'
                              elseif a:rev =~# '^>[~^]'
                                let file = len(expand('%')) ? '!' . a:rev[1:-1] . ':%' : '%'
                              elseif a:rev =~# '^>[> ]\@!'
                                let file = len(expand('%')) ? a:rev[1:-1] . ':%' : '%'
                              else
                                let file = a:rev
                              endif
                              return substitute(file, '\(\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand, '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),"", a:0 ? a:1 : getcwd())', 'g')

FUNCTION  sy#util#popup_create()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let offset      = s:offset()
                              let winline     = winline()
                              let min_height  = 6
                              let max_height  = winheight('%') - winline
                              let diff_height = len(a:hunkdiff)
                              let height      = min([diff_height, max_height])
                            
                              if diff_height > max_height && max_height < min_height
                                let max_scroll = min_height - max_height
                                let scroll     = min([max_scroll, diff_height - max_height])
                                " Old versions don't have feedkeys(..., 'x')
                                execute 'normal!' scroll.''
                                let winline -= scroll
                                let height  += scroll
                              endif
                            
                              if exists('*nvim_open_win')
                                call sy#util#popup_close()
                                let buf = nvim_create_buf(0, 1)
                                call nvim_buf_set_option(buf, 'syntax', 'diff')
                                call nvim_buf_set_lines(buf, 0, -1, 0, a:hunkdiff)
                                let s:popup_window = nvim_open_win(buf, v:false, { 'relative': 'win', 'row': winline, 'col': offset - 1, 'width': winwidth('%') - offset + 1, 'height': height, })
                                call nvim_win_set_option(s:popup_window, 'cursorline', v:false)
                                call nvim_win_set_option(s:popup_window, 'foldcolumn', 0)
                                call nvim_win_set_option(s:popup_window, 'foldenable', v:false)
                                call nvim_win_set_option(s:popup_window, 'number', v:false)
                                call nvim_win_set_option(s:popup_window, 'relativenumber', v:false)
                                call nvim_win_set_option(s:popup_window, 'wrap', v:true)
                                autocmd CursorMoved * ++once call sy#util#popup_close()
                              elseif exists('*popup_create')
                                let s:popup_window = popup_create(a:hunkdiff, { 'line': 'cursor+1', 'col': offset, 'minwidth': winwidth('%'), 'maxheight': height, 'moved': 'any', 'zindex': 1000, })
                                call setbufvar(winbufnr(s:popup_window), '&syntax', 'diff')
                              else
                                return 0
                              endif
                            
                              return 1

FUNCTION  go#lsp#ResetWorkspaceDirectories()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call go#lsp#CleanWorkspaces()
                            
                              let l:lsp = s:lspfactory.get()
                            
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:noop')
                              let l:msg = go#lsp#message#ChangeWorkspaceFolders(l:lsp.workspaceDirectories, l:lsp.workspaceDirectories)
                              call l:lsp.sendMessage(l:msg, l:state)
                            
                              return 0

FUNCTION  go#util#Shellescape()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              try
                                let ssl_save = &shellslash
                                set noshellslash
                                return shellescape(a:arg)
                              finally
                                let &shellslash = ssl_save
                              endtry

FUNCTION  <SNR>94_exit_cb()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let self.exit_status = a:exitval
                              let self.exited = 1
                            
                              call self.show_status(a:job, a:exitval)
                            
                              if self.closed || has('nvim')
                                call self.complete(a:job, self.exit_status, self.messages)
                              endif

FUNCTION  <SNR>4_GetCmdArg()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:sect == ''
                                return a:page
                              endif
                              return s:man_sect_arg.' '.a:sect.' '.a:page

FUNCTION  go#config#TemplateUsePkg()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_template_use_pkg', 0)

FUNCTION  <SNR>85_GoNeosnippet()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if get(g:, 'loaded_neosnippet') isnot 1
                                return
                              endif
                            
                              let g:neosnippet#enable_snipmate_compatibility = 1
                            
                              let l:gosnippets_dir = globpath(&rtp, 'gosnippets/snippets')
                              if type(g:neosnippet#snippets_directory) == type([])
                                let g:neosnippet#snippets_directory += [l:gosnippets_dir]
                              elseif type(g:neosnippet#snippets_directory) == type("")
                                if strlen(g:neosnippet#snippets_directory) > 0
                                  let g:neosnippet#snippets_directory = g:neosnippet#snippets_directory . "," . l:gosnippets_dir
                                else
                                  let g:neosnippet#snippets_directory = l:gosnippets_dir
                                endif
                              endif

FUNCTION  fugitive#foldtext()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#Foldtext()

FUNCTION  go#config#SetTemplateAutocreate()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:go_template_autocreate = a:value

FUNCTION  <SNR>100_run()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [cwd, chdir] = sy#util#chdir()
                              try
                                execute chdir fnameescape(b:sy.info.dir)
                                let ret = system(s:expand_cmd(a:vcs, g:signify_vcs_cmds))
                              catch
                                " This exception message can be seen via :SignifyDebugUnknown.
                                " E.g. unquoted VCS programs in vcd_cmds can lead to E484.
                                let ret = v:exception .' at '. v:throwpoint
                              finally
                                execute chdir fnameescape(cwd)
                                return ret
                              endtry

FUNCTION  go#lsp#AddWorkspaceDirectory()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:0 == 0
                                return
                              endif
                            
                              call go#lsp#CleanWorkspaces()
                            
                              let l:workspaces = []
                              for l:dir in a:000
                                let l:dir = fnamemodify(l:dir, ':p')
                                if !isdirectory(l:dir)
                                  continue
                                endif
                            
                                let l:workspaces = add(l:workspaces, l:dir)
                              endfor
                            
                              let l:lsp = s:lspfactory.get()
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:noop')
                              let l:lsp.workspaceDirectories = extend(l:lsp.workspaceDirectories, l:workspaces)
                              let l:msg = go#lsp#message#ChangeWorkspaceFolders(l:workspaces, [])
                              call l:lsp.sendMessage(l:msg, l:state)
                            
                              return 0

FUNCTION  11()
Called 2 times
Total time:   0.000413
 Self time:   0.000113

count  total (s)   self (s)
    2              0.000017     if a:req.method == 'workspace/workspaceFolders'
                                  let l:resp = go#lsp#message#WorkspaceFoldersResult(self.workspaceDirectories)
    2              0.000011     elseif a:req.method == 'workspace/configuration' && has_key(a:req, 'params') && has_key(a:req.params, 'items')
    1   0.000101   0.000007       let l:resp = go#lsp#message#ConfigurationResult(a:req.params.items)
    1              0.000005     elseif a:req.method == 'client/registerCapability' && has_key(a:req, 'params') && has_key(a:req.params, 'registrations')
    1              0.000003       let l:resp = v:null
                                else
                                  return
    2              0.000002     endif
                            
    2              0.000015     if get(self, 'exited', 0)
                                  return
    2              0.000002     endif
                            
    2   0.000033   0.000014     let l:msg = self.newResponse(a:req.id, l:resp)
    2   0.000199   0.000012     call self.write(l:msg)

FUNCTION  fugitive#delete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if a:0 && len(a:1) || commit !~# '^\d$'
                                return -1
                              endif
                              let entry = s:PathInfo(a:url)
                              if entry[2] !=# 'blob'
                                return -1
                              endif
                              let exec_error = s:SystemError([dir, 'update-index', '--index-info'], '000000 0000000000000000000000000000000000000000 ' . commit . "\t" . file[1:-1])[1]
                              return exec_error ? -1 : 0

FUNCTION  <SNR>57_LP_OpPush()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            "  call Dfunc("LP_OpPush(op<".a:op.">)")
                            
                              " determine new operator's precedence level
                              if a:op == '('
                              	let s:preclvl= s:preclvl + 10
                            	let preclvl  = s:preclvl
                              elseif a:op == ')'
                              	let s:preclvl= s:preclvl - 10
                               if s:preclvl < 0
                                let s:preclvl= 0
                                echoerr "too many )s"
                               endif
                               let preclvl= s:preclvl
                              elseif a:op =~ '|'
                               let preclvl= s:preclvl + 2
                              elseif a:op =~ '&'
                               let preclvl= s:preclvl + 4
                              elseif a:op == '!'
                               let preclvl= s:preclvl + 6
                              elseif a:op == 'Z'
                               let preclvl= -1
                              else
                               echoerr "expr<".expr."> not supported (yet)"
                               let preclvl= s:preclvl
                              endif
                            "  call Decho("new operator<".a:op."> preclvl=".preclvl)
                            
                              " execute higher-precdence operators
                            "  call Decho("execute higher-precedence operators")
                              call s:LP_Execute(preclvl)
                            
                              " push new operator onto operator-stack
                            "  call Decho("push new operator<".a:op."> onto stack with preclvl=".preclvl." at nopstack=".(s:nopstack+1))
                              if a:op =~ '!'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              elseif a:op =~ '|'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              elseif a:op == '&'
                               let s:nopstack             = s:nopstack + 1
                               let s:opprec_{s:nopstack}  = preclvl
                               let s:opstack_{s:nopstack} = a:op
                              endif
                            
                            "  call s:StackLook("oppush") "Decho
                            "  call Dret("LP_OpPush : s:preclvl=".s:preclvl)

FUNCTION  fugitive#ReadCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let mods = s:Mods(a:mods)
                              let after = a:count
                              if a:count < 0
                                let delete = 'silent 1,' . line('$') . 'delete_|'
                                let after = line('$')
                              elseif a:range == 2
                                let delete = 'silent ' . a:line1 . ',' . a:count . 'delete_|'
                              else
                                let delete = ''
                              endif
                              if a:bang
                                let dir = s:Dir()
                                let args = s:SplitExpand(a:arg, s:Tree(dir))
                                silent execute mods . after . 'read!' escape(s:UserCommand(dir, ['--no-pager'] + args), '!#%')
                                execute delete . 'diffupdate'
                                call fugitive#ReloadStatus()
                                return 'redraw|echo '.string(':!'.s:UserCommand(dir, args))
                              endif
                              try
                                let [file, pre] = s:OpenParse(a:args)
                                let file = s:Generate(file)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if file =~# '^fugitive:' && after is# 0
                                return 'exe ' .string(mods . fugitive#FileReadCmd(file, 0, pre)) . '|diffupdate'
                              endif
                              if foldlevel(after)
                                exe after . 'foldopen!'
                              endif
                              return mods . after . 'read' . pre . ' ' . s:fnameescape(file) . '|' . delete . 'diffupdate' . (a:count < 0 ? '|' . line('.') : '')

FUNCTION  fugitive#resolve()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let url = fugitive#simplify(a:url)
                              if url =~? '^fugitive:'
                                return url
                              else
                                return resolve(url)
                              endif

FUNCTION  fugitive#PrepareDirEnvArgv()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:0 && type(a:1) ==# type([])
                                let cmd = a:000[1:-1] + a:1
                              else
                                let cmd = copy(a:000)
                              endif
                              let env = {}
                              let i = 0
                              while i < len(cmd)
                                if cmd[i] =~# '^$\|[\/.]' && cmd[i] !~# '^-'
                                  let dir = remove(cmd, 0)
                                elseif cmd[i] =~# '^--git-dir='
                                  let dir = remove(cmd, 0)[10:-1]
                                elseif type(cmd[i]) ==# type(0)
                                  let dir = s:Dir(remove(cmd, i))
                                elseif cmd[i] ==# '-c' && len(cmd) > i + 1
                                  let key = matchstr(cmd[i+1], '^[^=]*')
                                  if has_key(s:prepare_env, tolower(key)) || key !~# '\.'
                                    let var = get(s:prepare_env, tolower(key), key)
                                    let val = matchstr(cmd[i+1], '=\zs.*')
                                    let env[var] = val
                                  endif
                                  if fugitive#GitVersion(1, 8) && cmd[i+1] =~# '\.'
                                    let i += 2
                                  else
                                    call remove(cmd, i, i + 1)
                                  endif
                                elseif cmd[i] =~# '^--.*pathspecs$'
                                  let explicit_pathspec_option = 1
                                  if fugitive#GitVersion(1, 9)
                                    let i += 1
                                  else
                                    call remove(cmd, i)
                                  endif
                                elseif cmd[i] !~# '^-'
                                  break
                                else
                                  let i += 1
                                endif
                              endwhile
                              if !exists('dir')
                                let dir = s:Dir()
                              endif
                              call s:PreparePathArgs(cmd, dir, !exists('explicit_pathspec_option'))
                              return [dir, env, cmd]

FUNCTION  go#auto#auto_type_info()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !go#config#AutoTypeInfo() || !isdirectory(expand('%:p:h'))
                                return
                              endif
                            
                              " GoInfo automatic update
                              call go#tool#Info(0)

FUNCTION  sy#highlight#line_toggle()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_disable()
                              else
                                call sy#highlight#line_enable()
                              endif
                            
                              redraw!
                              call sy#start()

FUNCTION  go#config#TemplateTestFile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_template_test_file', "hello_world_test.go")

FUNCTION  <SNR>57_String()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return "'".escape(a:str, '"')."'"

FUNCTION  <SNR>85_GoMinisnip()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if get(g:, 'loaded_minisnip') isnot 1
                                return
                              endif
                            
                              if exists('g:minisnip_dir')
                                let g:minisnip_dir .= go#util#PathListSep() . globpath(&rtp, 'gosnippets/minisnip')
                              else
                                let g:minisnip_dir = globpath(&rtp, 'gosnippets/minisnip')
                              endif

FUNCTION  fugitive#getftype()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get({'tree': 'dir', 'blob': 'file'}, s:PathInfo(a:url)[2], '')

FUNCTION  FugitivePath()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:0 > 1
                                return fugitive#Path(a:1, a:2, FugitiveGitDir(a:0 > 2 ? a:3 : -1))
                              else
                                return FugitiveReal(a:0 ? a:1 : @%)
                              endif

FUNCTION  <SNR>103_Selection()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:arg1 ==# 'n'
                                let arg1 = line('.')
                                let arg2 = -v:count
                              elseif a:arg1 ==# 'v'
                                let arg1 = line("'<")
                                let arg2 = line("'>")
                              else
                                let arg1 = a:arg1
                                let arg2 = a:0 ? a:1 : 0
                              endif
                              let first = arg1
                              if arg2 < 0
                                let last = first - arg2 + 1
                              elseif arg2 > 0
                                let last = arg2
                              else
                                let last = first
                              endif
                              while getline(first) =~# '^$\|^[A-Z][a-z]'
                                let first += 1
                              endwhile
                              if first > last || &filetype !=# 'fugitive'
                                return []
                              endif
                              let flnum = first
                              while getline(flnum) =~# '^[ @\+-]'
                                let flnum -= 1
                              endwhile
                              let slnum = flnum + 1
                              let section = ''
                              let index = 0
                              while len(getline(slnum - 1)) && empty(section)
                                let slnum -= 1
                                let heading = matchstr(getline(slnum), '^\u\l\+.* (\d\+)$')
                                if empty(heading) && getline(slnum) !~# '^[ @\+-]'
                                  let index += 1
                                endif
                              endwhile
                              let results = []
                              let template = { 'heading': heading, 'section': matchstr(heading, '^\u\l\+\ze.* (\d\+)$'), 'filename': '', 'relative': [], 'paths': [], 'commit': '', 'status': '', 'patch': 0, 'index': index}
                              let line = getline(flnum)
                              let lnum = first - (arg1 == flnum ? 0 : 1)
                              let root = s:Tree() . '/'
                              while lnum <= last
                                if line =~# '^\u\l\+\ze.* (\d\+)$'
                                  let template.heading = getline(lnum)
                                  let template.section = matchstr(template.heading, '^\u\l\+\ze.* (\d\+)$')
                                  let template.index = 0
                                elseif line =~# '^[ @\+-]'
                                  let template.index -= 1
                                  if !results[-1].patch
                                    let results[-1].patch = lnum
                                  endif
                                  let results[-1].lnum = lnum
                                elseif line =~# '^[A-Z?] '
                                  let filename = matchstr(line, '^[A-Z?] \zs.*')
                                  call add(results, extend(deepcopy(template), { 'lnum': lnum, 'filename': filename, 'relative': reverse(split(filename, ' -> ')), 'paths': map(reverse(split(filename, ' -> ')), 'root . v:val'), 'status': matchstr(line, '^[A-Z?]'), }))
                                elseif line =~# '^\x\x\x\+ '
                                  call add(results, extend({ 'lnum': lnum, 'commit': matchstr(line, '^\x\x\x\+'), }, template, 'keep'))
                                elseif line =~# '^\l\+ \x\x\x\+ '
                                  call add(results, extend({ 'lnum': lnum, 'commit': matchstr(line, '^\l\+ \zs\x\x\x\+'), 'status': matchstr(line, '^\l\+'), }, template, 'keep'))
                                endif
                                let lnum += 1
                                let template.index += 1
                                let line = getline(lnum)
                              endwhile
                              if len(results) && results[0].patch && arg2 == 0
                                while getline(results[0].patch) =~# '^[ \+-]'
                                  let results[0].patch -= 1
                                endwhile
                                while getline(results[0].lnum + 1) =~# '^[ \+-]'
                                  let results[0].lnum += 1
                                endwhile
                              endif
                              return results

FUNCTION  <SNR>34_mixedcase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(s:camelcase(a:word),'^.','\u&','')

FUNCTION  go#util#PathSep()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if go#util#IsWin()
                                return '\'
                              endif
                              return '/'

FUNCTION  <SNR>103_executable()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !has_key(s:executables, a:binary)
                                let s:executables[a:binary] = executable(a:binary)
                              endif
                              return s:executables[a:binary]

FUNCTION  <SNR>109_fmt_cmd()
Called 1 time
Total time:   0.000057
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000004   let l:cmd = [a:bin_name, '-w']
                            
                              " add the options for binary (if any). go_fmt_options was by default of type
                              " string, however to allow customization it's now a dictionary of binary
                              " name mapping to options.
    1   0.000013   0.000007   let opts = go#config#FmtOptions()
    1              0.000004   if type(opts) == type({})
    1              0.000006     let opts = has_key(opts, a:bin_name) ? opts[a:bin_name] : ""
    1              0.000001   endif
    1              0.000011   call extend(cmd, split(opts, " "))
    1              0.000003   if a:bin_name is# 'goimports'
    1              0.000005     call extend(cmd, ["-srcdir", a:target])
    1              0.000001   endif
                            
    1              0.000004   call add(cmd, a:source)
    1              0.000001   return cmd

FUNCTION  <SNR>103_DoToggleStagedHeading()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:TreeChomp('reset', '-q')
                              return 1

FUNCTION  <SNR>44_LinuxCodingStyle()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call s:LinuxFormatting()
                                call s:LinuxKeywords()
                                call s:LinuxHighlighting()

FUNCTION  go#lsp#message#DidChange()
Called 1 time
Total time:   0.000128
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000127   0.000023   return { 'notification': 1, 'method': 'textDocument/didChange', 'params': {     'textDocument': {         'uri': go#path#ToURI(a:file),     },     'contentChanges': [       {         'text': a:content,       }     ] } }

FUNCTION  go#config#HighlightFunctionCalls()
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000013   return get(g:, 'go_highlight_function_calls', 0)

FUNCTION  fugitive#BlameSyntax()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let conceal = has('conceal') ? ' conceal' : ''
                              let config = fugitive#Config()
                              let flags = get(s:TempState(), 'blame_flags', [])
                              syn match FugitiveblameBlank                      "^\s\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalFile,FugitiveblameOriginalLineNumber skipwhite
                              syn match FugitiveblameHash       "\%(^\^\=[?*]*\)\@<=\<\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              syn match FugitiveblameUncommitted "\%(^\^\=\)\@<=\<0\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              if get(get(config, 'blame.blankboundary', ['x']), 0, 'x') =~# '^$\|^true$' || s:HasOpt(flags, '-b')
                                syn match FugitiveblameBoundaryIgnore "^\^[*?]*\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              else
                                syn match FugitiveblameBoundary "^\^"
                              endif
                              syn match FugitiveblameScoreDebug        " *\d\+\s\+\d\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile contained skipwhite
                              syn region FugitiveblameAnnotation matchgroup=FugitiveblameDelimiter start="(" end="\%(\s\d\+\)\@<=)" contained keepend oneline
                              syn match FugitiveblameTime "[0-9:/+-][0-9:/+ -]*[0-9:/+-]\%(\s\+\d\+)\)\@=" contained containedin=FugitiveblameAnnotation
                              exec 'syn match FugitiveblameLineNumber         "\s*\d\+)\@=" contained containedin=FugitiveblameAnnotation' conceal
                              exec 'syn match FugitiveblameOriginalFile       "\s\%(\f\+\D\@<=\|\D\@=\f\+\)\%(\%(\s\+\d\+\)\=\s\%((\|\s*\d\+)\)\)\@=" contained nextgroup=FugitiveblameOriginalLineNumber,FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-name', '-f') ? '' : conceal)
                              exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s(\)\@=" contained nextgroup=FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
                              exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s\+\d\+)\)\@=" contained nextgroup=FugitiveblameShort skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
                              syn match FugitiveblameShort              " \d\+)" contained contains=FugitiveblameLineNumber
                              syn match FugitiveblameNotCommittedYet "(\@<=Not Committed Yet\>" contained containedin=FugitiveblameAnnotation
                              hi def link FugitiveblameBoundary           Keyword
                              hi def link FugitiveblameHash               Identifier
                              hi def link FugitiveblameBoundaryIgnore     Ignore
                              hi def link FugitiveblameUncommitted        Ignore
                              hi def link FugitiveblameScoreDebug         Debug
                              hi def link FugitiveblameTime               PreProc
                              hi def link FugitiveblameLineNumber         Number
                              hi def link FugitiveblameOriginalFile       String
                              hi def link FugitiveblameOriginalLineNumber Float
                              hi def link FugitiveblameShort              FugitiveblameDelimiter
                              hi def link FugitiveblameDelimiter          Delimiter
                              hi def link FugitiveblameNotCommittedYet    Comment
                              if !get(g:, 'fugitive_dynamic_colors', 1) && !s:HasOpt(flags, '--color-lines') || s:HasOpt(flags, '--no-color-lines')
                                return
                              endif
                              let seen = {}
                              for lnum in range(1, line('$'))
                                let hash = matchstr(getline(lnum), '^\^\=\zs\x\{6\}')
                                if hash ==# '' || hash ==# '000000' || has_key(seen, hash)
                                  continue
                                endif
                                let seen[hash] = 1
                                if &t_Co > 16 && get(g:, 'CSApprox_loaded') && !empty(findfile('autoload/csapprox/per_component.vim', escape(&rtp, ' '))) && empty(get(s:hash_colors, hash))
                                  let [s, r, g, b; __] = map(matchlist(hash, '\(\x\x\)\(\x\x\)\(\x\x\)'), 'str2nr(v:val,16)')
                                  let color = csapprox#per_component#Approximate(r, g, b)
                                  if color == 16 && &background ==# 'dark'
                                    let color = 8
                                  endif
                                  let s:hash_colors[hash] = ' ctermfg='.color
                                else
                                  let s:hash_colors[hash] = ''
                                endif
                                exe 'syn match FugitiveblameHash'.hash.'       "\%(^\^\=\)\@<='.hash.'\x\{1,34\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile skipwhite'
                              endfor
                              call s:BlameRehighlight()

FUNCTION  <SNR>103_NextItem()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for i in range(a:count)
                                if !search(s:item_pattern, 'W') && getline('.') !~# s:item_pattern
                                  call search('^commit ', 'W')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'

FUNCTION  sy#util#shell_redirect()
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
                              " if shellredir contains a %s it is replaced with the path
                              " otherwise, just append it (from :help shellredir:
                              "   The name of the temporary file can be represented by '%s' if necessary
                              "   (the file name is appended automatically if no %s appears in the value
                              "   of this option)
    1              0.000008   if &shellredir =~# '%s'
    1              0.000020     return substitute(&shellredir, '\C%s', a:path, 'g')
                              else
                                return &shellredir .' '. a:path
                              endif

FUNCTION  <SNR>7_Match_wrapper()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " In s:CleanUp(), :execute "set" restore_options .
                              let restore_options = ""
                              if exists("b:match_ignorecase") && b:match_ignorecase != &ic
                                let restore_options .= (&ic ? " " : " no") . "ignorecase"
                                let &ignorecase = b:match_ignorecase
                              endif
                              if &ve != ''
                                let restore_options = " ve=" . &ve . restore_options
                                set ve=
                              endif
                              " If this function was called from Visual mode, make sure that the cursor
                              " is at the correct end of the Visual range:
                              if a:mode == "v"
                                execute "normal! gv\<Esc>"
                              endif
                              " In s:CleanUp(), we may need to check whether the cursor moved forward.
                              let startline = line(".")
                              let startcol = col(".")
                              " Use default behavior if called with a count.
                              if v:count
                                exe "normal! " . v:count . "%"
                                return s:CleanUp(restore_options, a:mode, startline, startcol)
                              end
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR	flag for whether there are backrefs
                              "   s:pat	parsed version of b:match_words
                              "   s:all	regexp based on s:pat and the default groups
                              "
                              if !exists("b:match_words") || b:match_words == ""
                                let match_words = ""
                                " Allow b:match_words = "GetVimMatchWords()" .
                              elseif b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                execute "let match_words =" b:match_words
                              endif
                            " Thanks to Preben "Peppe" Guldberg and Bram Moolenaar for this suggestion!
                              if (match_words != s:last_words) || (&mps != s:last_mps) || exists("b:match_debug")
                                let s:last_mps = &mps
                                " The next several lines were here before
                                " BF started messing with this script.
                                " quote the special chars in 'matchpairs', replace [,:] with \| and then
                                " append the builtin pairs (/*, */, #if, #ifdef, #else, #elif, #endif)
                                " let default = substitute(escape(&mps, '[$^.*~\\/?]'), '[,:]\+',
                                "  \ '\\|', 'g').'\|\/\*\|\*\/\|#if\>\|#ifdef\>\|#else\>\|#elif\>\|#endif\>'
                                let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") . '\/\*:\*\/,#\s*if\%(def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                                " s:all = pattern with all the keywords
                                let match_words = match_words . (strlen(match_words) ? "," : "") . default
                                let s:last_words = match_words
                                if match_words !~ s:notslash . '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = substitute(s:pat, s:notslash . '\zs[,:]\+', '\\|', 'g')
                                let s:all = '\%(' . s:all . '\)'
                                " let s:all = '\%(' . substitute(s:all, '\\\ze[,:]', '', 'g') . '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                                " Reconstruct the version with unresolved backrefs.
                                let s:patBR = substitute(match_words.',', s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
                                let s:patBR = substitute(s:patBR, s:notslash.'\zs:\{2,}', ':', 'g')
                              endif
                            
                              " Second step:  set the following local variables:
                              "     matchline = line on which the cursor started
                              "     curcol    = number of characters before match
                              "     prefix    = regexp for start of line to start of match
                              "     suffix    = regexp for end of match to end of line
                              " Require match to end on or after the cursor and prefer it to
                              " start on or before the cursor.
                              let matchline = getline(startline)
                              if a:word != ''
                                " word given
                                if a:word !~ s:all
                                  echohl WarningMsg|echo 'Missing rule for word:"'.a:word.'"'|echohl NONE
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
                                let matchline = a:word
                                let curcol = 0
                                let prefix = '^\%('
                                let suffix = '\)$'
                              " Now the case when "word" is not given
                              else	" Find the match that ends on or after the cursor and set curcol.
                                let regexp = s:Wholematch(matchline, s:all, startcol-1)
                                let curcol = match(matchline, regexp)
                                " If there is no match, give up.
                                if curcol == -1
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
                                let endcol = matchend(matchline, regexp)
                                let suf = strlen(matchline) - endcol
                                let prefix = (curcol ? '^.*\%'  . (curcol + 1) . 'c\%(' : '^\%(')
                                let suffix = (suf ? '\)\%' . (endcol + 1) . 'c.*$'  : '\)$')
                              endif
                              if exists("b:match_debug")
                                let b:match_match = matchstr(matchline, regexp)
                                let b:match_col = curcol+1
                              endif
                            
                              " Third step:  Find the group and single word that match, and the original
                              " (backref) versions of these.  Then, resolve the backrefs.
                              " Set the following local variable:
                              " group = colon-separated list of patterns, one of which matches
                              "       = ini:mid:fin or ini:fin
                              "
                              " Now, set group and groupBR to the matching group: 'if:endif' or
                              " 'while:endwhile' or whatever.  A bit of a kluge:  s:Choose() returns
                              " group . "," . groupBR, and we pick it apart.
                              let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, s:patBR)
                              let i = matchend(group, s:notslash . ",")
                              let groupBR = strpart(group, i)
                              let group = strpart(group, 0, i-1)
                              " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
                              if s:do_BR " Do the hard part:  resolve those backrefs!
                                let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              endif
                              if exists("b:match_debug")
                                let b:match_wholeBR = groupBR
                                let i = matchend(groupBR, s:notslash . ":")
                                let b:match_iniBR = strpart(groupBR, 0, i-1)
                              endif
                            
                              " Fourth step:  Set the arguments for searchpair().
                              let i = matchend(group, s:notslash . ":")
                              let j = matchend(group, '.*' . s:notslash . ":")
                              let ini = strpart(group, 0, i-1)
                              let mid = substitute(strpart(group, i,j-i-1), s:notslash.'\zs:', '\\|', 'g')
                              let fin = strpart(group, j)
                              "Un-escape the remaining , and : characters.
                              let ini = substitute(ini, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              let mid = substitute(mid, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              let fin = substitute(fin, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              " searchpair() requires that these patterns avoid \(\) groups.
                              let ini = substitute(ini, s:notslash . '\zs\\(', '\\%(', 'g')
                              let mid = substitute(mid, s:notslash . '\zs\\(', '\\%(', 'g')
                              let fin = substitute(fin, s:notslash . '\zs\\(', '\\%(', 'g')
                              " Set mid.  This is optimized for readability, not micro-efficiency!
                              if a:forward && matchline =~ prefix . fin . suffix || !a:forward && matchline =~ prefix . ini . suffix
                                let mid = ""
                              endif
                              " Set flag.  This is optimized for readability, not micro-efficiency!
                              if a:forward && matchline =~ prefix . fin . suffix || !a:forward && matchline !~ prefix . ini . suffix
                                let flag = "bW"
                              else
                                let flag = "W"
                              endif
                              " Set skip.
                              if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" . b:match_comment
                              else
                                let skip = 's:comment\|string'
                              endif
                              let skip = s:ParseSkip(skip)
                              if exists("b:match_debug")
                                let b:match_ini = ini
                                let b:match_tail = (strlen(mid) ? mid.'\|' : '') . fin
                              endif
                            
                              " Fifth step:  actually start moving the cursor and call searchpair().
                              " Later, :execute restore_cursor to get to the original screen.
                              let restore_cursor = virtcol(".") . "|"
                              normal! g0
                              let restore_cursor = line(".") . "G" .  virtcol(".") . "|zs" . restore_cursor
                              normal! H
                              let restore_cursor = "normal!" . line(".") . "Gzt" . restore_cursor
                              execute restore_cursor
                              call cursor(0, curcol + 1)
                              " normal! 0
                              " if curcol
                              "   execute "normal!" . curcol . "l"
                              " endif
                              if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = '0'
                              else
                                execute "if " . skip . "| let skip = '0' | endif"
                              endif
                              let sp_return = searchpair(ini, mid, fin, flag, skip)
                              let final_position = "call cursor(" . line(".") . "," . col(".") . ")"
                              " Restore cursor position and original screen.
                              execute restore_cursor
                              normal! m'
                              if sp_return > 0
                                execute final_position
                              endif
                              return s:CleanUp(restore_options, a:mode, startline, startcol, mid.'\|'.fin)

FUNCTION  go#util#Exec()
Called 2 times
Total time:   0.052808
 Self time:   0.000135

count  total (s)   self (s)
    2              0.000010   if len(a:cmd) == 0
                                call go#util#EchoError("go#util#Exec() called with empty a:cmd")
                                return ['', 1]
    2              0.000002   endif
                            
    2              0.000017   let l:bin = a:cmd[0]
                            
                              " Lookup the full path, respecting settings such as 'go_bin_path'. On errors,
                              " CheckBinPath will show a warning for us.
    2   0.000841   0.000025   let l:bin = go#path#CheckBinPath(l:bin)
    2              0.000005   if empty(l:bin)
                                return ['', 1]
    2              0.000001   endif
                            
                              " Finally execute the command using the full, resolved path. Do not pass the
                              " unmodified command as the correct program might not exist in $PATH.
    2   0.051902   0.000045   return call('s:exec', [[l:bin] + a:cmd[1:]] + a:000)

FUNCTION  <SNR>103_BlameBufnr()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let state = s:TempState(bufname(a:0 ? a:1 : ''))
                              if get(state, 'filetype', '') ==# 'fugitiveblame'
                                return get(state, 'bufnr', -1)
                              else
                                return -1
                              endif

FUNCTION  go#config#SetGuruScope()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if empty(a:scope)
                                if exists('g:go_guru_scope')
                                  unlet g:go_guru_scope
                                endif
                              else
                                let g:go_guru_scope = a:scope
                              endif

FUNCTION  <SNR>103_DoStageUntrackedHeading()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:DoToggleUntrackedHeading(a:heading)

FUNCTION  fugitive#BufWriteCmd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#FileWriteCmd(a:0 ? a:1 : expand('<amatch>'), 1)

FUNCTION  go#config#SetTermEnabled()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:go_term_enabled = a:value

FUNCTION  gutentags#default_get_project_root()
Called 1 time
Total time:   0.000775
 Self time:   0.000702

count  total (s)   self (s)
    1   0.000044   0.000006     let l:path = gutentags#stripslash(a:path)
    1              0.000003     let l:previous_path = ""
    1              0.000005     let l:markers = g:gutentags_project_root[:]
    1              0.000004     if g:gutentags_add_ctrlp_root_markers && exists('g:ctrlp_root_markers')
                                    for crm in g:ctrlp_root_markers
                                        if index(l:markers, crm) < 0
                                            call add(l:markers, crm)
                                        endif
                                    endfor
    1              0.000001     endif
    3              0.000008     while l:path != l:previous_path
   17              0.000021         for root in l:markers
   15              0.000178             if !empty(globpath(l:path, root, 1))
    1              0.000009                 let l:proj_dir = simplify(fnamemodify(l:path, ':p'))
    1   0.000042   0.000007                 let l:proj_dir = gutentags#stripslash(l:proj_dir)
    1              0.000003                 if l:proj_dir == ''
                                                call gutentags#trace("Found project marker '" . root ."' at the root of your file-system! " ." That's probably wrong, disabling " ."gutentags for this file...",1)
                                                call gutentags#throw("Marker found at root, aborting.")
    1              0.000000                 endif
    2              0.000004                 for ign in g:gutentags_exclude_project_root
    1              0.000002                     if l:proj_dir == ign
                                                    call gutentags#trace("Ignoring project root '" . l:proj_dir ."' because it is in the list of ignored" ." projects.")
                                                    call gutentags#throw("Ignore project: " . l:proj_dir)
    1              0.000000                     endif
    2              0.000000                 endfor
    1              0.000002                 return l:proj_dir
   14              0.000011             endif
   16              0.000018         endfor
    2              0.000004         let l:previous_path = l:path
    2              0.000007         let l:path = fnamemodify(l:path, ':h')
    2              0.000001     endwhile
                                call gutentags#throw("Can't figure out what tag file to use for: " . a:path)

FUNCTION  gutentags#setup_gutentags()
Called 1 time
Total time:   0.007681
 Self time:   0.000950

count  total (s)   self (s)
    1              0.000007     if exists('b:gutentags_files') && !g:gutentags_debug
                                    " This buffer already has gutentags support.
                                    return
    1              0.000001     endif
                            
                                " Don't setup gutentags for anything that's not a normal buffer
                                " (so don't do anything for help buffers and quickfix windows and
                                "  other such things)
                                " Also don't do anything for the default `[No Name]` buffer you get
                                " after starting Vim.
    1              0.000009     if &buftype != '' || (bufname('%') == '' && !g:gutentags_generate_on_empty_buffer)
                                    return
    1              0.000000     endif
                            
                                " Don't setup gutentags for things that don't need it, or that could
                                " cause problems.
    1              0.000007     if index(g:gutentags_exclude_filetypes, &filetype) >= 0
                                    return
    1              0.000001     endif
                            
                                " Let the user specify custom ways to disable Gutentags.
    1              0.000005     if g:gutentags_init_user_func != '' &&!call(g:gutentags_init_user_func, [expand('%:p')])
                                    call gutentags#trace("Ignoring '" . bufname('%') . "' because of " ."custom user function.")
                                    return
    1              0.000000     endif
                            
                                " Try and find what tags file we should manage.
    1   0.000019   0.000011     call gutentags#trace("Scanning buffer '" . bufname('%') . "' for gutentags setup...")
    1              0.000001     try
    1              0.000022         let l:buf_dir = expand('%:p:h', 1)
    1              0.000002         if g:gutentags_resolve_symlinks
                                        let l:buf_dir = fnamemodify(resolve(expand('%:p', 1)), ':p:h')
    1              0.000001         endif
    1              0.000003         if !exists('b:gutentags_root')
    1   0.000796   0.000007             let b:gutentags_root = gutentags#get_project_root(l:buf_dir)
    1              0.000001         endif
    1              0.000003         if !len(b:gutentags_root)
                                        call gutentags#trace("no valid project root.. no gutentags support.")
                                        return
    1              0.000001         endif
    1              0.000009         if filereadable(b:gutentags_root . '/.notags')
                                        call gutentags#trace("'.notags' file found... no gutentags support.")
                                        return
    1              0.000001         endif
                            
    1              0.000004         if !has_key(s:known_projects, b:gutentags_root)
    1   0.000142   0.000010             call s:cache_project_root(b:gutentags_root)
    1              0.000001         endif
    1              0.000002         if g:gutentags_trace
                                        let l:projnfo = gutentags#get_project_info(b:gutentags_root)
                                        if l:projnfo != {}
                                            call gutentags#trace("Setting project type to ".l:projnfo['type'])
                                        else
                                            call gutentags#trace("No specific project type.")
                                        endif
    1              0.000000         endif
                            
    1              0.000002         let b:gutentags_files = {}
    2              0.000004         for module in g:gutentags_modules
    1   0.001044   0.000277             call call("gutentags#".module."#init", [b:gutentags_root])
    2              0.000002         endfor
                                catch /^gutentags\:/
                                    call gutentags#trace("No gutentags support for this buffer.")
                                    return
    1              0.000001     endtry
                            
                                " We know what tags file to manage! Now set things up.
    1   0.000019   0.000011     call gutentags#trace("Setting gutentags for buffer '".bufname('%')."'")
                            
                                " Autocommands for updating the tags on save.
                                " We need to pass the buffer number to the callback function in the rare
                                " case that the current buffer is changed by another `BufWritePost`
                                " callback. This will let us get that buffer's variables without causing
                                " errors.
    1              0.000004     let l:bn = bufnr('%')
    1              0.000011     execute 'augroup gutentags_buffer_' . l:bn
    1              0.000275     execute '  autocmd!'
    1              0.000019     execute '  autocmd BufWritePost <buffer=' . l:bn . '> call s:write_triggered_update_tags(' . l:bn . ')'
    1              0.000004     execute 'augroup end'
                            
                                " Miscellaneous commands.
    1              0.000016     command! -buffer -bang GutentagsUpdate :call s:manual_update_tags(<bang>0)
                            
                                " Add these tags files to the known tags files.
    2              0.000022     for module in keys(b:gutentags_files)
    1              0.000004         let l:tagfile = b:gutentags_files[module]
    1              0.000004         let l:found = index(s:known_files, l:tagfile)
    1              0.000002         if l:found < 0
    1              0.000005             call add(s:known_files, l:tagfile)
                            
                                        " Generate this new file depending on settings and stuff.
    1              0.000001             if g:gutentags_enabled
    1              0.000017                 if g:gutentags_generate_on_missing && !filereadable(l:tagfile)
                                                call gutentags#trace("Generating missing tags file: " . l:tagfile)
                                                call s:update_tags(l:bn, module, 1, 1)
    1              0.000002                 elseif g:gutentags_generate_on_new
    1   0.000015   0.000007                     call gutentags#trace("Generating tags file: " . l:tagfile)
    1   0.005051   0.000032                     call s:update_tags(l:bn, module, 1, 1)
    1              0.000004                 endif
    1              0.000000             endif
    1              0.000000         endif
    2              0.000002     endfor

FUNCTION  <SNR>103_repo_find()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#Find(a:object, self.git_dir)

FUNCTION  <SNR>103_RevertSubcommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Dir()
                              let no_commit = s:HasOpt(a:args, '-n', '--no-commit', '--no-edit', '--abort', '--continue', '--quit')
                              let cmd = s:UserCommand(dir, ['revert'] + (no_commit ? [] : ['-n']) + a:args)
                              let [out, exec_error] = s:SystemError(cmd)
                              call fugitive#ReloadStatus(-1, 1)
                              if no_commit || exec_error
                                return 'echo ' . string(substitute(out, "\n$", '', ''))
                              endif
                              return s:CommitSubcommand(a:line1, a:line2, a:range, a:bang, a:mods, [], dir)

FUNCTION  go#path#GoPath()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " no argument, show GOPATH
                              if len(a:000) == 0
                                echo go#path#Default()
                                return
                              endif
                            
                              " we have an argument, replace GOPATH
                              " clears the current manually set GOPATH and restores it to the
                              " initial GOPATH, which was set when Vim was started.
                              if len(a:000) == 1 && a:1 == '""'
                                if !empty(s:initial_go_path)
                                  let $GOPATH = s:initial_go_path
                                  let s:initial_go_path = ""
                                endif
                            
                                echon "vim-go: " | echohl Function | echon "GOPATH restored to ". $GOPATH | echohl None
                                return
                              endif
                            
                              echon "vim-go: " | echohl Function | echon "GOPATH changed to ". a:1 | echohl None
                              let s:initial_go_path = $GOPATH
                              let $GOPATH = a:1

FUNCTION  go#list#Type()
Called 1 time
Total time:   0.000061
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000033   0.000012   let l:listtype = s:listtype(get(s:default_list_type_commands, a:for))
    1              0.000003   if l:listtype == "0"
                                call go#util#EchoError(printf( "unknown list type command value found ('%s'). Please open a bug report in the vim-go repo.", a:for))
                                let l:listtype = "quickfix"
    1              0.000001   endif
                            
    1   0.000016   0.000009   return get(go#config#ListTypeCommands(), a:for, l:listtype)

FUNCTION  go#config#ListType()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   return get(g:, 'go_list_type', '')

FUNCTION  FugitiveVimPath()
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000010   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
    2              0.000003   else
    2              0.000004     return a:path
                              endif

FUNCTION  <SNR>7_InsertRefs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:matchline !~ a:prefix . substitute(a:group, s:notslash . '\zs:', '\\|', 'g') . a:suffix
                                return a:group
                              endif
                              let i = matchend(a:groupBR, s:notslash . ':')
                              let ini = strpart(a:groupBR, 0, i-1)
                              let tailBR = strpart(a:groupBR, i)
                              let word = s:Choose(a:group, a:matchline, ":", "", a:prefix, a:suffix, a:groupBR)
                              let i = matchend(word, s:notslash . ":")
                              let wordBR = strpart(word, i)
                              let word = strpart(word, 0, i-1)
                              " Now, a:matchline =~ a:prefix . word . a:suffix
                              if wordBR != ini
                                let table = s:Resolve(ini, wordBR, "table")
                              else
                                " let table = "----------"
                                let table = ""
                                let d = 0
                                while d < 10
                                  if tailBR =~ s:notslash . '\\' . d
                            	" let table[d] = d
                            	let table = table . d
                                  else
                            	let table = table . "-"
                                  endif
                                  let d = d + 1
                                endwhile
                              endif
                              let d = 9
                              while d
                                if table[d] != "-"
                                  let backref = substitute(a:matchline, a:prefix.word.a:suffix, '\'.table[d], "")
                            	" Are there any other characters that should be escaped?
                                  let backref = escape(backref, '*,:')
                                  execute s:Ref(ini, d, "start", "len")
                                  let ini = strpart(ini, 0, start) . backref . strpart(ini, start+len)
                                  let tailBR = substitute(tailBR, s:notslash . '\zs\\' . d, escape(backref, '\\&'), 'g')
                                endif
                                let d = d-1
                              endwhile
                              if exists("b:match_debug")
                                if s:do_BR
                                  let b:match_table = table
                                  let b:match_word = word
                                else
                                  let b:match_table = ""
                                  let b:match_word = ""
                                endif
                              endif
                              return ini . ":" . tailBR

FUNCTION  <SNR>103_gsub()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(a:str,'\v\C'.a:pat,a:rep,'g')

FUNCTION  sy#util#popup_close()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if s:popup_window
                                call nvim_win_close(s:popup_window, 1)
                                let s:popup_window = 0
                              endif

FUNCTION  gutentags#remove_job()
Called 1 time
Total time:   0.000128
 Self time:   0.000111

count  total (s)   self (s)
    1              0.000006     let l:tags_file = s:update_in_progress[a:module][a:job_idx][0]
    1              0.000005     call remove(s:update_in_progress[a:module], a:job_idx)
                            
                                " Run the user callback for finished jobs.
    1   0.000043   0.000039     silent doautocmd User GutentagsUpdated
                            
                                " See if we had any more updates queued up for this.
    1              0.000003     let l:qu_idx = -1
    1              0.000008     for qu_info in s:update_queue[a:module]
                                    let l:qu_idx += 1
                                    if qu_info[0] == l:tags_file
                                        break
                                    endif
    1              0.000002     endfor
    1              0.000002     if l:qu_idx >= 0
                                    let l:qu_info = s:update_queue[a:module][l:qu_idx]
                                    call remove(s:update_queue[a:module], l:qu_idx)
                            
                                    if bufexists(l:qu_info[1])
                                        call gutentags#trace("Finished ".a:module." job, "."running queued update for '".l:tags_file."'.")
                                        call s:update_tags(l:qu_info[1], a:module, l:qu_info[2], 2)
                                    else
                                        call gutentags#trace("Finished ".a:module." job, "."but skipping queued update for '".l:tags_file."' "."because originating buffer doesn't exist anymore.")
                                    endif
    1              0.000001     else
    1   0.000022   0.000009         call gutentags#trace("Finished ".a:module." job.")
    1              0.000001     endif

FUNCTION  <SNR>103_CommitComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:A =~# '^--fixup=\|^--squash='
                                let commits = s:LinesError(['log', '--pretty=format:%s', '@{upstream}..'])[0]
                                let pre = matchstr(a:A, '^--\w*=''\=') . ':/^'
                                if pre =~# "'"
                                  call map(commits, 'pre . string(tr(v:val, "|\"^$*[]", "......."))[1:-1]')
                                  call filter(commits, 'strpart(v:val, 0, strlen(a:A)) ==# a:A')
                                  return commits
                                else
                                  return s:FilterEscape(map(commits, 'pre . tr(v:val, "\\ !^$*?[]()''\"`&;<>|#", "....................")'), a:A)
                                endif
                              else
                                return s:CompleteSub('commit', a:A, a:L, a:P, function('fugitive#CompletePath'))
                              endif
                              return []

FUNCTION  go#path#Detect()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let gopath = go#path#Default()
                            
                              let current_dir = fnameescape(expand('%:p:h'))
                            
                              " TODO(arslan): this should be changed so folders or files should be
                              " fetched from a customizable list. The user should define any new package
                              " management tool by it's own.
                            
                              " src folders outside $GOPATH
                              let src_roots = finddir("src", current_dir .";", -1)
                            
                              " for cases like GOPATH/src/foo/src/bar, pick up GOPATH/src instead of
                              " GOPATH/src/foo/src
                              let src_root = ""
                              if len(src_roots) > 0
                                let src_root = src_roots[-1]
                              endif
                            
                              if !empty(src_root)
                                let src_path = fnamemodify(src_root, ':p:h:h') . go#util#PathSep()
                            
                                " gb vendor plugin
                                " (https://github.com/constabulary/gb/tree/master/cmd/gb-vendor)
                                let gb_vendor_root = src_path . "vendor" . go#util#PathSep()
                                if isdirectory(gb_vendor_root) && !s:HasPath(gb_vendor_root)
                                  let gopath = gb_vendor_root . go#util#PathListSep() . gopath
                                endif
                            
                                if !s:HasPath(src_path)
                                  let gopath =  src_path . go#util#PathListSep() . gopath
                                endif
                              endif
                            
                              " Godeps
                              let godeps_root = finddir("Godeps", current_dir .";")
                              if !empty(godeps_root)
                                let godeps_path = join([fnamemodify(godeps_root, ':p:h:h'), "Godeps", "_workspace" ], go#util#PathSep())
                            
                                if !s:HasPath(godeps_path)
                                  let gopath =  godeps_path . go#util#PathListSep() . gopath
                                endif
                              endif
                            
                              " Fix up the case where initial $GOPATH is empty,
                              " and we end up with a trailing :
                              let gopath = substitute(gopath, ":$", "", "")
                              return gopath

FUNCTION  <SNR>103_UserCommandList()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let git = split(get(g:, 'fugitive_git_command', g:fugitive_git_executable), '\s\+')
                              let dir = a:0 ? s:Dir(a:1) : ''
                              if len(dir)
                                let tree = s:Tree(dir)
                                if empty(tree)
                                  call add(git, '--git-dir=' . FugitiveGitPath(dir))
                                elseif len(tree) && s:cpath(tree) !=# s:cpath(getcwd())
                                  if fugitive#GitVersion(1, 8, 5)
                                    call extend(git, ['-C', FugitiveGitPath(tree)])
                                  else
                                    throw 'fugitive: Git 1.8.5 or higher required to change directory'
                                  endif
                                endif
                              endif
                              return git

FUNCTION  <SNR>92_newHandlerState()
Called 3 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    3              0.000036   let l:state = { 'winid': win_getid(winnr()), 'statustype': a:statustype, 'jobdir': getcwd(), }
                            
                              " explicitly bind requestComplete to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
    3              0.000032   let l:state.requestComplete = funcref('s:requestComplete', [], l:state)
                            
                              " explicitly bind start to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
    3              0.000019   let l:state.start = funcref('s:start', [], l:state)
                            
    3              0.000005   return l:state

FUNCTION  go#guru#ChannelPeers()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = { 'mode': 'peers', 'format': 'plain', 'selected': a:selected, 'needs_scope': 1, }
                            
                              call s:run_guru(args)

FUNCTION  <SNR>92_noop()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  <SNR>103_GrepSubcommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              let listnr = a:line1 == 0 ? a:line1 : a:line2
                              let cmd = ['--no-pager', 'grep', '-n', '--no-color', '--full-name']
                              if fugitive#GitVersion(2, 19)
                                call add(cmd, '--column')
                              endif
                              let tree = s:Tree(dir)
                              if type(a:args) == type([])
                                let [args, after] = [a:args, '']
                              else
                                let [args, after] = s:SplitExpandChain(a:args, tree)
                              endif
                              let prefix = FugitiveVimPath(s:HasOpt(args, '--cached') || empty(tree) ? 'fugitive://' . dir . '//0/' : tree . '/')
                              let name_only = s:HasOpt(args, '-l', '--files-with-matches', '--name-only', '-L', '--files-without-match')
                              let title = [listnr < 0 ? ':Ggrep' : ':Glgrep'] + args
                              if listnr > 0
                                exe listnr 'wincmd w'
                              else
                                call s:BlurStatus()
                              endif
                              redraw
                              call s:QuickfixCreate(listnr, {'title': (listnr < 0 ? ':Ggrep ' : ':Glgrep ') . s:fnameescape(args)})
                              let tempfile = tempname()
                              if v:version >= 704 | exe 'silent doautocmd <nomodeline> QuickFixCmdPre ' (listnr < 0 ? 'Ggrep' : 'Glgrep') | endif
                              exe '!' . escape(s:UserCommand(dir, cmd + args), '%#!') printf(&shellpipe . (&shellpipe =~# '%s' ? '' : ' %s'), s:shellesc(tempfile))
                              let list = map(readfile(tempfile), 's:GrepParseLine(prefix, name_only, dir, v:val)')
                              call s:QuickfixSet(listnr, list, 'a')
                              if v:version >= 704 | exe 'silent doautocmd <nomodeline> QuickFixCmdPost ' (listnr < 0 ? 'Ggrep' : 'Glgrep') | endif
                              if !has('gui_running')
                                redraw
                              endif
                              if !a:bang && !empty(list)
                                return (listnr < 0 ? 'c' : 'l').'first' . after
                              else
                                return after[1:-1]
                              endif

FUNCTION  fugitive#CdComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return filter(fugitive#CompletePath(a:A), 'v:val =~# "/$"')

FUNCTION  <SNR>103_repo_bare()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if self.dir() =~# '/\.git$'
                                return 0
                              else
                                return s:Tree(self.git_dir) ==# ''
                              endif

FUNCTION  <SNR>49_wrapreg()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let orig = getreg(a:reg)
                              let type = substitute(getregtype(a:reg),'\d\+$','','')
                              let new = s:wrap(orig,a:char,type,a:removed,a:special)
                              call setreg(a:reg,new,type)

FUNCTION  <SNR>103_linechars()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let chars = strlen(s:gsub(matchstr(getline('.'), a:pattern), '.', '.'))
                              if exists('*synconcealed') && &conceallevel > 1
                                for col in range(1, chars)
                                  let chars -= synconcealed(line('.'), col)[0]
                                endfor
                              endif
                              return chars

FUNCTION  <SNR>103_DoUnstageUnpulled()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call feedkeys(':Grebase ' . a:record.commit)

FUNCTION  <SNR>103_PushComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:CompleteSub('push', a:A, a:L, a:P, function('s:CompleteRemote'))

FUNCTION  <SNR>92_completionHandler()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " gopls returns a CompletionList.
                              let l:matches = []
                              let l:start = -1
                            
                              for l:item in a:msg.items
                                let l:start = l:item.textEdit.range.start.character
                            
                                let l:match = {'abbr': l:item.label, 'word': l:item.textEdit.newText, 'info': '', 'kind': go#lsp#completionitemkind#Vim(l:item.kind)}
                                if has_key(l:item, 'detail')
                                    let l:match.menu = l:item.detail
                                    if go#lsp#completionitemkind#IsFunction(l:item.kind) || go#lsp#completionitemkind#IsMethod(l:item.kind)
                                      let l:match.info = printf('%s %s', l:item.label, l:item.detail)
                            
                                      " The detail provided by gopls hasn't always provided the the full
                                      " signature including the return value. The label used to be the
                                      " function signature and the detail was the return value. Handle
                                      " that case for backward compatibility. This can be removed in the
                                      " future once it's likely that the majority of users are on a recent
                                      " version of gopls.
                                      if l:item.detail !~ '^func'
                                        let l:match.info = printf('func %s %s', l:item.label, l:item.detail)
                                      endif
                                    endif
                                endif
                            
                                if has_key(l:item, 'documentation')
                                  let l:match.info .= "\n\n" . l:item.documentation
                                endif
                            
                                let l:matches = add(l:matches, l:match)
                              endfor
                              let l:args = [l:start, l:matches]
                              call call(a:next, l:args)

FUNCTION  go#job#Options()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let cbs = {}
                              let state = { 'winid': win_getid(winnr()), 'dir': getcwd(), 'jobdir': expand("%:p:h"), 'messages': [], 'bang': 0, 'for': "_job", 'exited': 0, 'exit_status': 0, 'closed': 0, 'errorformat': &errorformat, 'statustype' : '' }
                            
                              if has("patch-8.0.0902") || has('nvim')
                                let cbs.cwd = state.jobdir
                              endif
                            
                              if has_key(a:args, 'bang')
                                let state.bang = a:args.bang
                              endif
                            
                              if has_key(a:args, 'for')
                                let state.for = a:args.for
                              endif
                            
                              if has_key(a:args, 'statustype')
                                let state.statustype = a:args.statustype
                              endif
                            
                              if has_key(a:args, 'errorformat')
                                let state.errorformat = a:args.errorformat
                              endif
                            
                              function state.complete(job, exit_status, data)
                                if has_key(self, 'custom_complete')
                                  let l:winid = win_getid(winnr())
                                  " Always set the active window to the window that was active when the job
                                  " was started. Among other things, this makes sure that the correct
                                  " window's location list will be populated when the list type is
                                  " 'location' and the user has moved windows since starting the job.
                                  call win_gotoid(self.winid)
                                  call self.custom_complete(a:job, a:exit_status, a:data)
                                  call win_gotoid(l:winid)
                                endif
                            
                                call self.show_errors(a:job, a:exit_status, a:data)
                              endfunction
                            
                              function state.show_status(job, exit_status) dict
                                if self.statustype == ''
                                  return
                                endif
                            
                                if go#config#EchoCommandInfo()
                                  let prefix = '[' . self.statustype . '] '
                                  if a:exit_status == 0
                                    call go#util#EchoSuccess(prefix . "SUCCESS")
                                  else
                                    call go#util#EchoError(prefix . "FAIL")
                                  endif
                                endif
                            
                                let status = { 'desc': 'last status', 'type': self.statustype, 'state': "success", }
                            
                                if a:exit_status
                                  let status.state = "failed"
                                endif
                            
                                if has_key(self, 'started_at')
                                  let elapsed_time = reltimestr(reltime(self.started_at))
                                  " strip whitespace
                                  let elapsed_time = substitute(elapsed_time, '^\s*\(.\{-}\)\s*$', '\1', '')
                                  let status.state .= printf(" (%ss)", elapsed_time)
                                endif
                            
                                call go#statusline#Update(self.jobdir, status)
                              endfunction
                            
                              if has_key(a:args, 'complete')
                                let state.custom_complete = a:args.complete
                              endif
                            
                              " explicitly bind _start to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
                              "
                              " _start is intended only for internal use and should not be referenced
                              " outside of this file.
                              let cbs._start = function('s:start', [''], state)
                            
                              " explicitly bind callback to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
                              let cbs.callback = function('s:callback', [], state)
                            
                              " explicitly bind exit_cb to state so that within it, self will always refer
                              " to state. See :help Partial for more information.
                              let cbs.exit_cb = function('s:exit_cb', [], state)
                            
                              " explicitly bind close_cb to state so that within it, self will
                              " always refer to state. See :help Partial for more information.
                              let cbs.close_cb = function('s:close_cb', [], state)
                            
                              function state.show_errors(job, exit_status, data)
                                if self.for == '_'
                                  return
                                endif
                            
                                let l:winid = win_getid(winnr())
                                " Always set the active window to the window that was active when the job
                                " was started. Among other things, this makes sure that the correct
                                " window's location list will be populated when the list type is
                                " 'location' and the user has moved windows since starting the job.
                                call win_gotoid(self.winid)
                            
                                let l:listtype = go#list#Type(self.for)
                                if a:exit_status == 0
                                  call go#list#Clean(l:listtype)
                                  call win_gotoid(l:winid)
                                  return
                                endif
                            
                                let l:listtype = go#list#Type(self.for)
                                if len(a:data) == 0
                                  call go#list#Clean(l:listtype)
                                  call win_gotoid(l:winid)
                                  return
                                endif
                            
                                let out = join(self.messages, "\n")
                            
                                let l:cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : 'cd'
                                try
                                  " parse the errors relative to self.jobdir
                                  execute l:cd fnameescape(self.jobdir)
                                  call go#list#ParseFormat(l:listtype, self.errorformat, out, self.for)
                                  let errors = go#list#Get(l:listtype)
                                finally
                                  execute l:cd fnameescape(self.dir)
                                endtry
                            
                            
                                if empty(errors)
                                  " failed to parse errors, output the original content
                                  call go#util#EchoError([self.dir] + self.messages)
                                  call win_gotoid(l:winid)
                                  return
                                endif
                            
                                " only open the error window if user was still in the window from which
                                " the job was started.
                                if self.winid == l:winid
                                  call go#list#Window(l:listtype, len(errors))
                                  if self.bang
                                    call win_gotoid(l:winid)
                                  else
                                    call go#list#JumpToFirst(l:listtype)
                                  endif
                                endif
                              endfunction
                            
                              return cbs

FUNCTION  <SNR>57_LP_PatPop()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            "  call Dfunc("LP_PatPop(lookup=".a:lookup.")")
                              if s:npatstack > 0
                               let ret         = s:patstack_{s:npatstack}
                               let s:npatstack = s:npatstack - 1
                              else
                               let ret= "---error---"
                               echoerr "(LogiPat) invalid expression"
                              endif
                            "  call s:StackLook("patpop") "Decho
                            "  call Dret("LP_PatPop ".ret)
                              return ret

FUNCTION  go#guru#DescribeBalloon()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " don't even try if async isn't available.
                              if !go#util#has_job()
                                return
                              endif
                            
                              " json_encode() and friends are introduced with this patch (7.4.1304)
                              " vim: https://groups.google.com/d/msg/vim_dev/vLupTNhQhZ8/cDGIk0JEDgAJ
                              " nvim: https://github.com/neovim/neovim/pull/4131
                              if !exists("*json_decode")
                                call go#util#EchoError("requires 'json_decode'. Update your Vim/Neovim version.")
                                return
                              endif
                            
                              " change the active window to the window where the cursor is.
                              let l:winid = win_getid(winnr())
                              call win_gotoid(v:beval_winid)
                            
                              let l:args = { 'mode': 'describe', 'format': 'json', 'selected': -1, 'needs_scope': 0, 'custom_parse': function('s:describe_balloon'), 'disable_progress': 1, 'postype': 'balloon', }
                            
                              call s:async_guru(args)
                            
                              " make the starting window active again
                              call win_gotoid(l:winid)
                            
                              return ''

FUNCTION  go#config#FmtAutosave()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000011 	return get(g:, "go_fmt_autosave", 1)

FUNCTION  go#config#PlayBrowserCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if go#util#IsWin()
                                    let go_play_browser_command = '!start rundll32 url.dll,FileProtocolHandler %URL%'
                                elseif go#util#IsMac()
                                    let go_play_browser_command = 'open %URL%'
                                elseif executable('xdg-open')
                                    let go_play_browser_command = 'xdg-open %URL%'
                                elseif executable('firefox')
                                    let go_play_browser_command = 'firefox %URL% &'
                                elseif executable('chromium')
                                    let go_play_browser_command = 'chromium %URL% &'
                                else
                                    let go_play_browser_command = ''
                                endif
                            
                                return get(g:, 'go_play_browser_command', go_play_browser_command)

FUNCTION  <SNR>103_ExecPath()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !has_key(s:exec_paths, g:fugitive_git_executable)
                                let s:exec_paths[g:fugitive_git_executable] = s:sub(system(g:fugitive_git_executable.' --exec-path'),'\n$','')
                              endif
                              return s:exec_paths[g:fugitive_git_executable]

FUNCTION  FugitiveGitDir()
Called 3 times
Total time:   0.000126
 Self time:   0.000114

count  total (s)   self (s)
    3              0.000025   if !a:0 || type(a:1) == type(0) && a:1 < 0
    2              0.000010     let dir = get(b:, 'git_dir', '')
    2              0.000009     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
    2              0.000002     endif
    2              0.000002     return dir
    1              0.000003   elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
    1              0.000010   elseif type(a:1) == type('')
    1   0.000033   0.000021     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  go#guru#Callers()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = { 'mode': 'callers', 'format': 'plain', 'selected': a:selected, 'needs_scope': 1, }
                            
                              call s:run_guru(args)

FUNCTION  fugitive#Path()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if empty(a:url)
                                return ''
                              endif
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let tree = s:Tree(dir)
                              if !a:0
                                return fugitive#Real(a:url)
                              elseif a:1 =~# '\.$'
                                let path = s:Slash(fugitive#Real(a:url))
                                let cwd = getcwd()
                                let lead = ''
                                while s:cpath(tree . '/', (cwd . '/')[0 : len(tree)])
                                  if s:cpath(cwd . '/', path[0 : len(cwd)])
                                    if strpart(path, len(cwd) + 1) =~# '^\.git\%(/\|$\)'
                                      break
                                    endif
                                    return a:1[0:-2] . (empty(lead) ? './' : lead) . strpart(path, len(cwd) + 1)
                                  endif
                                  let cwd = fnamemodify(cwd, ':h')
                                  let lead .= '../'
                                endwhile
                                return a:1[0:-2] . path
                              endif
                              let url = a:url
                              let temp_state = s:TempState(url)
                              if has_key(temp_state, 'bufnr')
                                let url = bufname(temp_state.bufnr)
                              endif
                              let url = s:Slash(fnamemodify(url, ':p'))
                              if url =~# '/$' && s:Slash(a:url) !~# '/$'
                                let url = url[0:-2]
                              endif
                              let [argdir, commit, file] = s:DirCommitFile(a:url)
                              if len(argdir) && s:cpath(argdir) !=# s:cpath(dir)
                                let file = ''
                              elseif len(dir) && s:cpath(url[0 : len(dir)]) ==# s:cpath(dir . '/')
                                let file = '/.git'.url[strlen(dir) : -1]
                              elseif len(tree) && s:cpath(url[0 : len(tree)]) ==# s:cpath(tree . '/')
                                let file = url[len(tree) : -1]
                              elseif s:cpath(url) ==# s:cpath(tree)
                                let file = '/'
                              endif
                              if empty(file) && a:1 =~# '^$\|^[.:]/$'
                                return FugitiveGitPath(fugitive#Real(a:url))
                              endif
                              return substitute(file, '^/', a:1, '')

FUNCTION  sy#start()
Called 2 times
Total time:   0.004088
 Self time:   0.000748

count  total (s)   self (s)
    2              0.000009   if g:signify_locked
                                call sy#verbose('Locked.')
                                return
    2              0.000002   endif
                            
    2              0.000076   let sy_path = resolve(expand('%:p'))
    2              0.000011   if has('win32')
                                let sy_path = substitute(sy_path, '\v^(\w):\\\\', '\1:\\', '')
    2              0.000002   endif
                            
    2   0.000131   0.000014   if s:skip(sy_path)
                                call sy#verbose('Skip file: '. sy_path)
                                if exists('b:sy')
                                  call sy#sign#remove_all_signs(bufnr(''))
                                  unlet! b:sy
                                endif
                                return
    2              0.000002   endif
                            
    2              0.000015   if !exists('b:sy') || b:sy.path != sy_path
    1   0.000054   0.000017     call sy#verbose('Register new file: '. sy_path)
    1   0.000439   0.000131     let b:sy = { 'path':       sy_path, 'buffer':     bufnr(''), 'active':     0, 'detecting':  0, 'vcs':        [], 'hunks':      [], 'signid':     0x100, 'updated_by': '', 'stats':      [-1, -1, -1], 'info':       {    'dir':  fnamemodify(sy_path, ':p:h'),    'path': sy#util#escape(sy_path),    'file': sy#util#escape(fnamemodify(sy_path, ':t')) }}
    1              0.000003     if get(g:, 'signify_disable_by_default')
                                  call sy#verbose('Disabled by default.')
                                  return
    1              0.000000     endif
    1              0.000003     let b:sy.active = 1
    1   0.001997   0.000095     call sy#repo#detect()
    1              0.000004   elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
    1              0.000001   elseif !b:sy.active
                                call sy#verbose('Inactive buffer.')
                                return
    1              0.000003   elseif empty(b:sy.vcs)
                                if get(b:sy, 'retry')
                                  let b:sy.retry = 0
                                  call sy#verbose('Redetecting VCS.')
                                  call sy#repo#detect()
                                else
                                  if get(b:sy, 'detecting')
                                    call sy#verbose('Detection is already in progress.')
                                  else
                                    call sy#verbose('No VCS found. Disabling.')
                                    call sy#disable()
                                  endif
                                endif
    1              0.000000   else
    2              0.000010     for vcs in b:sy.vcs
    1              0.000005       let job_id = get(b:, 'sy_job_id_'. vcs)
    1              0.000004       if type(job_id) != type(0) || job_id > 0
                                    call sy#verbose('Update is already in progress.', vcs)
    1              0.000001       else
    1   0.000028   0.000010         call sy#verbose('Updating signs.', vcs)
    1   0.001034   0.000076         call sy#repo#get_diff(vcs, function('sy#sign#set_signs'))
    1              0.000003       endif
    2              0.000017     endfor
    2              0.000003   endif

FUNCTION  <SNR>103_SplitExpand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:ExpandSplit(a:string, 0, a:0 ? a:1 : getcwd())

FUNCTION  fugitive#getftime()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:PathInfo(a:url)[0]

FUNCTION  <SNR>103_DoStageUnpushedHeading()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let remote = matchstr(a:heading, 'to \zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:heading, 'to \%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Gpush ' . remote . ' ' . 'HEAD:' . branch)

FUNCTION  <SNR>58_DoMatchParen()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"

FUNCTION  <SNR>7_CleanUp()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if strlen(a:options)
                                execute "set" a:options
                              endif
                              " Open folds, if appropriate.
                              if a:mode != "o"
                                if &foldopen =~ "percent"
                                  normal! zv
                                endif
                                " In Operator-pending mode, we want to include the whole match
                                " (for example, d%).
                                " This is only a problem if we end up moving in the forward direction.
                              elseif (a:startline < line(".")) || (a:startline == line(".") && a:startcol < col("."))
                                if a:0
                                  " Check whether the match is a single character.  If not, move to the
                                  " end of the match.
                                  let matchline = getline(".")
                                  let currcol = col(".")
                                  let regexp = s:Wholematch(matchline, a:1, currcol-1)
                                  let endcol = matchend(matchline, regexp)
                                  if endcol > currcol  " This is NOT off by one!
                            	call cursor(0, endcol)
                                  endif
                                endif " a:0
                              endif " a:mode != "o" && etc.
                              return 0

FUNCTION  <SNR>100_check_diff_hg()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  gutentags#ctags#init()
Called 1 time
Total time:   0.000297
 Self time:   0.000153

count  total (s)   self (s)
                                " Figure out the path to the tags file.
                                " Check the old name for this option, too, before falling back to the
                                " globally defined name.
    1              0.000012     let l:tagfile = getbufvar("", 'gutentags_ctags_tagfile',getbufvar("", 'gutentags_tagfile', g:gutentags_ctags_tagfile))
    1   0.000152   0.000008     let b:gutentags_files['ctags'] = gutentags#get_cachefile(a:project_root, l:tagfile)
                            
                                " Set the tags file for Vim to use.
    1              0.000002     if g:gutentags_ctags_auto_set_tags
    1              0.000039         execute 'setlocal tags^=' . fnameescape(b:gutentags_files['ctags'])
    1              0.000002     endif
                            
                                " Check if the ctags executable exists.
    1              0.000003     if s:did_check_exe == 0
    1              0.000073         if g:gutentags_enabled && executable(expand(g:gutentags_ctags_executable, 1)) == 0
                                        let g:gutentags_enabled = 0
                                        echoerr "Executable '".g:gutentags_ctags_executable."' can't be found. "."Gutentags will be disabled. You can re-enable it by "."setting g:gutentags_enabled back to 1."
    1              0.000000         endif
    1              0.000002         let s:did_check_exe = 1
    1              0.000001     endif

FUNCTION  gutentags#statusline()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let l:modules_in_progress = gutentags#inprogress()
                                if empty(l:modules_in_progress)
                                   return ''
                                endif
                            
                                let l:prefix = ''
                                let l:suffix = ''
                                if a:0 > 0
                                   let l:prefix = a:1
                                endif
                                if a:0 > 1
                                   let l:suffix = a:2
                                endif
                            
                                if a:0 > 2
                                   let l:genmsg = a:3
                                else
                                   let l:genmsg = join(l:modules_in_progress, ',')
                                endif
                            
                                return l:prefix.l:genmsg.l:suffix

FUNCTION  <SNR>103_define_commands()
Called 1 time
Total time:   0.000286
 Self time:   0.000286

count  total (s)   self (s)
   10              0.000017   for command in s:commands
    9              0.000252     exe 'command! -buffer '.command
   10              0.000011   endfor

FUNCTION  <SNR>103_DirRev()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              return [dir, (commit =~# '^.$' ? ':' : '') . commit . substitute(file, '^/', ':', '')]

FUNCTION  <SNR>103_DoToggleUntrackedHeading()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:TreeChomp('add', '.')
                              return 1

FUNCTION  fugitive#getfperm()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              let perm = getfperm(dir)
                              let fperm = s:PathInfo(a:url)[1]
                              if fperm ==# '040000'
                                let fperm = '000755'
                              endif
                              if fperm !~# '[15]'
                                let perm = tr(perm, 'x', '-')
                              endif
                              if fperm !~# '[45]$'
                                let perm = tr(perm, 'rw', '--')
                              endif
                              if commit !~# '^\d$'
                                let perm = tr(perm, 'w', '-')
                              endif
                              return perm ==# '---------' ? '' : perm

FUNCTION  <SNR>103_RebaseComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:CompleteSub('rebase', a:A, a:L, a:P, function('s:CompleteRevision'))

FUNCTION  <SNR>41_gofiletype_post()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000004   let &g:fileformats = s:current_fileformats
    1              0.000002   let &g:fileencodings = s:current_fileencodings

FUNCTION  <SNR>7_Choose()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let tail = (a:patterns =~ a:comma."$" ? a:patterns : a:patterns . a:comma)
                              let i = matchend(tail, s:notslash . a:comma)
                              if a:0
                                let alttail = (a:1 =~ a:comma."$" ? a:1 : a:1 . a:comma)
                                let j = matchend(alttail, s:notslash . a:comma)
                              endif
                              let current = strpart(tail, 0, i-1)
                              if a:branch == ""
                                let currpat = current
                              else
                                let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
                              endif
                              while a:string !~ a:prefix . currpat . a:suffix
                                let tail = strpart(tail, i)
                                let i = matchend(tail, s:notslash . a:comma)
                                if i == -1
                                  return -1
                                endif
                                let current = strpart(tail, 0, i-1)
                                if a:branch == ""
                                  let currpat = current
                                else
                                  let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
                                endif
                                if a:0
                                  let alttail = strpart(alttail, j)
                                  let j = matchend(alttail, s:notslash . a:comma)
                                endif
                              endwhile
                              if a:0
                                let current = current . a:comma . strpart(alttail, 0, j-1)
                              endif
                              return current

FUNCTION  <SNR>5_GetCmdArg()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:sect == ''
                                return a:page
                              endif
                              return s:man_sect_arg.' '.a:sect.' '.a:page

FUNCTION  sy#repo#diffmode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              execute sy#util#return_if_no_changes()
                            
                              let vcs = b:sy.updated_by
                              if !has_key(g:signify_vcs_cmds_diffmode, vcs)
                                echomsg 'SignifyDiff has no support for: '. vcs
                                echomsg 'Open an issue for it at: https://github.com/mhinz/vim-signify/issues'
                                return
                              endif
                              let cmd = s:expand_cmd(vcs, g:signify_vcs_cmds_diffmode)
                              call sy#verbose('SignifyDiff: '. cmd, vcs)
                              let ft = &filetype
                              let fenc = &fenc
                              if a:do_tab
                                tabedit %
                              endif
                              diffthis
                              let [cwd, chdir] = sy#util#chdir()
                              try
                                execute chdir fnameescape(b:sy.info.dir)
                                leftabove vnew
                                if (fenc != &enc) && has('iconv')
                                  silent put =iconv(system(cmd), fenc, &enc)
                                else
                                  silent put =system(cmd)
                                endif
                              finally
                                execute chdir fnameescape(cwd)
                              endtry
                              silent 1delete
                              set buftype=nofile bufhidden=wipe nomodified
                              let &filetype = ft
                              diffthis
                              wincmd p
                              normal! ]czt

FUNCTION  qf#GetList()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if get(b:, 'qf_isLoc', 0)
                                    return getloclist(0)
                                else
                                    return getqflist()
                                endif

FUNCTION  <SNR>103_BlameQuit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let cmd = s:BlameLeave()
                              if empty(cmd)
                                return 'bdelete'
                              elseif len(s:DirCommitFile(@%)[1])
                                return cmd . '|Gedit'
                              else
                                return cmd
                              endif

FUNCTION  <SNR>49_process()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let i = 0
                              for i in range(7)
                                let repl_{i} = ''
                                let m = matchstr(a:string,nr2char(i).'.\{-\}\ze'.nr2char(i))
                                if m != ''
                                  let m = substitute(strpart(m,1),'\r.*','','')
                                  let repl_{i} = input(match(m,'\w\+$') >= 0 ? m.': ' : m)
                                endif
                              endfor
                              let s = ""
                              let i = 0
                              while i < strlen(a:string)
                                let char = strpart(a:string,i,1)
                                if char2nr(char) < 8
                                  let next = stridx(a:string,char,i+1)
                                  if next == -1
                                    let s .= char
                                  else
                                    let insertion = repl_{char2nr(char)}
                                    let subs = strpart(a:string,i+1,next-i-1)
                                    let subs = matchstr(subs,'\r.*')
                                    while subs =~ '^\r.*\r'
                                      let sub = matchstr(subs,"^\r\\zs[^\r]*\r[^\r]*")
                                      let subs = strpart(subs,strlen(sub)+1)
                                      let r = stridx(sub,"\r")
                                      let insertion = substitute(insertion,strpart(sub,0,r),strpart(sub,r+1),'')
                                    endwhile
                                    let s .= insertion
                                    let i = next
                                  endif
                                else
                                  let s .= char
                                endif
                                let i += 1
                              endwhile
                              return s

FUNCTION  <SNR>34_uppercase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return toupper(s:snakecase(a:word))

FUNCTION  <SNR>57_LP_Or()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            "  call Dfunc("LP_Or(pat1<".a:pat1."> pat2<".a:pat2.">)")
                              let ret= '\%('.a:pat1.'\|'.a:pat2.'\)'
                            "  call Dret("LP_Or ".ret)
                              return ret

FUNCTION  <SNR>24_SynSet()
Called 3 times
Total time:   0.008995
 Self time:   0.002925

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    3              0.000025   syn clear
    3              0.000012   if exists("b:current_syntax")
                                unlet b:current_syntax
    3              0.000003   endif
                            
    3              0.000012   let s = expand("<amatch>")
    3              0.000007   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    3              0.000005   elseif s == "OFF"
                                let s = ""
    3              0.000001   endif
                            
    3              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    6              0.000039     for name in split(s, '\.')
    3   0.008817   0.002747       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    6              0.000012     endfor
    3              0.000003   endif

FUNCTION  <SNR>34_parse_substitute()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if get(a:args,0,'') =~ '^[/?'']'
                                let separator = matchstr(a:args[0],'^.')
                                let args = split(join(a:args,' '),separator,1)
                                call remove(args,0)
                              else
                                let args = a:args
                              endif
                              if len(args) < 2
                                call s:throw("E471: Argument required")
                              elseif len(args) > 3
                                call s:throw("E488: Trailing characters")
                              endif
                              let [bad,good,flags] = (args + [""])[0:2]
                              if a:count == 0
                                let cmd = "substitute"
                              else
                                let cmd = a:line1.",".a:line2."substitute"
                              endif
                              return s:substitute_command(cmd,bad,good,flags)

FUNCTION  FugitiveDetect()
Called 1 time
Total time:   0.013974
 Self time:   0.000353

count  total (s)   self (s)
    1              0.000006   if exists('b:git_dir') && b:git_dir =~# '^$\|/$\|^fugitive:'
                                unlet b:git_dir
    1              0.000001   endif
    1              0.000003   if !exists('b:git_dir')
    1   0.000607   0.000013     let dir = FugitiveExtractGitDir(a:path)
    1              0.000002     if dir !=# ''
    1              0.000002       let b:git_dir = dir
    1              0.000001     endif
    1              0.000001   endif
    1              0.000003   if exists('b:git_dir')
    1   0.013343   0.000316     return fugitive#Init()
                              endif

FUNCTION  <SNR>102_get_ctags_executable()
Called 2 times
Total time:   0.000097
 Self time:   0.000086

count  total (s)   self (s)
                                "Only consider the main filetype in cases like 'python.django'
    2              0.000024     let l:ftype = get(split(&filetype, '\.'), 0, '')
    2   0.000026   0.000015     let l:proj_info = gutentags#get_project_info(a:proj_dir)
    2              0.000008     let l:type = get(l:proj_info, 'type', l:ftype)
    2              0.000014     let exepath = exists('g:gutentags_ctags_executable_{l:type}') ? g:gutentags_ctags_executable_{l:type} : g:gutentags_ctags_executable
    2              0.000016     return expand(exepath, 1)

FUNCTION  <SNR>104_complete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let output = join(a:messages, "\n")
                              call self.parse(a:exit_status, output, self.mode)

FUNCTION  <SNR>103_buffer_type()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return 'see b:fugitive_type'

FUNCTION  fugitive#SourceCmd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let temp = s:BlobTemp(amatch)
                              if empty(temp)
                                return 'noautocmd source ' . s:fnameescape(amatch)
                              endif
                              if !exists('g:virtual_scriptnames')
                                let g:virtual_scriptnames = {}
                              endif
                              let g:virtual_scriptnames[temp] = amatch
                              return 'source ' . s:fnameescape(temp)

FUNCTION  <SNR>100_preview_hunk()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call sy#verbose('s:preview_hunk()', a:vcs)
                            
                              let in_hunk = 0
                              let hunk = []
                            
                              for line in a:diff
                                if in_hunk
                                  if line[:2] == '@@ ' || empty(line)
                                    break
                                  endif
                                  call add(hunk, line)
                                elseif line[:2] == '@@ ' && s:is_cur_line_in_hunk(line)
                                  let in_hunk = 1
                                endif
                              endfor
                            
                              if !in_hunk
                                return
                              endif
                            
                              if sy#util#popup_create(hunk)
                                return
                              endif
                            
                              silent! wincmd P
                              if !&previewwindow
                                noautocmd botright new
                              endif
                              call setline(1, hunk)
                              silent! %foldopen!
                              setlocal previewwindow filetype=diff buftype=nofile bufhidden=delete
                              " With :noautocmd wincmd p, the first line of the preview window would show
                              " the 'cursorline', although it's not focused. Use feedkeys() instead.
                              noautocmd call feedkeys("\<c-w>p", 'nt')

FUNCTION  fugitive#filewritable()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if commit !~# '^\d$' || !filewritable(fugitive#Find('.git/index', dir))
                                return 0
                              endif
                              return s:PathInfo(a:url)[2] ==# 'blob' ? 1 : 2

FUNCTION  <SNR>100_expand_cmd()
Called 2 times
Total time:   0.000202
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000007   let cmd = a:vcs_cmds[a:vcs]
    2   0.000122   0.000024   let cmd = s:replace(cmd, '%f', s:get_vcs_path(a:vcs))
    2   0.000036   0.000015   let cmd = s:replace(cmd, '%d', s:difftool)
    2   0.000032   0.000012   let cmd = s:replace(cmd, '%n', s:devnull)
    2              0.000004   return cmd

FUNCTION  go#config#EchoGoInfo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_echo_go_info", 1)

FUNCTION  <SNR>103_BlobTemp()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(file)
                                return ''
                              endif
                              if !has_key(s:blobdirs, dir)
                                let s:blobdirs[dir] = tempname()
                              endif
                              let tempfile = s:blobdirs[dir] . '/' . commit . file
                              let tempparent = fnamemodify(tempfile, ':h')
                              if !isdirectory(tempparent)
                                call mkdir(tempparent, 'p')
                              endif
                              if commit =~# '^\d$' || !filereadable(tempfile)
                                let rev = s:DirRev(a:url)[1]
                                let exec_error = s:TempCmd(tempfile, [dir, 'cat-file', 'blob', rev])[1]
                                if exec_error
                                  call delete(tempfile)
                                  return ''
                                endif
                              endif
                              return s:Resolve(tempfile)

FUNCTION  go#auto#asmfmt_autosave()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !(go#config#AsmfmtAutosave() && isdirectory(expand('%:p:h')) && expand('<afile>:p') == expand('%:p'))
                                return
                              endif
                            
                              " Go asm formatting on save
                              call go#asmfmt#Format()

FUNCTION  sy#util#chdir()
Called 2 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000019   let chdir = haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1, 0)) ? 'tcd' : 'cd'
    2              0.000013   return [getcwd(), chdir]

FUNCTION  <SNR>102_process_options_file()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if empty(g:gutentags_cache_dir)
                                    " If we're not using a cache directory to store tag files, we can
                                    " use the options file straight away.
                                    return a:path
                                endif
                            
                                " See if we need to process the options file.
                                let l:do_process = 0
                                let l:proj_dir = gutentags#stripslash(a:proj_dir)
                                let l:out_path = gutentags#get_cachefile(l:proj_dir, 'options')
                                if !filereadable(l:out_path)
                                    call gutentags#trace("Processing options file '".a:path."' because "."it hasn't been processed yet.")
                                    let l:do_process = 1
                                elseif getftime(a:path) > getftime(l:out_path)
                                    call gutentags#trace("Processing options file '".a:path."' because "."it has changed.")
                                    let l:do_process = 1
                                endif
                                if l:do_process == 0
                                    " Nothing's changed, return the existing processed version of the
                                    " options file.
                                    return l:out_path
                                endif
                            
                                " We have to process the options file. Right now this only means capturing
                                " all the 'exclude' rules, and rewrite them to make them absolute.
                                "
                                " This is because since `ctags` is run with absolute paths (because we
                                " want the tag file to be in a cache directory), it will do its path
                                " matching with absolute paths too, so the exclude rules need to be
                                " absolute.
                                let l:lines = readfile(a:path)
                                let l:outlines = []
                                for line in l:lines
                                    let l:exarg_idx = matchend(line, '\v^\-\-exclude=')
                                    if l:exarg_idx < 0
                                        call add(l:outlines, line)
                                        continue
                                    endif
                            
                                    " Don't convert things that don't look like paths.
                                    let l:exarg = strpart(line, l:exarg_idx + 1)
                                    let l:do_convert = 1
                                    if l:exarg[0] == '@'   " Manifest file path
                                        let l:do_convert = 0
                                    endif
                                    if stridx(l:exarg, '/') < 0 && stridx(l:exarg, '\\') < 0   " Filename
                                        let l:do_convert = 0
                                    endif
                                    if l:do_convert == 0
                                        call add(l:outlines, line)
                                        continue
                                    endif
                            
                                    let l:fullp = l:proj_dir . gutentags#normalizepath('/'.l:exarg)
                                    let l:ol = '--exclude='.l:fullp
                                    call add(l:outlines, l:ol)
                                endfor
                            
                                call writefile(l:outlines, l:out_path)
                                return l:out_path

FUNCTION  <SNR>34_expand_braces()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let new_dict = {}
                              for [key,val] in items(a:dict)
                                if key =~ '{.*}'
                                  let redo = 1
                                  let [all,kbefore,kmiddle,kafter;crap] = matchlist(key,'\(.\{-\}\){\(.\{-\}\)}\(.*\)')
                                  let [all,vbefore,vmiddle,vafter;crap] = matchlist(val,'\(.\{-\}\){\(.\{-\}\)}\(.*\)') + ["","","",""]
                                  if all == ""
                                    let [vbefore,vmiddle,vafter] = [val, ",", ""]
                                  endif
                                  let targets      = split(kmiddle,',',1)
                                  let replacements = split(vmiddle,',',1)
                                  if replacements == [""]
                                    let replacements = targets
                                  endif
                                  for i in range(0,len(targets)-1)
                                    let new_dict[kbefore.targets[i].kafter] = vbefore.replacements[i%len(replacements)].vafter
                                  endfor
                                else
                                  let new_dict[key] = val
                                endif
                              endfor
                              if exists("redo")
                                return s:expand_braces(new_dict)
                              else
                                return new_dict
                              endif

FUNCTION  <SNR>103_command()
Called 9 times
Total time:   0.000387
 Self time:   0.000387

count  total (s)   self (s)
    9              0.000029   let def = a:definition
    9              0.000047   if !has('patch-7.4.542')
                                let def = substitute(def, '-addr=\S\+ ', '', '')
    9              0.000009   endif
    9              0.000033   if !has('patch-8.1.560')
    9              0.000079     let def = substitute(def, '-addr=other ', '', '')
    9              0.000010   endif
    9              0.000020   if a:0
    9              0.000075     call add(s:commands, def . ' execute s:Command(' . string(a:1) . ", <line1>, <count>, +'<range>', <bang>0, '<mods>', <q-args>, [<f-args>])")
                              else
                                call add(s:commands, def)
    9              0.000005   endif

FUNCTION  <SNR>34_find_command()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let opts = s:normalize_options(a:flags)
                              let dict = s:create_dictionary(a:word,"",opts)
                              " This is tricky.  If we use :/pattern, the search drops us at the
                              " beginning of the line, and we can't use position flags (e.g., /foo/e).
                              " If we use :norm /pattern, we leave ourselves vulnerable to "press enter"
                              " prompts (even with :silent).
                              let cmd = (a:cmd =~ '[?!]' ? '?' : '/')
                              let @/ = s:pattern(dict,opts.boundaries)
                              if opts.flags == "" || !search(@/,'n')
                                return "norm! ".cmd."\<CR>"
                              elseif opts.flags =~ ';[/?]\@!'
                                call s:throw("E386: Expected '?' or '/' after ';'")
                              else
                                return "exe 'norm! ".cmd.cmd.opts.flags."\<CR>'|call histdel('search',-1)"
                                return ""
                              endif

FUNCTION  GetProjectRoot()
Called 1 time
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000004     if a:0 == 0
    1              0.000023         let l:dir_curr = getcwd()
                                else
                                    let l:dir_curr = a:1
    1              0.000001     endif
                            
    1              0.000003     let l:dir_last = ""
                            
    1              0.000006     while l:dir_last != l:dir_curr
    1              0.000006         for l:vcs_dir in ['.git', '.svn', '.darcs', '.hg']
    1              0.000013             if isdirectory(l:dir_curr . '/' . l:vcs_dir) || filereadable(l:dir_curr . '/.git')
    1              0.000003                 return l:dir_curr
                                        endif
                                    endfor
                            
                                    let l:dir_last = l:dir_curr
                                    let l:dir_curr = fnamemodify(l:dir_curr, ':h')
                                endwhile
                            
                                " no vcs dir was found, assuming this is not a version controlled
                                " directory
                                return ""

FUNCTION  go#config#BuildTags()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000008   return get(g:, 'go_build_tags', '')

FUNCTION  <SNR>96_encode()
Called 4 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    4              0.000103     return substitute(   a:value,   a:unreserved,   '\="%".printf(''%02X'', char2nr(submatch(0)))',   'g')

FUNCTION  go#util#PathListSep()
Called 6 times
Total time:   0.000088
 Self time:   0.000050

count  total (s)   self (s)
    6   0.000066   0.000028   if go#util#IsWin()
                                return ";"
    6              0.000006   endif
    6              0.000006   return ":"

FUNCTION  sy#toggle()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('b:sy') || !b:sy.active
                                call sy#enable()
                              else
                                call sy#disable()
                              endif

FUNCTION  gutentags#shellslash()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if exists('+shellslash') && !&shellslash
                                    return substitute(a:path, '\v\\', '/', 'g')
                                else
                                    return a:path
                                endif

FUNCTION  <SNR>103_AskPassArgs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if (len($DISPLAY) || len($TERM_PROGRAM) || has('gui_running')) && fugitive#GitVersion(1, 8) && empty($GIT_ASKPASS) && empty($SSH_ASKPASS) && empty(fugitive#Config('core.askPass', a:dir))
                                if s:executable(s:ExecPath() . '/git-gui--askpass')
                                  return ['-c', 'core.askPass=' . s:ExecPath() . '/git-gui--askpass']
                                elseif s:executable('ssh-askpass')
                                  return ['-c', 'core.askPass=ssh-askpass']
                                endif
                              endif
                              return []

FUNCTION  <SNR>103_BlameFileType()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              setlocal nomodeline
                              setlocal foldmethod=manual
                              if len(s:Dir())
                                let &l:keywordprg = s:Keywordprg()
                              endif
                              let b:undo_ftplugin = 'setl keywordprg= foldmethod<'
                              if exists('+concealcursor')
                                setlocal concealcursor=nc conceallevel=2
                                let b:undo_ftplugin .= ' concealcursor< conceallevel<'
                              endif
                              if &modifiable
                                return ''
                              endif
                              call s:Map('n', '<F1>', ':help fugitive-:Gblame<CR>', '<silent>')
                              call s:Map('n', 'g?',   ':help fugitive-:Gblame<CR>', '<silent>')
                              if mapcheck('q', 'n') =~# '^$\|bdelete'
                                call s:Map('n', 'q',  ':exe <SID>BlameQuit()<Bar>echohl WarningMsg<Bar>echo ":Gblame q is deprecated in favor of gq"<Bar>echohl NONE<CR>', '<silent>')
                              endif
                              call s:Map('n', 'gq',   ':exe <SID>BlameQuit()<CR>', '<silent>')
                              call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', '<CR>', ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', '-',    ':<C-U>exe <SID>BlameJump("")<CR>', '<silent>')
                              call s:Map('n', 'P',    ':<C-U>exe <SID>BlameJump("^".v:count1)<CR>', '<silent>')
                              call s:Map('n', '~',    ':<C-U>exe <SID>BlameJump("~".v:count1)<CR>', '<silent>')
                              call s:Map('n', 'i',    ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', 'o',    ':<C-U>exe <SID>BlameCommit("split")<CR>', '<silent>')
                              call s:Map('n', 'O',    ':<C-U>exe <SID>BlameCommit("tabedit")<CR>', '<silent>')
                              call s:Map('n', 'p',    ':<C-U>exe <SID>BlameCommit("pedit")<CR>', '<silent>')

FUNCTION  go#config#MetalinterDeadline()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " gometalinter has a default deadline of 5 seconds only when asynchronous
                              " jobs are not supported.
                            
                              let deadline = '5s'
                              if go#util#has_job() && has('lambda')
                                let deadline = ''
                              endif
                            
                              return get(g:, 'go_metalinter_deadline', deadline)

FUNCTION  fugitive#MoveCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:Move(a:bang, 0, a:arg)

FUNCTION  <SNR>103_function()
Called 16 times
Total time:   0.000389
 Self time:   0.000389

count  total (s)   self (s)
   16              0.000373   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))

FUNCTION  <SNR>103_DoUnstageStaged()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:DoToggleStaged(a:record)

FUNCTION  <SNR>103_StageIgnore()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let paths = []
                              for info in s:Selection(a:lnum1, a:lnum2)
                                call extend(paths, info.relative)
                              endfor
                              call map(paths, '"/" . v:val')
                              exe 'Gsplit' (a:count ? '.gitignore' : '.git/info/exclude')
                              let last = line('$')
                              if last == 1 && empty(getline(1))
                                call setline(last, paths)
                              else
                                call append(last, paths)
                                exe last + 1
                              endif
                              return ''

FUNCTION  <SNR>103_DirCheck()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !empty(a:0 ? s:Dir(a:1) : s:Dir())
                                return ''
                              elseif empty(bufname(''))
                                return 'return ' . string('echoerr "fugitive: blank buffer unsupported (edit a file from a repository)"')
                              else
                                return 'return ' . string('echoerr "fugitive: file does not belong to a Git repository"')
                              endif

FUNCTION  gutentags#inprogress()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " Does this buffer have gutentags enabled?
                                if !exists('b:gutentags_files')
                                    return []
                                endif
                            
                                " Find any module that has a job in progress for any of this buffer's
                                " tags files.
                                let l:modules_in_progress = []
                                for [module, tags_file] in items(b:gutentags_files)
                                    let l:jobidx = gutentags#find_job_index_by_tags_file(module, tags_file)
                                    if l:jobidx >= 0
                                        call add(l:modules_in_progress, module)
                                    endif
                                endfor
                                return l:modules_in_progress

FUNCTION  <SNR>44_LinuxHighlighting()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                highlight default link LinuxError ErrorMsg
                            
                                syn match LinuxError / \+\ze\t/     " spaces before tab
                                syn match LinuxError /\%>80v[^()\{\}\[\]<>]\+/ " virtual column 81 and more
                            
                                " Highlight trailing whitespace, unless we're in insert mode and the
                                " cursor's placed right after the whitespace. This prevents us from having
                                " to put up with whitespace being highlighted in the middle of typing
                                " something
                                autocmd InsertEnter * match LinuxError /\s\+\%#\@<!$/
                                autocmd InsertLeave * match LinuxError /\s\+$/

FUNCTION  go#guru#Callees()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = { 'mode': 'callees', 'format': 'plain', 'selected': a:selected, 'needs_scope': 1, }
                            
                              call s:run_guru(args)

FUNCTION  TestFiletypeFuncs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output

FUNCTION  go#util#System()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return call('s:system', [a:str] + a:000)

FUNCTION  <SNR>85_GoUltiSnips()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if get(g:, 'did_plugin_ultisnips') isnot 1
                                return
                              endif
                            
                              if !exists("g:UltiSnipsSnippetDirectories")
                                let g:UltiSnipsSnippetDirectories = ["gosnippets/UltiSnips"]
                              else
                                let g:UltiSnipsSnippetDirectories += ["gosnippets/UltiSnips"]
                              endif

FUNCTION  gutentags#ctags#on_job_exit()
Called 1 time
Total time:   0.000212
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000196   0.000012     call gutentags#remove_job_by_data('ctags', a:job)
                            
    1              0.000004     if a:exit_val != 0
                                    call gutentags#warning("ctags job failed, returned: ".string(a:exit_val))
    1              0.000001     endif

FUNCTION  go#util#ShowInfo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if empty(a:info)
                                return
                              endif
                            
                              echo "vim-go: " | echohl Function | echon a:info | echohl None

FUNCTION  go#util#snippetcase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:snippet_case = go#config#AddtagsTransform()
                              if l:snippet_case == "snakecase"
                                return go#util#snakecase(a:word)
                              elseif l:snippet_case == "camelcase"
                                return go#util#camelcase(a:word)
                              else
                                return a:word " do nothing
                              endif

FUNCTION  <SNR>103_PathInfo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(dir) || !get(g:, 'fugitive_file_api', 1)
                                return [-1, '000000', '', '', -1]
                              endif
                              let path = substitute(file[1:-1], '/*$', '', '')
                              let [tree, ftime] = s:TreeInfo(dir, commit)
                              let entry = empty(path) ? [ftime, '040000', 'tree', '', -1] : get(tree, path, [])
                              if empty(entry) || file =~# '/$' && entry[2] !=# 'tree'
                                return [-1, '000000', '', '', -1]
                              else
                                return entry
                              endif

FUNCTION  fugitive#BufReadCmd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              try
                                let [dir, rev] = s:DirRev(amatch)
                                if empty(dir)
                                  return 'echo "Invalid Fugitive URL"'
                                endif
                                if rev =~# '^:\d$'
                                  let b:fugitive_type = 'stage'
                                else
                                  let [b:fugitive_type, exec_error] = s:ChompError([dir, 'cat-file', '-t', rev])
                                  if exec_error && rev =~# '^:0'
                                    let sha = s:ChompDefault('', dir, 'write-tree', '--prefix=' . rev[3:-1])
                                    let exec_error = empty(sha)
                                    let b:fugitive_type = exec_error ? '' : 'tree'
                                  endif
                                  if exec_error
                                    let error = b:fugitive_type
                                    unlet b:fugitive_type
                                    setlocal noswapfile
                                    if empty(&bufhidden)
                                      setlocal bufhidden=delete
                                    endif
                                    if rev =~# '^:\d:'
                                      let &l:readonly = !filewritable(fugitive#Find('.git/index', dir))
                                      return 'silent doautocmd BufNewFile'
                                    else
                                      setlocal readonly nomodifiable
                                      return 'silent doautocmd BufNewFile|echo ' . string(error)
                                    endif
                                  elseif b:fugitive_type !~# '^\%(tag\|commit\|tree\|blob\)$'
                                    return "echoerr ".string("fugitive: unrecognized git type '".b:fugitive_type."'")
                                  endif
                                  if !exists('b:fugitive_display_format') && b:fugitive_type != 'blob'
                                    let b:fugitive_display_format = +getbufvar('#','fugitive_display_format')
                                  endif
                                endif
                            
                                if b:fugitive_type !=# 'blob'
                                  setlocal nomodeline
                                endif
                            
                                setlocal noreadonly modifiable
                                let pos = getpos('.')
                                silent keepjumps %delete_
                                setlocal endofline
                            
                                try
                                  silent doautocmd BufReadPre
                                  if b:fugitive_type ==# 'tree'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'ls-tree', exists('sha') ? sha : rev])
                                    else
                                      if !exists('sha')
                                        let sha = s:TreeChomp(dir, 'rev-parse', '--verify', rev, '--')
                                      endif
                                      call s:ReplaceCmd([dir, 'show', '--no-color', sha])
                                    endif
                                  elseif b:fugitive_type ==# 'tag'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                    else
                                      call s:ReplaceCmd([dir, 'cat-file', '-p', rev])
                                    endif
                                  elseif b:fugitive_type ==# 'commit'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                    else
                                      call s:ReplaceCmd([dir, 'show', '--no-color', '--pretty=format:tree%x20%T%nparent%x20%P%nauthor%x20%an%x20<%ae>%x20%ad%ncommitter%x20%cn%x20<%ce>%x20%cd%nencoding%x20%e%n%n%s%n%n%b', rev])
                                      keepjumps call search('^parent ')
                                      if getline('.') ==# 'parent '
                                        silent keepjumps delete_
                                      else
                                        silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps s/\m\C\%(^parent\)\@<! /\rparent /e' . (&gdefault ? '' : 'g')
                                      endif
                                      keepjumps let lnum = search('^encoding \%(<unknown>\)\=$','W',line('.')+3)
                                      if lnum
                                        silent keepjumps delete_
                                      end
                                      silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps 1,/^diff --git\|\%$/s/\r$//e'
                                      keepjumps 1
                                    endif
                                  elseif b:fugitive_type ==# 'stage'
                                    call s:ReplaceCmd([dir, 'ls-files', '--stage'])
                                  elseif b:fugitive_type ==# 'blob'
                                    call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                  endif
                                finally
                                  keepjumps call setpos('.',pos)
                                  setlocal nomodified noswapfile
                                  let modifiable = rev =~# '^:.:' && b:fugitive_type !=# 'tree'
                                  let &l:readonly = !modifiable || !filewritable(fugitive#Find('.git/index', dir))
                                  if empty(&bufhidden)
                                    setlocal bufhidden=delete
                                  endif
                                  let &l:modifiable = modifiable
                                  if b:fugitive_type !=# 'blob'
                                    setlocal filetype=git foldmethod=syntax
                                    call s:Map('n', 'a', ":<C-U>let b:fugitive_display_format += v:count1<Bar>exe fugitive#BufReadCmd(@%)<CR>", '<silent>')
                                    call s:Map('n', 'i', ":<C-U>let b:fugitive_display_format -= v:count1<Bar>exe fugitive#BufReadCmd(@%)<CR>", '<silent>')
                                  endif
                                  call fugitive#MapJumps()
                                endtry
                            
                                setlocal modifiable
                                return 'silent doautocmd' . s:nomodeline . ' BufReadPost' . (modifiable ? '' : '|setl nomodifiable')
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry

FUNCTION  sy#repo#get_diff()
Called 2 times
Total time:   0.001870
 Self time:   0.001472

count  total (s)   self (s)
    2   0.000047   0.000014   call sy#verbose('sy#repo#get_diff()', a:vcs)
    2              0.000010   let job_id = get(b:, 'sy_job_id_'.a:vcs)
    2   0.000314   0.000018   let [cmd, options] = s:initialize_job(a:vcs)
    2              0.000006   let options.func = a:func
                            
                              " Neovim
    2              0.000006   if has('nvim')
                                if job_id
                                  silent! call jobstop(job_id)
                                endif
                            
                                let [cwd, chdir] = sy#util#chdir()
                                call sy#verbose(['CMD: '. string(cmd), 'CMD DIR:  '. b:sy.info.dir, 'ORIG DIR: '. cwd], a:vcs)
                            
                                try
                                  execute chdir fnameescape(b:sy.info.dir)
                                catch
                                  echohl ErrorMsg
                                  echomsg 'signify: Changing directory failed: '. b:sy.info.dir
                                  echohl NONE
                                  return
                                endtry
                                let b:sy_job_id_{a:vcs} = jobstart(cmd, extend(options, { 'on_stdout': function('s:callback_nvim_stdout'), 'on_exit':   function('s:callback_nvim_exit'), }))
                                execute chdir fnameescape(cwd)
                            
                              " Newer Vim
    2              0.000010   elseif has('patch-7.4.1967')
    2              0.000007     if type(job_id) != type(0)
                                  silent! call job_stop(job_id)
    2              0.000002     endif
                            
    2   0.000050   0.000015     let [cwd, chdir] = sy#util#chdir()
    2   0.000071   0.000037     call sy#verbose(['CMD: '. string(cmd), 'CMD DIR:  '. b:sy.info.dir, 'ORIG DIR: '. cwd], a:vcs)
                            
    2              0.000002     try
    2              0.000063       execute chdir fnameescape(b:sy.info.dir)
                                catch
                                  echohl ErrorMsg
                                  echomsg 'signify: Changing directory failed: '. b:sy.info.dir
                                  echohl NONE
                                  return
    2              0.000002     endtry
    2              0.000037     let opts = { 'in_io':    'null', 'out_cb':   function('s:callback_vim_stdout', options), 'close_cb': function('s:callback_vim_close', options), }
    2              0.000951     let b:sy_job_id_{a:vcs} = job_start(cmd, opts)
    2              0.000139     execute chdir fnameescape(cwd)
                            
                              " Older Vim
                              else
                                let options.stdoutbuf = split(s:run(a:vcs), '\n')
                                call s:handle_diff(options, v:shell_error)
    2              0.000002   endif

FUNCTION  <SNR>57_LP_PatPush()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            "  call Dfunc("LP_PatPush(pat<".a:pat.">)")
                              let s:npatstack              = s:npatstack + 1
                              let s:patstack_{s:npatstack} = a:pat
                            "  call s:StackLook("patpush") "Decho
                            "  call Dret("LP_PatPush : npatstack=".s:npatstack)

FUNCTION  <SNR>100_check_diff_svn()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  go#lsp#message#Completion()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return { 'notification': 0, 'method': 'textDocument/completion', 'params': {   'textDocument': {       'uri': go#path#ToURI(a:file)   },   'position': s:position(a:line, a:col), } }

FUNCTION  <SNR>101_update_tags()
Called 2 times
Total time:   0.006537
 Self time:   0.000421

count  total (s)   self (s)
                                " Figure out where to save.
    2              0.000018     let l:buf_gutentags_files = getbufvar(a:bufno, 'gutentags_files')
    2              0.000010     let l:tags_file = l:buf_gutentags_files[a:module]
    2              0.000009     let l:proj_dir = getbufvar(a:bufno, 'gutentags_root')
                            
                                " Check that there's not already an update in progress.
    2   0.000070   0.000022     let l:in_progress_idx = gutentags#find_job_index_by_tags_file(a:module, l:tags_file)
    2              0.000004     if l:in_progress_idx >= 0
                                    if a:queue_mode == 2
                                        let l:needs_queuing = 1
                                        for qu_info in s:update_queue[a:module]
                                            if qu_info[0] == l:tags_file
                                                let l:needs_queuing = 0
                                                break
                                            endif
                                        endfor
                                        if l:needs_queuing
                                            call add(s:update_queue[a:module], [l:tags_file, a:bufno, a:write_mode])
                                        endif
                                        call gutentags#trace("Tag file '" . l:tags_file . "' is already being updated. Queuing it up...")
                                    elseif a:queue_mode == 1
                                        call gutentags#trace("Tag file '" . l:tags_file ."' is already being updated. Skipping...")
                                    elseif a:queue_mode == 0
                                        echom "gutentags: The tags file is already being updated, " ."please try again later."
                                    else
                                        call gutentags#throw("Unknown queue mode: " . a:queue_mode)
                                    endif
                            
                                    " Don't update the tags right now.
                                    return
    2              0.000002     endif
                            
                                " Switch to the project root to make the command line smaller, and make
                                " it possible to get the relative path of the filename to parse if we're
                                " doing an incremental update.
    2              0.000030     let l:prev_cwd = getcwd()
    2   0.000114   0.000032     call gutentags#chdir(fnameescape(l:proj_dir))
    2              0.000003     try
    2   0.005991   0.000130         call call("gutentags#".a:module."#generate",[l:proj_dir, l:tags_file, {   'write_mode': a:write_mode, }])
                                catch /^gutentags\:/
                                    echom "Error while generating ".a:module." file:"
                                    echom v:exception
    2              0.000003     finally
                                    " Restore the current directory...
    2   0.000170   0.000045         call gutentags#chdir(fnameescape(l:prev_cwd))
    2              0.000004     endtry

FUNCTION  gutentags#get_project_root()
Called 1 time
Total time:   0.000789
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000003     if g:gutentags_project_root_finder != ''
                                    return call(g:gutentags_project_root_finder, [a:path])
    1              0.000001     endif
    1   0.000782   0.000007     return gutentags#default_get_project_root(a:path)

FUNCTION  gutentags#stripslash()
Called 4 times
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
    4              0.000125     return fnamemodify(a:path, ':s?[/\\]$??')

FUNCTION  go#util#goos()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(s:exec(['go', 'env', 'GOOS'])[0], '\n', '', 'g')

FUNCTION  <SNR>103_MergeSubcommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:MergeRebase('merge', a:bang, a:mods, a:args)

FUNCTION  go#config#GocodeProposeBuiltins()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_gocode_propose_builtins', 1)

FUNCTION  gutentags#get_plat_file()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006     return g:gutentags_plat_dir . a:filename . g:gutentags_script_ext

FUNCTION  <SNR>7_Match_debug()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let b:match_debug = 1	" Save debugging information.
                              " pat = all of b:match_words with backrefs parsed
                              amenu &Matchit.&pat	:echo b:match_pat<CR>
                              " match = bit of text that is recognized as a match
                              amenu &Matchit.&match	:echo b:match_match<CR>
                              " curcol = cursor column of the start of the matching text
                              amenu &Matchit.&curcol	:echo b:match_col<CR>
                              " wholeBR = matching group, original version
                              amenu &Matchit.wh&oleBR	:echo b:match_wholeBR<CR>
                              " iniBR = 'if' piece, original version
                              amenu &Matchit.ini&BR	:echo b:match_iniBR<CR>
                              " ini = 'if' piece, with all backrefs resolved from match
                              amenu &Matchit.&ini	:echo b:match_ini<CR>
                              " tail = 'else\|endif' piece, with all backrefs resolved from match
                              amenu &Matchit.&tail	:echo b:match_tail<CR>
                              " fin = 'endif' piece, with all backrefs resolved from match
                              amenu &Matchit.&word	:echo b:match_word<CR>
                              " '\'.d in ini refers to the same thing as '\'.table[d] in word.
                              amenu &Matchit.t&able	:echo '0:' . b:match_table . ':9'<CR>

FUNCTION  <SNR>109_show_errors()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:listtype = go#list#Type("GoFmt")
                              if !empty(a:errors)
                                call go#list#Populate(l:listtype, a:errors, 'Format')
                                echohl Error | echomsg "Gofmt returned error" | echohl None
                              endif
                            
                              " this closes the window if there are no errors or it opens
                              " it if there is any
                              call go#list#Window(l:listtype, len(a:errors))

FUNCTION  <SNR>94_winjobarg()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if empty(a:val)
                                return '""'
                              endif
                              return a:val

FUNCTION  go#lsp#message#DidClose()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return { 'notification': 1, 'method': 'textDocument/didClose', 'params': {     'textDocument': {         'uri': go#path#ToURI(a:file),     } } }

FUNCTION  go#config#HighlightGenerateTags()
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000016   return get(g:, 'go_highlight_generate_tags', 0)

FUNCTION  <SNR>100_check_diff_bzr()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return (a:exitval =~ '[012]') ? [1, a:diff] : [0, []]

FUNCTION  go#config#ModFmtAutosave()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            	return get(g:, "go_mod_fmt_autosave", 1)

FUNCTION  <SNR>34_pattern()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:boundaries == 2
                                let a = '<'
                                let b = '>'
                              elseif a:boundaries
                                let a = '%(<|_@<=|[[:lower:]]@<=[[:upper:]]@=)'
                                let b =  '%(>|_@=|[[:lower:]]@<=[[:upper:]]@=)'
                              else
                                let a = ''
                                let b = ''
                              endif
                              return '\v\C'.a.'%('.join(map(sort(keys(a:dict),function('s:sort')),'s:subesc(v:val)'),'|').')'.b

FUNCTION  go#guru#DescribeInfo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " json_encode() and friends are introduced with this patch (7.4.1304)
                              " vim: https://groups.google.com/d/msg/vim_dev/vLupTNhQhZ8/cDGIk0JEDgAJ
                              " nvim: https://github.com/neovim/neovim/pull/4131
                              if !exists("*json_decode")
                                call go#util#EchoError("requires 'json_decode'. Update your Vim/Neovim version.")
                                return
                              endif
                            
                              let args = { 'mode': 'describe', 'format': 'json', 'selected': -1, 'needs_scope': 0, 'custom_parse': function('s:info'), 'disable_progress': a:showstatus == 0, }
                            
                              call s:run_guru(args)

FUNCTION  TCommentOpFunc_Commentb()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_Commentb')
                            call tcomment#SetOption("mode_extra", "B")
                            return call('tcomment#operator#Line', a:000)

FUNCTION  TCommentOpFunc_Commentc()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_Commentc')
                            
                            return call('tcomment#operator#LineAnyway', a:000)

FUNCTION  <SNR>103_Keywordprg()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = ' --git-dir='.escape(s:Dir(),"\\\"' ")
                              if has('gui_running') && !has('win32')
                                return s:UserCommand() . ' --no-pager' . args . ' log -1'
                              else
                                return s:UserCommand() . args . ' show'
                              endif

FUNCTION  fugitive#writefile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let url = type(a:url) ==# type('') ? a:url : ''
                              let [dir, commit, file] = s:DirCommitFile(url)
                              let entry = s:PathInfo(url)
                              if commit =~# '^\d$' && entry[2] !=# 'tree'
                                let temp = tempname()
                                if a:0 && a:1 =~# 'a' && entry[2] ==# 'blob'
                                  call writefile(fugitive#readfile(url, 'b'), temp, 'b')
                                endif
                                call call('writefile', [a:lines, temp] + a:000)
                                let [hash, exec_error] = s:ChompError([dir, 'hash-object', '-w', temp])
                                let mode = len(entry[1]) ? entry[1] : '100644'
                                if !exec_error && hash =~# '^\x\{40,\}$'
                                  let exec_error = s:SystemError([dir, 'update-index', '--index-info'], mode . ' ' . hash . ' ' . commit . "\t" . file[1:-1])[1]
                                  if !exec_error
                                    return 0
                                  endif
                                endif
                              endif
                              return call('writefile', [a:lines, a:url] + a:000)

FUNCTION  go#statusline#Update()
Called 2 times
Total time:   0.000297
 Self time:   0.000111

count  total (s)   self (s)
    2              0.000013   let a:status.created_at = reltime()
    2              0.000012   let s:statuses[a:status_dir] = a:status
                            
                              " force to update the statusline, otherwise the user needs to move the
                              " cursor
    2              0.000032   exe 'let &ro = &ro'
                            
                              " before we stop the timer, check if we have any previous jobs to be cleaned
                              " up. Otherwise every job will reset the timer when this function is called
                              " and thus old jobs will never be cleaned
    2   0.000211   0.000025   call s:clear()
                            
                              " also reset the timer, so the user has time to see it in the statusline.
                              " Setting the timer_id to 0 will cause a new timer to be created the next
                              " time the go#statusline#Show() is called.
    2              0.000010   call timer_stop(s:timer_id)
    2              0.000006   let s:timer_id = 0

FUNCTION  go#lsp#message#Definition()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return { 'notification': 0, 'method': 'textDocument/definition', 'params': {   'textDocument': {       'uri': go#path#ToURI(a:file)   },   'position': s:position(a:line, a:col) } }

FUNCTION  <SNR>103_repo_git_command()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let git = s:UserCommand() . ' --git-dir='.s:shellesc(self.git_dir)
                              return git.join(map(copy(a:000),'" ".s:shellesc(v:val)'),'')

FUNCTION  <SNR>103_NextFile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for i in range(a:count)
                                exe s:StageInline('hide')
                                if !search(s:file_pattern, 'W')
                                  break
                                endif
                              endfor
                              exe s:StageInline('hide')
                              return '.'

FUNCTION  gutentags#get_res_file()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000008     return g:gutentags_res_dir . a:filename

FUNCTION  go#config#HighlightVariableDeclarations()
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000009   return get(g:, 'go_highlight_variable_declarations', 0)

FUNCTION  <SNR>103_ReloadStatus()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:ExpireStatus(-1)
                              if get(b:, 'fugitive_type', '') !=# 'index'
                                return ''
                              endif
                              let original_lnum = a:0 ? a:1 : line('.')
                              let info = s:StageInfo(original_lnum)
                              call fugitive#BufReadStatus()
                              exe s:StageSeek(info, original_lnum)
                              normal! 0
                              return ''

FUNCTION  <SNR>58_Highlight_Matching_Pair()
Called 77 times
Total time:   0.059481
 Self time:   0.059481

count  total (s)   self (s)
                              " Remove any previous match.
   77              0.000736   if exists('w:paren_hl_on') && w:paren_hl_on
    2              0.000014     silent! call matchdelete(3)
    2              0.000008     let w:paren_hl_on = 0
   77              0.000122   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   77              0.000544   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   77              0.000057   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   77              0.000382   let c_lnum = line('.')
   77              0.000293   let c_col = col('.')
   77              0.000179   let before = 0
                            
   77              0.000358   let text = getline(c_lnum)
   77              0.002576   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   77              0.000288   if empty(matches)
                                let [c_before, c] = ['', '']
   77              0.000109   else
   77              0.000537     let [c_before, c] = matches[1:2]
   77              0.000092   endif
   77              0.001776   let plist = split(&matchpairs, '.\zs[:,]')
   77              0.000404   let i = index(plist, c)
   77              0.000143   if i < 0
                                " not found, in Insert mode try character before the cursor
   74              0.000406     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   66              0.000252       let before = strlen(c_before)
   66              0.000117       let c = c_before
   66              0.000185       let i = index(plist, c)
   74              0.000071     endif
   74              0.000088     if i < 0
                                  " not found, nothing to do
   74              0.000144       return
                                endif
    3              0.000003   endif
                            
                              " Figure out the arguments for searchpairpos().
    3              0.000005   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
    3              0.000002   else
    3              0.000006     let s_flags = 'nbW'
    3              0.000004     let c2 = c
    3              0.000010     let c = plist[i - 1]
    3              0.000003   endif
    3              0.000005   if c == '['
                                let c = '\['
                                let c2 = '\]'
    3              0.000002   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    3              0.000007   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    3              0.000003   endif
                            
    3              0.000027   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    3              0.000003   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
    3              0.000018     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    3              0.000005     try
    3              0.039203       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    3              0.000004     endtry
    3              0.000002   endif
                            
                              " Limit the search to lines visible in the window.
    3              0.000028   let stoplinebottom = line('w$')
    3              0.000011   let stoplinetop = line('w0')
    3              0.000007   if i % 2 == 0
                                let stopline = stoplinebottom
    3              0.000003   else
    3              0.000009     let stopline = stoplinetop
    3              0.000002   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    3              0.000013   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    3              0.000003   else
    3              0.000017     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    3              0.000003   endif
    3              0.000003   try
    3              0.007696     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    3              0.000006   endtry
                            
    3              0.000007   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    3              0.000003   endif
                            
                              " If a match is found setup match highlighting.
    3              0.000009   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    3              0.000010     if exists('*matchaddpos')
    3              0.000061       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    3              0.000003     endif
    3              0.000010     let w:paren_hl_on = 1
    3              0.000003   endif

FUNCTION  FugitiveHead()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
                              if empty(dir)
                                return ''
                              endif
                              return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  <SNR>41_CheckBinaries()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !executable('go')
                                echohl Error | echomsg "vim-go: go executable not found." | echohl None
                                return -1
                              endif
                            
                              if !executable('git')
                                echohl Error | echomsg "vim-go: git executable not found." | echohl None
                                return -1
                              endif

FUNCTION  <SNR>103_NextHunk()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &filetype ==# 'fugitive' && getline('.') =~# s:file_pattern
                                exe s:StageInline('show')
                              endif
                              for i in range(a:count)
                                if &filetype ==# 'fugitive'
                                  call search(s:file_pattern . '\|^@', 'W')
                                  if getline('.') =~# s:file_pattern
                                    exe s:StageInline('show')
                                    if getline(line('.') + 1) =~# '^@'
                                      +
                                    endif
                                  endif
                                else
                                  call search('^@@', 'W')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'

FUNCTION  <SNR>103_PullComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:CompleteSub('pull', a:A, a:L, a:P, function('s:CompleteRemote'))

FUNCTION  <SNR>41_register()
Called 2 times
Total time:   0.036711
 Self time:   0.000319

count  total (s)   self (s)
    2              0.000015   if !(&modifiable && expand('<amatch>') ==# 'go')
                                return
    2              0.000001   endif
                            
    2              0.000018   let l:RestoreGopath = function('s:noop')
    2   0.000029   0.000015   if go#config#AutodetectGopath()
                                let l:RestoreGopath = go#util#SetEnv('GOPATH', go#path#Detect())
    2              0.000002   endif
    2   0.036608   0.000230   call go#lsp#DidOpen(expand('<afile>:p'))
    2              0.000020   call call(l:RestoreGopath, [])

FUNCTION  go#util#OpenBrowser()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let l:cmd = go#config#PlayBrowserCommand()
                                if len(l:cmd) == 0
                                    redraw
                                    echohl WarningMsg
                                    echo "It seems that you don't have general web browser. Open URL below."
                                    echohl None
                                    echo a:url
                                    return
                                endif
                            
                                " if setting starts with a !.
                                if l:cmd =~ '^!'
                                    let l:cmd = substitute(l:cmd, '%URL%', '\=escape(shellescape(a:url), "#")', 'g')
                                    silent! exec l:cmd
                                elseif cmd =~ '^:[A-Z]'
                                    let l:cmd = substitute(l:cmd, '%URL%', '\=escape(a:url,"#")', 'g')
                                    exec l:cmd
                                else
                                    let l:cmd = substitute(l:cmd, '%URL%', '\=shellescape(a:url)', 'g')
                                    call go#util#System(l:cmd)
                                endif

FUNCTION  sy#repo#preview_hunk()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('b:sy') && !empty(b:sy.updated_by)
                                call sy#repo#get_diff(b:sy.updated_by, function('s:preview_hunk'))
                              endif

FUNCTION  <SNR>13_gomod()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for l:i in range(1, line('$'))
                                let l:l = getline(l:i)
                                if l:l ==# '' || l:l[:1] ==# '//'
                                  continue
                                endif
                            
                                if l:l =~# '^module .\+'
                                  setfiletype gomod
                                endif
                            
                                break
                              endfor

FUNCTION  <SNR>103_DoToggleUnstagedHeading()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:TreeChomp('add', '-u')
                              return 1

FUNCTION  <SNR>100_check_diff_rcs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return (a:exitval == 2) ? [0, []] : [1, a:diff]

FUNCTION  <SNR>103_GlobComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:lead ==# '/'
                                return []
                              elseif v:version >= 704
                                let results = glob(a:lead . a:pattern, 0, 1)
                              else
                                let results = split(glob(a:lead . a:pattern), "\n")
                              endif
                              call map(results, 'v:val !~# "/$" && isdirectory(v:val) ? v:val."/" : v:val')
                              call map(results, 'v:val[ strlen(a:lead) : -1 ]')
                              return results

FUNCTION  FugitiveCommonDir()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = FugitiveGitDir(a:0 ? a:1 : -1)
                              if empty(dir)
                                return ''
                              endif
                              return fugitive#CommonDir(dir)

FUNCTION  sy#util#escape()
Called 3 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    3              0.000024   if exists('+shellslash')
                                let old_ssl = &shellslash
                                if fnamemodify(&shell, ':t') == 'cmd.exe'
                                  set noshellslash
                                else
                                  set shellslash
                                endif
    3              0.000002   endif
                            
    3              0.000012   let path = shellescape(a:path)
                            
    3              0.000006   if exists('old_ssl')
                                let &shellslash = old_ssl
    3              0.000001   endif
                            
    3              0.000005   return path

FUNCTION  <SNR>103_FetchComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:CompleteSub('fetch', a:A, a:L, a:P, function('s:CompleteRemote'))

FUNCTION  <SNR>49_dosurround()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let scount = v:count1
                              let char = (a:0 ? a:1 : s:inputtarget())
                              let spc = ""
                              if char =~ '^\d\+'
                                let scount = scount * matchstr(char,'^\d\+')
                                let char = substitute(char,'^\d\+','','')
                              endif
                              if char =~ '^ '
                                let char = strpart(char,1)
                                let spc = 1
                              endif
                              if char == 'a'
                                let char = '>'
                              endif
                              if char == 'r'
                                let char = ']'
                              endif
                              let newchar = ""
                              if a:0 > 1
                                let newchar = a:2
                                if newchar == "\<Esc>" || newchar == "\<C-C>" || newchar == ""
                                  return s:beep()
                                endif
                              endif
                              let cb_save = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let append = ""
                              let original = getreg('"')
                              let otype = getregtype('"')
                              call setreg('"',"")
                              let strcount = (scount == 1 ? "" : scount)
                              if char == '/'
                                exe 'norm! '.strcount.'[/d'.strcount.']/'
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>"''`]'
                                exe 'norm! T'.char
                                if getline('.')[col('.')-1] == char
                                  exe 'norm! l'
                                endif
                                exe 'norm! dt'.char
                              else
                                exe 'norm! d'.strcount.'i'.char
                              endif
                              let keeper = getreg('"')
                              let okeeper = keeper " for reindent below
                              if keeper == ""
                                call setreg('"',original,otype)
                                let &clipboard = cb_save
                                return ""
                              endif
                              let oldline = getline('.')
                              let oldlnum = line('.')
                              if char ==# "p"
                                call setreg('"','','V')
                              elseif char ==# "s" || char ==# "w" || char ==# "W"
                                " Do nothing
                                call setreg('"','')
                              elseif char =~ "[\"'`]"
                                exe "norm! i \<Esc>d2i".char
                                call setreg('"',substitute(getreg('"'),' ','',''))
                              elseif char == '/'
                                norm! "_x
                                call setreg('"','/**/',"c")
                                let keeper = substitute(substitute(keeper,'^/\*\s\=','',''),'\s\=\*$','','')
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>]'
                                exe 'norm! F'.char
                                exe 'norm! df'.char
                              else
                                " One character backwards
                                call search('\m.', 'bW')
                                exe "norm! da".char
                              endif
                              let removed = getreg('"')
                              let rem2 = substitute(removed,'\n.*','','')
                              let oldhead = strpart(oldline,0,strlen(oldline)-strlen(rem2))
                              let oldtail = strpart(oldline,  strlen(oldline)-strlen(rem2))
                              let regtype = getregtype('"')
                              if char =~# '[\[({<T]' || spc
                                let keeper = substitute(keeper,'^\s\+','','')
                                let keeper = substitute(keeper,'\s\+$','','')
                              endif
                              if col("']") == col("$") && col('.') + 1 == col('$')
                                if oldhead =~# '^\s*$' && a:0 < 2
                                  let keeper = substitute(keeper,'\%^\n'.oldhead.'\(\s*.\{-\}\)\n\s*\%$','\1','')
                                endif
                                let pcmd = "p"
                              else
                                let pcmd = "P"
                              endif
                              if line('.') + 1 < oldlnum && regtype ==# "V"
                                let pcmd = "p"
                              endif
                              call setreg('"',keeper,regtype)
                              if newchar != ""
                                let special = a:0 > 2 ? a:3 : 0
                                call s:wrapreg('"',newchar,removed,special)
                              endif
                              silent exe 'norm! ""'.pcmd.'`['
                              if removed =~ '\n' || okeeper =~ '\n' || getreg('"') =~ '\n'
                                call s:reindent()
                              endif
                              if getline('.') =~ '^\s\+$' && keeper =~ '^\s*\n'
                                silent norm! cc
                              endif
                              call setreg('"',original,otype)
                              let s:lastdel = removed
                              let &clipboard = cb_save
                              if newchar == ""
                                silent! call repeat#set("\<Plug>Dsurround".char,scount)
                              else
                                silent! call repeat#set("\<Plug>C".(a:0 > 2 && a:3 ? "S" : "s")."urround".char.newchar.s:input,scount)
                              endif

FUNCTION  <SNR>50_addAllMappings()
Called 1 time
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
                                " this is somewhat ugly, but we still need these nl values inside of the
                                " expression mapping and don't want to have this legacy fallback in two
                                " places
    1              0.000011     let g:targets_nl = get(g:, 'targets_nl', get(g:, 'targets_nlNL', 'nl')[0:1]) " legacy fallback
    1              0.000004     let aiAI         = get(g:, 'targets_aiAI', 'aiAI')
    1              0.000004     let mapped_aiAI  = get(g:, 'targets_mapped_aiAI', aiAI)
    1              0.000022     let [s:a,  s:i,  s:A,  s:I]  = split(aiAI, '\zs')
    1              0.000012     let [s:ma, s:mi, s:mA, s:mI] = split(mapped_aiAI, '\zs')
    1              0.000009     let [s:n, s:l]               = split(g:targets_nl, '\zs')
                            
    1              0.000004     if v:version >= 704 || (v:version == 703 && has('patch338'))
                                    " if possible, create only a few expression mappings to speed up loading times
    1              0.000022         silent! execute 'omap <expr> <unique>' s:i "targets#e('o', 'i', '" . s:mi . "')"
    1              0.000014         silent! execute 'omap <expr> <unique>' s:a "targets#e('o', 'a', '" . s:ma . "')"
    1              0.000013         silent! execute 'omap <expr> <unique>' s:I "targets#e('o', 'I', '" . s:mI . "')"
    1              0.000012         silent! execute 'omap <expr> <unique>' s:A "targets#e('o', 'A', '" . s:mA . "')"
                            
    1              0.000013         silent! execute 'xmap <expr> <unique>' s:i "targets#e('x', 'i', '" . s:mi . "')"
    1              0.000012         silent! execute 'xmap <expr> <unique>' s:a "targets#e('x', 'a', '" . s:ma . "')"
    1              0.000026         silent! execute 'xmap <expr> <unique>' s:I "targets#e('x', 'I', '" . s:mI . "')"
    1              0.000013         silent! execute 'xmap <expr> <unique>' s:A "targets#e('x', 'A', '" . s:mA . "')"
                            
                                    " #209: The above mappings don't use <silent> for better visual
                                    " feedback on `!ip` (when we pass back control to Vim). To be silent
                                    " when calling internal targest functions, we use this special mapping
                                    " which does use <silent>. It should not lead to conflicts because (
                                    " is not a valid register.
    1              0.000013         onoremap <silent> @(targets) :<C-U>call targets#do()<CR>
    1              0.000011         xnoremap <silent> @(targets) :<C-U>call targets#do()<CR>
                            
                                else
                                    " otherwise create individual mappings #117
                                    " NOTE: for old versions only these legacy settings are used
                                    " the more flexible targets#mappings only work with the expression
                                    " mappings above (from Vim version 7.3.338 on)
                                    call targets#legacy#addMappings(s:a, s:i, s:A, s:I, s:n, s:l)
    1              0.000001     endif

FUNCTION  <SNR>103_MessageCfile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let tree = s:Tree()
                              let lead = s:cpath(tree, getcwd()) ? './' : tree . '/'
                              if getline('.') =~# '^.\=\trenamed:.* -> '
                                return lead . matchstr(getline('.'),' -> \zs.*')
                              elseif getline('.') =~# '^.\=\t\(\k\| \)\+\p\?: *.'
                                return lead . matchstr(getline('.'),': *\zs.\{-\}\ze\%( ([^()[:digit:]]\+)\)\=$')
                              elseif getline('.') =~# '^.\=\t.'
                                return lead . matchstr(getline('.'),'\t\zs.*')
                              elseif getline('.') =~# ': needs merge$'
                                return lead . matchstr(getline('.'),'.*\ze: needs merge$')
                              elseif getline('.') =~# '^\%(. \)\=Not currently on any branch.$'
                                return 'HEAD'
                              elseif getline('.') =~# '^\%(. \)\=On branch '
                                return 'refs/heads/'.getline('.')[12:]
                              elseif getline('.') =~# "^\\%(. \\)\=Your branch .*'"
                                return matchstr(getline('.'),"'\\zs\\S\\+\\ze'")
                              else
                                return ''
                              endif

FUNCTION  <SNR>103_MergeRebase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 ? a:1 : s:Dir()
                              let args = a:args
                              let mods = s:Mods(a:mods)
                              if a:cmd =~# '^rebase' && s:HasOpt(args, '-i', '--interactive')
                                let cmd = fugitive#Prepare(dir, '-c', 'sequence.editor=sh ' . s:RebaseSequenceAborter(), 'rebase') . ' ' . s:shellesc(args)
                                let out = system(cmd)[0:-2]
                                for file in ['end', 'msgnum']
                                  let file = fugitive#Find('.git/rebase-merge/' . file, dir)
                                  if !filereadable(file)
                                    return 'echoerr ' . string("fugitive: " . out)
                                  endif
                                  call writefile([readfile(file)[0] - 1], file)
                                endfor
                                call writefile([], fugitive#Find('.git/rebase-merge/done', dir))
                                if a:bang
                                  return 'exe'
                                endif
                                return s:RebaseEdit(mods . 'split', dir)
                              elseif a:cmd =~# '^rebase' && s:HasOpt(args, '--edit-todo') && filereadable(fugitive#Find('.git/rebase-merge/git-rebase-todo', dir))
                                return s:RebaseEdit(mods . 'split', dir)
                              elseif a:cmd =~# '^rebase' && s:HasOpt(args, '--continue') && !a:0
                                let rdir = fugitive#Find('.git/rebase-merge', dir)
                                let exec_error = s:ChompError([dir, 'diff-index', '--cached', '--quiet', 'HEAD', '--'])[1]
                                if exec_error && isdirectory(rdir)
                                  if getfsize(rdir . '/amend') <= 0
                                    return 'exe ' . string(mods . 'Gcommit -n -F ' . s:fnameescape(rdir .'/message') . ' -e') . '|let b:fugitive_commit_rebase = 1'
                                  elseif readfile(rdir . '/amend')[0] ==# fugitive#Head(-1, dir)
                                    return 'exe ' . string(mods . 'Gcommit --amend -n -F ' . s:fnameescape(rdir . '/message') . ' -e') . '|let b:fugitive_commit_rebase = 1'
                                  endif
                                endif
                              endif
                              let had_merge_msg = filereadable(fugitive#Find('.git/MERGE_MSG', dir))
                              let argv = []
                              if a:cmd ==# 'pull'
                                let argv += s:AskPassArgs(dir) + ['pull', '--progress']
                              else
                                call add(argv, a:cmd)
                              endif
                              if !s:HasOpt(args, '--no-edit', '--abort', '-m') && a:cmd !=# 'rebase'
                                call add(argv, '--edit')
                              endif
                              if a:cmd ==# 'rebase' && s:HasOpt(args, '--autosquash') && !s:HasOpt(args, '--interactive', '-i')
                                call add(argv, '--interactive')
                              endif
                              call extend(argv, args)
                            
                              let [mp, efm] = [&l:mp, &l:efm]
                              try
                                let cdback = s:Cd(s:Tree(dir))
                                let &l:errorformat = '' . '%-Gerror:%.%#false''.,' . '%-G%.%# ''git commit'' %.%#,' . '%+Emerge:%.%#,' . s:common_efm . ',' . '%+ECannot %.%#: You have unstaged changes.,' . '%+ECannot %.%#: Your index contains uncommitted changes.,' . '%+EThere is no tracking information for the current branch.,' . '%+EYou are not currently on a branch. Please specify which,' . '%+I %#git rebase --continue,' . 'CONFLICT (%m): %f deleted in %.%#,' . 'CONFLICT (%m): Merge conflict in %f,' . 'CONFLICT (%m): Rename \"%f\"->%.%#,' . 'CONFLICT (%m): Rename %.%#->%f %.%#,' . 'CONFLICT (%m): There is a directory with name %f in %.%#,' . '%+ECONFLICT %.%#,' . '%+EKONFLIKT %.%#,' . '%+ECONFLIT %.%#,' . "%+EXUNG \u0110\u1ed8T %.%#," . "%+E\u51b2\u7a81 %.%#," . 'U%\t%f'
                                if a:cmd =~# '^merge' && empty(args) && (had_merge_msg || isdirectory(fugitive#Find('.git/rebase-apply', dir)) ||  !empty(s:TreeChomp(dir, 'diff-files', '--diff-filter=U')))
                                  let cmd = g:fugitive_git_executable.' diff-files --name-status --diff-filter=U'
                                else
                                  let cmd = s:UserCommand(dir, argv)
                                endif
                                if !empty($GIT_SEQUENCE_EDITOR) || has('win32')
                                  let old_sequence_editor = $GIT_SEQUENCE_EDITOR
                                  let $GIT_SEQUENCE_EDITOR = 'true'
                                else
                                  let cmd = 'env GIT_SEQUENCE_EDITOR=true ' . cmd
                                endif
                                if !empty($GIT_EDITOR) || has('win32')
                                  let old_editor = $GIT_EDITOR
                                  let $GIT_EDITOR = 'false'
                                else
                                  let cmd = 'env GIT_EDITOR=false ' . substitute(cmd, '^env ', '', '')
                                endif
                                if !has('patch-8.1.0334') && has('terminal') && &autowrite
                                  let autowrite_was_set = 1
                                  set noautowrite
                                  silent! wall
                                endif
                                let &l:makeprg = cmd
                                silent noautocmd make!
                              catch /^Vim\%((\a\+)\)\=:E211/
                                let err = v:exception
                              finally
                                if exists('autowrite_was_set')
                                  set autowrite
                                endif
                                redraw!
                                let [&l:mp, &l:efm] = [mp, efm]
                                if exists('old_editor')
                                  let $GIT_EDITOR = old_editor
                                endif
                                if exists('old_sequence_editor')
                                  let $GIT_SEQUENCE_EDITOR = old_sequence_editor
                                endif
                                execute cdback
                              endtry
                              call fugitive#ReloadStatus(dir, 1)
                              if empty(filter(getqflist(),'v:val.valid && v:val.type !=# "I"'))
                                if a:cmd =~# '^rebase' && filereadable(fugitive#Find('.git/rebase-merge/amend', dir)) && filereadable(fugitive#Find('.git/rebase-merge/done', dir)) && get(readfile(fugitive#Find('.git/rebase-merge/done', dir)), -1, '') =~# '^[^e]'
                                  cclose
                                  return 'exe ' . string(mods . 'Gcommit --amend -n -F ' . s:fnameescape(fugitive#Find('.git/rebase-merge/message', dir)) . ' -e') . '|let b:fugitive_commit_rebase = 1'
                                elseif !had_merge_msg && filereadable(fugitive#Find('.git/MERGE_MSG', dir))
                                  cclose
                                  return mods . 'Gcommit --no-status -n -t '.s:fnameescape(fugitive#Find('.git/MERGE_MSG', dir))
                                endif
                              endif
                              let qflist = getqflist()
                              let found = 0
                              for e in qflist
                                if !empty(e.bufnr)
                                  let found = 1
                                  let e.pattern = '^<<<<<<<'
                                endif
                              endfor
                              call fugitive#Cwindow()
                              if found
                                call setqflist(qflist, 'r')
                                if !a:bang
                                  call s:BlurStatus()
                                  return 'cfirst'
                                endif
                              endif
                              return exists('err') ? 'echoerr '.string(err) : 'exe'

FUNCTION  fugitive#GrepComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:CompleteSub('grep', a:A, a:L, a:P)

FUNCTION  <SNR>99_offset()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let offset = &foldcolumn
                              let offset += 2  " FIXME: Find better way to calculate the sign column width.
                              if &number
                                let l = len(line('$')) + 1
                                let offset += (&numberwidth > l) ? &numberwidth : l
                              elseif &relativenumber
                                let l = len(winheight('%')) + 1
                                let offset += (&numberwidth > l) ? &numberwidth : l
                              endif
                              return offset

FUNCTION  go#config#MetalinterCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_metalinter_command", "golangci-lint")

FUNCTION  <SNR>5_PopPage()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if s:man_tag_depth > 0
                                let s:man_tag_depth = s:man_tag_depth - 1
                                exec "let s:man_tag_buf=s:man_tag_buf_".s:man_tag_depth
                                exec "let s:man_tag_lin=s:man_tag_lin_".s:man_tag_depth
                                exec "let s:man_tag_col=s:man_tag_col_".s:man_tag_depth
                                exec s:man_tag_buf."b"
                                exec s:man_tag_lin
                                exec "norm ".s:man_tag_col."|"
                                exec "unlet s:man_tag_buf_".s:man_tag_depth
                                exec "unlet s:man_tag_lin_".s:man_tag_depth
                                exec "unlet s:man_tag_col_".s:man_tag_depth
                                unlet s:man_tag_buf s:man_tag_lin s:man_tag_col
                              endif

FUNCTION  fugitive#LogComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:CompleteSub('log', a:A, a:L, a:P)

FUNCTION  <SNR>103_StageApply()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:info.status ==# 'R'
                                call s:throw('fugitive: patching renamed file not yet supported')
                              endif
                              let cmd = ['apply', '-p0', '--recount'] + a:extra
                              let info = a:info
                              let start = info.patch
                              let end = info.lnum
                              let lines = getline(start, end)
                              if empty(filter(copy(lines), 'v:val =~# "^[+-]"'))
                                return -1
                              endif
                              while getline(end) =~# '^[-+ ]'
                                let end += 1
                                if getline(end) =~# '^[' . (a:reverse ? '+' : '-') . ' ]'
                                  call add(lines, ' ' . getline(end)[1:-1])
                                endif
                              endwhile
                              while start > 0 && getline(start) !~# '^@'
                                let start -= 1
                                if getline(start) =~# '^[' . (a:reverse ? '+' : '-') . ' ]'
                                  call insert(lines, ' ' . getline(start)[1:-1])
                                elseif getline(start) =~# '^@'
                                  call insert(lines, getline(start))
                                endif
                              endwhile
                              if start == 0
                                throw 'fugitive: cold not find hunk'
                              elseif getline(start) !~# '^@@ '
                                throw 'fugitive: cannot apply conflict hunk'
                              endif
                              let i = b:fugitive_expanded[info.section][info.filename][0]
                              let head = []
                              while get(b:fugitive_diff[info.section], i, '@') !~# '^@'
                                call add(head, b:fugitive_diff[info.section][i])
                                let i += 1
                              endwhile
                              call extend(lines, head, 'keep')
                              let temp = tempname()
                              call writefile(lines, temp)
                              if a:reverse
                                call add(cmd, '--reverse')
                              endif
                              call extend(cmd, ['--', temp])
                              let [output, exec_error] = s:ChompError(cmd)
                              if !exec_error
                                return 1
                              endif
                              call s:throw(output)

FUNCTION  go#util#StripTrailingSlash()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return map(copy(a:paths), 'go#util#StripPathSep(v:val)')

FUNCTION  <SNR>92_typeDefinitionHandler()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " gopls returns a []Location; just take the first one.
                              let l:msg = a:msg[0]
                              let l:args = [[printf('%s:%d:%d: %s', go#path#FromURI(l:msg.uri), l:msg.range.start.line+1, go#lsp#lsp#PositionOf(getline(l:msg.range.start.line+1), l:msg.range.start.character), 'lsp does not supply a description')]]
                              call call(a:next, l:args)

FUNCTION  go#uri#EncodePath()
Called 4 times
Total time:   0.000221
 Self time:   0.000084

count  total (s)   self (s)
    4              0.000013     let l:separator = '/'
    4   0.000054   0.000023     if go#util#IsWin()
                                  let l:separator = '\\'
    4              0.000004     endif
    4   0.000136   0.000030     return s:encode(a:value, '[^' . l:separator . 'A-Za-z0-9_.~-]')

FUNCTION  go#guru#ClearSameIds()
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000004   let l:cleared = 0
                            
    1              0.000004   let m = getmatches()
    1              0.000003   for item in m
                                if item['group'] == 'goSameId'
                                  call matchdelete(item['id'])
                                  let l:cleared = 1
                                endif
    1              0.000002   endfor
                            
    1              0.000002   if !l:cleared
    1              0.000001     return 1
                              endif
                            
                              " remove the autocmds we defined
                              augroup vim-go-sameids
                                autocmd! * <buffer>
                              augroup end
                            
                              return 0

FUNCTION  <SNR>100_replace()
Called 6 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    6              0.000044   let parts = split(a:cmd, a:pat, 1)
    6              0.000023   return join(parts, a:sub)

FUNCTION  go#config#SetAutoSameids()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:go_auto_sameids = a:value

FUNCTION  <SNR>106_external_sign_present()
Called 71 times
Total time:   0.000956
 Self time:   0.000956

count  total (s)   self (s)
   71              0.000273   if has_key(a:sy.external, a:line)
                                if has_key(a:sy.internal, a:line)
                                  " Remove Sy signs from lines with other signs.
                                  execute 'sign unplace' a:sy.internal[a:line].id 'buffer='.a:sy.buffer
                                endif
                                return 1
   71              0.000065   endif

FUNCTION  <SNR>103_buffer_repo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#repo(self['#'])

FUNCTION  <SNR>100_callback_nvim_exit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:handle_diff(self, a:exitval)

FUNCTION  <SNR>103_FinishCommit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let buf = +expand('<abuf>')
                              let args = getbufvar(buf, 'fugitive_commit_arguments')
                              if !empty(args)
                                call setbufvar(buf, 'fugitive_commit_arguments', [])
                                if getbufvar(buf, 'fugitive_commit_rebase')
                                  call setbufvar(buf, 'fugitive_commit_rebase', 0)
                                  let s:rebase_continue = s:Dir(buf)
                                endif
                                return s:CommitSubcommand(-1, -1, 0, 0, '', args, s:Dir(buf))
                              endif
                              return ''

FUNCTION  fugitive#RenameCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:Move(a:bang, 1, a:arg)

FUNCTION  go#lsp#message#DidOpen()
Called 1 time
Total time:   0.000488
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000485   0.000019   return { 'notification': 1, 'method': 'textDocument/didOpen', 'params': {     'textDocument': {         'uri': go#path#ToURI(a:file),         'languageId': 'go',         'text': a:content,     } } }

FUNCTION  <SNR>103_OpenParse()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let pre = []
                              let args = copy(a:args)
                              while !empty(args) && args[0] =~# '^+'
                                call add(pre, ' ' . escape(remove(args, 0), ' |"'))
                              endwhile
                              if len(args)
                                let file = join(args)
                              elseif empty(expand('%'))
                                let file = ''
                              elseif empty(s:DirCommitFile(@%)[1]) && s:Relative('./') !~# '^\./\.git\>'
                                let file = '>:0'
                              else
                                let file = '>'
                              endif
                              return [s:Expand(file), join(pre)]

FUNCTION  <SNR>49_reindent()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists("b:surround_indent") ? b:surround_indent : (!exists("g:surround_indent") || g:surround_indent)
                                silent norm! '[=']
                              endif

FUNCTION  sy#highlight#line_disable()
Called 1 time
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
    1              0.000014   execute 'sign define SignifyAdd text='. s:sign_add 'texthl=SignifySignAdd linehl='
    1              0.000007   execute 'sign define SignifyChange text='. s:sign_change 'texthl=SignifySignChange linehl='
    1              0.000007   execute 'sign define SignifyRemoveFirstLine text='. s:sign_delete_first_line 'texthl=SignifySignDeleteFirstLine linehl='
                            
    1              0.000002   if s:sign_show_count
    1              0.000005     while strwidth(s:sign_changedelete) > 1
                                  let s:sign_changedelete = substitute(s:sign_changedelete, '.', '', '')
    1              0.000002     endwhile
   10              0.000020     for n in range(1, 9)
    9              0.000093       execute 'sign define SignifyChangeDelete'. n 'text='. s:sign_changedelete . n 'texthl=SignifySignChangeDelete linehl='
   10              0.000013     endfor
    1              0.000007     execute 'sign define SignifyChangeDeleteMore text='. s:sign_changedelete .'> texthl=SignifySignChangeDelete linehl='
                              else
                                for n in range(1, 9)
                                  execute 'sign define SignifyChangeDelete'. n 'text='. s:sign_changedelete 'texthl=SignifySignChangeDelete linehl='
                                endfor
                                execute 'sign define SignifyChangeDeleteMore text='. s:sign_changedelete 'texthl=SignifySignChangeDelete linehl='
    1              0.000001   endif
                            
    1              0.000010   let g:signify_line_highlight = 0

FUNCTION  go#config#HighlightTrailingWhitespaceError()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000011   return get(g:, 'go_highlight_trailing_whitespace_error', 0)

FUNCTION  <SNR>41_complete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return filter(keys(s:packages), 'strpart(v:val, 0, len(a:lead)) == a:lead')

FUNCTION  fugitive#LogCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              let listnr = a:type =~# '^l' ? 0 : -1
                              let [args, after] = s:SplitExpandChain(a:args, s:Tree(dir))
                              let split = index(args, '--')
                              if split > 0
                                let paths = args[split : -1]
                                let args = args[0 : split - 1]
                              elseif split == 0
                                let paths = args
                                let args = []
                              else
                                let paths = []
                              endif
                              if a:line1 == 0 && a:count
                                let path = fugitive#Path(bufname(a:count), '/', dir)
                              elseif a:count >= 0
                                let path = fugitive#Path(@%, '/', dir)
                              else
                                 let path = ''
                              endif
                              let range = ''
                              let extra = []
                              let state = {'context': 'init', 'child_found': 0, 'queue': [], 'follow': 0}
                              if path =~# '^/\.git\%(/\|$\)\|^$'
                                let path = ''
                              elseif a:line1 == 0
                                let range = "0," . (a:count ? a:count : bufnr(''))
                                let extra = ['.' . path]
                                if (empty(paths) || paths ==# ['--']) && !s:HasOpt(args, '--no-follow')
                                  let state.follow = 1
                                  if !s:HasOpt(args, '--follow')
                                    call insert(args, '--follow')
                                  endif
                                  if !s:HasOpt(args, '--summary')
                                    call insert(args, '--summary')
                                    let state.ignore_summary = 1
                                  endif
                                endif
                              elseif a:count > 0
                                if !s:HasOpt(args, '--merges', '--no-merges')
                                  call insert(args, '--no-merges')
                                endif
                                call add(args, '-L' . a:line1 . ',' . a:count . ':' . path[1:-1])
                              endif
                              if len(path) && empty(filter(copy(args), 'v:val =~# "^[^-]"'))
                                let owner = s:Owner(@%, dir)
                                if len(owner)
                                  call add(args, owner)
                                endif
                              endif
                              if empty(extra)
                                let path = ''
                              endif
                              if s:HasOpt(args, '-g', '--walk-reflogs')
                                let format = "%gd\t%H %gs"
                              else
                                let format = "%h\t%H " . g:fugitive_summary_format
                              endif
                              let cmd = ['--no-pager']
                              if fugitive#GitVersion(1, 9)
                                call extend(cmd, ['-c', 'diff.context=0', '-c', 'diff.noprefix=false', 'log'])
                              else
                                call extend(cmd, ['log', '-U0', '--no-patch'])
                              endif
                              call extend(cmd, ['--no-color', '--no-ext-diff', '--pretty=format:fugitive ' . format] + args + paths + extra)
                              let state.target = path
                              let title = (listnr < 0 ? ':Gclog ' : ':Gllog ') . s:fnameescape(args + paths)
                              if empty(paths + extra) && empty(a:type) && len(s:Relative('/'))
                                let after = '|echohl WarningMsg|echo ' . string('Use :0Glog or :0Gclog for old behavior of targeting current file') . '|echohl NONE' . after
                              endif
                              return s:QuickfixStream(listnr, title, s:UserCommandList(dir) + cmd, !a:bang, s:function('s:LogParse'), state, dir) . after

FUNCTION  fugitive#repo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 ? s:Dir(a:1) : (len(s:Dir()) ? s:Dir() : FugitiveExtractGitDir(expand('%:p')))
                              if dir !=# ''
                                if has_key(s:repos, dir)
                                  let repo = get(s:repos, dir)
                                else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
                                return extend(repo, s:repo_prototype, 'keep')
                              endif
                              call s:throw('not a Git repository')

FUNCTION  <SNR>100_is_cur_line_in_hunk()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let cur_line = line('.')
                              let [_old_line, new_line, old_count, new_count] = sy#sign#parse_hunk(a:hunkline)
                            
                              if cur_line == 1 && new_line == 0
                                " deleted first line
                                return 1
                              endif
                            
                              if cur_line == new_line && new_count < old_count
                                " deleted lines
                                return 1
                              endif
                            
                              if cur_line >= new_line && cur_line < (new_line + new_count)
                                " added/changed lines
                                return 1
                              endif
                            
                              return 0

FUNCTION  <SNR>103_Dir()
Called 2 times
Total time:   0.000077
 Self time:   0.000021

count  total (s)   self (s)
    2   0.000076   0.000020   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  <SNR>103_BufName()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:var ==# '%'
                                return bufname(get(s:TempState(), 'bufnr', ''))
                              elseif a:var =~# '^#\d*$'
                                let nr = get(s:TempState(bufname(+a:var[1:-1])), 'bufnr', '')
                                return bufname(nr ? nr : +a:var[1:-1])
                              else
                                return expand(a:var)
                              endif

FUNCTION  <SNR>103_FormatRebase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:dict.status . ' ' . a:dict.commit . ' ' . a:dict.subject

FUNCTION  go#util#Shelllist()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              try
                                let ssl_save = &shellslash
                                set noshellslash
                                if a:0
                                  return map(copy(a:arglist), 'shellescape(v:val, ' . a:1 . ')')
                                endif
                                return map(copy(a:arglist), 'shellescape(v:val)')
                              finally
                                let &shellslash = ssl_save
                              endtry

FUNCTION  go#lsp#message#Hover()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return { 'notification': 0, 'method': 'textDocument/hover', 'params': {   'textDocument': {       'uri': go#path#ToURI(a:file)   },   'position': s:position(a:line, a:col), } }

FUNCTION  <SNR>100_check_diff_tfs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:exitval ? [0, []] : [1, s:strip_context(a:diff)]

FUNCTION  go#config#TextobjIncludeFunctionDoc()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_textobj_include_function_doc", 1)

FUNCTION  fugitive#CommonDir()
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000003   if empty(a:dir)
                                return ''
    1              0.000001   endif
    1              0.000004   if !has_key(s:commondirs, a:dir)
    1              0.000012     if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
    1              0.000016     elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
    1              0.000000     else
    1              0.000003       let s:commondirs[a:dir] = a:dir
    1              0.000001     endif
    1              0.000001   endif
    1              0.000003   return s:commondirs[a:dir]

FUNCTION  <SNR>49_getchar()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let c = getchar()
                              if c =~ '^\d\+$'
                                let c = nr2char(c)
                              endif
                              return c

FUNCTION  <SNR>103_CompareAge()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let scores = {':0': 1, ':1': 2, ':2': 3, ':': 4, ':3': 5}
                              let mine = substitute(a:mine, '^:', '', '')
                              let theirs = substitute(a:theirs, '^:', '', '')
                              let my_score    = get(scores, ':'.mine, 0)
                              let their_score = get(scores, ':'.theirs, 0)
                              if my_score || their_score
                                return my_score < their_score ? -1 : my_score != their_score
                              elseif mine ==# theirs
                                return 0
                              endif
                              let base = s:TreeChomp('merge-base', mine, theirs)
                              if base ==# mine
                                return -1
                              elseif base ==# theirs
                                return 1
                              endif
                              let my_time    = +s:TreeChomp('log', '--max-count=1', '--pretty=format:%at', a:mine, '--')
                              let their_time = +s:TreeChomp('log', '--max-count=1', '--pretty=format:%at', a:theirs, '--')
                              return my_time < their_time ? -1 : my_time != their_time

FUNCTION  go#config#DebugCommands()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " make sure g:go_debug_commands is set so that it can be added to easily.
                              let g:go_debug_commands = get(g:, 'go_debug_commands', [])
                              return g:go_debug_commands

FUNCTION  go#util#GetLines()
Called 3 times
Total time:   0.000510
 Self time:   0.000510

count  total (s)   self (s)
    3              0.000459   let buf = getline(1, '$')
    3              0.000014   if &encoding != 'utf-8'
                                let buf = map(buf, 'iconv(v:val, &encoding, "utf-8")')
    3              0.000002   endif
    3              0.000005   if &l:fileformat == 'dos'
                                " XXX: line2byte() depend on 'fileformat' option.
                                " so if fileformat is 'dos', 'buf' must include '\r'.
                                let buf = map(buf, 'v:val."\r"')
    3              0.000003   endif
    3              0.000006   return buf

FUNCTION  <SNR>103_BlameRehighlight()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for [hash, cterm] in items(s:hash_colors)
                                if !empty(cterm) || has('gui_running') || has('termguicolors') && &termguicolors
                                  exe 'hi FugitiveblameHash'.hash.' guifg=#'.hash.get(s:hash_colors, hash, '')
                                else
                                  exe 'hi link FugitiveblameHash'.hash.' Identifier'
                                endif
                              endfor

FUNCTION  sy#highlight#line_enable()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              execute 'sign define SignifyAdd text='. s:sign_add 'texthl=SignifySignAdd linehl=SignifyLineAdd'
                              execute 'sign define SignifyChange text='. s:sign_change 'texthl=SignifySignChange linehl=SignifyLineChange'
                              execute 'sign define SignifyRemoveFirstLine text='. s:sign_delete_first_line 'texthl=SignifySignDeleteFirstLine linehl=SignifyLineDeleteFirstLine'
                            
                              if s:sign_show_count
                                let s:sign_changedelete = substitute(s:sign_changedelete, '^.\zs.*', '', '')
                                for n in range(1, 9)
                                  execute 'sign define SignifyChangeDelete'. n 'text='. s:sign_changedelete . n 'texthl=SignifySignChangeDelete linehl=SignifyLineChangeDelete'
                                endfor
                                execute 'sign define SignifyChangeDeleteMore text='. s:sign_changedelete .'> texthl=SignifySignChangeDelete linehl=SignifyLineChangeDelete'
                              else
                                for n in range(1, 9)
                                  execute 'sign define SignifyChangeDelete'. n 'text='. s:sign_changedelete 'texthl=SignifySignChangeDelete linehl=SignifyLineChangeDelete'
                                endfor
                                execute 'sign define SignifyChangeDeleteMore text='. s:sign_changedelete 'texthl=SignifySignChangeDelete linehl=SignifyLineChangeDelete'
                              endif
                            
                              let g:signify_line_highlight = 1

FUNCTION  sy#sign#id_next()
Called 71 times
Total time:   0.000489
 Self time:   0.000489

count  total (s)   self (s)
   71              0.000179   let id = a:sy.signid
   71              0.000139   let a:sy.signid += 1
   71              0.000102   return id

FUNCTION  go#util#EchoProgress()
Called 2 times
Total time:   0.006103
 Self time:   0.005887

count  total (s)   self (s)
    2              0.005862   redraw
    2   0.000239   0.000023   call s:echo(a:msg, 'Identifier')

FUNCTION  fugitive#Head()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              if empty(dir) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                return ''
                              endif
                              let head = readfile(fugitive#Find('.git/HEAD', dir))[0]
                              if head =~# '^ref: '
                                return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>92_definitionHandler()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " gopls returns a []Location; just take the first one.
                              let l:msg = a:msg[0]
                              let l:args = [[printf('%s:%d:%d: %s', go#path#FromURI(l:msg.uri), l:msg.range.start.line+1, go#lsp#lsp#PositionOf(getline(l:msg.range.start.line+1), l:msg.range.start.character), 'lsp does not supply a description')]]
                              call call(a:next, l:args)

FUNCTION  <SNR>5_FindPage()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let where = system("/usr/bin/man ".s:man_find_arg.' '.s:GetCmdArg(a:sect, a:page))
                              if where !~ "^/"
                                if matchstr(where, " [^ ]*$") !~ "^ /"
                                  return 0
                                endif
                              endif
                              return 1

FUNCTION  <SNR>49_opfunc()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:type ==# 'setup'
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
                                return 'g@'
                              endif
                              let char = s:inputreplacement()
                              if char == ""
                                return s:beep()
                              endif
                              let reg = '"'
                              let sel_save = &selection
                              let &selection = "inclusive"
                              let cb_save  = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let reg_save = getreg(reg)
                              let reg_type = getregtype(reg)
                              let type = a:type
                              if a:type == "char"
                                silent exe 'norm! v`[o`]"'.reg.'y'
                                let type = 'v'
                              elseif a:type == "line"
                                silent exe 'norm! `[V`]"'.reg.'y'
                                let type = 'V'
                              elseif a:type ==# "v" || a:type ==# "V" || a:type ==# "\<C-V>"
                                let &selection = sel_save
                                let ve = &virtualedit
                                if !(a:0 && a:1)
                                  set virtualedit=
                                endif
                                silent exe 'norm! gv"'.reg.'y'
                                let &virtualedit = ve
                              elseif a:type =~ '^\d\+$'
                                let type = 'v'
                                silent exe 'norm! ^v'.a:type.'$h"'.reg.'y'
                                if mode() ==# 'v'
                                  norm! v
                                  return s:beep()
                                endif
                              else
                                let &selection = sel_save
                                let &clipboard = cb_save
                                return s:beep()
                              endif
                              let keeper = getreg(reg)
                              if type ==# "v" && a:type !=# "v"
                                let append = matchstr(keeper,'\_s\@<!\s*$')
                                let keeper = substitute(keeper,'\_s\@<!\s*$','','')
                              endif
                              call setreg(reg,keeper,type)
                              call s:wrapreg(reg,char,"",a:0 && a:1)
                              if type ==# "v" && a:type !=# "v" && append != ""
                                call setreg(reg,append,"ac")
                              endif
                              silent exe 'norm! gv'.(reg == '"' ? '' : '"' . reg).'p`['
                              if type ==# 'V' || (getreg(reg) =~ '\n' && type ==# 'v')
                                call s:reindent()
                              endif
                              call setreg(reg,reg_save,reg_type)
                              let &selection = sel_save
                              let &clipboard = cb_save
                              if a:type =~ '^\d\+$'
                                silent! call repeat#set("\<Plug>Y".(a:0 && a:1 ? "S" : "s")."surround".char.s:input,a:type)
                              else
                                silent! call repeat#set("\<Plug>SurroundRepeat".char.s:input)
                              endif

FUNCTION  <SNR>100_initialize_job()
Called 2 times
Total time:   0.000296
 Self time:   0.000094

count  total (s)   self (s)
    2   0.000217   0.000015   let vcs_cmd = s:expand_cmd(a:vcs, g:signify_vcs_cmds)
    2              0.000009   if has('win32')
                                if has('nvim')
                                  let cmd = &shell =~ '\v%(cmd|powershell)' ? vcs_cmd : ['sh', '-c', vcs_cmd]
                                else
                                  if &shell =~ 'cmd'
                                    let cmd = join([&shell, &shellcmdflag, '(', vcs_cmd, ')'])
                                  elseif empty(&shellxquote)
                                    let cmd = join([&shell, &shellcmdflag, &shellquote, vcs_cmd, &shellquote])
                                  else
                                    let cmd = join([&shell, &shellcmdflag, &shellxquote, vcs_cmd, &shellxquote])
                                  endif
                                endif
    2              0.000002   else
    2              0.000006     let cmd = ['sh', '-c', vcs_cmd]
    2              0.000002   endif
    2              0.000016   let options = { 'stdoutbuf':   [''], 'vcs':         a:vcs, 'bufnr':       bufnr('%'), }
    2              0.000006   return [cmd, options]

FUNCTION  <SNR>103_ChompError()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [out, exec_error] = s:SystemError(call('fugitive#Prepare', a:000))
                              return [s:sub(out, '\n$', ''), exec_error]

FUNCTION  <SNR>103_FetchSubcommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:Dispatch(a:bang ? '!' : '', 'fetch', a:args)

FUNCTION  <SNR>103_Relative()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#Path(@%, a:0 ? a:1 : ':(top)', a:0 > 1 ? a:2 : s:Dir())

FUNCTION  sy#util#execute()
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000003   let lang = v:lang
    1              0.000005   redir => output
    1              0.000011     silent! execute a:cmd
    1              0.000003   redir END
    1              0.000024   silent! execute 'language message' lang
    1              0.000002   return output

FUNCTION  gutentags#rescan()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if exists('b:gutentags_files')
                                    unlet b:gutentags_files
                                endif
                                if a:0 && a:1
                                    let l:trace_backup = g:gutentags_trace
                                    let l:gutentags_trace = 1
                                endif
                                call gutentags#setup_gutentags()
                                if a:0 && a:1
                                    let g:gutentags_trace = l:trace_backup
                                endif

FUNCTION  <SNR>34_parse_subvert()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:args =~ '^\%(\w\|$\)'
                                let args = (a:bang ? "!" : "").a:args
                              else
                                let args = a:args
                              endif
                              let separator = matchstr(args,'^.')
                              let split = split(args,separator,1)[1:]
                              if a:count || split == [""]
                                return s:parse_substitute(a:bang,a:line1,a:line2,a:count,split)
                              elseif len(split) == 1
                                return s:find_command(separator,"",split[0])
                              elseif len(split) == 2 && split[1] =~# '^[A-Za-z]*n[A-Za-z]*$'
                                return s:parse_substitute(a:bang,a:line1,a:line2,a:count,[split[0],"",split[1]])
                              elseif len(split) == 2 && split[1] =~# '^[A-Za-z]*\%([+-]\d\+\)\=$'
                                return s:find_command(separator,split[1],split[0])
                              elseif len(split) >= 2 && split[1] =~# '^[A-Za-z]* '
                                let flags = matchstr(split[1],'^[A-Za-z]*')
                                let rest = matchstr(join(split[1:],separator),' \zs.*')
                                return s:grep_command(rest,a:bang,flags,split[0])
                              elseif len(split) >= 2 && separator == ' '
                                return s:grep_command(join(split[1:],' '),a:bang,"",split[0])
                              else
                                return s:parse_substitute(a:bang,a:line1,a:line2,a:count,split)
                              endif

FUNCTION  go#config#ListAutoclose()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_list_autoclose', 1)

FUNCTION  <SNR>103_DoUnstageStagedHeading()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:DoToggleStagedHeading(a:heading)

FUNCTION  gutentags#get_cachefile()
Called 1 time
Total time:   0.000144
 Self time:   0.000087

count  total (s)   self (s)
    1   0.000017   0.000008     if gutentags#is_path_rooted(a:filename)
                                    return a:filename
    1              0.000001     endif
    1   0.000036   0.000008     let l:tag_path = gutentags#stripslash(a:root_dir) . '/' . a:filename
    1              0.000003     if g:gutentags_cache_dir != ""
                                    " Put the tag file in the cache dir instead of inside the
                                    " project root.
    1              0.000019         let l:tag_path = g:gutentags_cache_dir . '/' .tr(l:tag_path, '\/: ', '---_')
    1              0.000010         let l:tag_path = substitute(l:tag_path, '/\-', '/', '')
    1              0.000024         let l:tag_path = substitute(l:tag_path, '[\-_]*$', '', '')
    1              0.000001     endif
    1   0.000026   0.000006     let l:tag_path = gutentags#normalizepath(l:tag_path)
    1              0.000002     return l:tag_path

FUNCTION  fugitive#BrowseCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              try
                                let validremote = '\.\|\.\=/.*\|[[:alnum:]_-]\+\%(://.\{-\}\)\='
                                if a:args ==# ['-']
                                  if a:count >= 0
                                    return 'echoerr ' . string('fugitive: ''-'' no longer required to get persistent URL if range given')
                                  else
                                    return 'echoerr ' . string('fugitive: use :0Gbrowse instead of :Gbrowse -')
                                  endif
                                elseif len(a:args)
                                  let remote = matchstr(join(a:args, ' '),'@\zs\%('.validremote.'\)$')
                                  let rev = substitute(join(a:args, ' '),'@\%('.validremote.'\)$','','')
                                else
                                  let remote = ''
                                  let rev = ''
                                endif
                                if rev ==# ''
                                  let rev = s:DirRev(@%)[1]
                                endif
                                if rev =~# '^:\=$'
                                  let expanded = s:Relative()
                                else
                                  let expanded = s:Expand(rev)
                                endif
                                let cdir = FugitiveVimPath(fugitive#CommonDir(dir))
                                for subdir in ['tags/', 'heads/', 'remotes/']
                                  if expanded !~# '^[./]' && filereadable(cdir . '/refs/' . subdir . expanded)
                                    let expanded = '.git/refs/' . subdir . expanded
                                  endif
                                endfor
                                let full = fugitive#Find(expanded, dir)
                                let commit = ''
                                if full =~? '^fugitive:'
                                  let [pathdir, commit, path] = s:DirCommitFile(full)
                                  if commit =~# '^:\=\d$'
                                    let commit = ''
                                  endif
                                  if commit =~ '..'
                                    let type = s:TreeChomp('cat-file','-t',commit.s:sub(path,'^/',':'))
                                    let branch = matchstr(expanded, '^[^:]*')
                                  else
                                    let type = 'blob'
                                  endif
                                  let path = path[1:-1]
                                elseif empty(s:Tree(dir))
                                  let path = '.git/' . full[strlen(dir)+1:-1]
                                  let type = ''
                                else
                                  let path = fugitive#Path(full, '/')[1:-1]
                                  if path =~# '^\.git/'
                                    let type = ''
                                  elseif isdirectory(full) || empty(path)
                                    let type = 'tree'
                                  else
                                    let type = 'blob'
                                  endif
                                endif
                                if type ==# 'tree' && !empty(path)
                                  let path = s:sub(path, '/\=$', '/')
                                endif
                                if path =~# '^\.git/.*HEAD$' && filereadable(dir . '/' . path[5:-1])
                                  let body = readfile(dir . '/' . path[5:-1])[0]
                                  if body =~# '^\x\{40,\}$'
                                    let commit = body
                                    let type = 'commit'
                                    let path = ''
                                  elseif body =~# '^ref: refs/'
                                    let path = '.git/' . matchstr(body,'ref: \zs.*')
                                  endif
                                endif
                            
                                let merge = ''
                                if path =~# '^\.git/refs/remotes/.'
                                  if empty(remote)
                                    let remote = matchstr(path, '^\.git/refs/remotes/\zs[^/]\+')
                                    let branch = matchstr(path, '^\.git/refs/remotes/[^/]\+/\zs.\+')
                                  else
                                    let merge = matchstr(path, '^\.git/refs/remotes/[^/]\+/\zs.\+')
                                    let path = '.git/refs/heads/'.merge
                                  endif
                                elseif path =~# '^\.git/refs/heads/.'
                                  let branch = path[16:-1]
                                elseif !exists('branch')
                                  let branch = FugitiveHead()
                                endif
                                if !empty(branch)
                                  let r = fugitive#Config('branch.'.branch.'.remote')
                                  let m = fugitive#Config('branch.'.branch.'.merge')[11:-1]
                                  if r ==# '.' && !empty(m)
                                    let r2 = fugitive#Config('branch.'.m.'.remote')
                                    if r2 !~# '^\.\=$'
                                      let r = r2
                                      let m = fugitive#Config('branch.'.m.'.merge')[11:-1]
                                    endif
                                  endif
                                  if empty(remote)
                                    let remote = r
                                  endif
                                  if r ==# '.' || r ==# remote
                                    let merge = m
                                    if path =~# '^\.git/refs/heads/.'
                                      let path = '.git/refs/heads/'.merge
                                    endif
                                  endif
                                endif
                            
                                let line1 = a:count > 0 ? a:line1 : 0
                                let line2 = a:count > 0 ? a:count : 0
                                if empty(commit) && path !~# '^\.git/'
                                  if a:count < 0 && !empty(merge)
                                    let commit = merge
                                  else
                                    let commit = ''
                                    if len(merge)
                                      let owner = s:Owner(@%)
                                      let [commit, exec_error] = s:ChompError(['merge-base', 'refs/remotes/' . remote . '/' . merge, empty(owner) ? 'HEAD' : owner, '--'])
                                      if exec_error
                                        let commit = ''
                                      endif
                                      if a:count > 0 && empty(a:args) && commit =~# '^\x\{40,\}$'
                                        let blame_list = tempname()
                                        call writefile([commit, ''], blame_list, 'b')
                                        let blame_in = tempname()
                                        silent exe '%write' blame_in
                                        let [blame, exec_error] = s:LinesError(['-c', 'blame.coloring=none', 'blame', '--contents', blame_in, '-L', a:line1.','.a:count, '-S', blame_list, '-s', '--show-number', './' . path])
                                        if !exec_error
                                          let blame_regex = '^\^\x\+\s\+\zs\d\+\ze\s'
                                          if get(blame, 0) =~# blame_regex && get(blame, -1) =~# blame_regex
                                            let line1 = +matchstr(blame[0], blame_regex)
                                            let line2 = +matchstr(blame[-1], blame_regex)
                                          else
                                            call s:throw("Can't browse to uncommitted change")
                                          endif
                                        endif
                                      endif
                                    endif
                                  endif
                                  if empty(commit)
                                    let commit = readfile(fugitive#Find('.git/HEAD', dir), '', 1)[0]
                                  endif
                                  let i = 0
                                  while commit =~# '^ref: ' && i < 10
                                    let commit = readfile(cdir . '/' . commit[5:-1], '', 1)[0]
                                    let i -= 1
                                  endwhile
                                endif
                            
                                if empty(remote)
                                  let remote = '.'
                                endif
                                let raw = fugitive#RemoteUrl(remote)
                                if empty(raw)
                                  let raw = remote
                                endif
                            
                                if raw =~# '^https\=://' && s:executable('curl')
                                  if !has_key(s:redirects, raw)
                                    let s:redirects[raw] = matchstr(system('curl -I ' . s:shellesc(raw . '/info/refs?service=git-upload-pack')), 'Location: \zs\S\+\ze/info/refs?')
                                  endif
                                  if len(s:redirects[raw])
                                    let raw = s:redirects[raw]
                                  endif
                                endif
                            
                                let opts = { 'dir': dir, 'repo': fugitive#repo(dir), 'remote': raw, 'revision': 'No longer provided', 'commit': commit, 'path': path, 'type': type, 'line1': line1, 'line2': line2}
                            
                                let url = ''
                                for Handler in get(g:, 'fugitive_browse_handlers', [])
                                  let url = call(Handler, [copy(opts)])
                                  if !empty(url)
                                    break
                                  endif
                                endfor
                            
                                if empty(url)
                                  call s:throw("No Gbrowse handler installed for '".raw."'")
                                endif
                            
                                let url = s:gsub(url, '[ <>]', '\="%".printf("%02X",char2nr(submatch(0)))')
                                if a:bang
                                  if has('clipboard')
                                    let @+ = url
                                  endif
                                  return 'echomsg '.string(url)
                                elseif exists(':Browse') == 2
                                  return 'echomsg '.string(url).'|Browse '.url
                                else
                                  if !exists('g:loaded_netrw')
                                    runtime! autoload/netrw.vim
                                  endif
                                  if exists('*netrw#BrowseX')
                                    return 'echomsg '.string(url).'|call netrw#BrowseX('.string(url).', 0)'
                                  else
                                    return 'echomsg '.string(url).'|call netrw#NetrwBrowseX('.string(url).', 0)'
                                  endif
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry

FUNCTION  go#util#ShellError()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000008   return v:shell_error

FUNCTION  fugitive#WqCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let bang = a:4 ? '!' : ''
                              if exists('b:fugitive_commit_arguments')
                                return 'wq'.bang
                              endif
                              let result = call('fugitive#WriteCommand', a:000)
                              if result =~# '^\%(write\|wq\|echoerr\)'
                                return s:sub(result,'^write','wq')
                              else
                                return result.'|quit'.bang
                              endif

FUNCTION  <SNR>5_PreGetPage()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:cnt == 0
                                let old_isk = &iskeyword
                                setl iskeyword+=(,)
                                let str = expand("<cword>")
                                let &l:iskeyword = old_isk
                                let page = substitute(str, '(*\(\k\+\).*', '\1', '')
                                let sect = substitute(str, '\(\k\+\)(\([^()]*\)).*', '\2', '')
                                if match(sect, '^[0-9 ]\+$') == -1
                                  let sect = ""
                                endif
                                if sect == page
                                  let sect = ""
                                endif
                              else
                                let sect = a:cnt
                                let page = expand("<cword>")
                              endif
                              call s:GetPage(sect, page)

FUNCTION  fugitive#BufReadStatus()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let amatch = s:Slash(expand('%:p'))
                              let b:fugitive_type = 'index'
                              unlet! b:fugitive_reltime
                              try
                                silent doautocmd BufReadPre
                                let cmd = [fnamemodify(amatch, ':h')]
                                setlocal noro ma nomodeline buftype=nowrite
                                if s:cpath(fnamemodify($GIT_INDEX_FILE !=# '' ? $GIT_INDEX_FILE : fugitive#Find('.git/index'), ':p')) !=# s:cpath(amatch)
                                  let cmd += ['-c', 'GIT_INDEX_FILE=' . amatch]
                                endif
                                let cmd += ['status', '--porcelain', '-bz']
                                let [output, message, exec_error] = s:NullError(cmd)
                                if exec_error
                                  throw 'fugitive: ' . message
                                endif
                            
                                let head = matchstr(output[0], '^## \zs\S\+\ze\%($\| \[\)')
                                let pull = ''
                                if head =~# '\.\.\.'
                                  let [head, pull] = split(head, '\.\.\.')
                                  let branch = head
                                elseif head ==# 'HEAD' || empty(head)
                                  let head = FugitiveHead(11)
                                  let branch = ''
                                else
                                  let branch = head
                                endif
                            
                                let b:fugitive_status = {'Staged': {}, 'Unstaged': {}}
                                let [staged, unstaged, untracked] = [[], [], []]
                                let i = 0
                                while i < len(output)
                                  let line = output[i]
                                  let file = line[3:-1]
                                  let files = file
                                  let i += 1
                                  if line[2] !=# ' '
                                    continue
                                  endif
                                  if line[0:1] =~# '[RC]'
                                    let files = output[i] . ' -> ' . file
                                    let i += 1
                                  endif
                                  if line[0] !~# '[ ?!#]'
                                    call add(staged, {'type': 'File', 'status': line[0], 'filename': files})
                                  endif
                                  if line[0:1] ==# '??'
                                    call add(untracked, {'type': 'File', 'status': line[1], 'filename': files})
                                  elseif line[1] !~# '[ !#]'
                                    call add(unstaged, {'type': 'File', 'status': line[1], 'filename': files})
                                  endif
                                endwhile
                            
                                for dict in staged
                                  let b:fugitive_status['Staged'][dict.filename] = dict.status
                                endfor
                                for dict in unstaged
                                  let b:fugitive_status['Unstaged'][dict.filename] = dict.status
                                endfor
                            
                                let config = fugitive#Config()
                            
                                let pull_type = 'Pull'
                                if len(pull)
                                  let rebase = fugitive#Config('branch.' . branch . '.rebase', config)
                                  if empty(rebase)
                                    let rebase = fugitive#Config('pull.rebase', config)
                                  endif
                                  if rebase =~# '^\%(true\|yes\|on\|1\|interactive\)$'
                                    let pull_type = 'Rebase'
                                  elseif rebase =~# '^\%(false\|no|off\|0\|\)$'
                                    let pull_type = 'Merge'
                                  endif
                                endif
                            
                                let push_remote = fugitive#Config('branch.' . branch . '.pushRemote', config)
                                if empty(push_remote)
                                  let push_remote = fugitive#Config('remote.pushDefault', config)
                                endif
                                let push = len(push_remote) && len(branch) ? push_remote . '/' . branch : ''
                                if empty(push)
                                  let push = pull
                                endif
                            
                                if len(pull)
                                  let unpulled = s:QueryLog(head . '..' . pull)
                                else
                                  let unpulled = []
                                endif
                                if len(push)
                                  let unpushed = s:QueryLog(push . '..' . head)
                                else
                                  let unpushed = []
                                endif
                            
                                if isdirectory(fugitive#Find('.git/rebase-merge/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-merge/')
                                elseif isdirectory(fugitive#Find('.git/rebase-apply/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-apply/')
                                endif
                            
                                let rebasing = []
                                let rebasing_head = 'detached HEAD'
                                if exists('rebasing_dir') && filereadable(rebasing_dir . 'git-rebase-todo')
                                  let rebasing_head = substitute(readfile(rebasing_dir . 'head-name')[0], '\C^refs/heads/', '', '')
                                  let len = 11
                                  let lines = readfile(rebasing_dir . 'git-rebase-todo')
                                  for line in lines
                                    let hash = matchstr(line, '^[^a-z].*\s\zs[0-9a-f]\{4,\}\ze\.\.')
                                    if len(hash)
                                      let len = len(hash)
                                      break
                                    endif
                                  endfor
                                  if getfsize(rebasing_dir . 'done') > 0
                                    let done = readfile(rebasing_dir . 'done')
                                    call map(done, 'substitute(v:val, ''^\l\+\>'', "done", "")')
                                    let done[-1] = substitute(done[-1], '^\l\+\>', 'stop', '')
                                    let lines = done + lines
                                  endif
                                  call reverse(lines)
                                  for line in lines
                                    let match = matchlist(line, '^\(\l\+\)\s\+\(\x\{4,\}\)\s\+\(.*\)')
                                    if len(match) && match[1] !~# 'exec\|merge\|label'
                                      call add(rebasing, {'type': 'Rebase', 'status': get(s:rebase_abbrevs, match[1], match[1]), 'commit': strpart(match[2], 0, len), 'subject': match[3]})
                                    endif
                                  endfor
                                endif
                            
                                let diff = {'Staged': [], 'Unstaged': []}
                                if len(staged)
                                  let diff['Staged'] = s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix', '--cached'])[0]
                                endif
                                if len(unstaged)
                                  let diff['Unstaged'] = s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix'])[0]
                                endif
                                let b:fugitive_diff = diff
                                let expanded = get(b:, 'fugitive_expanded', {'Staged': {}, 'Unstaged': {}})
                                let b:fugitive_expanded = {'Staged': {}, 'Unstaged': {}}
                            
                                silent keepjumps %delete_
                            
                                call s:AddHeader('Head', head)
                                call s:AddHeader(pull_type, pull)
                                if push !=# pull
                                  call s:AddHeader('Push', push)
                                endif
                                call s:AddSection('Rebasing ' . rebasing_head, rebasing)
                                call s:AddSection('Untracked', untracked)
                                call s:AddSection('Unstaged', unstaged)
                                let unstaged_end = len(unstaged) ? line('$') : 0
                                call s:AddSection('Staged', staged)
                                let staged_end = len(staged) ? line('$') : 0
                                call s:AddSection('Unpushed to ' . push, unpushed)
                                call s:AddSection('Unpulled from ' . pull, unpulled)
                            
                                setlocal nomodified readonly noswapfile
                                silent doautocmd BufReadPost
                                setlocal nomodifiable
                                if &bufhidden ==# ''
                                  setlocal bufhidden=delete
                                endif
                                let b:dispatch = ':Gfetch --all'
                                call fugitive#MapJumps()
                                call s:Map('n', '-', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
                                call s:Map('x', '-', ":<C-U>execute <SID>Do('Toggle',1)<CR>", '<silent>')
                                call s:Map('n', 's', ":<C-U>execute <SID>Do('Stage',0)<CR>", '<silent>')
                                call s:Map('x', 's', ":<C-U>execute <SID>Do('Stage',1)<CR>", '<silent>')
                                call s:Map('n', 'u', ":<C-U>execute <SID>Do('Unstage',0)<CR>", '<silent>')
                                call s:Map('x', 'u', ":<C-U>execute <SID>Do('Unstage',1)<CR>", '<silent>')
                                call s:Map('n', 'U', ":exe <SID>EchoExec('reset', '-q')<CR>", '<silent>')
                                call s:MapMotion('gu', "exe <SID>StageJump(v:count, 'Untracked', 'Unstaged')")
                                call s:MapMotion('gU', "exe <SID>StageJump(v:count, 'Unstaged', 'Untracked')")
                                call s:MapMotion('gs', "exe <SID>StageJump(v:count, 'Staged')")
                                call s:MapMotion('gp', "exe <SID>StageJump(v:count, 'Unpushed')")
                                call s:MapMotion('gP', "exe <SID>StageJump(v:count, 'Unpulled')")
                                call s:MapMotion('gr', "exe <SID>StageJump(v:count, 'Rebasing')")
                                call s:Map('n', 'C', ":<C-U>Gcommit<CR>:echohl WarningMsg<Bar>echo ':Gstatus C is deprecated in favor of cc'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'a', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
                                call s:Map('n', 'i', ":<C-U>execute <SID>NextExpandedHunk(v:count1)<CR>", '<silent>')
                                call s:Map('n', "=", ":<C-U>execute <SID>StageInline('toggle',line('.'),v:count)<CR>", '<silent>')
                                call s:Map('n', "<", ":<C-U>execute <SID>StageInline('hide',  line('.'),v:count)<CR>", '<silent>')
                                call s:Map('n', ">", ":<C-U>execute <SID>StageInline('show',  line('.'),v:count)<CR>", '<silent>')
                                call s:Map('x', "=", ":<C-U>execute <SID>StageInline('toggle',line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('x', "<", ":<C-U>execute <SID>StageInline('hide',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('x', ">", ":<C-U>execute <SID>StageInline('show',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('n', 'D', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'dd', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'dh', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'ds', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'dp', ":<C-U>execute <SID>StageDiffEdit()<CR>", '<silent>')
                                call s:Map('n', 'dv', ":<C-U>execute <SID>StageDiff('Gvdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
                                call s:Map('n', 'P', ":<C-U>execute <SID>StagePatch(line('.'),line('.')+v:count1-1)<CR>", '<silent>')
                                call s:Map('x', 'P', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                call s:Map('n', 'p', ":<C-U>if v:count<Bar>silent exe <SID>GF('pedit')<Bar>else<Bar>echoerr 'Use = for inline diff, P for :Git add/reset --patch, 1p for :pedit'<Bar>endif<CR>", '<silent>')
                                call s:Map('x', 'p', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                call s:Map('n', 'I', ":<C-U>execute <SID>StagePatch(line('.'),line('.'))<CR>", '<silent>')
                                call s:Map('x', 'I', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q :<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<Bar>echohl WarningMsg<Bar>echo ':Gstatus q is deprecated in favor of gq or the built-in <Lt>C-W>q'<Bar>echohl NONE<CR>
                                endif
                                call s:Map('n', 'gq', ":<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<CR>", '<silent>')
                                call s:Map('n', 'R', ":echohl WarningMsg<Bar>echo 'Reloading is automatic.  Use :e to force'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent>')
                                call s:Map('x', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent>')
                                call s:Map('n', 'X', ":<C-U>execute <SID>StageDelete(line('.'), 0, v:count)<CR>", '<silent>')
                                call s:Map('x', 'X', ":<C-U>execute <SID>StageDelete(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
                                call s:Map('n', 'gI', ":<C-U>execute <SID>StageIgnore(line('.'), line('.'), v:count)<CR>", '<silent>')
                                call s:Map('x', 'gI', ":<C-U>execute <SID>StageIgnore(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
                                call s:Map('n', '.', ':<C-U> <C-R>=<SID>StageArgs(0)<CR><Home>')
                                call s:Map('x', '.', ':<C-U> <C-R>=<SID>StageArgs(1)<CR><Home>')
                                setlocal filetype=fugitive
                            
                                for [lnum, section] in [[staged_end, 'Staged'], [unstaged_end, 'Unstaged']]
                                  while len(getline(lnum))
                                    let filename = matchstr(getline(lnum), '^[A-Z?] \zs.*')
                                    if has_key(expanded[section], filename)
                                      call s:StageInline('show', lnum)
                                    endif
                                    let lnum -= 1
                                  endwhile
                                endfor
                            
                                let b:fugitive_reltime = reltime()
                                return ''
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry

FUNCTION  go#config#HighlightFunctionParameters()
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                              " fallback to highlight_function_arguments for backwards compatibility
    3              0.000016   return get(g:, 'go_highlight_function_parameters', get(g:, 'go_highlight_function_arguments', 0))

FUNCTION  GoIndent()
Called 2 times
Total time:   0.000506
 Self time:   0.000506

count  total (s)   self (s)
    2              0.000060   let prevlnum = prevnonblank(a:lnum-1)
    2              0.000008   if prevlnum == 0
                                " top of file
                                return 0
    2              0.000005   endif
                            
                              " grab the previous and current line, stripping comments.
    2              0.000061   let prevl = substitute(getline(prevlnum), '//.*$', '', '')
    2              0.000017   let thisl = substitute(getline(a:lnum), '//.*$', '', '')
    2              0.000008   let previ = indent(prevlnum)
                            
    2              0.000004   let ind = previ
                            
    2              0.000129   for synid in synstack(a:lnum, 1)
                                if synIDattr(synid, 'name') == 'goRawString'
                                  if prevl =~ '\%(\%(:\?=\)\|(\|,\)\s*`[^`]*$'
                                    " previous line started a multi-line raw string
                                    return 0
                                  endif
                                  " return -1 to keep the current indent.
                                  return -1
                                endif
    2              0.000004   endfor
                            
    2              0.000032   if prevl =~ '[({]\s*$'
                                " previous line opened a block
                                let ind += shiftwidth()
    2              0.000002   endif
    2              0.000021   if prevl =~# '^\s*\(case .*\|default\):$'
                                " previous line is part of a switch statement
                                let ind += shiftwidth()
    2              0.000001   endif
                              " TODO: handle if the previous line is a label.
                            
    2              0.000011   if thisl =~ '^\s*[)}]'
                                " this line closed a block
                                let ind -= shiftwidth()
    2              0.000002   endif
                            
                              " Colons are tricky.
                              " We want to outdent if it's part of a switch ("case foo:" or "default:").
                              " We ignore trying to deal with jump labels because (a) they're rare, and
                              " (b) they're hard to disambiguate from a composite literal key.
    2              0.000013   if thisl =~# '^\s*\(case .*\|default\):$'
                                let ind -= shiftwidth()
    2              0.000002   endif
                            
    2              0.000004   return ind

FUNCTION  <SNR>103_Remove()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              if len(@%) && s:DirCommitFile(@%)[1] ==# ''
                                let cmd = ['rm']
                              elseif s:DirCommitFile(@%)[1] ==# '0'
                                let cmd = ['rm','--cached']
                              else
                                return 'echoerr ' . string('fugitive: rm not supported for this buffer')
                              endif
                              if a:force
                                let cmd += ['--force']
                              endif
                              let [message, exec_error] = s:ChompError(cmd + ['--', expand('%:p')], dir)
                              if exec_error
                                let v:errmsg = 'fugitive: '.s:sub(message,'error:.*\zs\n\(.*-f.*',' (add ! to force)')
                                return 'echoerr '.string(v:errmsg)
                              else
                                call fugitive#ReloadStatus(dir)
                                return a:after . (a:force ? '!' : '')
                              endif

FUNCTION  <SNR>103_diffoff_all()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let curwin = winnr()
                              for nr in range(1,winnr('$'))
                                if getwinvar(nr,'&diff')
                                  if nr != winnr()
                                    execute nr.'wincmd w'
                                    let restorewinnr = 1
                                  endif
                                  if s:Dir() ==# a:dir
                                    call s:diffoff()
                                  endif
                                endif
                              endfor
                              execute curwin.'wincmd w'

FUNCTION  sy#util#return_if_no_changes()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('b:sy') || empty(b:sy.hunks)
                                echomsg 'signify: There are no changes.'
                                return 'return'
                              endif
                              return ''

FUNCTION  <SNR>103_PreparePathArgs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let literal_supported = fugitive#GitVersion(1, 9)
                              if a:literal && literal_supported
                                call insert(a:cmd, '--literal-pathspecs')
                              endif
                              let split = index(a:cmd, '--')
                              for i in range(split < 0 ? len(a:cmd) : split)
                                if type(a:cmd[i]) == type(0)
                                  let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                endif
                              endfor
                              if split < 0
                                return a:cmd
                              endif
                              for i in range(split + 1, len(a:cmd) - 1)
                                if type(a:cmd[i]) == type(0)
                                  let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                elseif a:literal
                                  let a:cmd[i] = fugitive#Path(a:cmd[i], './', a:dir)
                                elseif !literal_supported
                                  let a:cmd[i] = substitute(a:cmd[i], '^:\%(/\|([^)]*)\)\=:\=', './', '')
                                endif
                              endfor
                              return a:cmd

FUNCTION  go#config#TermMode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_term_mode', 'vsplit')

FUNCTION  <SNR>59_LocalBrowse()
Called 2 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
    2              0.000007   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
    1              0.000002    return
    1              0.000000   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    1              0.000004   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    1              0.000005   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
    1              0.000000   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    1              0.000001   endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  <SNR>34_subesc()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(a:pattern,'[][\\/.*+?~%()&]','\\&','g')

FUNCTION  <SNR>103_Uniq()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let i = 0
                              let seen = {}
                              while i < len(a:list)
                                let str = string(a:list[i])
                                if has_key(seen, str)
                                  call remove(a:list, i)
                                else
                                  let seen[str] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:list

FUNCTION  <SNR>103_QuickfixSet()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:nr < 0
                                return call('setqflist', a:000)
                              else
                                return call('setloclist', [a:nr] + a:000)
                              endif

FUNCTION  go#list#Close()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let autoclose_window = go#config#ListAutoclose()
                              if !autoclose_window
                                return
                              endif
                            
                              if a:listtype == "locationlist"
                                lclose
                              else
                                cclose
                              endif

FUNCTION  sy#repo#get_stats()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return exists('b:sy') ? b:sy.stats : [-1, -1, -1]

FUNCTION  qf#PreviewFileUnderCursor()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let cur_list = b:qf_isLoc == 1 ? getloclist('.') : getqflist()
                                let cur_line = getline(line('.'))
                                let cur_file = fnameescape(substitute(cur_line, '|.*$', '', ''))
                                if cur_line =~ '|\d\+'
                                    let cur_pos  = substitute(cur_line, '^\(.\{-}|\)\(\d\+\)\(.*\)', '\2', '')
                                    execute "pedit +" . cur_pos . " " . cur_file
                                else
                                    execute "pedit " . cur_file
                                endif

FUNCTION  <SNR>97_clear()
Called 2 times
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
    4              0.000018   for [status_dir, status] in items(s:statuses)
    2              0.000016     let elapsed_time = reltimestr(reltime(status.created_at))
                                " strip whitespace
    2              0.000065     let elapsed_time = substitute(elapsed_time, '^\s*\(.\{-}\)\s*$', '\1', '')
                            
    2              0.000009     if str2nr(elapsed_time) > 10
                                  call remove(s:statuses, status_dir)
    2              0.000003     endif
    4              0.000006   endfor
                            
    2              0.000006   if len(s:statuses) == 0
                                let s:statuses = {}
    2              0.000002   endif
                            
                              " force to update the statusline, otherwise the user needs to move the
                              " cursor
    2              0.000018   exe 'let &ro = &ro'

FUNCTION  gutentags#validate_cmd()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000004     if !empty(a:cmd) && executable(split(a:cmd)[0])
                                    return a:cmd
    1              0.000001     endif
    1              0.000001     return ""

FUNCTION  go#config#HighlightArrayWhitespaceError()
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    3              0.000013   return get(g:, 'go_highlight_array_whitespace_error', 0)

FUNCTION  <SNR>7_Ref()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let len = strlen(a:string)
                              if a:d == 0
                                let start = 0
                              else
                                let cnt = a:d
                                let match = a:string
                                while cnt
                                  let cnt = cnt - 1
                                  let index = matchend(match, s:notslash . '\\(')
                                  if index == -1
                            	return ""
                                  endif
                                  let match = strpart(match, index)
                                endwhile
                                let start = len - strlen(match)
                                if a:0 == 1 && a:1 == "start"
                                  return start - 2
                                endif
                                let cnt = 1
                                while cnt
                                  let index = matchend(match, s:notslash . '\\(\|\\)') - 1
                                  if index == -2
                            	return ""
                                  endif
                                  " Increment if an open, decrement if a ')':
                                  let cnt = cnt + (match[index]=="(" ? 1 : -1)  " ')'
                                  " let cnt = stridx('0(', match[index]) + cnt
                                  let match = strpart(match, index+1)
                                endwhile
                                let start = start - 2
                                let len = len - start - strlen(match)
                              endif
                              if a:0 == 1
                                return len
                              elseif a:0 == 2
                                return "let " . a:1 . "=" . start . "| let " . a:2 . "=" . len
                              else
                                return strpart(a:string, start, len)
                              endif

FUNCTION  qf#SetList()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " generate partial
                                let Func = get(b:, 'qf_isLoc', 0) ? function('setloclist', [0, a:newlist]) : function('setqflist', [a:newlist])
                            
                                " get user-defined maximum height
                                let max_height = get(g:, 'qf_max_height', 10) < 1 ? 10 : get(g:, 'qf_max_height', 10)
                            
                                " call partial with optional arguments
                                call call(Func, a:000)
                            
                                if get(b:, 'qf_isLoc', 0)
                                    execute get(g:, "qf_auto_resize", 1) ? 'lclose|' . min([ max_height, len(getloclist(0)) ]) . 'lwindow' : 'lwindow'
                                else
                                    execute get(g:, "qf_auto_resize", 1) ? 'cclose|' . min([ max_height, len(getqflist()) ]) . 'cwindow' : 'cwindow'
                                endif

FUNCTION  go#job#Spawn()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:options = go#job#Options(a:args)
                              return go#job#Start(a:cmd, l:options)

FUNCTION  gutentags#statusline_cb()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let l:modules_in_progress = gutentags#inprogress()
                            
                                if (a:0 == 0 || !a:1) && empty(l:modules_in_progress)
                                   return ''
                                endif
                            
                                return call(a:fmt_cb, [l:modules_in_progress])

FUNCTION  <SNR>103_SplitExpandChain()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:ExpandSplit(a:string, 1, a:0 ? a:1 : getcwd())

FUNCTION  fugitive#Command()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Dir()
                              let [args, after] = s:SplitExpandChain(a:arg, s:Tree(dir))
                              if empty(args)
                                let cmd = s:StatusCommand(a:line1, a:line2, a:range, a:line2, a:bang, a:mods, '', '', [])
                                return (empty(cmd) ? 'exe' : cmd) . after
                              endif
                              let alias = get(s:Aliases(dir), args[0], '!')
                              if get(args, 1, '') !=# '--help' && alias !~# '^!\|[\"'']' && !filereadable(s:ExecPath() . '/git-' . args[0]) && !(has('win32') && filereadable(s:ExecPath() . '/git-' . args[0] . '.exe'))
                                call remove(args, 0)
                                call extend(args, split(alias, '\s\+'), 'keep')
                              endif
                              let name = substitute(args[0], '\%(^\|-\)\(\l\)', '\u\1', 'g')
                              if exists('*s:' . name . 'Subcommand') && get(args, 1, '') !=# '--help'
                                try
                                  exe s:DirCheck(dir)
                                  return 'exe ' . string(s:{name}Subcommand(a:line1, a:line2, a:range, a:bang, a:mods, args[1:-1])) . after
                                catch /^fugitive:/
                                  return 'echoerr ' . string(v:exception)
                                endtry
                              endif
                              if a:bang || args[0] =~# '^-P$\|^--no-pager$\|diff\%(tool\)\@!\|log\|^show$' || (args[0] ==# 'stash' && get(args, 1, '') ==# 'show') || (args[0] ==# 'help' || get(args, 1, '') ==# '--help') && !s:HasOpt(args, '--web')
                                return s:OpenExec((a:line2 > 0 ? a:line2 : '') . (a:line2 ? 'split' : 'edit'), a:mods, args, dir) . after
                              endif
                              if s:HasOpt(args, ['add', 'checkout', 'commit', 'stage', 'stash', 'reset'], '-p', '--patch') || s:HasOpt(args, ['add', 'clean', 'stage'], '-i', '--interactive') || index(['--paginate', '-p'], args[0]) >= 0
                                let mods = substitute(s:Mods(a:mods), '\<tab\>', '-tab', 'g')
                                let assign = len(dir) ? '|let b:git_dir = ' . string(dir) : ''
                                if has('nvim')
                                  if &autowrite || &autowriteall | silent! wall | endif
                                  return mods . (a:line2 ? 'split' : 'edit') . ' term://' . s:fnameescape(s:UserCommand(dir, args)) . assign . '|startinsert' . after
                                elseif has('terminal')
                                  if &autowrite || &autowriteall | silent! wall | endif
                                  return 'exe ' . string(mods . 'terminal ' . (a:line2 ? '' : '++curwin ') . join(map(s:UserCommandList(dir) + args, 's:fnameescape(v:val)'))) . assign . after
                                endif
                              endif
                              if has('gui_running') && !has('win32')
                                call insert(args, '--no-pager')
                              endif
                              let pre = ''
                              if has('nvim') && executable('env')
                                let pre .= 'env GIT_TERMINAL_PROMPT=0 '
                              endif
                              return 'exe ' . string('!' . escape(pre . s:UserCommand(dir, args), '!#%')) . after

FUNCTION  <SNR>100_check_diff_cvs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [found_diff, diff] = [0, []]
                              if a:exitval == 1
                                for diffline in a:diff
                                  if diffline =~ '^+++'
                                    let [found_diff, diff] = [1, a:diff]
                                    break
                                  endif
                                endfor
                              elseif a:exitval == 0 && len(a:diff) == 0
                                let found_diff = 1
                              endif
                              return [found_diff, diff]

FUNCTION  <SNR>103_PullSubcommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:MergeRebase('pull', a:bang, a:mods, a:args)

FUNCTION  gutentags#warning()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                echohl WarningMsg
                                echom "gutentags: " . a:message
                                echohl None

FUNCTION  <SNR>103_DirCommitFile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let vals = matchlist(s:Slash(a:path), '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if empty(vals)
                                return ['', '', '']
                              endif
                              return vals[1:3]

FUNCTION  go#list#JumpToFirst()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:listtype == "locationlist"
                                ll 1
                              else
                                cc 1
                              endif

FUNCTION  fugitive#CompleteObject()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 == 1 ? a:1 : a:0 == 3 ? a:3 : s:Dir()
                              let cwd = getcwd()
                              let tree = s:Tree(dir) . '/'
                              let subdir = ''
                              if len(tree) > 1 && s:cpath(tree, cwd[0 : len(tree) - 1])
                                let subdir = strpart(cwd, len(tree)) . '/'
                              endif
                            
                              if a:base =~# '^\.\=/\|^:(' || a:base !~# ':'
                                let results = []
                                if a:base =~# '^refs/'
                                  let results += map(s:GlobComplete(fugitive#CommonDir(dir) . '/', a:base . '*'), 's:Slash(v:val)')
                                elseif a:base !~# '^\.\=/\|^:('
                                  let heads = ['HEAD', 'ORIG_HEAD', 'FETCH_HEAD', 'MERGE_HEAD', 'refs/']
                                  let heads += sort(s:LinesError(["rev-parse","--symbolic","--branches","--tags","--remotes"], dir)[0])
                                  if filereadable(fugitive#Find('.git/refs/stash', dir))
                                    let heads += ["stash"]
                                    let heads += sort(s:LinesError(["stash","list","--pretty=format:%gd"], dir)[0])
                                  endif
                                  call filter(heads,'v:val[ 0 : strlen(a:base)-1 ] ==# a:base')
                                  let results += heads
                                endif
                                call map(results, 's:fnameescape(v:val)')
                                if !empty(tree)
                                  let results += a:0 == 1 ? fugitive#CompletePath(a:base, dir) : fugitive#CompletePath(a:base)
                                endif
                                return results
                            
                              elseif a:base =~# '^:'
                                let entries = s:LinesError(['ls-files','--stage'], dir)[0]
                                if a:base =~# ':\./'
                                  call map(entries, 'substitute(v:val, "\\M\t\\zs" . subdir, "./", "")')
                                endif
                                call map(entries,'s:sub(v:val,".*(\\d)\\t(.*)",":\\1:\\2")')
                                if a:base !~# '^:[0-3]\%(:\|$\)'
                                  call filter(entries,'v:val[1] == "0"')
                                  call map(entries,'v:val[2:-1]')
                                endif
                            
                              else
                                let tree = matchstr(a:base, '.*[:/]')
                                let entries = s:LinesError(['ls-tree', substitute(tree,  ':\zs\./', '\=subdir', '')], dir)[0]
                                call map(entries,'s:sub(v:val,"^04.*\\zs$","/")')
                                call map(entries,'tree.s:sub(v:val,".*\t","")')
                            
                              endif
                              return s:FilterEscape(entries, a:base)

FUNCTION  <SNR>103_CompleteRevision()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:FilterEscape(['HEAD', 'FETCH_HEAD', 'MERGE_HEAD', 'ORIG_HEAD'] + s:LinesError('rev-parse', '--symbolic', '--branches', '--tags', '--remotes')[0], a:A)

FUNCTION  <SNR>103_StageArgs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let commits = []
                              let paths = []
                              for record in s:Selection(a:visual ? 'v' : 'n')
                                if len(record.commit)
                                  call add(commits, record.commit)
                                endif
                                call extend(paths, record.paths)
                              endfor
                              if s:cpath(s:Tree(), getcwd())
                                call map(paths, 'fugitive#Path(v:val, "./")')
                              endif
                              return join(map(commits + paths, 's:fnameescape(v:val)'), ' ')

FUNCTION  <SNR>59_VimEnter()
Called 1 time
Total time:   0.001018
 Self time:   0.000967

count  total (s)   self (s)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
    1              0.000004   let curwin       = winnr()
    1              0.000002   let s:vimentered = 1
    1   0.001001   0.000950   windo call s:LocalBrowse(expand("%:p"))
    1              0.000008   exe curwin."wincmd w"
                            "  call Dret("s:VimEnter")

FUNCTION  <SNR>103_LinesError()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [out, exec_error] = call('s:ChompError', a:000)
                              return [len(out) && !exec_error ? split(out, "\n", 1) : [], exec_error]

FUNCTION  <SNR>103_IsConflicted()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return len(@%) && !empty(s:ChompDefault('', 'ls-files', '--unmerged', '--', expand('%:p')))

FUNCTION  <SNR>34_camelcase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let word = substitute(a:word, '-', '_', 'g')
                              if word !~# '_' && word =~# '\l'
                                return substitute(word,'^.','\l&','')
                              else
                                return substitute(word,'\C\(_\)\=\(.\)','\=submatch(1)==""?tolower(submatch(2)) : toupper(submatch(2))','g')
                              endif

FUNCTION  <SNR>34_SubComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:A =~ '^[/?]\k\+$'
                                let char = strpart(a:A,0,1)
                                return join(map(s:words(),'char . v:val'),"\n")
                              elseif a:A =~# '^\k\+$'
                                return join(s:words(),"\n")
                              endif

FUNCTION  <SNR>34_throw()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let v:errmsg = a:msg
                              throw "Abolish: ".a:msg

FUNCTION  fugitive#Config()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Dir()
                              let name = ''
                              if a:0 >= 2 && type(a:2) == type({})
                                let name = substitute(a:1, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                                return len(a:1) ? get(get(a:2, name, []), 0, '') : a:2
                              elseif a:0 >= 2
                                let dir = a:2
                                let name = a:1
                              elseif a:0 == 1 && type(a:1) == type({})
                                return a:1
                              elseif a:0 == 1 && a:1 =~# '^[[:alnum:]-]\+\.'
                                let name = a:1
                              elseif a:0 == 1
                                let dir = a:1
                              endif
                              let name = substitute(name, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                              let key = len(dir) ? dir : '_'
                              if has_key(s:config, key) && s:config[key][0] ==# s:ConfigTimestamps(dir, s:config[key][1])
                                let dict = s:config[key][1]
                              else
                                let dict = {}
                                let [lines, message, exec_error] = s:NullError([dir, 'config', '--list', '-z'])
                                if exec_error
                                  return {}
                                endif
                                for line in lines
                                  let key = matchstr(line, "^[^\n]*")
                                  if !has_key(dict, key)
                                    let dict[key] = []
                                  endif
                                  call add(dict[key], strpart(line, len(key) + 1))
                                endfor
                                let s:config[dir] = [s:ConfigTimestamps(dir, dict), dict]
                                lockvar! dict
                              endif
                              return len(name) ? get(get(dict, name, []), 0, '') : dict

FUNCTION  fugitive#ReloadStatus()
Called 1 time
Total time:   0.000248
 Self time:   0.000113

count  total (s)   self (s)
    1   0.000142   0.000014   call s:ExpireStatus(a:0 ? a:1 : -2)
    1              0.000006   if a:0 > 1 ? a:2 : s:CanAutoReloadStatus()
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
    1              0.000001   else
    1   0.000016   0.000009     call s:ReloadWinStatus()
    1              0.000001   endif

FUNCTION  <SNR>100_callback_nvim_stdout()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let self.stdoutbuf[-1] .= a:data[0]
                              call extend(self.stdoutbuf, a:data[1:])

FUNCTION  sy#sign#process_diff()
Called 1 time
Total time:   0.019802
 Self time:   0.006308

count  total (s)   self (s)
    1              0.000004   let a:sy.signtable             = {}
    1              0.000003   let a:sy.hunks                 = []
    1              0.000004   let [added, modified, deleted] = [0, 0, 0]
                            
    1   0.000116   0.000006   call sy#sign#get_current_signs(a:sy)
                            
                              " Determine where we have to put our signs.
   20              0.000355   for line in filter(a:diff, 'v:val =~ "^@@ "')
   19              0.000054     let a:sy.lines = []
   19              0.000031     let ids        = []
                            
   19   0.001168   0.000188     let [old_line, new_line, old_count, new_count] = sy#sign#parse_hunk(line)
                            
                                " Workaround for non-conventional diff output in older Fossil versions:
                                " https://fossil-scm.org/forum/forumpost/834ce0f1e1
                                " Fixed as of: https://fossil-scm.org/index.html/info/7fd2a3652ea7368a
   19              0.000066     if a:vcs == 'fossil' && new_line == 0
                                  let new_line = old_line - 1 - deleted
   19              0.000016     endif
                            
                                " 2 lines added:
                            
                                " @@ -5,0 +6,2 @@ this is line 5
                                " +this is line 5
                                " +this is line 5
   19              0.000049     if (old_count == 0) && (new_count >= 1)
    9              0.000020       let added += new_count
    9              0.000013       let offset = 0
   60              0.000120       while offset < new_count
   51              0.000170         let line    = new_line + offset
   51              0.000087         let offset += 1
  102   0.001054   0.000370         if s:external_sign_present(a:sy, line) | continue | endif
   51   0.004016   0.000426         call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
   60              0.000085       endwhile
                            
                                " 2 lines removed:
                            
                                " @@ -6,2 +5,0 @@ this is line 5
                                " -this is line 6
                                " -this is line 7
   10              0.000026     elseif (old_count >= 1) && (new_count == 0)
   12   0.000130   0.000044       if s:external_sign_present(a:sy, new_line) | continue | endif
    6              0.000014       let deleted += old_count
    6              0.000008       if new_line == 0
                                    call add(ids, s:add_sign(a:sy, 1, 'SignifyRemoveFirstLine'))
    6              0.000009       elseif s:sign_show_count
    6              0.000025         let text = s:sign_delete . (old_count <= 99 ? old_count : '>')
    7              0.000021         while strwidth(text) > 2
    1              0.000010           let text = substitute(text, '.', '', '')
    7              0.000006         endwhile
    6   0.000753   0.000069         call add(ids, s:add_sign(a:sy, new_line, 'SignifyDelete'. old_count, text))
                                  else
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDeleteMore', s:sign_delete))
    6              0.000007       endif
                            
                                " 2 lines changed:
                            
                                " @@ -5,2 +5,2 @@ this is line 4
                                " -this is line 5
                                " -this is line 6
                                " +this os line 5
                                " +this os line 6
    4              0.000005     elseif old_count == new_count
                                  let modified += old_count
                                  let offset    = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                  endwhile
    4              0.000004     else
                            
                                  " 2 lines changed; 2 lines removed:
                            
                                  " @@ -5,4 +5,2 @@ this is line 4
                                  " -this is line 5
                                  " -this is line 6
                                  " -this is line 7
                                  " -this is line 8
                                  " +this os line 5
                                  " +this os line 6
    4              0.000007       if old_count > new_count
    2              0.000004         let modified += new_count
    2              0.000006         let removed   = old_count - new_count
    2              0.000004         let deleted  += removed
    2              0.000002         let offset    = 0
    8              0.000024         while offset < new_count - 1
    6              0.000018           let line    = new_line + offset
    6              0.000021           let offset += 1
   12   0.000119   0.000045           if s:external_sign_present(a:sy, line) | continue | endif
    6   0.001379   0.000049           call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
    8              0.000017         endwhile
    2              0.000006         let line = new_line + offset
    4   0.000038   0.000013         if s:external_sign_present(a:sy, line) | continue | endif
    2   0.000298   0.000044         call add(ids, s:add_sign(a:sy, line, (removed > 9) ? 'SignifyChangeDeleteMore' : 'SignifyChangeDelete'. removed))
                            
                                  " lines changed and added:
                            
                                  " @@ -5 +5,3 @@ this is line 4
                                  " -this is line 5
                                  " +this os line 5
                                  " +this is line 42
                                  " +this is line 666
    2              0.000002       else
    2              0.000005         let modified += old_count
    2              0.000004         let offset    = 0
    5              0.000010         while offset < old_count
    3              0.000010           let line    = new_line + offset
    3              0.000005           let offset += 1
    5   0.000069   0.000022           if s:external_sign_present(a:sy, line) | continue | endif
    3   0.005100   0.000028           call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
    5              0.000008         endwhile
    5              0.000011         while offset < new_count
    3              0.000007           let added  += 1
    3              0.000012           let line    = new_line + offset
    3              0.000005           let offset += 1
    5   0.000062   0.000022           if s:external_sign_present(a:sy, line) | continue | endif
    3   0.000527   0.000027           call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
    5              0.000014         endwhile
    4              0.000004       endif
   19              0.000013     endif
                            
   19              0.000075     if !empty(ids)
   19              0.000237       call add(a:sy.hunks, { 'ids'  : ids, 'start': a:sy.lines[0], 'end'  : a:sy.lines[-1] })
   19              0.000025     endif
   20              0.000021   endfor
                            
                              " Remove obsoleted signs.
    1              0.000007   for line in filter(keys(a:sy.internal), '!has_key(a:sy.signtable, v:val)')
                                execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
    1              0.000001   endfor
                            
    1              0.000007   if has('gui_macvim') && has('gui_running') && mode() == 'n'
                                " MacVim needs an extra kick in the butt, when setting signs from the
                                " exit handler. :redraw would trigger a "hanging cursor" issue.
                                call feedkeys("\<c-l>", 'n')
    1              0.000001   endif
                            
    1              0.000003   if empty(a:sy.updated_by) && empty(a:sy.hunks)
                                call sy#verbose('Successful exit value, but no diff. Keep VCS for time being.', a:vcs)
                                return
    1              0.000000   endif
                            
    1   0.000027   0.000009   call sy#verbose('Signs updated.', a:vcs)
    1              0.000002   let a:sy.updated_by = a:vcs
    1              0.000002   if len(a:sy.vcs) > 1
                                call sy#verbose('Disable all other VCS.', a:vcs)
                                let a:sy.vcs = [a:vcs]
    1              0.000001   endif
                            
    1              0.000004   let a:sy.stats = [added, modified, deleted]

FUNCTION  go#config#InfoMode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_info_mode', 'gopls')

FUNCTION  <SNR>92_infoDefinitionHandler()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " gopls returns a []Location; just take the first one.
                              let l:msg = a:msg[0]
                            
                              let l:fname = go#path#FromURI(l:msg.uri)
                              let l:line = l:msg.range.start.line
                              let l:col = l:msg.range.start.character
                            
                              let l:lsp = s:lspfactory.get()
                              let l:msg = go#lsp#message#Hover(l:fname, l:line, l:col)
                            
                              if a:showstatus
                                let l:state = s:newHandlerState('info')
                              else
                                let l:state = s:newHandlerState('')
                              endif
                            
                              let l:state.handleResult = funcref('s:hoverHandler', [a:next], l:state)
                              let l:state.error = funcref('s:noop')
                              return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  fugitive#GitVersion()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !has_key(s:git_versions, g:fugitive_git_executable)
                                let s:git_versions[g:fugitive_git_executable] = matchstr(system(g:fugitive_git_executable.' --version'), '\d[^[:space:]]\+')
                              endif
                              if !a:0
                                return s:git_versions[g:fugitive_git_executable]
                              endif
                              let components = split(s:git_versions[g:fugitive_git_executable], '\D\+')
                              if empty(components)
                                return -1
                              endif
                              for i in range(len(a:000))
                                if a:000[i] > +get(components, i)
                                  return 0
                                elseif a:000[i] < +get(components, i)
                                  return 1
                                endif
                              endfor
                              return a:000[i] ==# get(components, i)

FUNCTION  go#path#Default()
Called 3 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    3              0.000007   if $GOPATH == ""
                                " use default GOPATH via go env
                                return go#util#env("gopath")
    3              0.000003   endif
                            
    3              0.000004   return $GOPATH

FUNCTION  <SNR>103_StatusCfile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let tree = s:Tree()
                              let lead = s:cpath(tree, getcwd()) ? './' : tree . '/'
                              let info = s:StageInfo()
                              let line = getline('.')
                              if len(info.sigil) && len(info.section) && len(info.paths)
                                if info.section ==# 'Unstaged' && info.sigil !=# '-'
                                  return [lead . info.relative[0], info.offset, 'normal!zv']
                                elseif info.section ==# 'Staged' && info.sigil ==# '-'
                                  return ['@:' . info.relative[0], info.offset, 'normal!zv']
                                else
                                  return [':0:' . info.relative[0], info.offset, 'normal!zv']
                                endif
                              elseif len(info.paths)
                                return [lead . info.relative[0]]
                              elseif len(info.commit)
                                return [info.commit]
                              elseif line =~# '^\%(Head\|Merge\|Rebase\|Upstream\|Pull\|Push\): '
                                return [matchstr(line, ' \zs.*')]
                              else
                                return ['']
                              endif

FUNCTION  <SNR>34_egrep_pattern()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:boundaries == 2
                                let a = '\<'
                                let b = '\>'
                              elseif a:boundaries
                                let a = '(\<\|_)'
                                let b = '(\>\|_\|[[:upper:]][[:lower:]])'
                              else
                                let a = ''
                                let b = ''
                              endif
                              return a.'('.join(map(sort(keys(a:dict),function('s:sort')),'s:subesc(v:val)'),'\|').')'.b

FUNCTION  go#job#Start()
Called 1 time
Total time:   0.000771
 Self time:   0.000753

count  total (s)   self (s)
    1              0.000010   let l:cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : 'cd'
    1              0.000006   let l:options = copy(a:options)
                            
    1              0.000004   if has('nvim')
                                let l:options = s:neooptions(l:options)
    1              0.000001   endif
                            
                              " Verify that the working directory for the job actually exists. Return
                              " early if the directory does not exist. This helps avoid errors when
                              " working with plugins that use virtual files that don't actually exist on
                              " the file system.
    1              0.000021   let l:filedir = expand("%:p:h")
    1              0.000008   if has_key(l:options, 'cwd') && !isdirectory(l:options.cwd)
                                  return
    1              0.000004   elseif !isdirectory(l:filedir)
                                return
    1              0.000001   endif
                            
    1              0.000003   let l:manualcd = 0
    1              0.000011   if !has_key(l:options, 'cwd')
                                " pre start
                                let l:manualcd = 1
                                let dir = getcwd()
                                execute l:cd fnameescape(filedir)
    1              0.000005   elseif !(has("patch-8.0.0902") || has('nvim'))
                                let l:manualcd = 1
                                let l:dir = l:options.cwd
                                execute l:cd fnameescape(l:dir)
                                call remove(l:options, 'cwd')
    1              0.000001   endif
                            
    1              0.000003   if has_key(l:options, '_start')
                                call l:options._start()
                                " remove _start to play nicely with vim (when vim encounters an unexpected
                                " job option it reports an "E475: invalid argument" error).
                                unlet l:options._start
    1              0.000001   endif
                            
                              " noblock was added in 8.1.350; remove it if it's not supported.
    1              0.000008   if has_key(l:options, 'noblock') && (has('nvim') || !has("patch-8.1.350"))
    1              0.000004     call remove(l:options, 'noblock')
    1              0.000001   endif
                            
    1   0.000017   0.000004   if go#util#HasDebug('shell-commands')
                                call go#util#EchoInfo('job command: ' . string(a:cmd))
    1              0.000001   endif
                            
    1              0.000003   if has('nvim')
                                let l:input = []
                                if has_key(a:options, 'in_io') && a:options.in_io ==# 'file' && !empty(a:options.in_name)
                                  let l:input = readfile(a:options.in_name, "b")
                                endif
                            
                                let job = jobstart(a:cmd, l:options)
                            
                                if len(l:input) > 0
                                  call chansend(job, l:input)
                                  " close stdin to signal that no more bytes will be sent.
                                  call chanclose(job, 'stdin')
                                endif
    1              0.000001   else
    1              0.000002     let l:cmd = a:cmd
    1   0.000008   0.000003     if go#util#IsWin()
                                  let l:cmd = join(map(copy(a:cmd), function('s:winjobarg')), " ")
    1              0.000001     endif
                            
    1              0.000558     let job = job_start(l:cmd, l:options)
    1              0.000010   endif
                            
    1              0.000003   if l:manualcd
                                " post start
                                execute l:cd fnameescape(l:dir)
    1              0.000001   endif
                            
    1              0.000002   return job

FUNCTION  <SNR>103_ChompDefault()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [out, exec_error] = call('s:ChompError', a:000)
                              return exec_error ? a:default : out

FUNCTION  go#fmt#run()
Called 1 time
Total time:   0.029939
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000064   0.000007   let l:cmd = s:fmt_cmd(a:bin_name, a:source, a:target)
    1              0.000004   if empty(l:cmd)
                                return
    1              0.000002   endif
    1   0.029866   0.000019   return go#util#Exec(l:cmd)

FUNCTION  <SNR>49_inputreplacement()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let c = s:getchar()
                              if c == " "
                                let c .= s:getchar()
                              endif
                              if c =~ "\<Esc>" || c =~ "\<C-C>"
                                return ""
                              else
                                return c
                              endif

FUNCTION  go#util#osarch()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return go#util#env("goos") . '_' . go#util#env("goarch")

FUNCTION  <SNR>100_callback_vim_close()
Called 1 time
Total time:   0.021288
 Self time:   0.000077

count  total (s)   self (s)
    1              0.000004   let job = ch_getjob(a:channel)
    1              0.000002   while 1
    1              0.000032     if job_status(job) == 'dead'
    1              0.000009       let exitval = job_info(job).exitval
    1              0.000002       break
                                endif
                                sleep 10m
    1              0.000002   endwhile
    1   0.021232   0.000021   return s:handle_diff(self, exitval)

FUNCTION  <SNR>34_substitute_command()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let opts = s:normalize_options(a:flags)
                              let dict = s:create_dictionary(a:bad,a:good,opts)
                              let lhs = s:pattern(dict,opts.boundaries)
                              let g:abolish_last_dict = dict
                              return a:cmd.'/'.lhs.'/\=Abolished()'."/".opts.flags

FUNCTION  Abolished()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:abolish_last_dict,submatch(0),submatch(0))

FUNCTION  <SNR>49_extractbefore()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:str =~ '\r'
                                return matchstr(a:str,'.*\ze\r')
                              else
                                return matchstr(a:str,'.*\ze\n')
                              endif

FUNCTION  <SNR>103_NavigateUp()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let rev = substitute(s:DirRev(@%)[1], '^$', ':', 'g')
                              let c = a:count
                              while c
                                if rev =~# ':.*/.'
                                  let rev = matchstr(rev, '.*\ze/.\+', '')
                                elseif rev =~# '.:.'
                                  let rev = matchstr(rev, '^.[^:]*:')
                                elseif rev =~# '^:'
                                  let rev = 'HEAD^{}'
                                elseif rev =~# ':$'
                                  let rev = rev[0:-2]
                                else
                                  return rev.'~'.c
                                endif
                                let c -= 1
                              endwhile
                              return rev

FUNCTION  fugitive#PathComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return call('fugitive#CompletePath', a:000)

FUNCTION  fugitive#WriteCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('b:fugitive_commit_arguments')
                                return 'write|bdelete'
                              elseif expand('%:t') == 'COMMIT_EDITMSG' && $GIT_INDEX_FILE != ''
                                return 'wq'
                              elseif get(b:, 'fugitive_type', '') ==# 'index'
                                return 'Gcommit'
                              elseif &buftype ==# 'nowrite' && getline(4) =~# '^+++ '
                                let filename = getline(4)[6:-1]
                                setlocal buftype=
                                silent write
                                setlocal buftype=nowrite
                                if matchstr(getline(2),'index [[:xdigit:]]\+\.\.\zs[[:xdigit:]]\{7\}') ==# fugitive#RevParse(':0:'.filename)[0:6]
                                  let [message, exec_error] = s:ChompError(['apply', '--cached', '--reverse', '--', expand('%:p')])
                                else
                                  let [message, exec_error] = s:ChompError(['apply', '--cached', '--', expand('%:p')])
                                endif
                                if exec_error
                                  echohl ErrorMsg
                                  echo message
                                  echohl NONE
                                  return ''
                                elseif a:bang
                                  return 'bdelete'
                                else
                                  return 'Gedit '.fnameescape(filename)
                                endif
                              endif
                              let mytab = tabpagenr()
                              let mybufnr = bufnr('')
                              try
                                let file = len(a:args) ? s:Generate(s:Expand(join(a:args, ' '))) : fugitive#Real(@%)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if empty(file)
                                return 'echoerr '.string('fugitive: cannot determine file path')
                              endif
                              if file =~# '^fugitive:'
                                return 'write' . (a:bang ? '! ' : ' ') . s:fnameescape(file)
                              endif
                              exe s:DirCheck()
                              let always_permitted = s:cpath(fugitive#Real(@%), file) && empty(s:DirCommitFile(@%)[1])
                              if !always_permitted && !a:bang && (len(s:TreeChomp('diff', '--name-status', 'HEAD', '--', file)) || len(s:TreeChomp('ls-files', '--others', '--', file)))
                                let v:errmsg = 'fugitive: file has uncommitted changes (use ! to override)'
                                return 'echoerr v:errmsg'
                              endif
                              let treebufnr = 0
                              for nr in range(1,bufnr('$'))
                                if fnamemodify(bufname(nr),':p') ==# file
                                  let treebufnr = nr
                                endif
                              endfor
                            
                              if treebufnr > 0 && treebufnr != bufnr('')
                                let temp = tempname()
                                silent execute 'keepalt %write '.temp
                                for tab in [mytab] + range(1,tabpagenr('$'))
                                  for winnr in range(1,tabpagewinnr(tab,'$'))
                                    if tabpagebuflist(tab)[winnr-1] == treebufnr
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        let lnum = line('.')
                                        let last = line('$')
                                        silent execute '$read '.temp
                                        silent execute '1,'.last.'delete_'
                                        silent write!
                                        silent execute lnum
                                        diffupdate
                                        let did = 1
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                      break
                                    endif
                                  endfor
                                endfor
                                if !exists('did')
                                  call writefile(readfile(temp,'b'),file,'b')
                                endif
                              else
                                execute 'write! '.s:fnameescape(file)
                              endif
                            
                              if a:bang
                                let [error, exec_error] = s:ChompError(['add', '--force', '--', file])
                              else
                                let [error, exec_error] = s:ChompError(['add', '--', file])
                              endif
                              if exec_error
                                let v:errmsg = 'fugitive: '.error
                                return 'echoerr v:errmsg'
                              endif
                              if s:cpath(fugitive#Real(@%), file) && s:DirCommitFile(@%)[1] =~# '^\d$'
                                setlocal nomodified
                              endif
                            
                              let one = s:Generate(':1:'.file)
                              let two = s:Generate(':2:'.file)
                              let three = s:Generate(':3:'.file)
                              for nr in range(1,bufnr('$'))
                                let name = fnamemodify(bufname(nr), ':p')
                                if bufloaded(nr) && !getbufvar(nr,'&modified') && (name ==# one || name ==# two || name ==# three)
                                  execute nr.'bdelete'
                                endif
                              endfor
                            
                              unlet! restorewinnr
                              let zero = s:Generate(':0:'.file)
                              silent execute 'doautocmd' s:nomodeline 'BufWritePost' s:fnameescape(zero)
                              for tab in range(1,tabpagenr('$'))
                                for winnr in range(1,tabpagewinnr(tab,'$'))
                                  let bufnr = tabpagebuflist(tab)[winnr-1]
                                  let bufname = fnamemodify(bufname(bufnr), ':p')
                                  if bufname ==# zero && bufnr != mybufnr
                                    execute 'tabnext '.tab
                                    if winnr != winnr()
                                      execute winnr.'wincmd w'
                                      let restorewinnr = 1
                                    endif
                                    try
                                      let lnum = line('.')
                                      let last = line('$')
                                      silent execute '$read '.s:fnameescape(file)
                                      silent execute '1,'.last.'delete_'
                                      silent execute lnum
                                      setlocal nomodified
                                      diffupdate
                                    finally
                                      if exists('restorewinnr')
                                        wincmd p
                                      endif
                                      execute 'tabnext '.mytab
                                    endtry
                                    break
                                  endif
                                endfor
                              endfor
                              call fugitive#ReloadStatus()
                              return 'checktime'

FUNCTION  go#util#EchoInfo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:echo(a:msg, 'Debug')

FUNCTION  go#lsp#Restart()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !go#util#has_job() || len(s:lspfactory) == 0 || !has_key(s:lspfactory, 'current')
                                return
                              endif
                            
                              let l:lsp = s:lspfactory.get()
                            
                              let l:lsp.restarting = 1
                            
                              let l:state = s:newHandlerState('exit')
                            
                              let l:msg = go#lsp#message#Shutdown()
                              let l:state.handleResult = funcref('s:noop')
                              let l:retval = l:lsp.sendMessage(l:msg, l:state)
                            
                              let l:msg = go#lsp#message#Exit()
                              let l:retval = l:lsp.sendMessage(l:msg, l:state)
                            
                              return l:retval

FUNCTION  <SNR>103_Mods()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let mods = substitute(a:mods, '\C<mods>', '', '')
                              let mods = mods =~# '\S$' ? mods . ' ' : mods
                              if a:0 && mods !~# '\<\%(aboveleft\|belowright\|leftabove\|rightbelow\|topleft\|botright\|tab\)\>'
                                let mods = a:1 . ' ' . mods
                              endif
                              return substitute(mods, '\s\+', ' ', 'g')

FUNCTION  go#config#AutoTypeInfo()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000009   return get(g:, "go_auto_type_info", 0)

FUNCTION  FugitiveIsGitDir()
Called 3 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    3              0.000051   let path = substitute(a:path, '[\/]$', '', '') . '/'
    3              0.000039   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  FugitiveStatusline()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('b:git_dir')
                                return ''
                              endif
                              return fugitive#Statusline()

FUNCTION  <SNR>34_function()
Called 9 times
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
    9              0.000197   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))

FUNCTION  go#util#camelcase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let word = substitute(a:word, '-', '_', 'g')
                              if word !~# '_' && word =~# '\l'
                                return substitute(word, '^.', '\l&', '')
                              else
                                return substitute(word, '\C\(_\)\=\(.\)', '\=submatch(1)==""?tolower(submatch(2)) : toupper(submatch(2))','g')
                              endif

FUNCTION  <SNR>103_DoToggleUnstaged()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:record.patch && a:record.status !=# 'A'
                                return s:StageApply(a:record, 0, ['--cached'])
                              else
                                call s:TreeChomp(['add', '-A', '--'] + a:record.paths)
                                return 1
                              endif

FUNCTION  fugitive#MapJumps()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !&modifiable
                                if get(b:, 'fugitive_type', '') ==# 'blob'
                                  let blame_map = 'Gblame<C-R>=v:count ? " --reverse" : ""<CR><CR>'
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>0,2' . blame_map, '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>0,3' . blame_map, '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>0,4' . blame_map, '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>0,5' . blame_map, '<silent>')
                            
                                  call s:Map('n', 'D',  ":<C-U>call <SID>DiffClose()<Bar>Gdiffsplit!<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
                                  call s:Map('n', 'dd', ":<C-U>call <SID>DiffClose()<Bar>Gdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dh', ":<C-U>call <SID>DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'ds', ":<C-U>call <SID>DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dv', ":<C-U>call <SID>DiffClose()<Bar>Gvdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
                            
                                else
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>exe <SID>GF("split")<CR>', '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>exe <SID>GF("vsplit")<CR>', '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>exe <SID>GF("tabedit")<CR>', '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>exe <SID>GF("pedit")<CR>', '<silent>')
                            
                                  if !exists('g:fugitive_no_maps')
                                    if exists(':CtrlP') && get(g:, 'ctrl_p_map') =~? '^<c-p>$'
                                      nnoremap <buffer> <silent> <C-P> :<C-U>execute line('.') == 1 ? 'CtrlP ' . fnameescape(<SID>Tree()) : <SID>PreviousItem(v:count1)<CR>
                                    else
                                      nnoremap <buffer> <silent> <C-P> :<C-U>execute <SID>PreviousItem(v:count1)<CR>
                                    endif
                                    nnoremap <buffer> <silent> <C-N> :<C-U>execute <SID>NextItem(v:count1)<CR>
                                  endif
                                  call s:MapMotion('(', 'exe <SID>PreviousItem(v:count1)')
                                  call s:MapMotion(')', 'exe <SID>NextItem(v:count1)')
                                  call s:MapMotion('K', 'exe <SID>PreviousHunk(v:count1)')
                                  call s:MapMotion('J', 'exe <SID>NextHunk(v:count1)')
                                  call s:MapMotion('[c', 'exe <SID>PreviousHunk(v:count1)')
                                  call s:MapMotion(']c', 'exe <SID>NextHunk(v:count1)')
                                  call s:MapMotion('[/', 'exe <SID>PreviousFile(v:count1)')
                                  call s:MapMotion(']/', 'exe <SID>NextFile(v:count1)')
                                  call s:MapMotion('[m', 'exe <SID>PreviousFile(v:count1)')
                                  call s:MapMotion(']m', 'exe <SID>NextFile(v:count1)')
                                  call s:MapMotion('[[', 'exe <SID>PreviousSection(v:count1)')
                                  call s:MapMotion(']]', 'exe <SID>NextSection(v:count1)')
                                  call s:MapMotion('[]', 'exe <SID>PreviousSectionEnd(v:count1)')
                                  call s:MapMotion('][', 'exe <SID>NextSectionEnd(v:count1)')
                                  call s:Map('nxo', '*', '<SID>PatchSearchExpr(0)', '<expr>')
                                  call s:Map('nxo', '#', '<SID>PatchSearchExpr(1)', '<expr>')
                                endif
                                call s:Map('n', 'S',    ':<C-U>echoerr "Use gO"<CR>', '<silent>')
                                call s:Map('n', 'dq', ":<C-U>call <SID>DiffClose()<CR>", '<silent>')
                                call s:Map('n', '-', ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>NavigateUp(v:count1))<Bar> if getline(1) =~# '^tree \x\{40,\}$' && empty(getline(2))<Bar>call search('^'.escape(expand('#:t'),'.*[]~\').'/\=$','wc')<Bar>endif<CR>", '<silent>')
                                call s:Map('n', 'P',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'^'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
                                call s:Map('n', '~',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'~'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
                                call s:Map('n', 'C',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'cp',    ":<C-U>echoerr 'Use gC'<CR>", '<silent>')
                                call s:Map('n', 'gC',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'gc',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
                                call s:Map('x', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
                            
                                nnoremap <buffer>       c<Space> :Git commit<Space>
                                nnoremap <buffer>          c<CR> :Git commit<CR>
                                nnoremap <buffer>      cv<Space> :Git commit -v<Space>
                                nnoremap <buffer>         cv<CR> :Git commit -v<CR>
                                nnoremap <buffer> <silent> ca    :<C-U>Gcommit --amend<CR>
                                nnoremap <buffer> <silent> cc    :<C-U>Gcommit<CR>
                                nnoremap <buffer> <silent> ce    :<C-U>Gcommit --amend --no-edit<CR>
                                nnoremap <buffer> <silent> cw    :<C-U>Gcommit --amend --only<CR>
                                nnoremap <buffer> <silent> cva   :<C-U>Gcommit -v --amend<CR>
                                nnoremap <buffer> <silent> cvc   :<C-U>Gcommit -v<CR>
                                nnoremap <buffer> <silent> cRa   :<C-U>Gcommit --reset-author --amend<CR>
                                nnoremap <buffer> <silent> cRe   :<C-U>Gcommit --reset-author --amend --no-edit<CR>
                                nnoremap <buffer> <silent> cRw   :<C-U>Gcommit --reset-author --amend --only<CR>
                                nnoremap <buffer>          cf    :<C-U>Gcommit --fixup=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cF    :<C-U><Bar>Grebase --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Gcommit --fixup=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cs    :<C-U>Gcommit --squash=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cS    :<C-U><Bar>Grebase --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Gcommit --squash=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cA    :<C-U>Gcommit --edit --squash=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer> <silent> c?    :<C-U>help fugitive_c<CR>
                            
                                nnoremap <buffer>      cr<Space> :Git revert<Space>
                                nnoremap <buffer>         cr<CR> :Git revert<CR>
                                nnoremap <buffer> <silent> crc   :<C-U>Grevert <C-R>=<SID>SquashArgument()<CR><CR>
                                nnoremap <buffer> <silent> crn   :<C-U>Grevert --no-commit <C-R>=<SID>SquashArgument()<CR><CR>
                                nnoremap <buffer> <silent> cr?   :help fugitive_cr<CR>
                            
                                nnoremap <buffer>      cm<Space> :Git merge<Space>
                                nnoremap <buffer>         cm<CR> :Git merge<CR>
                                nnoremap <buffer> <silent> cm?   :help fugitive_cm<CR>
                            
                                nnoremap <buffer>      cz<Space> :Git stash<Space>
                                nnoremap <buffer>         cz<CR> :Git stash<CR>
                                nnoremap <buffer> <silent> cza   :<C-U>exe <SID>EchoExec(['stash', 'apply', '--quiet', '--index', 'stash@{' . v:count . '}'])<CR>
                                nnoremap <buffer> <silent> czA   :<C-U>exe <SID>EchoExec(['stash', 'apply', '--quiet', 'stash@{' . v:count . '}'])<CR>
                                nnoremap <buffer> <silent> czp   :<C-U>exe <SID>EchoExec(['stash', 'pop', '--quiet', '--index', 'stash@{' . v:count . '}'])<CR>
                                nnoremap <buffer> <silent> czP   :<C-U>exe <SID>EchoExec(['stash', 'pop', '--quiet', 'stash@{' . v:count . '}'])<CR>
                                nnoremap <buffer> <silent> czv   :<C-U>exe 'Gedit' fugitive#RevParse('stash@{' . v:count . '}')<CR>
                                nnoremap <buffer> <silent> czw   :<C-U>exe <SID>EchoExec(['stash', '--keep-index'] + (v:count > 1 ? ['--all'] : v:count ? ['--include-untracked'] : []))<CR>
                                nnoremap <buffer> <silent> czz   :<C-U>exe <SID>EchoExec(['stash'] + (v:count > 1 ? ['--all'] : v:count ? ['--include-untracked'] : []))<CR>
                                nnoremap <buffer> <silent> cz?   :<C-U>help fugitive_cz<CR>
                            
                                nnoremap <buffer>      co<Space> :Git checkout<Space>
                                nnoremap <buffer>         co<CR> :Git checkout<CR>
                                nnoremap <buffer>          coo   :exe <SID>EchoExec(['checkout'] + split(<SID>SquashArgument()) + ['--'])<CR>
                                nnoremap <buffer>          co?   :<C-U>help fugitive_co<CR>
                            
                                nnoremap <buffer>      cb<Space> :Git branch<Space>
                                nnoremap <buffer>         cb<CR> :Git branch<CR>
                                nnoremap <buffer>         cb?    :<C-U>help fugitive_cb<CR>
                            
                                nnoremap <buffer>       r<Space> :Git rebase<Space>
                                nnoremap <buffer>          r<CR> :Git rebase<CR>
                                nnoremap <buffer> <silent> ri    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><CR>
                                nnoremap <buffer> <silent> rf    :<C-U>Grebase --autosquash<C-R>=<SID>RebaseArgument()<CR><CR>
                                nnoremap <buffer> <silent> ru    :<C-U>Grebase --interactive @{upstream}<CR>
                                nnoremap <buffer> <silent> rp    :<C-U>Grebase --interactive @{push}<CR>
                                nnoremap <buffer> <silent> rw    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/reword/e<CR>
                                nnoremap <buffer> <silent> rm    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/edit/e<CR>
                                nnoremap <buffer> <silent> rd    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>
                                nnoremap <buffer> <silent> rk    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>
                                nnoremap <buffer> <silent> rx    :<C-U>Grebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>
                                nnoremap <buffer> <silent> rr    :<C-U>Grebase --continue<CR>
                                nnoremap <buffer> <silent> rs    :<C-U>Grebase --skip<CR>
                                nnoremap <buffer> <silent> re    :<C-U>Grebase --edit-todo<CR>
                                nnoremap <buffer> <silent> ra    :<C-U>Grebase --abort<CR>
                                nnoremap <buffer> <silent> r?    :<C-U>help fugitive_r<CR>
                            
                                call s:Map('n', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
                                call s:Map('x', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
                                call s:Map('n', 'g?',    ":<C-U>help fugitive-map<CR>", '<silent>')
                                call s:Map('n', '<F1>',  ":<C-U>help fugitive-map<CR>", '<silent>')
                              endif

FUNCTION  go#util#IsUsingCygwinShell()
Called 3 times
Total time:   0.000034
 Self time:   0.000020

count  total (s)   self (s)
    3   0.000031   0.000017   return go#util#IsWin() && executable('cygpath') && &shell =~ '.*sh.*'

FUNCTION  <SNR>28_Drag_Lines()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " Clean up the temporary convenience...
                                nunmap <buffer>  M
                            
                                " Locate block being shifted...
                                let [buf_left,  line_left,  col_left,  offset_left ] = getpos("'<")
                                let [buf_right, line_right, col_right, offset_right] = getpos("'>")
                            
                                " Drag entire lines left if possible...
                                if a:dir == 'left'
                                    " Are all lines indented at least one space???
                                    let lines        = getline(line_left, line_right)
                                    let all_indented = match(lines, '^[^ ]') == -1
                            
                                    " If can't trim one space from start of each line, be a no-op...
                                    if !all_indented
                                        return 'gv'
                            
                                    " Otherwise drag left by removing one space from start of each line...
                                    else
                                        return    s:NO_REPORT . "gv:s/^ //\<CR>:nohlsearch\<CR>" . s:PREV_REPORT . "gv"
                                    endif
                            
                                " To drag entire lines right, add a space in column 1...
                                elseif a:dir == 'right'
                                    return   s:NO_REPORT . "gv:s/^/ /\<CR>:nohlsearch\<CR>" . s:PREV_REPORT . "gv"
                            
                                " To drag entire lines upwards...
                                elseif a:dir == 'up'
                                    let EOF = line('$')
                            
                                    " Can't drag up if at first line...
                                    if line_left == 1 || line_right == 1
                                        return 'gv'
                            
                                    " Needs special handling at EOF (because cursor moves up on delete)...
                                    elseif line_left == EOF || line_right == EOF
                                        let height = line_right - line_left
                                        let select_extra = height ? height . 'j' : ""
                                        return   s:NO_REPORT . 'gvxP' . s:PREV_REPORT . 'V' . select_extra
                            
                                    " Otherwise just cut-move-paste-reselect...
                                    else
                                        let height = line_right - line_left
                                        let select_extra = height ? height . 'j' : ""
                                        return   s:NO_REPORT . 'gvxkP' . s:PREV_REPORT . 'V' . select_extra
                                    endif
                            
                                " To drag entire lines downwards...
                                elseif a:dir == 'down'
                                    let EOF = line('$')
                            
                                    " This is how much extra we're going to have to reselect...
                                    let height = line_right - line_left
                                    let select_extra = height ? height . 'j' : ""
                            
                                    " Needs special handling at EOF (to push selection down into new space)...
                                    if line_left == EOF || line_right == EOF
                                        return   "O\<ESC>gv"
                            
                                    " Otherwise, just cut-move-paste-reselect...
                                    else
                                        return   s:NO_REPORT . 'gvxp' . s:PREV_REPORT . 'V' . select_extra
                                    endif
                            
                                endif

FUNCTION  fugitive#Cfile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let pre = ''
                              let results = s:cfile()
                              if empty(results)
                                let cfile = expand('<cfile>')
                                if &includeexpr =~# '\<v:fname\>'
                                  sandbox let cfile = eval(substitute(&includeexpr, '\C\<v:fname\>', '\=string(cfile)', 'g'))
                                endif
                                return cfile
                              elseif len(results) > 1
                                let pre = '+' . join(map(results[1:-1], 'escape(v:val, " ")'), '\|') . ' '
                              endif
                              return pre . s:fnameescape(s:Generate(results[0]))

FUNCTION  go#config#DocPopupWindow()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_doc_popup_window', 0)

FUNCTION  DVB_Float()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " No-op in Visual mode...
                                if mode() ==# 'v'
                                    return "\<ESC>gv"
                            
                                " Do Visual Line drag indirectly via temporary nmap
                                " (to ensure we have access to block position data)...
                                elseif mode() ==# 'V'
                                    " Set up a temporary convenience...
                                    exec "nnoremap <silent><expr><buffer>  M  \<SID>Float_Lines('".a:dir."')"
                            
                                    " Return instructions to implement the move and reset selection...
                                    return '"vyM'
                            
                                " Otherwise do Visual Block drag indirectly via temporary nmap
                                " (to ensure we have access to block position data)...
                                else
                                    " Set up a temporary convenience...
                                    exec "nnoremap <silent><expr><buffer>  M  \<SID>Float_Block('".a:dir."')"
                            
                                    " Return instructions to implement the move and reset selection...
                                    return '"vyM'
                                endif

FUNCTION  <SNR>103_DotRelative()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let cwd = a:0 ? a:1 : getcwd()
                              let path = substitute(a:path, '^[~$]\i*', '\=expand(submatch(0))', '')
                              if len(cwd) && s:cpath(cwd . '/', (path . '/')[0 : len(cwd)])
                                return '.' . strpart(path, len(cwd))
                              endif
                              return a:path

FUNCTION  FugitiveGitPath()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:Slash(a:path)

FUNCTION  <SNR>104_sync_guru()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let result = s:guru_cmd(a:args)
                              if has_key(result, 'err')
                                call go#util#EchoError(result.err)
                                return -1
                              endif
                            
                              if !has_key(a:args, 'disable_progress')
                                if a:args.needs_scope
                                  call go#util#EchoProgress("analysing with scope ". result.scope . " (see ':help go-guru-scope' if this doesn't work)...")
                                elseif a:args.mode !=# 'what'
                                  " the query might take time, let us give some feedback
                                  call go#util#EchoProgress("analysing ...")
                                endif
                              endif
                            
                              " run, forrest run!!!
                              if has_key(l:result, 'stdin_content')
                                let [l:out, l:err] = go#util#Exec(l:result.cmd, l:result.stdin_content)
                              else
                                let [l:out, l:err] = go#util#Exec(l:result.cmd)
                              endif
                            
                              if has_key(a:args, 'custom_parse')
                                call a:args.custom_parse(l:err, l:out, a:args.mode)
                              else
                                call s:parse_guru_output(l:err, l:out, a:args.mode)
                              endif
                            
                              return l:out

FUNCTION  <SNR>94_neocb()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " dealing with the channel lines of Neovim is awful. The docs (:help
                              " channel-lines) say:
                              "     stream event handlers may receive partial (incomplete) lines. For a
                              "     given invocation of on_stdout etc, `a:data` is not guaranteed to end
                              "     with a newline.
                              "       - `abcdefg` may arrive as `['abc']`, `['defg']`.
                              "       - `abc\nefg` may arrive as `['abc', '']`, `['efg']` or `['abc']`,
                              "         `['','efg']`, or even `['ab']`, `['c','efg']`.
                              "
                              " Thankfully, though, this is explained a bit better in an issue:
                              " https://github.com/neovim/neovim/issues/3555. Specifically in these two
                              " comments:
                              "     * https://github.com/neovim/neovim/issues/3555#issuecomment-152290804
                              "     * https://github.com/neovim/neovim/issues/3555#issuecomment-152588749
                              "
                              " The key is
                              "     Every item in the list passed to job control callbacks represents a
                              "     string after a newline(Except the first, of course). If the program
                              "     outputs: "hello\nworld" the corresponding list is ["hello", "world"].
                              "     If the program outputs "hello\nworld\n", the corresponding list is
                              "     ["hello", "world", ""]. In other words, you can always determine if
                              "     the last line received is complete or not.
                              " and
                              "     for every list you receive in a callback, all items except the first
                              "     represent newlines.
                            
                              let l:buf = ''
                            
                              " A single empty string means EOF was reached. The first item will never be
                              " an empty string except for when it's the only item and is signaling that
                              " EOF was reached.
                              if len(a:data) == 1 && a:data[0] == ''
                                " when there's nothing buffered, return early so that an
                                " erroneous message will not be added.
                                if a:buf == ''
                                  return ''
                                endif
                            
                                let l:data = [a:buf]
                              else
                                let l:data = copy(a:data)
                                let l:data[0] = a:buf . l:data[0]
                            
                                " The last element may be a partial line; save it for next time.
                                if a:mode != 'raw'
                                  let l:buf = l:data[-1]
                                  let l:data = l:data[:-2]
                                endif
                              endif
                            
                              let l:i = 0
                              let l:last = len(l:data) - 1
                              while l:i <= l:last
                                let l:msg = l:data[l:i]
                                if a:mode == 'raw' && l:i < l:last
                                  let l:msg = l:msg . "\n"
                                endif
                                call a:callback(a:ch, l:msg)
                            
                                let l:i += 1
                              endwhile
                            
                              return l:buf

FUNCTION  go#config#GocodeProposeSource()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_gocode_propose_source', 0)

FUNCTION  <SNR>103_CanAutoReloadStatus()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'fugitive_autoreload_status', !has('win32'))

FUNCTION  <SNR>7_Resolve()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let word = a:target
                              let i = matchend(word, s:notslash . '\\\d') - 1
                              let table = "----------"
                              while i != -2 " There are back references to be replaced.
                                let d = word[i]
                                let backref = s:Ref(a:source, d)
                                " The idea is to replace '\d' with backref.  Before we do this,
                                " replace any \(\) groups in backref with :1, :2, ... if they
                                " correspond to the first, second, ... group already inserted
                                " into backref.  Later, replace :1 with \1 and so on.  The group
                                " number w+b within backref corresponds to the group number
                                " s within a:source.
                                " w = number of '\(' in word before the current one
                                let w = s:Count( substitute(strpart(word, 0, i-1), '\\\\', '', 'g'), '\(', '1')
                                let b = 1 " number of the current '\(' in backref
                                let s = d " number of the current '\(' in a:source
                                while b <= s:Count(substitute(backref, '\\\\', '', 'g'), '\(', '1') && s < 10
                                  if table[s] == "-"
                            	if w + b < 10
                            	  " let table[s] = w + b
                            	  let table = strpart(table, 0, s) . (w+b) . strpart(table, s+1)
                            	endif
                            	let b = b + 1
                            	let s = s + 1
                                  else
                            	execute s:Ref(backref, b, "start", "len")
                            	let ref = strpart(backref, start, len)
                            	let backref = strpart(backref, 0, start) . ":". table[s] . strpart(backref, start+len)
                            	let s = s + s:Count(substitute(ref, '\\\\', '', 'g'), '\(', '1')
                                  endif
                                endwhile
                                let word = strpart(word, 0, i-1) . backref . strpart(word, i+1)
                                let i = matchend(word, s:notslash . '\\\d') - 1
                              endwhile
                              let word = substitute(word, s:notslash . '\zs:', '\\', 'g')
                              if a:output == "table"
                                return table
                              elseif a:output == "word"
                                return word
                              else
                                return table . word
                              endif

FUNCTION  <SNR>103_DiffClose()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let mywinnr = winnr()
                              for winnr in [winnr('#')] + range(winnr('$'),1,-1)
                                if winnr != mywinnr && getwinvar(winnr,'&diff')
                                  execute winnr.'wincmd w'
                                  close
                                  if winnr('$') > 1
                                    wincmd p
                                  endif
                                endif
                              endfor
                              diffoff!

FUNCTION  <SNR>103_MapMotion()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:Map('n', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>")
                              call s:Map('o', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>")
                              call s:Map('x', a:lhs, ":<C-U>exe 'normal! gv'<Bar>" . a:rhs . "<CR>", "<silent>")

FUNCTION  qf#IsQfWindowOpen()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                for winnum in range(1, winnr('$'))
                                    if qf#IsQfWindow(winnum)
                                        return 1
                                    endif
                                endfor
                                return 0

FUNCTION  <SNR>103_CompleteSub()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let pre = strpart(a:L, 0, a:P)
                              if pre =~# ' -- '
                                return fugitive#CompletePath(a:A)
                              elseif a:A =~# '^-' || a:A is# 0
                                return s:FilterEscape(split(s:ChompDefault('', a:subcommand, '--git-completion-helper'), ' '), a:A)
                              elseif !a:0
                                return fugitive#CompleteObject(a:A, s:Dir())
                              elseif type(a:1) == type(function('tr'))
                                return call(a:1, [a:A, a:L, a:P])
                              else
                                return s:FilterEscape(a:1, a:A)
                              endif

FUNCTION  fugitive#Foldtext()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &foldmethod !=# 'syntax'
                                return foldtext()
                              endif
                            
                              let line_foldstart = getline(v:foldstart)
                              if line_foldstart =~# '^diff '
                                let [add, remove] = [-1, -1]
                                let filename = ''
                                for lnum in range(v:foldstart, v:foldend)
                                  let line = getline(lnum)
                                  if filename ==# '' && line =~# '^[+-]\{3\} [abciow12]/'
                                    let filename = line[6:-1]
                                  endif
                                  if line =~# '^+'
                                    let add += 1
                                  elseif line =~# '^-'
                                    let remove += 1
                                  elseif line =~# '^Binary '
                                    let binary = 1
                                  endif
                                endfor
                                if filename ==# ''
                                  let filename = matchstr(line_foldstart, '^diff .\{-\} [abciow12]/\zs.*\ze [abciow12]/')
                                endif
                                if filename ==# ''
                                  let filename = line_foldstart[5:-1]
                                endif
                                if exists('binary')
                                  return 'Binary: '.filename
                                else
                                  return (add<10&&remove<100?' ':'') . add . '+ ' . (remove<10&&add<100?' ':'') . remove . '- ' . filename
                                endif
                              elseif line_foldstart =~# '^# .*:$'
                                let lines = getline(v:foldstart, v:foldend)
                                call filter(lines, 'v:val =~# "^#\t"')
                                cal map(lines, "s:sub(v:val, '^#\t%(modified: +|renamed: +)=', '')")
                                cal map(lines, "s:sub(v:val, '^([[:alpha:] ]+): +(.*)', '\\2 (\\1)')")
                                return line_foldstart.' '.join(lines, ', ')
                              endif
                              return foldtext()

FUNCTION  <SNR>103_diff_window_count()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let c = 0
                              for nr in range(1,winnr('$'))
                                let c += getwinvar(nr,'&diff')
                              endfor
                              return c

FUNCTION  sy#buffer_is_active()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return exists('b:sy') && b:sy.active

FUNCTION  <SNR>34_spacecase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(s:snakecase(a:word),'_',' ','g')

FUNCTION  DVB_Duplicate()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                exec "nnoremap <silent><expr><buffer>  M  \<SID>DuplicateBlock()"
                                return '"vyM'

FUNCTION  fugitive#MessageCfile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let file = s:Generate(s:MessageCfile())
                              return empty(file) ? fugitive#Cfile() : s:fnameescape(file)

FUNCTION  FugitiveFind()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#Find(a:0 ? a:1 : bufnr(''), FugitiveGitDir(a:0 > 1 ? a:2 : -1))

FUNCTION  <SNR>103_UsableWin()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:nr && !getwinvar(a:nr, '&previewwindow') && !getwinvar(a:nr, '&winfixwidth') && (empty(getwinvar(a:nr, 'fugitive_status')) || getbufvar(winbufnr(a:nr), 'fugitive_type') !=# 'index') && index(['gitrebase', 'gitcommit'], getbufvar(winbufnr(a:nr), '&filetype')) < 0 && index(['nofile','help','quickfix'], getbufvar(winbufnr(a:nr), '&buftype')) < 0

FUNCTION  <SNR>41_GoInstallBinaries()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let err = s:CheckBinaries()
                              if err != 0
                                return
                              endif
                            
                              if go#path#Default() == ""
                                echohl Error
                                echomsg "vim.go: $GOPATH is not set and 'go env GOPATH' returns empty"
                                echohl None
                                return
                              endif
                            
                              let go_bin_path = go#path#BinPath()
                            
                              " change $GOBIN so go get can automatically install to it
                              let $GOBIN = go_bin_path
                            
                              " vim's executable path is looking in PATH so add our go_bin path to it
                              let Restore_path = go#util#SetEnv('PATH', go_bin_path . go#util#PathListSep() . $PATH)
                            
                              " when shellslash is set on MS-* systems, shellescape puts single quotes
                              " around the output string. cmd on Windows does not handle single quotes
                              " correctly. Unsetting shellslash forces shellescape to use double quotes
                              " instead.
                              let resetshellslash = 0
                              if has('win32') && &shellslash
                                let resetshellslash = 1
                                set noshellslash
                              endif
                            
                              let l:get_base_cmd = ['go', 'get', '-v']
                            
                              " Filter packages from arguments (if any).
                              let l:packages = {}
                              if a:0 > 0
                                for l:bin in a:000
                                  let l:pkg = get(s:packages, l:bin, [])
                                  if len(l:pkg) == 0
                                    call go#util#EchoError('unknown binary: ' . l:bin)
                                    return
                                  endif
                                  let l:packages[l:bin] = l:pkg
                                endfor
                              else
                                let l:packages = s:packages
                              endif
                            
                              let l:platform = ''
                              if go#util#IsWin()
                                let l:platform = 'windows'
                              endif
                            
                              let l:oldmore = &more
                              let &more = 0
                            
                              for [l:binary, l:pkg] in items(l:packages)
                                let l:importPath = l:pkg[0]
                            
                                " TODO(bc): how to support this with modules? Do we have to clone and then
                                " install manually? Probably not. I suspect that we can just use GOPATH
                                " mode and then do the legacy method.
                                let bin_setting_name = "go_" . l:binary . "_bin"
                            
                                if exists("g:{bin_setting_name}")
                                  let bin = g:{bin_setting_name}
                                else
                                  if go#util#IsWin()
                                    let bin = l:binary . '.exe'
                                  else
                                    let bin = l:binary
                                  endif
                                endif
                            
                                if !executable(bin) || a:updateBinaries == 1
                                  if a:updateBinaries == 1
                                    echo "vim-go: Updating " . l:binary . ". Reinstalling ". importPath . " to folder " . go_bin_path
                                  else
                                    echo "vim-go: ". l:binary ." not found. Installing ". importPath . " to folder " . go_bin_path
                                  endif
                            
                                  if l:importPath =~ "@"
                                    let Restore_modules = go#util#SetEnv('GO111MODULE', 'on')
                                    let l:tmpdir = go#util#tempdir('vim-go')
                                    let l:cd = exists('*haslocaldir') && haslocaldir() ? 'lcd ' : 'cd '
                                    let l:dir = getcwd()
                                    try
                                      execute l:cd . fnameescape(l:tmpdir)
                                      let l:get_cmd = copy(l:get_base_cmd)
                            
                                      " first download the binary
                                      let [l:out, l:err] = go#util#Exec(l:get_cmd + [l:importPath])
                                      if l:err
                                        echom "Error installing " . l:importPath . ": " . l:out
                                      endif
                            
                                      call call(Restore_modules, [])
                                    finally
                                      execute l:cd . fnameescape(l:dir)
                                    endtry
                                    call call(Restore_modules, [])
                                  else
                                    let l:get_cmd = copy(l:get_base_cmd)
                                    let l:get_cmd += ['-d']
                                    if get(g:, "go_get_update", 1) != 0
                                      let l:get_cmd += ['-u']
                                    endif
                            
                                    " GO111MODULE must be off to install gometalinter.
                                    let Restore_modules = go#util#SetEnv('GO111MODULE', 'off')
                            
                                    " first download the binary
                                    let [l:out, l:err] = go#util#Exec(l:get_cmd + [l:importPath])
                                    if l:err
                                      echom "Error downloading " . l:importPath . ": " . l:out
                                    endif
                            
                                    " and then build and install it
                                    let l:build_cmd = ['go', 'build', '-o', go_bin_path . go#util#PathSep() . bin, l:importPath]
                                    if len(l:pkg) > 1 && get(l:pkg[1], l:platform, '') isnot ''
                                      let l:build_cmd += get(l:pkg[1], l:platform, '')
                                    endif
                            
                                    let [l:out, l:err] = go#util#Exec(l:build_cmd)
                                    if l:err
                                      echom "Error installing " . l:importPath . ": " . l:out
                                    endif
                            
                            
                                    call call(Restore_modules, [])
                                  endif
                            
                                  if len(l:pkg) > 2
                                    call call(get(l:pkg[2], 'after', function('s:noop', [])), [])
                                  endif
                                endif
                              endfor
                            
                              " restore back!
                              call call(Restore_path, [])
                            
                              if resetshellslash
                                set shellslash
                              endif
                            
                              if a:updateBinaries == 1
                                call go#util#EchoInfo('updating finished!')
                              else
                                call go#util#EchoInfo('installing finished!')
                              endif
                            
                              let &more = l:oldmore

FUNCTION  <SNR>103_UserCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:shellesc(call('s:UserCommandList', a:0 ? [a:1] : []) + (a:0 ? a:2 : []))

FUNCTION  go#path#FromURI()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let l:i = len('file://')
                                let l:encoded_path = a:uri[: l:i - 1] is# 'file://' ? a:uri[l:i :] : a:uri
                            
                                let l:path = go#uri#Decode(l:encoded_path)
                            
                                " If the path is like /C:/foo/bar, it should be C:\foo\bar instead.
                                if go#util#IsWin() && l:path =~# '^/[a-zA-Z]:'
                                    let l:path = substitute(l:path[1:], '/', '\\', 'g')
                                endif
                            
                                return l:path

FUNCTION  <SNR>103_repo_superglob()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return map(fugitive#CompleteObject(a:base, self.git_dir), 'substitute(v:val, ''\\\(.\)'', ''\1'', "g")')

FUNCTION  TCommentOpFunc_Comment()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_Comment')
                            
                            return call('tcomment#operator#Anyway', a:000)

FUNCTION  <SNR>103_Slash()
Called 3 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    3              0.000011   if exists('+shellslash')
                                return tr(a:path, '\', '/')
    3              0.000003   else
    3              0.000005     return a:path
                              endif

FUNCTION  <SNR>103_DoToggleUnpushed()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:DoStageUnpushed(a:record)

FUNCTION  sy#sign#remove_all_signs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let sy = getbufvar(a:bufnr, 'sy')
                            
                              for hunk in sy.hunks
                                for id in hunk.ids
                                  execute 'sign unplace' id 'buffer='.a:bufnr
                                endfor
                              endfor
                            
                              let sy.hunks = []

FUNCTION  <SNR>103_DoToggleUntracked()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:TreeChomp(['add', '--'] + a:record.paths)
                              return 1

FUNCTION  go#util#Join()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return join(a:000, go#util#PathSep())

FUNCTION  <SNR>103_GrepParseLine()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let entry = {'valid': 1}
                              let match = matchlist(a:line, '^\(.\{-\}\):\(\d\+\):\(\d\+:\)\=\(.*\)$')
                              if len(match)
                                let entry.module = match[1]
                                let entry.lnum = +match[2]
                                let entry.col = +match[3]
                                let entry.text = match[4]
                              elseif a:line =~# '^git: \|^usage: \|^error: \|^fatal: '
                                return {'text': a:line}
                              else
                                let entry.module = matchstr(a:line, '\CBinary file \zs.*\ze matches$')
                                if len(entry.module)
                                  let entry.text = 'Binary file'
                                  let entry.valid = 0
                                endif
                              endif
                              if empty(entry.module) && a:name_only
                                let entry.module = a:line
                              endif
                              if empty(entry.module)
                                return {'text': a:line}
                              endif
                              if entry.module !~# ':'
                                let entry.filename = a:prefix . entry.module
                              else
                                let entry.filename = fugitive#Find(entry.module, a:dir)
                              endif
                              return entry

FUNCTION  sy#stop()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let sy = getbufvar(a:bufnr, 'sy')
                              if empty(sy)
                                return
                              endif
                            
                              call sy#sign#remove_all_signs(a:bufnr)

FUNCTION  <SNR>103_diffoff()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('w:fugitive_diff_restore')
                                execute w:fugitive_diff_restore
                                unlet w:fugitive_diff_restore
                              else
                                diffoff
                              endif

FUNCTION  <SNR>21_LoadIndent()
Called 2 times
Total time:   0.001234
 Self time:   0.000905

count  total (s)   self (s)
    2              0.000010     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    2              0.000003     endif
    2              0.000010     let s = expand("<amatch>")
    2              0.000005     if s != ""
    2              0.000006       if exists("b:did_indent")
    1              0.000002 	unlet b:did_indent
    2              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000020       for name in split(s, '\.')
    2   0.001135   0.000806 	exe 'runtime! indent/' . name . '.vim'
    4              0.000006       endfor
    2              0.000002     endif

FUNCTION  <SNR>4_PreGetPage()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:cnt == 0
                                let old_isk = &iskeyword
                                if &ft == 'man'
                                  setl iskeyword+=(,)
                                endif
                                let str = expand("<cword>")
                                let &l:iskeyword = old_isk
                                let page = substitute(str, '(*\(\k\+\).*', '\1', '')
                                let sect = substitute(str, '\(\k\+\)(\([^()]*\)).*', '\2', '')
                                if match(sect, '^[0-9 ]\+$') == -1
                                  let sect = ""
                                endif
                                if sect == page
                                  let sect = ""
                                endif
                              else
                                let sect = a:cnt
                                let page = expand("<cword>")
                              endif
                              call s:GetPage(sect, page)

FUNCTION  <SNR>103_DoToggleUnpushedHeading()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:DoStageUnpushedHeading(a:heading)

FUNCTION  <SNR>104_same_ids_highlight()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call go#guru#ClearSameIds() " run after calling guru to reduce flicker.
                            
                              if a:output[0] !=# '{'
                                if !go#config#AutoSameids()
                                  call go#util#EchoError(a:output)
                                endif
                                return
                              endif
                            
                              let result = json_decode(a:output)
                              if type(result) != type({}) && !go#config#AutoSameids()
                                call go#util#EchoError("malformed output from guru")
                                return
                              endif
                            
                              if !has_key(result, 'sameids')
                                if !go#config#AutoSameids()
                                  call go#util#EchoError("no same_ids founds for the given identifier")
                                endif
                                return
                              endif
                            
                              let poslen = 0
                              for enclosing in result['enclosing']
                                if enclosing['desc'] == 'identifier'
                                  let poslen = enclosing['end'] - enclosing['start']
                                  break
                                endif
                              endfor
                            
                              " return when there's no identifier to highlight.
                              if poslen == 0
                                return
                              endif
                            
                              let same_ids = result['sameids']
                              " highlight the lines
                              for item in same_ids
                                let pos = split(item, ':')
                                call matchaddpos('goSameId', [[str2nr(pos[-2]), str2nr(pos[-1]), str2nr(poslen)]])
                              endfor
                            
                              if go#config#AutoSameids()
                                " re-apply SameIds at the current cursor position at the time the buffer
                                " is redisplayed: e.g. :edit, :GoRename, etc.
                                augroup vim-go-sameids
                                  autocmd! * <buffer>
                                  autocmd BufWinEnter <buffer> nested call go#guru#SameIds(0)
                                augroup end
                              endif

FUNCTION  <SNR>4_PopPage()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if s:man_tag_depth > 0
                                let s:man_tag_depth = s:man_tag_depth - 1
                                exec "let s:man_tag_buf=s:man_tag_buf_".s:man_tag_depth
                                exec "let s:man_tag_lin=s:man_tag_lin_".s:man_tag_depth
                                exec "let s:man_tag_col=s:man_tag_col_".s:man_tag_depth
                                exec s:man_tag_buf."b"
                                exec s:man_tag_lin
                                exec "norm! ".s:man_tag_col."|"
                                exec "unlet s:man_tag_buf_".s:man_tag_depth
                                exec "unlet s:man_tag_lin_".s:man_tag_depth
                                exec "unlet s:man_tag_col_".s:man_tag_depth
                                unlet s:man_tag_buf s:man_tag_lin s:man_tag_col
                              endif

FUNCTION  <SNR>103_QuickfixGet()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:nr < 0
                                return call('getqflist', a:000)
                              else
                                return call('getloclist', [a:nr] + a:000)
                              endif

FUNCTION  <SNR>103_DoToggleStaged()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:record.patch
                                return s:StageApply(a:record, 1, ['--cached'])
                              else
                                call s:TreeChomp(['reset', '-q', '--'] + a:record.paths)
                                return 1
                              endif

FUNCTION  fugitive#Init()
Called 1 time
Total time:   0.001063
 Self time:   0.000131

count  total (s)   self (s)
    1              0.000009   if exists('#User#FugitiveBoot')
                                try
                                  let [save_mls, &modelines] = [&mls, 0]
                                  doautocmd User FugitiveBoot
                                finally
                                  let &mls = save_mls
                                endtry
    1              0.000001   endif
    1   0.000046   0.000007   let dir = s:Dir()
    1              0.000018   if stridx(&tags, escape(dir, ', ')) == -1 && &tags !~# '\.git' && !exists('s:tags_warning')
    1   0.000564   0.000007     let actualdir = fugitive#Find('.git/', dir)
    1              0.000009     if filereadable(actualdir . 'tags')
                                  let s:tags_warning = 1
                                  echohl WarningMsg
                                  echo "Fugitive .git/tags support removed in favor of `:set tags^=./.git/tags;`"
                                  echohl NONE
    1              0.000001     endif
    1              0.000001   endif
    1              0.000001   try
    1              0.000017     let [save_mls, &modelines] = [&mls, 0]
    1   0.000304   0.000018     call s:define_commands()
    1   0.000060   0.000010     doautocmd User Fugitive
    1              0.000001   finally
    1              0.000007     let &mls = save_mls
    1              0.000002   endtry

FUNCTION  go#statusline#Show()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " lazy initialization of the cleaner
                              if !s:timer_id
                                let interval = go#config#StatuslineDuration()
                                let s:timer_id = timer_start(interval, function('go#statusline#Clear'), {'repeat': -1})
                              endif
                            
                              " nothing to show
                              if empty(s:statuses)
                                return ''
                              endif
                            
                              let status_dir =  expand('%:p:h')
                            
                              if !has_key(s:statuses, status_dir)
                                return ''
                              endif
                            
                              let status = s:statuses[status_dir]
                              if !has_key(status, 'desc') || !has_key(status, 'state') || !has_key(status, 'type')
                                return ''
                              endif
                            
                              let status_text = printf("[%s|%s]", status.type, status.state)
                              if empty(status_text)
                                return ''
                              endif
                            
                              " only update highlight if status has changed.
                              if status_text != s:last_status
                                if status.state =~ "success" || status.state =~ "finished" || status.state =~ "pass" || status.state =~ 'initialized'
                                  hi goStatusLineColor cterm=bold ctermbg=76 ctermfg=22 guibg=#5fd700 guifg=#005f00
                                elseif status.state =~ "started" || status.state =~ "analysing" || status.state =~ "compiling" || status.state =~ 'initializing'
                                  hi goStatusLineColor cterm=bold ctermbg=208 ctermfg=88 guibg=#ff8700 guifg=#870000
                                elseif status.state =~ "failed"
                                  hi goStatusLineColor cterm=bold ctermbg=196 ctermfg=52 guibg=#ff0000 guifg=#5f0000
                                endif
                              endif
                            
                              let s:last_status = status_text
                              return status_text

FUNCTION  go#config#DeclsMode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_decls_mode", "")

FUNCTION  TCommentOpFunc_gc1c()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gc1c')
                            call tcomment#SetOption("count", 1)
                            return call('tcomment#operator#Op', a:000)

FUNCTION  fugitive#is_git_dir()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return FugitiveIsGitDir(a:path)

FUNCTION  <SNR>49_opfunc2()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !a:0 || a:1 ==# 'setup'
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
                                return 'g@'
                              endif
                              call s:opfunc(a:1, 1)

FUNCTION  go#config#FmtFailSilently()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_fmt_fail_silently", 0)

FUNCTION  qf#IsLocWindow()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return getbufvar(winbufnr(a:nmbr), "qf_isLoc") == 1

FUNCTION  <SNR>34_Complete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:L = a:L
                              " Vim bug: :Abolish -<Tab> calls this function with a:A equal to 0
                              if a:A =~# '^[^/?-]' && type(a:A) != type(0)
                                return join(s:words(),"\n")
                              elseif a:L =~# '^\w\+\s\+\%(-\w*\)\=$'
                                return "-search\n-substitute\n-delete\n-buffer\n-cmdline\n"
                              elseif a:L =~# ' -\%(search\|substitute\)\>'
                                return "-flags="
                              else
                                return "-buffer\n-cmdline"
                              endif

FUNCTION  go#config#HighlightTypes()
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000010   return get(g:, 'go_highlight_types', 0)

FUNCTION  fugitive#Expand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(a:object, '\(\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand, '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5))', 'g')

FUNCTION  <SNR>31_save()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if exists('b:sy') && b:sy.active && &modified && &modifiable && ! &readonly
                                write
                              endif

FUNCTION  go#util#SetEnv()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:state = {}
                            
                              if len(a:name) == 0
                                return function('s:noop', [], l:state)
                              endif
                            
                              let l:remove = 0
                              if exists('$' . a:name)
                                let l:oldvalue = eval('$' . a:name)
                              else
                                let l:remove = 1
                              endif
                            
                              " wrap the value in single quotes so that it will work on windows when there
                              " are backslashes present in the value (e.g. $PATH).
                              call execute('let $' . a:name . " = '" . a:value . "'")
                            
                              if l:remove
                                function! s:remove(name) abort
                                  call execute('unlet $' . a:name)
                                endfunction
                                return function('s:remove', [a:name], l:state)
                              endif
                            
                              return function('go#util#SetEnv', [a:name, l:oldvalue], l:state)

FUNCTION  qf#GetEntryPath()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                "                          +- match from the first pipe to the end of line
                                "                          |  declaring EOL explicitly is faster than implicitly
                                "                          |      +- replace match with nothing
                                "                          |      |   +- no flags
                                return substitute(a:line, '|.*$', '', '')

FUNCTION  <SNR>103_AddSection()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let note = a:0 ? a:1 : ''
                              if empty(a:lines) && empty(note)
                                return
                              endif
                              call append(line('$'), ['', a:label . (len(note) ? ': ' . note : ' (' . len(a:lines) . ')')] + s:Format(a:lines))

FUNCTION  go#auto#template_autocreate()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !go#config#TemplateAutocreate() || !&modifiable
                                return
                              endif
                            
                              " create new template from scratch
                              call go#template#create()

FUNCTION  gutentags#chdir()
Called 4 times
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
    4              0.000047     if has('nvim')
                                    let chdir = haslocaldir() ? 'lcd' : haslocaldir(-1, 0) ? 'tcd' : 'cd'
    4              0.000004     else
    4              0.000013         let chdir = haslocaldir() ? 'lcd' : 'cd'
    4              0.000003     endif
    4              0.000103     execute chdir a:path

FUNCTION  go#config#GorenameBin()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_gorename_bin", "gorename")

FUNCTION  <SNR>103_add_methods()
Called 5 times
Total time:   0.000698
 Self time:   0.000309

count  total (s)   self (s)
   21              0.000051   for name in a:method_names
   16   0.000571   0.000182     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
   21              0.000044   endfor

FUNCTION  <SNR>103_can_diffoff()
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000020   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>103_Move()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              if s:DirCommitFile(@%)[1] !~# '^0\=$' || empty(@%)
                                return 'echoerr ' . string('fugitive: mv not supported for this buffer')
                              endif
                              if a:destination =~# '^\.\.\=\%(/\|$\)'
                                let destination = simplify(getcwd() . '/' . a:destination)
                              elseif a:destination =~# '^\a\+:\|^/'
                                let destination = a:destination
                              elseif a:destination =~# '^:/:\='
                                let destination = s:Tree(dir) . substitute(a:destination, '^:/:\=', '', '')
                              elseif a:destination =~# '^:(\%(top\|top,literal\|literal,top\))'
                                let destination = s:Tree(dir) . matchstr(a:destination, ')\zs.*')
                              elseif a:destination =~# '^:(literal)'
                                let destination = simplify(getcwd() . '/' . matchstr(a:destination, ')\zs.*'))
                              elseif a:rename
                                let destination = expand('%:p:s?[\/]$??:h') . '/' . a:destination
                              else
                                let destination = s:Tree(dir) . '/' . a:destination
                              endif
                              let destination = s:Slash(destination)
                              if isdirectory(@%)
                                setlocal noswapfile
                              endif
                              let [message, exec_error] = s:ChompError(['mv'] + (a:force ? ['-f'] : []) + ['--', expand('%:p'), destination], dir)
                              if exec_error
                                let v:errmsg = 'fugitive: '.message
                                return 'echoerr v:errmsg'
                              endif
                              if isdirectory(destination)
                                let destination = fnamemodify(s:sub(destination,'/$','').'/'.expand('%:t'),':.')
                              endif
                              call fugitive#ReloadStatus(dir)
                              if empty(s:DirCommitFile(@%)[1])
                                if isdirectory(destination)
                                  return 'keepalt edit '.s:fnameescape(destination)
                                else
                                  return 'keepalt saveas! '.s:fnameescape(destination)
                                endif
                              else
                                return 'file '.s:fnameescape(fugitive#Find(':0:'.destination, dir))
                              endif

FUNCTION  TCommentOpFunc_gc2c()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gc2c')
                            call tcomment#SetOption("count", 2)
                            return call('tcomment#operator#Op', a:000)

FUNCTION  go#config#SetBuildTags()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:value is ''
                                silent! unlet g:go_build_tags
                                call go#lsp#ResetWorkspaceDirectories()
                                return
                              endif
                            
                              let g:go_build_tags = a:value
                              call go#lsp#ResetWorkspaceDirectories()

FUNCTION  <SNR>103_StagePatch()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let add = []
                              let reset = []
                              let intend = []
                            
                              for lnum in range(a:lnum1,a:lnum2)
                                let info = s:StageInfo(lnum)
                                if empty(info.paths) && info.section ==# 'Staged'
                                  return 'Git reset --patch'
                                elseif empty(info.paths) && info.section ==# 'Unstaged'
                                  return 'Git add --patch'
                                elseif empty(info.paths) && info.section ==# 'Untracked'
                                  return 'Git add --interactive'
                                elseif empty(info.paths)
                                  continue
                                endif
                                execute lnum
                                if info.section ==# 'Staged'
                                  let reset += info.relative
                                elseif info.section ==# 'Untracked'
                                  let intend += info.paths
                                elseif info.status !~# '^D'
                                  let add += info.relative
                                endif
                              endfor
                              try
                                if !empty(intend)
                                  call s:TreeChomp(['add', '--intent-to-add', '--'] + intend)
                                endif
                                if !empty(add)
                                  execute "Git add --patch -- ".join(map(add,'s:fnameescape(v:val)'))
                                endif
                                if !empty(reset)
                                  execute "Git reset --patch -- ".join(map(reset,'s:fnameescape(v:val)'))
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              return s:ReloadStatus()

FUNCTION  go#config#TermCloseOnExit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_term_close_on_exit', 1)

FUNCTION  <SNR>2_ManPager()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              set nocompatible
                              if exists('+viminfofile')
                                set viminfofile=NONE
                              endif
                              set noswapfile 
                            
                              setlocal ft=man
                              runtime ftplugin/man.vim
                              setlocal buftype=nofile bufhidden=hide iskeyword+=: modifiable
                            
                              " Emulate 'col -b'
                              silent keepj keepp %s/\v(.)\b\ze\1?//ge
                            
                              " Remove empty lines above the header
                              call cursor(1, 1)
                              let n = search(".*(.*)", "c")
                              if n > 1
                                exe "1," . n-1 . "d"
                              endif
                              setlocal nomodified readonly
                            
                              syntax on

FUNCTION  fugitive#statusline()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return fugitive#Statusline()

FUNCTION  fugitive#RevParse()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [hash, exec_error] = s:ChompError([a:0 ? a:1 : s:Dir(), 'rev-parse', '--verify', a:rev, '--'])
                              if !exec_error && hash =~# '^\x\{40,\}$'
                                return hash
                              endif
                              throw 'fugitive: rev-parse '.a:rev.': '.hash

FUNCTION  <SNR>43_noop()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  <SNR>34_extractopts()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let i = 0
                              while i < len(a:list)
                                if a:list[i] =~ '^-[^=]' && has_key(a:opts,matchstr(a:list[i],'-\zs[^=]*'))
                                  let key   = matchstr(a:list[i],'-\zs[^=]*')
                                  let value = matchstr(a:list[i],'=\zs.*')
                                  if type(get(a:opts,key)) == type([])
                                    let a:opts[key] += [value]
                                  elseif type(get(a:opts,key)) == type(0)
                                    let a:opts[key] = 1
                                  else
                                    let a:opts[key] = value
                                  endif
                                else
                                  let i += 1
                                  continue
                                endif
                                call remove(a:list,i)
                              endwhile
                              return a:opts

FUNCTION  fugitive#simplify()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(dir)
                                return ''
                              endif
                              if file =~# '/\.\.\%(/\|$\)'
                                let tree = s:Tree(dir)
                                if len(tree)
                                  let path = simplify(tree . file)
                                  if strpart(path . '/', 0, len(tree) + 1) !=# tree . '/'
                                    return FugitiveVimPath(path)
                                  endif
                                endif
                              endif
                              return FugitiveVimPath('fugitive://' . simplify(dir) . '//' . commit . simplify(file))

FUNCTION  go#fmt#ToggleFmtAutoSave()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if go#config#FmtAutosave()
                                call go#config#SetFmtAutosave(0)
                                call go#util#EchoProgress("auto fmt disabled")
                                return
                              end
                            
                              call go#config#SetFmtAutosave(1)
                              call go#util#EchoProgress("auto fmt enabled")

FUNCTION  <SNR>41_noop()
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  NetUserPass()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")

FUNCTION  <SNR>103_diff_restore()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let restore = 'setlocal nodiff noscrollbind' . ' scrollopt=' . &l:scrollopt . (&l:wrap ? ' wrap' : ' nowrap') . ' foldlevel=999' . ' foldmethod=' . &l:foldmethod . ' foldcolumn=' . &l:foldcolumn . ' foldlevel=' . &l:foldlevel . (&l:foldenable ? ' foldenable' : ' nofoldenable')
                              if has('cursorbind')
                                let restore .= (&l:cursorbind ? ' ' : ' no') . 'cursorbind'
                              endif
                              return restore

FUNCTION  go#auto#echo_go_info()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !go#config#EchoGoInfo()
                                return
                              endif
                            
                              if !exists('v:completed_item') || empty(v:completed_item)
                                return
                              endif
                              let item = v:completed_item
                            
                              if !has_key(item, "info")
                                return
                              endif
                            
                              if empty(item.info)
                                return
                              endif
                            
                              redraws! | echo "vim-go: " | echohl Function | echon item.info | echohl None

FUNCTION  go#lsp#Completion()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call go#lsp#DidChange(a:fname)
                            
                              let l:lsp = s:lspfactory.get()
                              let l:msg = go#lsp#message#Completion(a:fname, a:line, a:col)
                              let l:state = s:newHandlerState('completion')
                              let l:state.handleResult = funcref('s:completionHandler', [function(a:handler, [], l:state)], l:state)
                              let l:state.error = funcref('s:completionErrorHandler', [function(a:handler, [], l:state)], l:state)
                              return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  <SNR>103_ConfigTimestamps()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let files = ['/etc/gitconfig', '~/.gitconfig', len($XDG_CONFIG_HOME) ? $XDG_CONFIG_HOME . '/git/config' : '~/.config/git/config']
                              if len(a:dir)
                                call add(files, fugitive#Find('.git/config', a:dir))
                              endif
                              call extend(files, get(a:dict, 'include.path', []))
                              return join(map(files, 'getftime(expand(v:val))'), ',')

FUNCTION  <SNR>106_add_sign()
Called 71 times
Total time:   0.011430
 Self time:   0.010941

count  total (s)   self (s)
   71              0.000255   call add(a:sy.lines, a:line)
   71              0.000307   let a:sy.signtable[a:line] = 1
                            
   71              0.000256   if has_key(a:sy.internal, a:line)
                                " There is a sign on this line already.
                                if a:type == a:sy.internal[a:line].type
                                  " Keep current sign since the new one is of the same type.
                                  return a:sy.internal[a:line].id
                                else
                                  " Update sign by overwriting the ID of the current sign.
                                  let id = a:sy.internal[a:line].id
                                endif
   71              0.000050   endif
                            
   71              0.000197   if !exists('id')
   71   0.000876   0.000387     let id = sy#sign#id_next(a:sy)
   71              0.000067   endif
                            
   71              0.000460   if a:type =~# 'SignifyDelete'
    6              0.000111     execute printf('sign define %s text=%s texthl=SignifySignDelete linehl=%s', a:type, a:1, s:delete_highlight[g:signify_line_highlight])
   71              0.000062   endif
   71              0.007414   execute printf('sign place %d line=%d name=%s buffer=%s', id, a:line, a:type, a:sy.buffer)
                            
   71              0.000163   return id

FUNCTION  qf#OpenLoclist()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if get(g:, 'qf_auto_open_loclist', 1)
                                    " get user-defined maximum height
                                    let max_height = get(g:, 'qf_max_height', 10) < 1 ? 10 : get(g:, 'qf_max_height', 10)
                                    execute get(g:, "qf_auto_resize", 1) ? 'lclose|' . min([ max_height, len(getloclist(0)) ]) . 'lwindow' : 'lwindow'
                                endif

FUNCTION  <SNR>103_Map()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for mode in split(a:mode, '\zs')
                                let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')
                                let head = a:lhs
                                let tail = ''
                                let keys = get(g:, mode.'remap', {})
                                if type(keys) == type([])
                                  return
                                endif
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
                                if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))
                                  exe mode.'map <buffer>' s:nowait flags head.tail a:rhs
                                  if a:0 > 1
                                    let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|sil! exe "' . mode . 'unmap <buffer> ' . head.tail . '"'
                                  endif
                                endif
                              endfor

FUNCTION  <SNR>4_FindPage()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let where = system("man ".s:man_find_arg.' '.s:GetCmdArg(a:sect, a:page))
                              if where !~ "^/"
                                if matchstr(where, " [^ ]*$") !~ "^ /"
                                  return 0
                                endif
                              endif
                              return 1

FUNCTION  <SNR>100_strip_context()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let diff = []
                              let hunk = []
                              let state = 0
                              let lines = a:context
                              let linenr = 0
                            
                              while linenr < len(lines)
                                let line = lines[linenr]
                            
                                if state == 0
                                  if line =~ "^@@ "
                                    let [old_line, new_line, old_count, new_count] = sy#sign#parse_hunk(line)
                                    let hunk = []
                                    let state = 1
                                  else
                                    call add(diff,line)
                                  endif
                                  let linenr += 1
                                elseif index([1,2,3],state) >= 0 && index(['\','/'],line[0]) >= 0
                                  let linenr += 1
                                  call add(hunk,line)
                                elseif state == 1
                                  if line[0] == ' '
                                    let old_line += 1
                                    let new_line += 1
                                    let old_count -= 1
                                    let new_count -= 1
                                    let linenr += 1
                                  else
                                    let old_count_part = 0
                                    let new_count_part = 0
                                    let state = 2
                                  endif
                                elseif state == 2
                                  if line[0] == '-'
                                    call add(hunk,line)
                                    let old_count_part += 1
                                    let linenr += 1
                                  else
                                    let state = 3
                                  endif
                                elseif state == 3
                                  if line[0] == '+'
                                    call add(hunk,line)
                                    let new_count_part += 1
                                    let linenr += 1
                                  else
                                    call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                    let diff += hunk
                                    let hunk = []
                                    let old_count -= old_count_part
                                    let new_count -= new_count_part
                                    let old_line += old_count_part
                                    let new_line += new_count_part
                                    let state = 1
                                  endif
                                endif
                            
                                if state > 0 && new_count <= 0 && old_count <= 0
                                  if len(hunk) > 0
                                    call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                    let diff = diff + hunk
                                    let hunk = []
                                  endif
                                  let state = 0
                                endif
                              endwhile
                              if len(hunk) > 0
                                call add(diff, printf("@@ -%d%s +%d%s @@",(old_count_part == 0 && old_line > 0) ? old_line -1 : old_line, old_count_part == 1 ? "" : printf(",%d", old_count_part), (new_count_part == 0 && new_line > 0) ? new_line - 1 : new_line, new_count_part == 1 ? "" : printf(",%d", new_count_part)))
                                let diff = diff + hunk
                                let hunk = []
                              endif
                              return diff

FUNCTION  sy#sign#set_signs()
Called 1 time
Total time:   0.020445
 Self time:   0.000184

count  total (s)   self (s)
    1   0.000040   0.000020   call sy#verbose('sy#sign#set_signs()', a:vcs)
                            
    1              0.000004   if a:sy.stats == [-1, -1, -1]
    1              0.000003     let a:sy.stats = [0, 0, 0]
    1              0.000001   endif
                            
    1              0.000003   if empty(a:diff)
                                call sy#verbose('No changes found.', a:vcs)
                                let a:sy.stats = [0, 0, 0]
                                call sy#sign#remove_all_signs(a:sy.buffer)
                                return
    1              0.000001   endif
                            
    1              0.000003   if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_enable()
    1              0.000000   else
    1   0.000551   0.000112     call sy#highlight#line_disable()
    1              0.000001   endif
                            
    1   0.019812   0.000010   call sy#sign#process_diff(a:sy, a:vcs, a:diff)
                            
    1              0.000007   if exists('#User#Signify')
                                doautocmd <nomodeline> User Signify
    1              0.000000   endif

FUNCTION  go#lsp#GetInfo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:fname = expand('%:p')
                              let [l:line, l:col] = go#lsp#lsp#Position()
                            
                              call go#lsp#DidChange(l:fname)
                            
                              let l:lsp = s:lspfactory.get()
                            
                              let l:state = s:newHandlerState('')
                            
                              let l:info = go#promise#New(function('s:info', [0], l:state), 10000, '')
                            
                              let l:state.handleResult = funcref('s:infoDefinitionHandler', [l:info.wrapper, 0], l:state)
                              let l:state.error = funcref('s:noop')
                              let l:msg = go#lsp#message#Definition(l:fname, l:line, l:col)
                              call l:lsp.sendMessage(l:msg, l:state)
                              return l:info.await()

FUNCTION  <SNR>76_map_if_not_mapped()
Called 6 times
Total time:   0.000221
 Self time:   0.000221

count  total (s)   self (s)
    6              0.000018     let l:unique = s:overwrite ? '' : ' <unique>'
    6              0.000098     if !hasmapto(a:rhs, a:mode)
    5              0.000089 	silent! exe a:mode . 'map' . l:unique a:lhs a:rhs
    6              0.000005     endif

FUNCTION  fugitive#Find()
Called 1 time
Total time:   0.000557
 Self time:   0.000316

count  total (s)   self (s)
    1              0.000004   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
    1              0.000019   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
    1   0.000030   0.000021   elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
    1   0.000024   0.000015   elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
    1              0.000001   endif
    1              0.000004   let dir = a:0 ? a:1 : s:Dir()
    1              0.000003   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
    1              0.000000   endif
    1   0.000014   0.000005   let rev = s:Slash(a:object)
    1   0.000151   0.000007   let tree = s:Tree(dir)
    1              0.000004   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
    1              0.000002   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
    1              0.000006   elseif rev =~# '^\.git/'
    1              0.000009     let f = substitute(rev, '^\.git', '', '')
    1   0.000068   0.000007     let cdir = fugitive#CommonDir(dir)
    1              0.000007     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
    1              0.000008     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
    1              0.000015     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
    1              0.000001     else
    1              0.000005       let f = simplify(dir . f)
    1              0.000001     endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^[^:.-][^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^[^:.-][^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit, '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
    1              0.000001   endif
    1   0.000016   0.000007   return FugitiveVimPath(f)

FUNCTION  <SNR>104_parse_guru_output()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:exit_val
                                call go#util#EchoError(a:output)
                                return
                              endif
                            
                              let errformat = "%f:%l.%c-%[%^:]%#:\ %m,%f:%l:%c:\ %m"
                              let l:listtype = go#list#Type("_guru")
                              call go#list#ParseFormat(l:listtype, errformat, a:output, a:title)
                            
                              let errors = go#list#Get(l:listtype)
                              call go#list#Window(l:listtype, len(errors))

FUNCTION  <SNR>49_wrap()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let keeper = a:string
                              let newchar = a:char
                              let s:input = ""
                              let type = a:type
                              let linemode = type ==# 'V' ? 1 : 0
                              let before = ""
                              let after  = ""
                              if type ==# "V"
                                let initspaces = matchstr(keeper,'\%^\s*')
                              else
                                let initspaces = matchstr(getline('.'),'\%^\s*')
                              endif
                              let pairs = "b()B{}r[]a<>"
                              let extraspace = ""
                              if newchar =~ '^ '
                                let newchar = strpart(newchar,1)
                                let extraspace = ' '
                              endif
                              let idx = stridx(pairs,newchar)
                              if newchar == ' '
                                let before = ''
                                let after  = ''
                              elseif exists("b:surround_".char2nr(newchar))
                                let all    = s:process(b:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif exists("g:surround_".char2nr(newchar))
                                let all    = s:process(g:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif newchar ==# "p"
                                let before = "\n"
                                let after  = "\n\n"
                              elseif newchar ==# 's'
                                let before = ' '
                                let after  = ''
                              elseif newchar ==# ':'
                                let before = ':'
                                let after = ''
                              elseif newchar =~# "[tT\<C-T><]"
                                let dounmapp = 0
                                let dounmapb = 0
                                if !maparg(">","c")
                                  let dounmapb = 1
                                  " Hide from AsNeeded
                                  exe "cn"."oremap > ><CR>"
                                endif
                                let default = ""
                                if newchar ==# "T"
                                  if !exists("s:lastdel")
                                    let s:lastdel = ""
                                  endif
                                  let default = matchstr(s:lastdel,'<\zs.\{-\}\ze>')
                                endif
                                let tag = input("<",default)
                                if dounmapb
                                  silent! cunmap >
                                endif
                                let s:input = tag
                                if tag != ""
                                  let keepAttributes = ( match(tag, ">$") == -1 )
                                  let tag = substitute(tag,'>*$','','')
                                  let attributes = ""
                                  if keepAttributes
                                    let attributes = matchstr(a:removed, '<[^ \t\n]\+\zs\_.\{-\}\ze>')
                                  endif
                                  let s:input = tag . '>'
                                  if tag =~ '/$'
                                    let tag = substitute(tag, '/$', '', '')
                                    let before = '<'.tag.attributes.' />'
                                    let after = ''
                                  else
                                    let before = '<'.tag.attributes.'>'
                                    let after  = '</'.substitute(tag,' .*','','').'>'
                                  endif
                                  if newchar == "\<C-T>"
                                    if type ==# "v" || type ==# "V"
                                      let before .= "\n\t"
                                    endif
                                    if type ==# "v"
                                      let after  = "\n". after
                                    endif
                                  endif
                                endif
                              elseif newchar ==# 'l' || newchar == '\'
                                " LaTeX
                                let env = input('\begin{')
                                if env != ""
                                  let s:input = env."\<CR>"
                                  let env = '{' . env
                                  let env .= s:closematch(env)
                                  echo '\begin'.env
                                  let before = '\begin'.env
                                  let after  = '\end'.matchstr(env,'[^}]*').'}'
                                endif
                              elseif newchar ==# 'f' || newchar ==# 'F'
                                let fnc = input('function: ')
                                if fnc != ""
                                  let s:input = fnc."\<CR>"
                                  let before = substitute(fnc,'($','','').'('
                                  let after  = ')'
                                  if newchar ==# 'F'
                                    let before .= ' '
                                    let after = ' ' . after
                                  endif
                                endif
                              elseif newchar ==# "\<C-F>"
                                let fnc = input('function: ')
                                let s:input = fnc."\<CR>"
                                let before = '('.fnc.' '
                                let after = ')'
                              elseif idx >= 0
                                let spc = (idx % 3) == 1 ? " " : ""
                                let idx = idx / 3 * 3
                                let before = strpart(pairs,idx+1,1) . spc
                                let after  = spc . strpart(pairs,idx+2,1)
                              elseif newchar == "\<C-[>" || newchar == "\<C-]>"
                                let before = "{\n\t"
                                let after  = "\n}"
                              elseif newchar !~ '\a'
                                let before = newchar
                                let after  = newchar
                              else
                                let before = ''
                                let after  = ''
                              endif
                              let after  = substitute(after ,'\n','\n'.initspaces,'g')
                              if type ==# 'V' || (a:special && type ==# "v")
                                let before = substitute(before,' \+$','','')
                                let after  = substitute(after ,'^ \+','','')
                                if after !~ '^\n'
                                  let after  = initspaces.after
                                endif
                                if keeper !~ '\n$' && after !~ '^\n'
                                  let keeper .= "\n"
                                elseif keeper =~ '\n$' && after =~ '^\n'
                                  let after = strpart(after,1)
                                endif
                                if keeper !~ '^\n' && before !~ '\n\s*$'
                                  let before .= "\n"
                                  if a:special
                                    let before .= "\t"
                                  endif
                                elseif keeper =~ '^\n' && before =~ '\n\s*$'
                                  let keeper = strcharpart(keeper,1)
                                endif
                                if type ==# 'V' && keeper =~ '\n\s*\n$'
                                  let keeper = strcharpart(keeper,0,strchars(keeper) - 1)
                                endif
                              endif
                              if type ==# 'V'
                                let before = initspaces.before
                              endif
                              if before =~ '\n\s*\%$'
                                if type ==# 'v'
                                  let keeper = initspaces.keeper
                                endif
                                let padding = matchstr(before,'\n\zs\s\+\%$')
                                let before  = substitute(before,'\n\s\+\%$','\n','')
                                let keeper = s:fixindent(keeper,padding)
                              endif
                              if type ==# 'V'
                                let keeper = before.keeper.after
                              elseif type =~ "^\<C-V>"
                                " Really we should be iterating over the buffer
                                let repl = substitute(before,'[\\~]','\\&','g').'\1'.substitute(after,'[\\~]','\\&','g')
                                let repl = substitute(repl,'\n',' ','g')
                                let keeper = substitute(keeper."\n",'\(.\{-\}\)\(\n\)',repl.'\n','g')
                                let keeper = substitute(keeper,'\n\%$','','')
                              else
                                let keeper = before.extraspace.keeper.extraspace.after
                              endif
                              return keeper

FUNCTION  TCommentOpFunc_gc3c()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gc3c')
                            call tcomment#SetOption("count", 3)
                            return call('tcomment#operator#Op', a:000)

FUNCTION  <SNR>103_CommitInteractive()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let status = s:StatusCommand(a:line1, a:line2, a:range, a:line2, a:bang, a:mods, '', '', [])
                              let status = len(status) ? status . '|' : ''
                              if a:patch
                                return status . 'if search("^Unstaged")|exe "normal >"|exe "+"|endif'
                              else
                                return status . 'if search("^Untracked\\|^Unstaged")|exe "+"|endif'
                              endif

FUNCTION  go#config#DebugAddress()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_debug_address', '127.0.0.1:8181')

FUNCTION  <SNR>57_LP_And()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            "  call Dfunc("LP_And(pat1<".a:pat1."> pat2<".a:pat2.">)")
                              let ret= '\%('.a:pat1.'\&'.a:pat2.'\)'
                            "  call Dret("LP_And ".ret)
                              return ret

FUNCTION  <SNR>34_titlecase()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(s:spacecase(a:word), '\(\<\w\)','\=toupper(submatch(1))','g')

FUNCTION  go#lsp#Definition()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call go#lsp#DidChange(a:fname)
                            
                              let l:lsp = s:lspfactory.get()
                              let l:state = s:newHandlerState('definition')
                              let l:state.handleResult = funcref('s:definitionHandler', [function(a:handler, [], l:state)], l:state)
                              let l:msg = go#lsp#message#Definition(fnamemodify(a:fname, ':p'), a:line, a:col)
                              return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  <SNR>44_LinuxKeywords()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                syn keyword cOperator likely unlikely
                                syn keyword cType u8 u16 u32 u64 s8 s16 s32 s64
                                syn keyword cType __u8 __u16 __u32 __u64 __s8 __s16 __s32 __s64

FUNCTION  <SNR>95_workspaceFolder()
Called 1 time
Total time:   0.000108
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000107   0.000007   return {'uri': go#path#ToURI(a:val), 'name': a:val}

FUNCTION  <SNR>103_repo_prepare()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return call('fugitive#Prepare', [self.git_dir] + a:000)

FUNCTION  go#guru#Referrers()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = { 'mode': 'referrers', 'format': 'plain', 'selected': a:selected, 'needs_scope': 0, }
                            
                              call s:run_guru(args)

FUNCTION  fugitive#head()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if empty(s:Dir())
                                return ''
                              endif
                            
                              return fugitive#Head(a:0 ? a:1 : 0)

FUNCTION  <SNR>19_LoadFTPlugin()
Called 2 times
Total time:   0.014945
 Self time:   0.005323

count  total (s)   self (s)
    2              0.000011     if exists("b:undo_ftplugin")
    1              0.000442       exe b:undo_ftplugin
    1              0.000005       unlet! b:undo_ftplugin b:did_ftplugin
    2              0.000003     endif
                            
    2              0.000010     let s = expand("<amatch>")
    2              0.000004     if s != ""
    2              0.000030       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    2              0.000002       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000022       for name in split(s, '\.')
    2   0.014370   0.004748 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    4              0.000008       endfor
    2              0.000002     endif

FUNCTION  <SNR>5_GetPage()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:0 >= 2
                                let sect = a:1
                                let page = a:2
                              elseif a:0 >= 1
                                let sect = ""
                                let page = a:1
                              else
                                return
                              endif
                            
                              " To support:	    nmap K :Man <cword>
                              if page == '<cword>'
                                let page = expand('<cword>')
                              endif
                            
                              if sect != "" && s:FindPage(sect, page) == 0
                                let sect = ""
                              endif
                              if s:FindPage(sect, page) == 0
                                echo "\nCannot find a '".page."'."
                                return
                              endif
                              exec "let s:man_tag_buf_".s:man_tag_depth." = ".bufnr("%")
                              exec "let s:man_tag_lin_".s:man_tag_depth." = ".line(".")
                              exec "let s:man_tag_col_".s:man_tag_depth." = ".col(".")
                              let s:man_tag_depth = s:man_tag_depth + 1
                            
                              " Use an existing "man" window if it exists, otherwise open a new one.
                              if &filetype != "man"
                                let thiswin = winnr()
                                exe "norm! \<C-W>b"
                                if winnr() > 1
                                  exe "norm! " . thiswin . "\<C-W>w"
                                  while 1
                            	if &filetype == "man"
                            	  break
                            	endif
                            	exe "norm! \<C-W>w"
                            	if thiswin == winnr()
                            	  break
                            	endif
                                  endwhile
                                endif
                                if &filetype != "man"
                                  new
                                  setl nonu fdc=0
                                endif
                              endif
                              silent exec "edit $HOME/".page.".".sect."~"
                              " Avoid warning for editing the dummy file twice
                              setl buftype=nofile noswapfile
                            
                              setl ma nonu nornu nofen
                              silent exec "norm 1GdG"
                              let $MANWIDTH = winwidth(0)
                              silent exec "r!/usr/bin/man ".s:GetCmdArg(sect, page)." | col -b"
                              " Remove blank lines from top and bottom.
                              while getline(1) =~ '^\s*$'
                                silent norm ggdd
                              endwhile
                              while getline('$') =~ '^\s*$'
                                silent norm Gdd
                              endwhile
                              1
                              setl ft=man nomod
                              setl bufhidden=hide
                              setl nobuflisted

FUNCTION  TCommentOpFunc_gc4c()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gc4c')
                            call tcomment#SetOption("count", 4)
                            return call('tcomment#operator#Op', a:000)

FUNCTION  <SNR>104_info()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:exit_val != 0
                                return
                              endif
                            
                              if a:output[0] !=# '{'
                                return
                              endif
                            
                              if empty(a:output) || type(a:output) != type("")
                                return
                              endif
                            
                              let result = json_decode(a:output)
                              if type(result) != type({})
                                call go#util#EchoError(printf("malformed output from guru: %s", a:output))
                                return
                              endif
                            
                              if !has_key(result, 'detail')
                                " if there is no detail check if there is a description and print it
                                if has_key(result, "desc")
                                  call go#util#EchoInfo(result["desc"])
                                  return
                                endif
                            
                                call go#util#EchoError("detail key is missing. Please open a bug report on vim-go repo.")
                                return
                              endif
                            
                              let detail = result['detail']
                              let info = ""
                            
                              " guru gives different information based on the detail mode. Let try to
                              " extract the most useful information
                            
                              if detail == "value"
                                if !has_key(result, 'value')
                                  call go#util#EchoError("value key is missing. Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let val = result["value"]
                                if !has_key(val, 'type')
                                  call go#util#EchoError("type key is missing (value.type). Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let info = val["type"]
                              elseif detail == "type"
                                if !has_key(result, 'type')
                                  call go#util#EchoError("type key is missing. Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let type = result["type"]
                                if !has_key(type, 'type')
                                  call go#util#EchoError("type key is missing (type.type). Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let info = type["type"]
                              elseif detail == "package"
                                if !has_key(result, 'package')
                                  call go#util#EchoError("package key is missing. Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let package = result["package"]
                                if !has_key(package, 'path')
                                  call go#util#EchoError("path key is missing (package.path). Please open a bug report on vim-go repo.")
                                  return
                                endif
                            
                                let info = printf("package %s", package["path"])
                              elseif detail == "unknown"
                                let info = result["desc"]
                              else
                                call go#util#EchoError(printf("unknown detail mode found '%s'. Please open a bug report on vim-go repo", detail))
                                return
                              endif
                            
                              call go#util#ShowInfo(info)

FUNCTION  go#config#MetalinterAutosaveEnabled()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:default_enabled = ["vet", "golint"]
                            
                              if go#config#MetalinterCommand() == "golangci-lint"
                                let l:default_enabled = ["govet", "golint"]
                              endif
                            
                              return get(g:, "go_metalinter_autosave_enabled", default_enabled)

FUNCTION  gutentags#make_args()
Called 2 times
Total time:   0.000538
 Self time:   0.000538

count  total (s)   self (s)
    2              0.000005         let l:outcmd = []
   26              0.000040         for cmdarg in a:cmd
                                        " Thanks Vimscript... you can use negative integers for strings
                                        " in the slice notation, but not for indexing characters :(
   24              0.000062             let l:arglen = strlen(cmdarg)
   24              0.000145             if (cmdarg[0] == '"' && cmdarg[l:arglen - 1] == '"') || (cmdarg[0] == "'" && cmdarg[l:arglen - 1] == "'")
   11              0.000044                 call add(l:outcmd, cmdarg[1:-2])
   13              0.000010             else
   13              0.000036                 call add(l:outcmd, cmdarg)
   24              0.000021             endif
   26              0.000059         endfor
    2              0.000004         return l:outcmd

FUNCTION  go#config#DefMode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_def_mode', 'gopls')

FUNCTION  <SNR>103_StageDiff()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let lnum = line('.')
                              let info = s:StageInfo(lnum)
                              let prefix = info.offset > 0 ? '+' . info.offset : ''
                              if empty(info.paths) && info.section ==# 'Staged'
                                return 'Git! diff --no-ext-diff --cached'
                              elseif empty(info.paths)
                                return 'Git! diff --no-ext-diff'
                              elseif len(info.paths) > 1
                                execute 'Gedit' . prefix s:fnameescape(':0:' . info.paths[0])
                                return a:diff . '! HEAD:'.s:fnameescape(info.paths[1])
                              elseif info.section ==# 'Staged' && info.sigil ==# '-'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! :0:%'
                              elseif info.section ==# 'Staged'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! @:%'
                              elseif info.sigil ==# '-'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! :(top)%'
                              else
                                execute 'Gedit' prefix s:fnameescape(':(top)'.info.paths[0])
                                return a:diff . '!'
                              endif

FUNCTION  go#list#Window()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " we don't use lwindow to close the location list as we need also the
                              " ability to resize the window. So, we are going to use lopen and lclose
                              " for a better user experience. If the number of errors in a current
                              " location list increases/decreases, cwindow will not resize when a new
                              " updated height is passed. lopen in the other hand resizes the screen.
                              if !a:0 || a:1 == 0
                                call go#list#Close(a:listtype)
                                return
                              endif
                            
                              let height = go#config#ListHeight()
                              if height == 0
                                " prevent creating a large location height for a large set of numbers
                                if a:1 > 10
                                  let height = 10
                                else
                                  let height = a:1
                                endif
                              endif
                            
                              if a:listtype == "locationlist"
                                exe 'lopen ' . height
                              else
                                exe 'copen ' . height
                              endif

FUNCTION  <SNR>7_Wholematch()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let group = '\%(' . a:pat . '\)'
                              let prefix = (a:start ? '\(^.*\%<' . (a:start + 2) . 'c\)\zs' : '^')
                              let len = strlen(a:string)
                              let suffix = (a:start+1 < len ? '\(\%>'.(a:start+1).'c.*$\)\@=' : '$')
                              if a:string !~ prefix . group . suffix
                                let prefix = ''
                              endif
                              return prefix . group . suffix

FUNCTION  sy#enable()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('b:sy')
                                call sy#start()
                                return
                              endif
                            
                              if !b:sy.active
                                let b:sy.active = 1
                                let b:sy.retry  = 1
                                call sy#start()
                              endif

FUNCTION  fugitive#FileWriteCmd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let tmp = tempname()
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let autype = a:0 > 1 ? 'Buf' : 'File'
                              if exists('#' . autype . 'WritePre')
                                execute 'doautocmd ' . autype . 'WritePre ' . s:fnameescape(amatch)
                              endif
                              try
                                let [dir, commit, file] = s:DirCommitFile(amatch)
                                if commit !~# '^[0-3]$' || !v:cmdbang && (line("'[") != 1 || line("']") != line('$'))
                                  return "noautocmd '[,']write" . (v:cmdbang ? '!' : '') . ' ' . s:fnameescape(amatch)
                                endif
                                silent execute "'[,']write !".fugitive#Prepare(dir, 'hash-object', '-w', '--stdin', '--').' > '.tmp
                                let sha1 = readfile(tmp)[0]
                                let old_mode = matchstr(s:SystemError([dir, 'ls-files', '--stage', '.' . file])[0], '^\d\+')
                                if empty(old_mode)
                                  let old_mode = executable(s:Tree(dir) . file) ? '100755' : '100644'
                                endif
                                let info = old_mode.' '.sha1.' '.commit."\t".file[1:-1]
                                let [error, exec_error] = s:SystemError([dir, 'update-index', '--index-info'], info . "\n")
                                if !exec_error
                                  setlocal nomodified
                                  if exists('#' . autype . 'WritePost')
                                    execute 'doautocmd ' . autype . 'WritePost ' . s:fnameescape(amatch)
                                  endif
                                  return ''
                                else
                                  return 'echoerr '.string('fugitive: '.error)
                                endif
                              finally
                                call delete(tmp)
                              endtry

FUNCTION  <SNR>104_describe_balloon()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:exit_val != 0
                                return
                              endif
                            
                              if a:output[0] !=# '{'
                                return
                              endif
                            
                              if empty(a:output) || type(a:output) != type("")
                                return
                              endif
                            
                              let l:result = json_decode(a:output)
                              if type(l:result) != type({})
                                call go#util#EchoError(printf('malformed output from guru: %s', a:output))
                                return
                              endif
                            
                              let l:info = []
                              if has_key(l:result, 'desc')
                                if l:result['desc'] != 'identifier'
                                  let l:info = add(l:info, l:result['desc'])
                                endif
                              endif
                            
                              if has_key(l:result, 'detail')
                                let l:detail = l:result['detail']
                            
                                " guru gives different information based on the detail mode. Let try to
                                " extract the most useful information
                            
                                if l:detail == 'value'
                                  if !has_key(l:result, 'value')
                                    call go#util#EchoError('value key is missing. Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:val = l:result['value']
                                  if !has_key(l:val, 'type')
                                    call go#util#EchoError('type key is missing (value.type). Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:info = add(l:info, printf('type: %s', l:val['type']))
                                  if has_key(l:val, 'value')
                                    let l:info = add(l:info, printf('value: %s', l:val['value']))
                                  endif
                                elseif l:detail == 'type'
                                  if !has_key(l:result, 'type')
                                    call go#util#EchoError('type key is missing. Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:type = l:result['type']
                                  if !has_key(l:type, 'type')
                                    call go#util#EchoError('type key is missing (type.type). Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:info = add(l:info, printf('type: %s', l:type['type']))
                            
                                  if has_key(l:type, 'methods')
                                    let l:info = add(l:info, 'methods:')
                                    for l:m in l:type.methods
                                      let l:info = add(l:info, printf("\t%s", l:m['name']))
                                    endfor
                                  endif
                                elseif l:detail == 'package'
                                  if !has_key(l:result, 'package')
                                    call go#util#EchoError('package key is missing. Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:package = result['package']
                                  if !has_key(l:package, 'path')
                                    call go#util#EchoError('path key is missing (package.path). Please open a bug report on vim-go repo.')
                                    return
                                  endif
                            
                                  let l:info = add(l:info, printf('package: %s', l:package["path"]))
                                elseif l:detail == 'unknown'
                                  " the description is already included in l:info, and there's no other
                                  " information on unknowns.
                                else
                                  call go#util#EchoError(printf('unknown detail mode (%s) found. Please open a bug report on vim-go repo', l:detail))
                                  return
                                endif
                              endif
                            
                              if has('balloon_eval')
                                call balloon_show(join(l:info, "\n"))
                                return
                              endif
                            
                              call balloon_show(l:info)

FUNCTION  <SNR>103_ExpandVarLegacy()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if get(g:, 'fugitive_legacy_quoting', 1)
                                return substitute(a:str, '\\\ze[%#!]', '', 'g')
                              else
                                return a:str
                              endif

FUNCTION  gutentags#trace()
Called 17 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
   17              0.000053     if g:gutentags_trace || (a:0 && a:1)
                                    let l:message = "gutentags: " . a:message
                                    echom l:message
   17              0.000015     endif

FUNCTION  gutentags#remove_job_by_data()
Called 1 time
Total time:   0.000184
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000047   0.000009     let l:idx = gutentags#find_job_index_by_data(a:module, a:data)
    1   0.000135   0.000007     call gutentags#remove_job(a:module, l:idx)

FUNCTION  go#config#FmtExperimental()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000010   return get(g:, "go_fmt_experimental", 0 )

FUNCTION  go#config#EchoCommandInfo()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000009   return get(g:, 'go_echo_command_info', 1)

FUNCTION  go#config#HighlightStringSpellcheck()
Called 3 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    3              0.000015   return get(g:, 'go_highlight_string_spellcheck', 1)

FUNCTION  sy#util#hunk_text_object()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              execute sy#util#return_if_no_changes()
                            
                              let lnum  = line('.')
                              let hunks = filter(copy(b:sy.hunks), 'v:val.start <= lnum && v:val.end >= lnum')
                            
                              if empty(hunks)
                                echomsg 'signify: Here is no hunk.'
                                return
                              endif
                            
                              execute hunks[0].start
                              normal! V
                            
                              if a:emptylines
                                let lnum = hunks[0].end
                                while getline(lnum+1) =~ '^$'
                                  let lnum += 1
                                endwhile
                                execute lnum
                              else
                                execute hunks[0].end
                              endif

FUNCTION  <SNR>103_NullError()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let [out, exec_error] = s:SystemError(call('fugitive#Prepare', a:000))
                              return [exec_error ? [] : split(out, "\1"), exec_error ? substitute(out, "\n$", "", "") : '', exec_error]

FUNCTION  <SNR>103_cpath()
Called 1 time
Total time:   0.000045
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000004   if exists('+fileignorecase') && &fileignorecase
                                let path = FugitiveVimPath(tolower(a:path))
    1              0.000001   else
    1   0.000027   0.000009     let path = FugitiveVimPath(a:path)
    1              0.000002   endif
    1              0.000007   return a:0 ? path ==# s:cpath(a:1) : path

FUNCTION  <SNR>57_StackLook()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            "  call Dfunc("StackLook(description<".a:description.">)")
                              let iop = 1
                              let ifp = 1
                            "  call Decho("Pattern                       Operator")
                            
                              " print both pattern and operator
                              while ifp <= s:npatstack && iop <= s:nopstack
                               let fp = s:patstack_{ifp}
                               let op = s:opstack_{iop}." (P".s:opprec_{s:nopstack}.')'
                               let fplen= strlen(fp)
                               if fplen < 30
                               	let fp= fp.strpart("                              ",1,30-fplen)
                               endif
                            "   call Decho(fp.op)
                               let ifp = ifp + 1
                               let iop = iop + 1
                              endwhile
                            
                              " print just pattern
                              while ifp <= s:npatstack
                               let fp  = s:patstack_{ifp}
                            "   call Decho(fp)
                               let ifp = ifp + 1
                              endwhile
                            
                              " print just operator
                              while iop <= s:nopstack
                               let op  = s:opstack_{iop}." (P".s:opprec_{s:nopstack}.')'
                            "   call Decho("                              ".op)
                               let iop = iop + 1
                              endwhile
                            "  call Dret("StackLook")

FUNCTION  <SNR>104_run_guru()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if go#util#has_job()
                                let res = s:async_guru(a:args)
                              else
                                let res = s:sync_guru(a:args)
                              endif
                            
                              return res

FUNCTION  TCommentOpFunc_gc5c()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gc5c')
                            call tcomment#SetOption("count", 5)
                            return call('tcomment#operator#Op', a:000)

FUNCTION  go#config#TermEnabled()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return has('nvim') && get(g:, 'go_term_enabled', 0)

FUNCTION  go#config#MetalinterAutosave()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return get(g:, "go_metalinter_autosave", 0)

FUNCTION  go#guru#Describe()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = { 'mode': 'describe', 'format': 'plain', 'selected': a:selected, 'needs_scope': 1, }
                            
                              call s:run_guru(args)

FUNCTION  LogiPat()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            "  call Dfunc("LogiPat(pat<".a:pat.">)")
                            
                              " LogiPat(pat,dosearch)
                              if a:0 > 0
                               let dosearch= a:1
                              else
                               let dosearch= 0
                              endif
                              if a:0 >= 3
                               let s:LogiPatFlags= a:3
                              endif
                            
                              let s:npatstack = 0
                              let s:nopstack  = 0
                              let s:preclvl   = 0
                              let expr        = a:pat
                            
                              " Lexer/Parser
                              while expr != ""
                            "   call Decho("expr<".expr.">")
                            
                               if expr =~ '^"'
                            	" push a Pattern; accept "" as a single " in the pattern
                                let expr = substitute(expr,'^\s*"','','')
                                let pat  = substitute(expr,'^\(\%([^"]\|\"\"\)\{-}\)"\([^"].*$\|$\)','\1','')
                            	let pat  = substitute(pat,'""','"','g')
                                let expr = substitute(expr,'^\(\%([^"]\|\"\"\)\{-}\)"\([^"].*$\|$\)','\2','')
                                let expr = substitute(expr,'^\s*','','')
                            "    call Decho("pat<".pat."> expr<".expr.">")
                            
                                call s:LP_PatPush('.*'.pat.'.*')
                            
                               elseif expr =~ '^[!()|&]'
                                " push an operator
                                let op   = strpart(expr,0,1)
                                let expr = strpart(expr,strlen(op))
                            	" allow for those who can't resist doubling their and/or operators
                            	if op =~ '[|&]' && expr[0] == op
                                 let expr = strpart(expr,strlen(op))
                            	endif
                                call s:LP_OpPush(op)
                            
                               elseif expr =~ '^\s'
                                " skip whitespace
                                let expr= strpart(expr,1)
                            
                               else
                                echoerr "operator<".strpart(expr,0,1)."> not supported (yet)"
                                let expr= strpart(expr,1)
                               endif
                            
                              endwhile
                            
                              " Final Execution
                              call s:LP_OpPush('Z')
                            
                              let result= s:LP_PatPop(1)
                            "  call Decho("result=".result)
                            
                              " sanity checks and cleanup
                              if s:npatstack > 0
                               echoerr s:npatstack." patterns left on stack!"
                               let s:npatstack= 0
                              endif
                              if s:nopstack > 0
                               echoerr s:nopstack." operators left on stack!"
                               let s:nopstack= 0
                              endif
                            
                              " perform the indicated search
                              if dosearch
                               if exists("s:LogiPatFlags") && s:LogiPatFlags != ""
                            "  call Decho("search(result<".result."> LogiPatFlags<".s:LogiPatFlags.">)")
                                call search(result,s:LogiPatFlags)
                               else
                            "  call Decho("search(result<".result.">)")
                                call search(result)
                               endif
                               let @/= result
                              endif
                            
                            "  call Dret("LogiPat ".result)
                              return result

FUNCTION  fugitive#extract_git_dir()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return FugitiveExtractGitDir(a:path)

FUNCTION  fugitive#Open()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:bang
                                return s:OpenExec(a:cmd, a:mods, s:SplitExpand(a:arg, s:Tree()))
                              endif
                            
                              let mods = s:Mods(a:mods)
                              try
                                let [file, pre] = s:OpenParse(a:args)
                                let file = s:Generate(file)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if file !~# '^\a\a\+:'
                                let file = s:sub(file, '/$', '')
                              endif
                              if a:cmd ==# 'edit'
                                call s:BlurStatus()
                              endif
                              return mods . a:cmd . pre . ' ' . s:fnameescape(file)

FUNCTION  go#path#BinPath()
Called 3 times
Total time:   0.000640
 Self time:   0.000528

count  total (s)   self (s)
    3   0.000063   0.000040   let bin_path = go#config#BinPath()
    3              0.000007   if bin_path != ""
                                return bin_path
    3              0.000003   endif
                            
                              " check if our global custom path is set, if not check if $GOBIN is set so
                              " we can use it, otherwise use default GOPATH
    3              0.000010   if $GOBIN != ""
                                let bin_path = $GOBIN
    3              0.000002   else
    3   0.000135   0.000046     let go_paths = split(go#path#Default(), go#util#PathListSep())
    3              0.000009     if len(go_paths) == 0
                                  return "" "nothing found
    3              0.000003     endif
    3              0.000352     let bin_path = expand(go_paths[0] . "/bin/")
    3              0.000004   endif
                            
    3              0.000008   return bin_path

FUNCTION  go#util#OffsetCursor()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return go#util#Offset(line('.'), col('.'))

FUNCTION  go#guru#AutoToggleSameIds()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if go#config#AutoSameids()
                                call go#util#EchoProgress("sameids auto highlighting disabled")
                                call go#guru#ClearSameIds()
                                call go#config#SetAutoSameids(0)
                                return
                              endif
                            
                              call go#util#EchoSuccess("sameids auto highlighting enabled")
                              call go#config#SetAutoSameids(1)

FUNCTION  <SNR>94_neooptions()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:options = {}
                              let l:options['stdout_buf'] = ''
                              let l:options['stderr_buf'] = ''
                            
                              let l:err_mode = get(a:options, 'err_mode', get(a:options, 'mode', ''))
                              let l:out_mode = get(a:options, 'out_mode', get(a:options, 'mode', ''))
                            
                              for key in keys(a:options)
                                  if key == 'cwd'
                                    let l:options['cwd'] = a:options['cwd']
                                    continue
                                  endif
                            
                                  if key == 'callback'
                                    let l:options['callback'] = a:options['callback']
                            
                                    if !has_key(a:options, 'out_cb')
                                      let l:options['on_stdout'] = function('s:callback2on_stdout', [l:out_mode], l:options)
                                    endif
                            
                                    if !has_key(a:options, 'err_cb')
                                      let l:options['on_stderr'] = function('s:callback2on_stderr', [l:err_mode], l:options)
                                    endif
                            
                                    continue
                                  endif
                            
                                  if key == 'out_cb'
                                    let l:options['out_cb'] = a:options['out_cb']
                                    let l:options['on_stdout'] = function('s:on_stdout', [l:out_mode], l:options)
                            
                                    continue
                                  endif
                            
                                  if key == 'err_cb'
                                    let l:options['err_cb'] = a:options['err_cb']
                                    let l:options['on_stderr'] = function('s:on_stderr', [l:err_mode], l:options)
                            
                                    continue
                                  endif
                            
                                  if key == 'exit_cb'
                                    let l:options['exit_cb'] = a:options['exit_cb']
                                    let l:options['on_exit'] = function('s:on_exit', [], l:options)
                            
                                    continue
                                  endif
                            
                                  if key == 'close_cb'
                                    continue
                                  endif
                            
                                  if key == 'stoponexit'
                                    if a:options['stoponexit'] == ''
                                      let l:options['detach'] = 1
                                    endif
                                    continue
                                  endif
                              endfor
                              return l:options

FUNCTION  go#util#EchoSuccess()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:echo(a:msg, 'Function')

FUNCTION  <SNR>51_Slash()
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000013   if exists('+shellslash')
                                return tr(a:path, '\', '/')
    2              0.000003   else
    2              0.000005     return a:path
                              endif

FUNCTION  go#config#GocodeUnimportedPackages()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_gocode_unimported_packages', 0)

FUNCTION  go#config#TestShowName()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_test_show_name', 0)

FUNCTION  fugitive#Complete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 == 1 ? a:1 : a:0 == 3 ? a:3 : s:Dir()
                              let pre = a:0 > 1 ? strpart(a:1, 0, a:2) : ''
                              let subcmd = matchstr(pre, '\u\w*[! ] *\zs[[:alnum:]-]\+\ze ')
                              if empty(subcmd)
                                let results = sort(s:Subcommands() + keys(s:Aliases(dir)))
                              elseif pre =~# ' -- '
                                return fugitive#CompletePath(a:lead, dir)
                              elseif a:lead =~# '^-'
                                let results = split(s:ChompDefault('', dir, subcmd, '--git-completion-helper'), ' ')
                              else
                                return fugitive#CompleteObject(a:lead, dir)
                              endif
                              return filter(results, 'strpart(v:val, 0, strlen(a:lead)) ==# a:lead')

FUNCTION  go#config#GocodeSocketType()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_gocode_socket_type', s:sock_type)

FUNCTION  sy#repo#detect()
Called 1 time
Total time:   0.001002
 Self time:   0.000090

count  total (s)   self (s)
    2              0.000011   for vcs in s:vcs_list
    1              0.000003     let b:sy.detecting += 1
    1   0.000952   0.000040     call sy#repo#get_diff(vcs, function('sy#sign#set_signs'))
    2              0.000015   endfor

FUNCTION  <SNR>103_PreviousItem()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for i in range(a:count)
                                if !search(s:item_pattern, 'Wbe') && getline('.') !~# s:item_pattern
                                  call search('^commit ', 'Wbe')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'

FUNCTION  gutentags#default_io_cb()
Called 7 times
Total time:   0.000179
 Self time:   0.000105

count  total (s)   self (s)
    7   0.000176   0.000102     call gutentags#trace('[job output]: '.string(a:msg))

FUNCTION  <SNR>92_completionErrorHandler()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call call(a:next, [-1, []])

FUNCTION  go#config#MetalinterEnabled()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:default_enabled = ["vet", "golint", "errcheck"]
                            
                              if go#config#MetalinterCommand() == "golangci-lint"
                                let l:default_enabled = ["govet", "golint"]
                              endif
                            
                              return get(g:, "go_metalinter_enabled", default_enabled)

FUNCTION  TCommentOpFunc_gc6c()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gc6c')
                            call tcomment#SetOption("count", 6)
                            return call('tcomment#operator#Op', a:000)

FUNCTION  fugitive#RemoveCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:Remove('edit', a:bang)

FUNCTION  <SNR>103_Command()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              try
                                if a:command =~# '^\l[[:alnum:]-]\+$'
                                  return fugitive#Command(a:line1, a:line2, a:range, a:bang, s:Mods(a:mods), a:command . ' ' . a:arg)
                                endif
                                return s:{a:command}Command(a:line1, a:line2, a:range, a:line2, a:bang, s:Mods(a:mods), '', a:arg, a:args)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry

FUNCTION  go#config#ListHeight()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_list_height", 0)

FUNCTION  go#path#CheckBinPath()
Called 3 times
Total time:   0.001161
 Self time:   0.000437

count  total (s)   self (s)
                              " remove whitespaces if user applied something like 'goimports   '
    3              0.000085   let binpath = substitute(a:binpath, '^\s*\(.\{-}\)\s*$', '\1', '')
                            
                              " save original path
    3              0.000012   let old_path = $PATH
                            
                              " check if we have an appropriate bin_path
    3   0.000660   0.000020   let go_bin_path = go#path#BinPath()
    3              0.000009   if !empty(go_bin_path)
                                " append our GOBIN and GOPATH paths and be sure they can be found there...
                                " let us search in our GOBIN and GOPATH paths
                                " respect the ordering specified by go_search_bin_path_first
    3   0.000031   0.000017     if go#config#SearchBinPathFirst()
    3   0.000073   0.000037       let $PATH = go_bin_path . go#util#PathListSep() . $PATH
                                else
                                  let $PATH = $PATH . go#util#PathListSep() . go_bin_path
    3              0.000001     endif
    3              0.000001   endif
                            
                              " if it's in PATH just return it
    3              0.000082   if executable(binpath)
    3              0.000010     if exists('*exepath')
    3              0.000056       let binpath = exepath(binpath)
    3              0.000003     endif
    3              0.000013     let $PATH = old_path
                            
    3   0.000051   0.000017     if go#util#IsUsingCygwinShell() == 1
                                  return s:CygwinPath(binpath)
    3              0.000003     endif
                            
    3              0.000005     return binpath
                              endif
                            
                              " just get the basename
                              let basename = fnamemodify(binpath, ":t")
                              if !executable(basename)
                                call go#util#EchoError(printf("could not find '%s'. Run :GoInstallBinaries to fix it", basename))
                            
                                " restore back!
                                let $PATH = old_path
                                return ""
                              endif
                            
                              let $PATH = old_path
                            
                              if go#util#IsUsingCygwinShell() == 1
                                return s:CygwinPath(a:binpath)
                              endif
                            
                              return go_bin_path . go#util#PathSep() . basename

FUNCTION  <SNR>43_echo()
Called 2 times
Total time:   0.000216
 Self time:   0.000216

count  total (s)   self (s)
    2              0.000009   let l:msg = []
    2              0.000019   if type(a:msg) != type([])
    2              0.000017     let l:msg = split(a:msg, "\n")
                              else
                                let l:msg = a:msg
    2              0.000002   endif
                            
                              " Tabs display as ^I or <09>, so manually expand them.
    2              0.000025   let l:msg = map(l:msg, 'substitute(v:val, "\t", "        ", "")')
                            
    2              0.000017   exe 'echohl ' . a:hi
    4              0.000009   for line in l:msg
    2              0.000082     echom "vim-go: " . line
    4              0.000006   endfor
    2              0.000007   echohl None

FUNCTION  <SNR>103_PreviousSectionEnd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let old = line('.')
                              for i in range(a:count)
                                if search(s:section_commit_pattern, 'Wb') <= 1
                                  exe old
                                  if i
                                    break
                                  else
                                    return ''
                                  endif
                                endif
                                let old = line('.')
                              endfor
                              return search('^.', 'Wb')

FUNCTION  go#config#DocUrl()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let godoc_url = get(g:, 'go_doc_url', 'https://godoc.org')
                              if godoc_url isnot 'https://godoc.org'
                                " strip last '/' character if available
                                let last_char = strlen(godoc_url) - 1
                                if godoc_url[last_char] == '/'
                                  let godoc_url = strpart(godoc_url, 0, last_char)
                                endif
                                " custom godoc installations expect /pkg before package names
                                let godoc_url .= "/pkg"
                              endif
                              return godoc_url

FUNCTION  gutentags#get_job_data()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return s:update_in_progress[a:module][a:job_idx][1]

FUNCTION  TCommentOpFunc_gc7c()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gc7c')
                            call tcomment#SetOption("count", 7)
                            return call('tcomment#operator#Op', a:000)

FUNCTION  <SNR>103_ReplaceCmd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let temp = tempname()
                              let [err, exec_error] = s:TempCmd(temp, a:cmd)
                              if exec_error
                                call s:throw((len(err) ? err : filereadable(temp) ? join(readfile(temp), ' ') : 'unknown error running ' . a:cmd))
                              endif
                              let temp = s:Resolve(temp)
                              let fn = expand('%:p')
                              silent exe 'keepalt file '.temp
                              let modelines = &modelines
                              try
                                set modelines=0
                                silent keepjumps noautocmd edit!
                              finally
                                let &modelines = modelines
                                try
                                  silent exe 'keepalt file '.s:fnameescape(fn)
                                catch /^Vim\%((\a\+)\)\=:E302:/
                                endtry
                                call delete(temp)
                                if s:cpath(fnamemodify(bufname('$'), ':p'), temp)
                                  silent execute 'bwipeout '.bufnr('$')
                                endif
                              endtry

FUNCTION  <SNR>109_parse_errors()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let splitted = split(a:content, '\n')
                            
                              " list of errors to be put into location list
                              let errors = []
                              for line in splitted
                                let tokens = matchlist(line, '^\(.\{-}\):\(\d\+\):\(\d\+\)\s*\(.*\)')
                                if !empty(tokens)
                                  call add(errors,{"filename": a:filename,"lnum":     tokens[2],"col":      tokens[3],"text":     tokens[4], })
                                endif
                              endfor
                            
                              return errors

FUNCTION  go#config#DebugWindows()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_debug_windows', { 'stack': 'leftabove 20vnew', 'out':   'botright 10new', 'vars':  'leftabove 30vnew', } )
                            

FUNCTION  <SNR>103_repo_git_chomp()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let git = g:fugitive_git_executable . ' --git-dir='.s:shellesc(self.git_dir)
                              let output = git . join(map(copy(a:000),'" ".s:shellesc(v:val)'),'')
                              return s:sub(system(output), '\n$', '')

FUNCTION  go#util#gomod()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(s:exec(['go', 'env', 'GOMOD'])[0], '\n', '', 'g')

FUNCTION  go#config#SetFmtAutosave()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:go_fmt_autosave = a:value

FUNCTION  FugitiveReal()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let file = a:0 ? a:1 : @%
                              if file =~# '^\a\a\+:' || a:0 > 1
                                return call('fugitive#Real', [file] + a:000[1:-1])
                              elseif file =~# '^/\|^\a:\|^$'
                                return file
                              else
                                return fnamemodify(file, ':p' . (file =~# '[\/]$' ? '' : ':s?[\/]$??'))
                              endif

FUNCTION  go#config#SetAsmfmtAutosave()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:go_asmfmt_autosave = a:value

FUNCTION  gutentags#error()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let v:errmsg = "gutentags: " . a:message
                                echoerr v:errmsg

FUNCTION  <SNR>100_handle_diff()
Called 1 time
Total time:   0.021211
 Self time:   0.000319

count  total (s)   self (s)
    1   0.000030   0.000011   call sy#verbose('s:handle_diff()', a:options.vcs)
                            
    1              0.000007   let sy = getbufvar(a:options.bufnr, 'sy')
    1              0.000002   if empty(sy)
                                call sy#verbose(printf('No b:sy found for %s', bufname(a:options.bufnr)), a:options.vcs)
                                return
    1              0.000003   elseif !empty(sy.updated_by) && sy.updated_by != a:options.vcs
                                call sy#verbose(printf('Signs already got updated by %s.', sy.updated_by), a:options.vcs)
                                return
    1              0.000003   elseif empty(sy.vcs) && sy.active
    1              0.000004     let sy.detecting -= 1
    1              0.000001   endif
                            
    1              0.000009   if (&fenc != &enc) && has('iconv')
                                call map(a:options.stdoutbuf, 'iconv(v:val, &fenc, &enc)')
    1              0.000001   endif
                            
    1   0.000018   0.000012   let [found_diff, diff] = s:check_diff_{a:options.vcs}(a:exitval, a:options.stdoutbuf)
    1              0.000001   if found_diff
    1              0.000004     if index(sy.vcs, a:options.vcs) == -1
    1              0.000003       let sy.vcs += [a:options.vcs]
    1              0.000001     endif
    1   0.021088   0.000221     call a:options.func(sy, a:options.vcs, diff)
                              else
                                call sy#verbose('No valid diff found. Disabling this VCS.', a:options.vcs)
    1              0.000001   endif
                            
    1              0.000008   call setbufvar(a:options.bufnr, 'sy_job_id_'.a:options.vcs, 0)

FUNCTION  fugitive#Cd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let path = substitute(a:path, '^:/:\=\|^:(\%(top\|top,literal\|literal,top\|literal\))', '', '')
                              if path !~# '^/\|^\a\+:\|^\.\.\=\%(/\|$\)'
                                let dir = s:Dir()
                                exe s:DirCheck(dir)
                                let path = (empty(s:Tree(dir)) ? dir : s:Tree(dir)) . '/' . path
                              endif
                              return (a:0 && a:1 ? 'lcd ' : 'cd ') . s:fnameescape(FugitiveVimPath(path))

FUNCTION  <SNR>34_c()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call histdel('search',-1)
                              return ""

FUNCTION  <SNR>49_insert()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " Optional argument causes the result to appear on 3 lines, not 1
                              let linemode = a:0 ? a:1 : 0
                              let char = s:inputreplacement()
                              while char == "\<CR>" || char == "\<C-S>"
                                " TODO: use total count for additional blank lines
                                let linemode += 1
                                let char = s:inputreplacement()
                              endwhile
                              if char == ""
                                return ""
                              endif
                              let cb_save = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let reg_save = @@
                              call setreg('"',"\r",'v')
                              call s:wrapreg('"',char,"",linemode)
                              " If line mode is used and the surrounding consists solely of a suffix,
                              " remove the initial newline.  This fits a use case of mine but is a
                              " little inconsistent.  Is there anyone that would prefer the simpler
                              " behavior of just inserting the newline?
                              if linemode && match(getreg('"'),'^\n\s*\zs.*') == 0
                                call setreg('"',matchstr(getreg('"'),'^\n\s*\zs.*'),getregtype('"'))
                              endif
                              " This can be used to append a placeholder to the end
                              if exists("g:surround_insert_tail")
                                call setreg('"',g:surround_insert_tail,"a".getregtype('"'))
                              endif
                              if &ve != 'all' && col('.') >= col('$')
                                if &ve == 'insert'
                                  let extra_cols = virtcol('.') - virtcol('$')
                                  if extra_cols > 0
                                    let [regval,regtype] = [getreg('"',1,1),getregtype('"')]
                                    call setreg('"',join(map(range(extra_cols),'" "'),''),'v')
                                    norm! ""p
                                    call setreg('"',regval,regtype)
                                  endif
                                endif
                                norm! ""p
                              else
                                norm! ""P
                              endif
                              if linemode
                                call s:reindent()
                              endif
                              norm! `]
                              call search('\r','bW')
                              let @@ = reg_save
                              let &clipboard = cb_save
                              return "\<Del>"

FUNCTION  go#list#Populate()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:listtype == "locationlist"
                                call setloclist(0, a:items, 'r')
                            
                                " The last argument ({what}) is introduced with 7.4.2200:
                                " https://github.com/vim/vim/commit/d823fa910cca43fec3c31c030ee908a14c272640
                                if has("patch-7.4.2200") | call setloclist(0, [], 'a', {'title': a:title}) | endif
                              else
                                call setqflist(a:items, 'r')
                                if has("patch-7.4.2200") | call setqflist([], 'a', {'title': a:title}) | endif
                              endif

FUNCTION  go#config#HighlightOperators()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000012   return get(g:, 'go_highlight_operators', 0)

FUNCTION  <SNR>34_coerce()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:type !~# '^\%(line\|char\|block\)'
                                let s:transformation = a:type
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w*')
                                return 'g@'
                              endif
                              let selection = &selection
                              let clipboard = &clipboard
                              try
                                set selection=inclusive clipboard-=unnamed clipboard-=unnamedplus
                                let regbody = getreg('"')
                                let regtype = getregtype('"')
                                let c = v:count1
                                while c > 0
                                  let c -= 1
                                  if a:type ==# 'line'
                                    let move = "'[V']"
                                  elseif a:type ==# 'block'
                                    let move = "`[\<C-V>`]"
                                  else
                                    let move = "`[v`]"
                                  endif
                                  silent exe 'normal!' move.'y'
                                  let word = @@
                                  let @@ = s:send(g:Abolish.Coercions,s:transformation,word)
                                  if !exists('begin')
                                    let begin = getpos("'[")
                                  endif
                                  if word !=# @@
                                    let changed = 1
                                    exe 'normal!' move.'p'
                                  endif
                                endwhile
                                call setreg('"',regbody,regtype)
                                call setpos("'[",begin)
                                call setpos(".",begin)
                              finally
                                let &selection = selection
                                let &clipboard = clipboard
                              endtry

FUNCTION  TCommentOpFunc_gC()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gC')
                            
                            return call('tcomment#operator#Line', a:000)

FUNCTION  gutentags#fake()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let g:gutentags_fake = !g:gutentags_fake
                                if a:0 > 0
                                    let g:gutentags_fake = a:1
                                endif
                                if g:gutentags_fake
                                    echom "gutentags: Now faking gutentags."
                                else
                                    echom "gutentags: Now running gutentags for real."
                                endif
                                echom ""

FUNCTION  <SNR>9_StarSetf()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif

FUNCTION  go#util#Offset()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &encoding != 'utf-8'
                                let sep = go#util#LineEnding()
                                let buf = a:line == 1 ? '' : (join(getline(1, a:line-1), sep) . sep)
                                let buf .= a:col == 1 ? '' : getline('.')[:a:col-2]
                                return len(iconv(buf, &encoding, 'utf-8'))
                              endif
                              return line2byte(a:line) + (a:col-2)

FUNCTION  go#lsp#CleanWorkspaces()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:workspaces = []
                            
                              let l:lsp = s:lspfactory.get()
                            
                              let l:i = 0
                              let l:missing = []
                              for l:dir in l:lsp.workspaceDirectories
                                if !isdirectory(l:dir)
                                  let l:dir = add(l:missing, l:dir)
                                  call remove(l:lsp.workspaceDirectories, l:i)
                                  continue
                                endif
                                let l:i += 1
                              endfor
                            
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:noop')
                              let l:msg = go#lsp#message#ChangeWorkspaceFolders([], l:missing)
                              call l:lsp.sendMessage(l:msg, l:state)
                            
                              return 0

FUNCTION  <SNR>103_StageSeek()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let info = a:info
                              if empty(info.section)
                                return a:fallback
                              endif
                              let line = search('^' . info.section, 'wn')
                              if !line
                                for section in get({'Staged': ['Unstaged', 'Untracked'], 'Unstaged': ['Untracked', 'Staged'], 'Untracked': ['Unstaged', 'Staged']}, info.section, [])
                                  let line = search('^' . section, 'wn')
                                  if line
                                    return line + (info.index > 0 ? 1 : 0)
                                  endif
                                endfor
                                return 1
                              endif
                              let i = 0
                              while len(getline(line))
                                let filename = matchstr(getline(line), '^[A-Z?] \zs.*')
                                if len(filename) && ((info.filename[-1:-1] ==# '/' && filename[0 : len(info.filename) - 1] ==# info.filename) || (filename[-1:-1] ==# '/' && filename ==# info.filename[0 : len(filename) - 1]) || filename ==# info.filename)
                                  if info.offset < 0
                                    return line
                                  else
                                    if getline(line+1) !~# '^@'
                                      exe s:StageInline('show', line)
                                    endif
                                    if getline(line+1) !~# '^@'
                                      return line
                                    endif
                                    let type = info.sigil ==# '-' ? '-' : '+'
                                    let offset = -1
                                    while offset < info.offset
                                      let line += 1
                                      if getline(line) =~# '^@'
                                        let offset = +matchstr(getline(line), type . '\zs\d\+') - 1
                                      elseif getline(line) =~# '^[ ' . type . ']'
                                        let offset += 1
                                      elseif getline(line) !~# '^[ @\+-]'
                                        return line - 1
                                      endif
                                    endwhile
                                    return line
                                  endif
                                endif
                                let commit = matchstr(getline(line), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\+')
                                if len(commit) && commit ==# info.commit
                                  return line
                                endif
                                if i ==# info.index
                                  let backup = line
                                endif
                                let i += getline(line) !~# '^[ @\+-]'
                                let line += 1
                              endwhile
                              return exists('backup') ? backup : line - 1

FUNCTION  go#config#DeclsIncludes()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, 'go_decls_includes', 'func,type')

FUNCTION  <SNR>103_sub()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  go#lsp#message#Initialized()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return { 'notification': 1, 'method': 'initialized', 'params': {}, }

FUNCTION  <SNR>103_CommitSubcommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let mods = substitute(s:Mods(a:mods), '\C\<tab\>', '-tab', 'g')
                              let dir = a:0 ? a:1 : s:Dir()
                              let tree = s:Tree(dir)
                              let msgfile = fugitive#Find('.git/COMMIT_EDITMSG', dir)
                              let outfile = tempname()
                              try
                                if s:winshell()
                                  let command = 'set GIT_EDITOR=false& '
                                else
                                  let command = 'env GIT_EDITOR=false '
                                endif
                                let argv = a:args
                                let i = 0
                                while get(argv, i, '--') !=# '--'
                                  if argv[i] =~# '^-[apzsneiovq].'
                                    call insert(argv, argv[i][0:1])
                                    let argv[i+1] = '-' . argv[i+1][2:-1]
                                  else
                                    let i += 1
                                  endif
                                endwhile
                                let command .= s:UserCommand(dir, ['commit'] + argv)
                                if (&autowrite || &autowriteall) && !a:0
                                  silent! wall
                                endif
                                if s:HasOpt(argv, '-i', '--interactive')
                                  return s:CommitInteractive(a:line1, a:line2, a:range, a:bang, a:mods, argv, 0)
                                elseif s:HasOpt(argv, '-p', '--patch')
                                  return s:CommitInteractive(a:line1, a:line2, a:range, a:bang, a:mods, argv, 1)
                                else
                                  let [error_string, exec_error] = s:TempCmd(outfile, command)
                                  let errors = split(error_string, "\n")
                                endif
                                if !has('gui_running')
                                  redraw!
                                endif
                                if !exec_error
                                  echo join(errors, "\n")
                                  if filereadable(outfile)
                                    echo join(readfile(outfile), "\n")
                                  endif
                                  call fugitive#ReloadStatus(dir, 1)
                                  return ''
                                else
                                  let error = get(errors,-2,get(errors,-1,'!'))
                                  if error =~# 'false''\=\.$'
                                    let i = 0
                                    while get(argv, i, '--') !=# '--'
                                      if argv[i] =~# '^\%(-[eips]\|-[CcFm].\+\|--edit\|--interactive\|--patch\|--signoff\|--reedit-message=.*\|--reuse-message=.*\|--file=.*\|--message=.*\)$'
                                        call remove(argv, i)
                                      elseif argv[i] =~# '^\%(-[CcFm]\|--reedit-message\|--reuse-message\|--file\|--message\)$'
                                        call remove(argv, i, i + 1)
                                      else
                                        if argv[i] =~# '^--cleanup\>'
                                          let cleanup = 1
                                        endif
                                        let i += 1
                                      endif
                                    endwhile
                                    call insert(argv, '--no-signoff', i)
                                    call insert(argv, '--no-interactive', i)
                                    call insert(argv, '--no-edit', i)
                                    if !exists('cleanup')
                                      call insert(argv, '--cleanup=strip')
                                    endif
                                    call extend(argv, ['-F', msgfile], 'keep')
                                    if (bufname('%') == '' && line('$') == 1 && getline(1) == '' && !&modified) || a:line2 == 0
                                      execute mods . 'keepalt edit' s:fnameescape(msgfile)
                                    elseif s:HasOpt(argv, '-v') || mods =~# '\<tab\>'
                                      execute mods . 'keepalt -tabedit' s:fnameescape(msgfile)
                                    else
                                      execute mods . 'keepalt split' s:fnameescape(msgfile)
                                    endif
                                    let b:fugitive_commit_arguments = argv
                                    setlocal bufhidden=wipe filetype=gitcommit
                                    return '1'
                                  elseif empty(errors)
                                    let out = readfile(outfile)
                                    echo get(out, -1, '') =~# 'stash\|\d' ? get(out, -2, '') : get(out, -1, '')
                                    return ''
                                  else
                                    echo join(errors, "\n")
                                    return ''
                                  endif
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                call delete(outfile)
                              endtry

FUNCTION  TCommentOpFunc_gc()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gc')
                            
                            return call('tcomment#operator#Op', a:000)

FUNCTION  sy#repo#debug_detection()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !exists('b:sy')
                                echomsg 'signify: I cannot detect any changes!'
                                return
                              endif
                            
                              for vcs in s:vcs_list
                                let cmd = s:expand_cmd(vcs, g:signify_vcs_cmds)
                                echohl Statement
                                echo cmd
                                echo repeat('=', len(cmd))
                                echohl NONE
                            
                                let diff = s:run(vcs)
                                if v:shell_error
                                  echohl ErrorMsg
                                  echo diff
                                  echohl NONE
                                else
                                  echo empty(diff) ? "<none>" : diff
                                endif
                                echo "\n"
                              endfor

FUNCTION  TCommentOpFunc_gc8c()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gc8c')
                            call tcomment#SetOption("count", 8)
                            return call('tcomment#operator#Op', a:000)

FUNCTION  go#config#GorenamePrefill()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_gorename_prefill", 'expand("<cword>") =~# "^[A-Z]"' . '? go#util#pascalcase(expand("<cword>"))' . ': go#util#camelcase(expand("<cword>"))')

FUNCTION  <SNR>103_DoToggleUnpulled()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:DoUnstageUnpulled(a:record)

FUNCTION  <SNR>100_check_diff_fossil()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  go#config#BinPath()
Called 3 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    3              0.000021   return get(g:, "go_bin_path", "")

FUNCTION  <SNR>54_GenerateConfig()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let l:cmd = "! " . s:config_gen . " -F " . a:fmt . " " . a:flags
                            
                                if a:overwrite
                                    let l:cmd = l:cmd . " -f"
                                endif
                            
                                " Only append the working directory if the last option is a flag
                                let l:split_flags = split(a:flags)
                                if len(l:split_flags) == 0 || l:split_flags[-1] =~ "^-"
                                    let l:cmd = l:cmd . " " . shellescape(getcwd())
                                endif
                            
                                " Disable interactive prompts for consistency with Neovim
                                execute l:cmd . " </dev/null"

FUNCTION  <SNR>103_TempReadPost()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                if has_key(dict, 'filetype') && dict.filetype !=# &l:filetype
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<,>>>>>>>
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q    :<C-U>bdelete<Bar>echohl WarningMsg<Bar>echo "Temp file q is deprecated in favor of the built-in <Lt>C-W>q"<Bar>echohl NONE<CR>
                                endif
                                if !&modifiable
                                  call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                endif
                              endif
                              return ''

FUNCTION  go#config#TextobjIncludeVariable()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(g:, "go_textobj_include_variable", 1)

FUNCTION  <SNR>103_NextSection()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let orig = line('.')
                              if getline('.') !~# '^commit '
                                -
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern, 'W')
                                  break
                                endif
                              endfor
                              if getline('.') =~# s:section_commit_pattern
                                call s:StageReveal()
                                return getline('.') =~# s:section_pattern ? '+' : ':'
                              else
                                return orig
                              endif

FUNCTION  go#lsp#Hover()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call go#lsp#DidChange(a:fname)
                            
                              let l:lsp = s:lspfactory.get()
                              let l:msg = go#lsp#message#Hover(a:fname, a:line, a:col)
                              let l:state = s:newHandlerState('')
                              let l:state.handleResult = funcref('s:hoverHandler', [function(a:handler, [], l:state)], l:state)
                              let l:state.error = funcref('s:noop')
                              return l:lsp.sendMessage(l:msg, l:state)

FUNCTION  gutentags#get_project_info()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000010     return get(s:known_projects, a:path, {})

FUNCTION  <SNR>51_ProjectionistDetect()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let file = s:Slash(get(g:, 'projectionist_file', ''))
                              let dir = FugitiveExtractGitDir(file)
                              let base = matchstr(file, '^fugitive://.\{-\}//\x\+')
                              if empty(base)
                                let base = s:Tree(dir)
                              endif
                              if len(base)
                                if exists('+shellslash') && !&shellslash
                                  let base = tr(base, '/', '\')
                                endif
                                let file = FugitiveCommonDir(dir) . '/info/projections.json'
                                if filereadable(file)
                                  call projectionist#append(base, file)
                                endif
                              endif

FUNCTION  DVB_Drag()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " No-op in Visual mode...
                                if mode() ==# 'v'
                                    return "\<ESC>gv"
                            
                                " Do Visual Line drag indirectly via temporary nmap
                                " (to ensure we have access to block position data)...
                                elseif mode() ==# 'V'
                                    " Set up a temporary convenience...
                                    exec "nnoremap <silent><expr><buffer>  M  \<SID>Drag_Lines('".a:dir."')"
                            
                                    " Return instructions to implement the move and reset selection...
                                    return '"vyM'
                            
                                " Otherwise do Visual Block drag indirectly via temporary nmap
                                " (to ensure we have access to block position data)...
                                else
                                    " Set up a temporary convenience...
                                    exec "nnoremap <silent><expr><buffer>  M  \<SID>Drag_Block('".a:dir."')"
                            
                                    " Return instructions to implement the move and reset selection...
                                    return '"vyM'
                                endif

FUNCTION  go#config#TestTimeout()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                             return get(g:, 'go_test_timeout', '10s')

FUNCTION  go#config#HighlightChanWhitespaceError()
Called 3 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    3              0.000012   return get(g:, 'go_highlight_chan_whitespace_error', 0)

FUNCTION  go#config#HighlightDebug()
Called 3 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    3              0.000015   return get(g:, 'go_highlight_debug', 1)

FUNCTION  <SNR>100_callback_vim_stdout()
Called 145 times
Total time:   0.000465
 Self time:   0.000465

count  total (s)   self (s)
  145              0.000422   let self.stdoutbuf += [a:data]

FUNCTION  go#util#EchoError()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              call s:echo(a:msg, 'ErrorMsg')

FUNCTION  <SNR>94_close_cb()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let self.closed = 1
                            
                              if self.exited
                                let job = ch_getjob(a:ch)
                                call self.complete(job, self.exit_status, self.messages)
                              endif

FUNCTION  <SNR>103_QuickfixCreate()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if has('patch-7.4.2200')
                                call s:QuickfixSet(a:nr, [], ' ', a:opts)
                              else
                                call s:QuickfixSet(a:nr, [], ' ')
                              endif

FUNCTION  TCommentOpFunc_gc9c()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_gc9c')
                            call tcomment#SetOption("count", 9)
                            return call('tcomment#operator#Op', a:000)

FUNCTION  FugitiveReloadCheck()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let t = b:fugitive_reltime
                              return [t, reltimestr(reltime(s:last_time, t)), reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t))]

FUNCTION  FugitiveParse()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let path = s:Slash(a:0 ? a:1 : @%)
                              if path !~# '^fugitive:'
                                return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg

FUNCTION  <SNR>103_Tree()
Called 1 time
Total time:   0.000144
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000144   0.000007   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  go#guru#Whicherrs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let args = { 'mode': 'whicherrs', 'format': 'plain', 'selected': a:selected, 'needs_scope': 1, }
                            
                            
                              " TODO(arslan): handle empty case for both sync/async
                              " if empty(out.out)
                              "   call go#util#EchoSuccess("no error variables found. Try to change the scope with :GoGuruScope")
                              "   return
                              " endif
                              call s:run_guru(args)

FUNCTION  go#util#LineEnding()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &fileformat == 'dos'
                                return "\r\n"
                              elseif &fileformat == 'mac'
                                return "\r"
                              endif
                            
                              return "\n"

FUNCTION  go#config#SetMetalinterAutosave()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:go_metalinter_autosave = a:value

FUNCTION  go#config#HighlightFields()
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000011   return get(g:, 'go_highlight_fields', 0)

FUNCTION  <SNR>103_StageInline()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if &filetype !=# 'fugitive'
                                return ''
                              endif
                              let lnum1 = a:0 ? a:1 : line('.')
                              let lnum = lnum1 + 1
                              if a:0 > 1 && a:2 == 0
                                let info = s:StageInfo(lnum - 1)
                                if empty(info.paths) && len(info.section)
                                  while len(getline(lnum))
                                    let lnum += 1
                                  endwhile
                                endif
                              elseif a:0 > 1
                                let lnum += a:2 - 1
                              endif
                              while lnum > lnum1
                                let lnum -= 1
                                while lnum > 0 && getline(lnum) =~# '^[ @\+-]'
                                  let lnum -= 1
                                endwhile
                                let info = s:StageInfo(lnum)
                                if !has_key(b:fugitive_diff, info.section)
                                  continue
                                endif
                                if getline(lnum + 1) =~# '^[ @\+-]'
                                  let lnum2 = lnum + 1
                                  while getline(lnum2 + 1) =~# '^[ @\+-]'
                                    let lnum2 += 1
                                  endwhile
                                  if a:mode !=# 'show'
                                    setlocal modifiable noreadonly
                                    exe 'silent keepjumps ' . (lnum + 1) . ',' . lnum2 . 'delete _'
                                    call remove(b:fugitive_expanded[info.section], info.filename)
                                    setlocal nomodifiable readonly nomodified
                                  endif
                                  continue
                                endif
                                if !has_key(b:fugitive_diff, info.section) || info.status !~# '^[ADMRU]$' || a:mode ==# 'hide'
                                  continue
                                endif
                                let mode = ''
                                let diff = []
                                let index = 0
                                let start = -1
                                for line in b:fugitive_diff[info.section]
                                  if mode ==# 'await' && line[0] ==# '@'
                                    let mode = 'capture'
                                  endif
                                  if mode !=# 'head' && line !~# '^[ @\+-]'
                                    if len(diff)
                                      break
                                    endif
                                    let start = index
                                    let mode = 'head'
                                  elseif mode ==# 'head' && substitute(line, "\t$", '', '') ==# '--- ' . info.relative[-1]
                                    let mode = 'await'
                                  elseif mode ==# 'head' && substitute(line, "\t$", '', '') ==# '+++ ' . info.relative[0]
                                    let mode = 'await'
                                  elseif mode ==# 'capture'
                                    call add(diff, line)
                                  elseif line[0] ==# '@'
                                    let mode = ''
                                  endif
                                  let index += 1
                                endfor
                                if len(diff)
                                  setlocal modifiable noreadonly
                                  silent call append(lnum, diff)
                                  let b:fugitive_expanded[info.section][info.filename] = [start, len(diff)]
                                  setlocal nomodifiable readonly nomodified
                                endif
                              endwhile
                              return lnum

FUNCTION  fugitive#MapCfile()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              exe 'cnoremap <buffer> <expr> <Plug><cfile>' (a:0 ? a:1 : 'fugitive#Cfile()')
                              let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|sil! exe "cunmap <buffer> <Plug><cfile>"'
                              if !exists('g:fugitive_no_maps')
                                call s:Map('n', 'gf',          '<SID>:find <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W>f',     '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W><C-F>', '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W>gf',  '<SID>:tabfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('c', '<C-R><C-F>', '<Plug><cfile>', '<silent><unique>', 1)
                              endif

FUNCTION  go#config#SnippetEngine()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000016   return get(g:, 'go_snippet_engine', 'automatic')

FUNCTION  <SNR>103_TempReadPre()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nomodeline
                                setlocal bufhidden=delete nobuflisted
                                setlocal buftype=nowrite
                                if has_key(dict, 'modifiable')
                                  let &l:modifiable = dict.modifiable
                                endif
                                if len(dict.dir)
                                  let b:git_dir = dict.dir
                                  call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                endif
                              endif

FUNCTION  <SNR>33_key_mapping()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:incsearch_cli_key_mappings[a:lhs] = {       'key' : a:rhs,       'noremap' : a:noremap,   }

FUNCTION  fugitive#DeleteCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:Remove('bdelete', a:bang)

FUNCTION  TCommentOpFunc_Uncomment()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            call tcomment#MaybeReuseOptions('TCommentOpFunc_Uncomment')
                            call tcomment#SetOption("mode_extra", "U")
                            return call('tcomment#operator#Op', a:000)

FUNCTION  <SNR>103_OpenExec()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 ? s:Dir(a:1) : s:Dir()
                              let temp = tempname()
                              let columns = get(g:, 'fugitive_columns', 80)
                              if columns <= 0
                                let env = ''
                              elseif s:winshell()
                                let env = 'set COLUMNS=' . columns . '& '
                              else
                                let env = 'env COLUMNS=' . columns . ' '
                              endif
                              silent! execute '!' . escape(env . s:UserCommand(dir, ['--no-pager'] + a:args), '!#%') . (&shell =~# 'csh' ? ' >& ' . temp : ' > ' . temp . ' 2>&1')
                              redraw!
                              let temp = s:Resolve(temp)
                              let first = join(readfile(temp, '', 2), "\n")
                              if first =~# '\<\([[:upper:][:digit:]_-]\+(\d\+)\).*\1'
                                let filetype = 'man'
                              else
                                let filetype = 'git'
                              endif
                              let s:temp_files[s:cpath(temp)] = { 'dir': dir, 'filetype': filetype, 'modifiable': first =~# '^diff ' }
                              if a:cmd ==# 'edit'
                                call s:BlurStatus()
                              endif
                              silent execute s:Mods(a:mods) . a:cmd temp
                              call fugitive#ReloadStatus(dir, 1)
                              return 'echo ' . string(':!' . s:UserCommand(dir, a:args))

FUNCTION  <SNR>101_cache_project_root()
Called 1 time
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
    1              0.000004     let l:result = {}
                            
    3              0.000009     for proj_info in g:gutentags_project_info
    2              0.000018         let l:filematch = get(proj_info, 'file', '')
    2              0.000033         if l:filematch != '' && filereadable(a:path . '/'. l:filematch)
                                        let l:result = copy(proj_info)
                                        break
    2              0.000001         endif
                            
    2              0.000019         let l:globmatch = get(proj_info, 'glob', '')
    2              0.000007         if l:globmatch != '' && glob(a:path . '/' . l:globmatch) != ''
                                        let l:result = copy(proj_info)
                                        break
    2              0.000001         endif
    3              0.000004     endfor
                            
    1              0.000004     let s:known_projects[a:path] = l:result

FUNCTION  <SNR>103_DoUnstageUnstaged()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:record.status ==# 'A'
                                call s:TreeChomp(['reset', '-q', '--'] + a:record.paths)
                                return 1
                              else
                                return -1
                              endif

FUNCTION  <SNR>103_TreeChomp()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let cmd = call('fugitive#Prepare', a:000)
                              let [out, exec_error] = s:SystemError(cmd)
                              let out = s:sub(out, '\n$', '')
                              if !exec_error
                                return out
                              endif
                              throw 'fugitive: error running `' . cmd . '`: ' . out

FUNCTION  <SNR>103_SystemError()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              try
                                if &shellredir ==# '>' && &shell =~# 'sh\|cmd'
                                  let shellredir = &shellredir
                                  if &shell =~# 'csh'
                                    set shellredir=>&
                                  else
                                    set shellredir=>%s\ 2>&1
                                  endif
                                endif
                                let out = call('system', [type(a:cmd) ==# type([]) ? fugitive#Prepare(a:cmd) : a:cmd] + a:000)
                                return [out, v:shell_error]
                              catch /^Vim\%((\a\+)\)\=:E484:/
                                let opts = ['shell', 'shellcmdflag', 'shellredir', 'shellquote', 'shellxquote', 'shellxescape', 'shellslash']
                                call filter(opts, 'exists("+".v:val) && !empty(eval("&".v:val))')
                                call map(opts, 'v:val."=".eval("&".v:val)')
                                call s:throw('failed to run `' . a:cmd . '` with ' . join(opts, ' '))
                              finally
                                if exists('shellredir')
                                  let &shellredir = shellredir
                                endif
                              endtry

FUNCTION  sy#sign#parse_hunk()
Called 19 times
Total time:   0.000980
 Self time:   0.000980

count  total (s)   self (s)
   19              0.000576   let tokens = matchlist(a:diffline, '^@@ -\v(\d+),?(\d*) \+(\d+),?(\d*)')
   19              0.000352   return [ str2nr(tokens[1]), str2nr(tokens[3]), empty(tokens[2]) ? 1 : str2nr(tokens[2]), empty(tokens[4]) ? 1 : str2nr(tokens[4]) ]

FUNCTION  <SNR>103_TempState()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return get(s:temp_files, s:cpath(fnamemodify(a:0 ? a:1 : @%, ':p')), {})

FUNCTION  go#job#Wait()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if has('nvim')
                                call jobwait([a:job])
                                return
                              endif
                            
                              while job_status(a:job) is# 'run'
                                sleep 50m
                              endwhile

FUNCTION  <SNR>103_BlameComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return s:CompleteSub('blame', a:A, a:L, a:P)

FUNCTION  go#job#Stop()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if has('nvim')
                                call jobstop(a:job)
                                return
                              endif
                            
                              call job_stop(a:job)
                              call go#job#Wait(a:job)
                              return

FUNCTION  <SNR>104_guru_cmd()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let mode = a:args.mode
                              let format = a:args.format
                              let needs_scope = a:args.needs_scope
                              let selected = a:args.selected
                              let postype = get(a:args, 'postype', 'cursor')
                            
                              let result = {}
                            
                              "return with a warning if the binary doesn't exist
                              let bin_path = go#path#CheckBinPath("guru")
                              if empty(bin_path)
                                return {'err': "bin path not found"}
                              endif
                            
                              " start constructing the command
                              let cmd = [bin_path, '-tags', go#config#BuildTags()]
                            
                              if &modified
                                let result.stdin_content = go#util#archive()
                                call add(cmd, "-modified")
                              endif
                            
                              " enable outputting in json format
                              if format == "json"
                                call add(cmd, "-json")
                              endif
                            
                              let scopes = go#config#GuruScope()
                              if empty(scopes)
                                " some modes require scope to be defined (such as callers). For these we
                                " choose a sensible setting, which is using the current file's package
                                if needs_scope
                                  let pkg = go#package#ImportPath()
                                  if pkg == -1
                                    return {'err': "current directory is not inside of a valid GOPATH"}
                                  endif
                                  let scopes = [pkg]
                                endif
                              endif
                            
                              " Add the scope.
                              if !empty(scopes)
                                " guru expect a comma-separated list of patterns.
                                let l:scope = join(scopes, ",")
                                let result.scope = l:scope
                                call extend(cmd, ["-scope", l:scope])
                              endif
                            
                              if postype == 'balloon'
                                let pos = printf("#%s", go#util#Offset(v:beval_lnum, v:beval_col))
                              else
                                let pos = printf("#%s", go#util#OffsetCursor())
                                if selected != -1
                                  " means we have a range, get it
                                  let pos1 = go#util#Offset(line("'<"), col("'<"))
                                  let pos2 = go#util#Offset(line("'>"), col("'>"))
                                  let pos = printf("#%s,#%s", pos1, pos2)
                                endif
                              endif
                            
                              let l:filename = fnamemodify(expand("%"), ':p:gs?\\?/?') . ':' . pos
                              call extend(cmd, [mode, l:filename])
                            
                              let result.cmd = cmd
                              return result

FUNCTION  <SNR>103_StageInfo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let lnum = a:0 ? a:1 : line('.')
                              let sigil = matchstr(getline(lnum), '^[ @\+-]')
                              let offset = -1
                              if len(sigil)
                                let type = sigil ==# '-' ? '-' : '+'
                                while lnum > 0 && getline(lnum) !~# '^@'
                                  if getline(lnum) =~# '^[ '.type.']'
                                    let offset += 1
                                  endif
                                  let lnum -= 1
                                endwhile
                                let offset += matchstr(getline(lnum), type.'\zs\d\+')
                                while getline(lnum) =~# '^[ @\+-]'
                                  let lnum -= 1
                                endwhile
                              endif
                              let slnum = lnum + 1
                              let section = ''
                              let index = 0
                              while len(getline(slnum - 1)) && empty(section)
                                let slnum -= 1
                                let section = matchstr(getline(slnum), '^\u\l\+\ze.* (\d\+)$')
                                if empty(section) && getline(slnum) !~# '^[ @\+-]'
                                  let index += 1
                                endif
                              endwhile
                              let text = matchstr(getline(lnum), '^[A-Z?] \zs.*')
                              return {'section': section, 'heading': getline(slnum), 'sigil': sigil, 'offset': offset, 'filename': text, 'relative': reverse(split(text, ' -> ')), 'paths': map(reverse(split(text, ' -> ')), 's:Tree() . "/" . v:val'), 'commit': matchstr(getline(lnum), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\{4,\}\ze '), 'status': matchstr(getline(lnum), '^[A-Z?]\ze \|^\%(\x\x\x\)\@!\l\+\ze [0-9a-f]'), 'index': index}

FUNCTION  go#list#Get()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:listtype == "locationlist"
                                return getloclist(0)
                              else
                                return getqflist()
                              endif

FUNCTION  <SNR>92_info()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let l:content = s:infoFromHoverContent(a:content)
                            
                              if a:show
                                call go#util#ShowInfo(l:content)
                              endif
                            
                              return l:content

FUNCTION  fugitive#Real()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if empty(a:url)
                                return ''
                              endif
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if len(dir)
                                let tree = s:Tree(dir)
                                return FugitiveVimPath((len(tree) ? tree : dir) . file)
                              endif
                              let pre = substitute(matchstr(a:url, '^\a\a\+\ze:'), '^.', '\u&', '')
                              if len(pre) && pre !=? 'fugitive' && exists('*' . pre . 'Real')
                                let url = {pre}Real(a:url)
                              else
                                let url = fnamemodify(a:url, ':p' . (a:url =~# '[\/]$' ? '' : ':s?[\/]$??'))
                              endif
                              return FugitiveVimPath(empty(url) ? a:url : url)

FUNCTION  go#config#SetAutoTypeInfo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let g:go_auto_type_info = a:value

FUNCTION  <SNR>102__handleOldOptions()
Called 1 time
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000008     let l:renamed_options = {'gutentags_exclude': 'gutentags_ctags_exclude','gutentags_tagfile': 'gutentags_ctags_tagfile','gutentags_auto_set_tags': 'gutentags_ctags_auto_set_tags'}
    4              0.000010     for key in keys(l:renamed_options)
    3              0.000009         if exists('g:'.key)
                                        let newname = l:renamed_options[key]
                                        echom "gutentags: Option 'g:'".key." has been renamed to "."'g:'".newname." Please update your vimrc."
                                        let g:[newname] = g:[key]
    3              0.000003         endif
    4              0.000004     endfor

FUNCTION  go#util#IsWin()
Called 26 times
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
   26              0.000149   return has('win32')

FUNCTION  funcref#Function()
Called 4 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    4              0.000014   let d = a:0 > 0 ? a:1 : {}
    4              0.000013   let d['faked_function_reference'] = a:name
    4              0.000005   return d

FUNCTION  <SNR>110_listtype()
Called 1 time
Total time:   0.000021
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000015   0.000010   let listtype = go#config#ListType()
    1              0.000003   if empty(listtype)
    1              0.000002     return a:listtype
                              endif
                            
                              return listtype

FUNCTION  <SNR>49_changesurround()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let a = s:inputtarget()
                              if a == ""
                                return s:beep()
                              endif
                              let b = s:inputreplacement()
                              if b == ""
                                return s:beep()
                              endif
                              call s:dosurround(a,b,a:0 && a:1)

FUNCTION  gutentags#get_job_tags_file()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return s:update_in_progress[a:module][a:job_idx][0]

FUNCTION  <SNR>103_EchoExec()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              echo call('s:ChompError', a:000)[0]
                              call fugitive#ReloadStatus(-1, 1)
                              return 'checktime'

FUNCTION  go#list#Parse()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if a:listtype == "locationlist"
                                lgetexpr a:items
                                if has("patch-7.4.2200") | call setloclist(0, [], 'a', {'title': a:title}) | endif
                              else
                                cgetexpr a:items
                                if has("patch-7.4.2200") | call setqflist([], 'a', {'title': a:title}) | endif
                              endif

FUNCTION  go#guru#Freevars()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              " Freevars requires a selection
                              if a:selected == -1
                                call go#util#EchoError("GoFreevars requires a selection (range) of code")
                                return
                              endif
                            
                              let args = { 'mode': 'freevars', 'format': 'plain', 'selected': 1, 'needs_scope': 0, }
                            
                              call s:run_guru(args)

FUNCTION  DispatchComplete()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return dispatch#complete(a:id)

FUNCTION  <SNR>100_check_diff_darcs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  <SNR>103_StageDiffEdit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let info = s:StageInfo(line('.'))
                              let arg = (empty(info.paths) ? s:Tree() : info.paths[0])
                              if info.section ==# 'Staged'
                                return 'Git! diff --no-ext-diff --cached '.s:fnameescape(arg)
                              elseif info.status ==# '?'
                                call s:TreeChomp('add', '--intent-to-add', '--', arg)
                                return s:ReloadStatus()
                              else
                                return 'Git! diff --no-ext-diff '.s:fnameescape(arg)
                              endif

FUNCTION  <SNR>34_abbreviate_from_dict()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              for [lhs,rhs] in items(a:dict)
                                exe a:cmd lhs rhs
                              endfor

FUNCTION  <SNR>103_Resolve()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let path = resolve(a:path)
                              if has('win32')
                                let path = FugitiveVimPath(fnamemodify(fnamemodify(path, ':h'), ':p') . fnamemodify(path, ':t'))
                              endif
                              return path

FUNCTION  <SNR>103_Aliases()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              if !has_key(s:aliases, a:dir)
                                let s:aliases[a:dir] = {}
                                let lines = s:NullError([a:dir, 'config', '-z', '--get-regexp', '^alias[.]'])[0]
                                for line in lines
                                  let s:aliases[a:dir][matchstr(line, '\.\zs.\{-}\ze\n')] = matchstr(line, '\n\zs.*')
                                endfor
                              endif
                              return s:aliases[a:dir]

FUNCTION  <SNR>103_StatusCommand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let dir = a:0 ? a:1 : s:Dir()
                              exe s:DirCheck(dir)
                              try
                                let mods = s:Mods(a:mods, &splitbelow ? 'botright' : 'topleft')
                                let file = fugitive#Find(':', dir)
                                let arg = ' +setl\ foldmethod=syntax\ foldlevel=1\|let\ w:fugitive_status=FugitiveGitDir() ' . s:fnameescape(file)
                                for winnr in range(1, winnr('$'))
                                  if s:cpath(file, fnamemodify(bufname(winbufnr(winnr)), ':p'))
                                    if winnr == winnr()
                                      call s:ReloadStatus()
                                    else
                                      call s:ExpireStatus(dir)
                                      exe winnr . 'wincmd w'
                                    endif
                                    let w:fugitive_status = dir
                                    1
                                    return ''
                                  endif
                                endfor
                                if a:count ==# 0
                                  return mods . 'edit' . (a:bang ? '!' : '') . arg
                                elseif a:bang
                                  return mods . 'pedit' . arg . '|wincmd P'
                                else
                                  return mods . (a:count > 0 ? a:count : '') . 'split' . arg
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              return ''

FUNCTION  <SNR>98_skip()
Called 2 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    2              0.000025   if &diff || !filereadable(a:path)
                                return 1
    2              0.000001   endif
                            
    2              0.000008   if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, &filetype)
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help') && (&buftype == 'help')
                                  return 1
                                endif
    2              0.000001   endif
                            
    2              0.000008   if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
    2              0.000002   endif
                            
    2              0.000006   if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
    2              0.000002   endif
                            
    2              0.000003   return 0

FUNCTION  <SNR>103_ContainingCommit()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                              let commit = s:Owner(@%)
                              return empty(commit) ? 'HEAD' : commit

FUNCTION  gutentags#build_default_job_options()
Called 2 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000033         let l:job_opts = {'exit_cb': 'gutentags#'.a:module.'#on_job_exit','out_cb': 'gutentags#default_io_cb','err_cb': 'gutentags#default_io_cb','stoponexit': 'term'}
    2              0.000007         return l:job_opts

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   77   0.059481             <SNR>58_Highlight_Matching_Pair()
    2   0.052808   0.000135  go#util#Exec()
    2   0.051857   0.000155  <SNR>43_exec()
    2   0.051554   0.000604  <SNR>43_system()
    1   0.050701   0.000311  go#auto#fmt_autosave()
    1   0.050067   0.003309  go#fmt#Format()
    2   0.036711   0.000319  <SNR>41_register()
    3   0.035312   0.000590  go#lsp#DidOpen()
    3   0.032166   0.000576  15()
    1   0.029939   0.000035  go#fmt#run()
    1   0.023270   0.000102  go#util#ModuleRoot()
    1   0.023158   0.000197  go#util#ExecInDir()
    1   0.021288   0.000077  <SNR>100_callback_vim_close()
    1   0.021211   0.000319  <SNR>100_handle_diff()
    1   0.020445   0.000184  sy#sign#set_signs()
    1   0.019802   0.006308  sy#sign#process_diff()
    1   0.016656   0.002080  go#fmt#update_file()
    2   0.014945   0.005323  <SNR>19_LoadFTPlugin()
    1   0.013974   0.000353  FugitiveDetect()
   16   0.013730   0.002596  10()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   77              0.059481  <SNR>58_Highlight_Matching_Pair()
   71   0.011430   0.010941  <SNR>106_add_sign()
   16   0.009239   0.008157  9()
    1   0.019802   0.006308  sy#sign#process_diff()
    2   0.006103   0.005887  go#util#EchoProgress()
    2   0.014945   0.005323  <SNR>19_LoadFTPlugin()
    2   0.003621   0.003579  <SNR>102_generate_wildignore_options()
    1   0.050067   0.003309  go#fmt#Format()
    3   0.008995   0.002925  <SNR>24_SynSet()
   20              0.002614  <SNR>52_map()
   16   0.013730   0.002596  10()
   26              0.002181  <SNR>1_AddRTP()
    1   0.016656   0.002080  go#fmt#update_file()
    2   0.001870   0.001472  sy#repo#get_diff()
    6   0.001659   0.001472  18()
   19              0.000980  sy#sign#parse_hunk()
    1   0.001018   0.000967  <SNR>59_VimEnter()
   71              0.000956  <SNR>106_external_sign_present()
    1   0.007681   0.000950  gutentags#setup_gutentags()
    2   0.001234   0.000905  <SNR>21_LoadIndent()

